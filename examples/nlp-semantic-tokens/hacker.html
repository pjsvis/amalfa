
    <head>
        <title>Matrix Page</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <style>
        /* Import a techy monospace font */
        @import url('https://fonts.googleapis.com/css2?family=Space+Mono:wght@700&display=swap');

:root {
    --polyvis-text:'::POLYVIS::'
--polyvis-font-size:1rem;
--stuff-color: #445566;
--thing-color:#EEFFFF;

}
            body {
              background: #050505;
              color: #0f0; /* Classic Matrix Green */
              display: flex;
              flex-direction: column;
              align-items: center;
              justify-content: center;
              height: 100vh;
              margin: 0;
            }

            .scramble-text {
                font-family: 'Space Mono', monospace;
                font-size: var(--polyvis-font-size);
                font-weight: 700;
                color: #445566; /* The "Stuff" color (dim, unstructured) */
                letter-spacing: 0.2rem;
                position: relative;
                cursor: default;
            }

            /* The individual character slots */
            .scramble-text span {
                display: inline-block;
                transition: color 0.1s, text-shadow 0.1s;
            }

            /* The "Sparkle" - When a character finds its home */
            .scramble-text span.locked {
                color: #EEFFFF; /* The "Thing" color (bright, coherent) */
                text-shadow: 0 0 10px rgba(255, 255, 255, 0.8),
                             0 0 20px rgba(0, 200, 255, 0.4);
            }
             </style>
    </head>
    <body>


        <div class="pipeline-container">
            <div id="polyvis-terminal" class="scramble-text"></div>
        </div>

        <script>


            const el = document.getElementById('polyvis-terminal');
            const targetStr = "...POLYVIS:::    ";
            // A mix of Katakana, Greek, and tech symbols
            const chars = "ｦｧｨｩｪｫｬｭｮｯｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐﾑﾒﾓﾔﾕﾖﾗﾘﾙﾚﾛﾜﾝΞΦΨΩΣΠ0123456789";

            // State
            let frame = 0;
            let queue = [];
            let iteration = 0;
            let animationId = null;

            // Setup the DOM structure (spans for individual sparkle control)
            el.innerHTML = targetStr.split('').map(() => `<span></span>`).join('');
            const spans = el.querySelectorAll('span');

            function randomChar() {
                return chars[Math.floor(Math.random() * chars.length)];
            }

            function update() {
                // The "Entropy" logic
                // We run for a set number of frames (e.g., 60 frames = 1 sec approx) per character index
                // But we run them partly in parallel for the "conglomerate" feel

                let complete = true;

                spans.forEach((span, i) => {
                    // "start" determines when this specific char enters the ingestion pipeline
                    const totalChars = spans.length;
                    const start = (totalChars - 1 - i) * 5;
                    const end = start + 40; // How long it stays chaotic

                    if (frame >= end) {
                        // State: Locked (Low Entropy)
                        // Force the correct character and add the "locked" class for the CSS glow
                        if (span.textContent !== targetStr[i]) {
                            span.textContent = targetStr[i];
                            span.classList.add('locked'); // Triggers the sparkle
                        }
                    } else if (frame >= start) {
                        // State: Processing (High Entropy)
                        // It's part of the pipeline, so scramble it
                        complete = false;
                        span.textContent = randomChar();
                        span.classList.remove('locked');
                    } else {
                        // State: Waiting (Pre-ingestion)
                        // Optional: keep it empty or show a placeholder
                        complete = false;
                        span.textContent = "";
                        // Or use randomChar() here if you want it always visible but chaotic
                    }
                });

                frame++;

                if (!complete) {
                    animationId = requestAnimationFrame(update);
                } else {
                    animationId = null;
                }
            }

            function restartAnimation() {
                // Cancel any existing animation
                if (animationId !== null) {
                    cancelAnimationFrame(animationId);
                    animationId = null;
                }

                // Reset state
                frame = 0;

                // Remove locked classes from all spans
                spans.forEach(span => {
                    span.classList.remove('locked');
                    span.textContent = "";
                });

                // Start new animation
                update();
            }

            // Trigger
            // In your app, call this at the end of your pipeline sequence
            update();

            // Add mouseover event to restart animation
            el.addEventListener('mouseover', restartAnimation);
        </script>

    </body>
</html>

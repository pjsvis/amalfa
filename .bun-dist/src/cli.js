#!/usr/bin/env bun
// @bun
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);
var __require = import.meta.require;

// node_modules/zod/v4/core/core.js
function $constructor(name, initializer, params) {
  function init(inst, def) {
    if (!inst._zod) {
      Object.defineProperty(inst, "_zod", {
        value: {
          def,
          constr: _,
          traits: new Set
        },
        enumerable: false
      });
    }
    if (inst._zod.traits.has(name)) {
      return;
    }
    inst._zod.traits.add(name);
    initializer(inst, def);
    const proto = _.prototype;
    const keys = Object.keys(proto);
    for (let i = 0;i < keys.length; i++) {
      const k = keys[i];
      if (!(k in inst)) {
        inst[k] = proto[k].bind(inst);
      }
    }
  }
  const Parent = params?.Parent ?? Object;

  class Definition extends Parent {
  }
  Object.defineProperty(Definition, "name", { value: name });
  function _(def) {
    var _a;
    const inst = params?.Parent ? new Definition : this;
    init(inst, def);
    (_a = inst._zod).deferred ?? (_a.deferred = []);
    for (const fn of inst._zod.deferred) {
      fn();
    }
    return inst;
  }
  Object.defineProperty(_, "init", { value: init });
  Object.defineProperty(_, Symbol.hasInstance, {
    value: (inst) => {
      if (params?.Parent && inst instanceof params.Parent)
        return true;
      return inst?._zod?.traits?.has(name);
    }
  });
  Object.defineProperty(_, "name", { value: name });
  return _;
}
function config(newConfig) {
  if (newConfig)
    Object.assign(globalConfig, newConfig);
  return globalConfig;
}
var NEVER, $brand, $ZodAsyncError, $ZodEncodeError, globalConfig;
var init_core = __esm(() => {
  NEVER = Object.freeze({
    status: "aborted"
  });
  $brand = Symbol("zod_brand");
  $ZodAsyncError = class $ZodAsyncError extends Error {
    constructor() {
      super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
    }
  };
  $ZodEncodeError = class $ZodEncodeError extends Error {
    constructor(name) {
      super(`Encountered unidirectional transform during encode: ${name}`);
      this.name = "ZodEncodeError";
    }
  };
  globalConfig = {};
});

// node_modules/zod/v4/core/util.js
var exports_util = {};
__export(exports_util, {
  unwrapMessage: () => unwrapMessage,
  uint8ArrayToHex: () => uint8ArrayToHex,
  uint8ArrayToBase64url: () => uint8ArrayToBase64url,
  uint8ArrayToBase64: () => uint8ArrayToBase64,
  stringifyPrimitive: () => stringifyPrimitive,
  slugify: () => slugify,
  shallowClone: () => shallowClone,
  safeExtend: () => safeExtend,
  required: () => required,
  randomString: () => randomString,
  propertyKeyTypes: () => propertyKeyTypes,
  promiseAllObject: () => promiseAllObject,
  primitiveTypes: () => primitiveTypes,
  prefixIssues: () => prefixIssues,
  pick: () => pick,
  partial: () => partial,
  parsedType: () => parsedType,
  optionalKeys: () => optionalKeys,
  omit: () => omit,
  objectClone: () => objectClone,
  numKeys: () => numKeys,
  nullish: () => nullish,
  normalizeParams: () => normalizeParams,
  mergeDefs: () => mergeDefs,
  merge: () => merge,
  jsonStringifyReplacer: () => jsonStringifyReplacer,
  joinValues: () => joinValues,
  issue: () => issue,
  isPlainObject: () => isPlainObject,
  isObject: () => isObject,
  hexToUint8Array: () => hexToUint8Array,
  getSizableOrigin: () => getSizableOrigin,
  getParsedType: () => getParsedType,
  getLengthableOrigin: () => getLengthableOrigin,
  getEnumValues: () => getEnumValues,
  getElementAtPath: () => getElementAtPath,
  floatSafeRemainder: () => floatSafeRemainder,
  finalizeIssue: () => finalizeIssue,
  extend: () => extend,
  escapeRegex: () => escapeRegex,
  esc: () => esc,
  defineLazy: () => defineLazy,
  createTransparentProxy: () => createTransparentProxy,
  cloneDef: () => cloneDef,
  clone: () => clone,
  cleanRegex: () => cleanRegex,
  cleanEnum: () => cleanEnum,
  captureStackTrace: () => captureStackTrace,
  cached: () => cached,
  base64urlToUint8Array: () => base64urlToUint8Array,
  base64ToUint8Array: () => base64ToUint8Array,
  assignProp: () => assignProp,
  assertNotEqual: () => assertNotEqual,
  assertNever: () => assertNever,
  assertIs: () => assertIs,
  assertEqual: () => assertEqual,
  assert: () => assert,
  allowsEval: () => allowsEval,
  aborted: () => aborted,
  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,
  Class: () => Class,
  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES
});
function assertEqual(val) {
  return val;
}
function assertNotEqual(val) {
  return val;
}
function assertIs(_arg) {}
function assertNever(_x) {
  throw new Error("Unexpected value in exhaustive check");
}
function assert(_) {}
function getEnumValues(entries) {
  const numericValues = Object.values(entries).filter((v) => typeof v === "number");
  const values = Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);
  return values;
}
function joinValues(array, separator = "|") {
  return array.map((val) => stringifyPrimitive(val)).join(separator);
}
function jsonStringifyReplacer(_, value) {
  if (typeof value === "bigint")
    return value.toString();
  return value;
}
function cached(getter) {
  const set = false;
  return {
    get value() {
      if (!set) {
        const value = getter();
        Object.defineProperty(this, "value", { value });
        return value;
      }
      throw new Error("cached value already set");
    }
  };
}
function nullish(input) {
  return input === null || input === undefined;
}
function cleanRegex(source) {
  const start = source.startsWith("^") ? 1 : 0;
  const end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start, end);
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepString = step.toString();
  let stepDecCount = (stepString.split(".")[1] || "").length;
  if (stepDecCount === 0 && /\d?e-\d?/.test(stepString)) {
    const match = stepString.match(/\d?e-(\d?)/);
    if (match?.[1]) {
      stepDecCount = Number.parseInt(match[1]);
    }
  }
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
function defineLazy(object, key, getter) {
  let value = undefined;
  Object.defineProperty(object, key, {
    get() {
      if (value === EVALUATING) {
        return;
      }
      if (value === undefined) {
        value = EVALUATING;
        value = getter();
      }
      return value;
    },
    set(v) {
      Object.defineProperty(object, key, {
        value: v
      });
    },
    configurable: true
  });
}
function objectClone(obj) {
  return Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
}
function assignProp(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: true,
    enumerable: true,
    configurable: true
  });
}
function mergeDefs(...defs) {
  const mergedDescriptors = {};
  for (const def of defs) {
    const descriptors = Object.getOwnPropertyDescriptors(def);
    Object.assign(mergedDescriptors, descriptors);
  }
  return Object.defineProperties({}, mergedDescriptors);
}
function cloneDef(schema) {
  return mergeDefs(schema._zod.def);
}
function getElementAtPath(obj, path) {
  if (!path)
    return obj;
  return path.reduce((acc, key) => acc?.[key], obj);
}
function promiseAllObject(promisesObj) {
  const keys = Object.keys(promisesObj);
  const promises = keys.map((key) => promisesObj[key]);
  return Promise.all(promises).then((results) => {
    const resolvedObj = {};
    for (let i = 0;i < keys.length; i++) {
      resolvedObj[keys[i]] = results[i];
    }
    return resolvedObj;
  });
}
function randomString(length = 10) {
  const chars = "abcdefghijklmnopqrstuvwxyz";
  let str2 = "";
  for (let i = 0;i < length; i++) {
    str2 += chars[Math.floor(Math.random() * chars.length)];
  }
  return str2;
}
function esc(str2) {
  return JSON.stringify(str2);
}
function slugify(input) {
  return input.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
}
function isObject(data) {
  return typeof data === "object" && data !== null && !Array.isArray(data);
}
function isPlainObject(o) {
  if (isObject(o) === false)
    return false;
  const ctor = o.constructor;
  if (ctor === undefined)
    return true;
  if (typeof ctor !== "function")
    return true;
  const prot = ctor.prototype;
  if (isObject(prot) === false)
    return false;
  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
    return false;
  }
  return true;
}
function shallowClone(o) {
  if (isPlainObject(o))
    return { ...o };
  if (Array.isArray(o))
    return [...o];
  return o;
}
function numKeys(data) {
  let keyCount = 0;
  for (const key in data) {
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      keyCount++;
    }
  }
  return keyCount;
}
function escapeRegex(str2) {
  return str2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone(inst, def, params) {
  const cl = new inst._zod.constr(def ?? inst._zod.def);
  if (!def || params?.parent)
    cl._zod.parent = inst;
  return cl;
}
function normalizeParams(_params) {
  const params = _params;
  if (!params)
    return {};
  if (typeof params === "string")
    return { error: () => params };
  if (params?.message !== undefined) {
    if (params?.error !== undefined)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  delete params.message;
  if (typeof params.error === "string")
    return { ...params, error: () => params.error };
  return params;
}
function createTransparentProxy(getter) {
  let target;
  return new Proxy({}, {
    get(_, prop, receiver) {
      target ?? (target = getter());
      return Reflect.get(target, prop, receiver);
    },
    set(_, prop, value, receiver) {
      target ?? (target = getter());
      return Reflect.set(target, prop, value, receiver);
    },
    has(_, prop) {
      target ?? (target = getter());
      return Reflect.has(target, prop);
    },
    deleteProperty(_, prop) {
      target ?? (target = getter());
      return Reflect.deleteProperty(target, prop);
    },
    ownKeys(_) {
      target ?? (target = getter());
      return Reflect.ownKeys(target);
    },
    getOwnPropertyDescriptor(_, prop) {
      target ?? (target = getter());
      return Reflect.getOwnPropertyDescriptor(target, prop);
    },
    defineProperty(_, prop, descriptor) {
      target ?? (target = getter());
      return Reflect.defineProperty(target, prop, descriptor);
    }
  });
}
function stringifyPrimitive(value) {
  if (typeof value === "bigint")
    return value.toString() + "n";
  if (typeof value === "string")
    return `"${value}"`;
  return `${value}`;
}
function optionalKeys(shape) {
  return Object.keys(shape).filter((k) => {
    return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
  });
}
function pick(schema, mask) {
  const currDef = schema._zod.def;
  const checks = currDef.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error(".pick() cannot be used on object schemas containing refinements");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = {};
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        newShape[key] = currDef.shape[key];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
function omit(schema, mask) {
  const currDef = schema._zod.def;
  const checks = currDef.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error(".omit() cannot be used on object schemas containing refinements");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = { ...schema._zod.def.shape };
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        delete newShape[key];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
function extend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to extend: expected a plain object");
  }
  const checks = schema._zod.def.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    const existingShape = schema._zod.def.shape;
    for (const key in shape) {
      if (Object.getOwnPropertyDescriptor(existingShape, key) !== undefined) {
        throw new Error("Cannot overwrite keys on object schemas containing refinements. Use `.safeExtend()` instead.");
      }
    }
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    }
  });
  return clone(schema, def);
}
function safeExtend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to safeExtend: expected a plain object");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    }
  });
  return clone(schema, def);
}
function merge(a, b) {
  const def = mergeDefs(a._zod.def, {
    get shape() {
      const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    get catchall() {
      return b._zod.def.catchall;
    },
    checks: []
  });
  return clone(a, def);
}
function partial(Class, schema, mask) {
  const currDef = schema._zod.def;
  const checks = currDef.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error(".partial() cannot be used on object schemas containing refinements");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in oldShape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = Class ? new Class({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      } else {
        for (const key in oldShape) {
          shape[key] = Class ? new Class({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    },
    checks: []
  });
  return clone(schema, def);
}
function required(Class, schema, mask) {
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in shape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = new Class({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      } else {
        for (const key in oldShape) {
          shape[key] = new Class({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    }
  });
  return clone(schema, def);
}
function aborted(x, startIndex = 0) {
  if (x.aborted === true)
    return true;
  for (let i = startIndex;i < x.issues.length; i++) {
    if (x.issues[i]?.continue !== true) {
      return true;
    }
  }
  return false;
}
function prefixIssues(path, issues) {
  return issues.map((iss) => {
    var _a;
    (_a = iss).path ?? (_a.path = []);
    iss.path.unshift(path);
    return iss;
  });
}
function unwrapMessage(message) {
  return typeof message === "string" ? message : message?.message;
}
function finalizeIssue(iss, ctx, config2) {
  const full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config2.customError?.(iss)) ?? unwrapMessage(config2.localeError?.(iss)) ?? "Invalid input";
    full.message = message;
  }
  delete full.inst;
  delete full.continue;
  if (!ctx?.reportInput) {
    delete full.input;
  }
  return full;
}
function getSizableOrigin(input) {
  if (input instanceof Set)
    return "set";
  if (input instanceof Map)
    return "map";
  if (input instanceof File)
    return "file";
  return "unknown";
}
function getLengthableOrigin(input) {
  if (Array.isArray(input))
    return "array";
  if (typeof input === "string")
    return "string";
  return "unknown";
}
function parsedType(data) {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "nan" : "number";
    }
    case "object": {
      if (data === null) {
        return "null";
      }
      if (Array.isArray(data)) {
        return "array";
      }
      const obj = data;
      if (obj && Object.getPrototypeOf(obj) !== Object.prototype && "constructor" in obj && obj.constructor) {
        return obj.constructor.name;
      }
    }
  }
  return t;
}
function issue(...args) {
  const [iss, input, inst] = args;
  if (typeof iss === "string") {
    return {
      message: iss,
      code: "custom",
      input,
      inst
    };
  }
  return { ...iss };
}
function cleanEnum(obj) {
  return Object.entries(obj).filter(([k, _]) => {
    return Number.isNaN(Number.parseInt(k, 10));
  }).map((el) => el[1]);
}
function base64ToUint8Array(base64) {
  const binaryString = atob(base64);
  const bytes = new Uint8Array(binaryString.length);
  for (let i = 0;i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes;
}
function uint8ArrayToBase64(bytes) {
  let binaryString = "";
  for (let i = 0;i < bytes.length; i++) {
    binaryString += String.fromCharCode(bytes[i]);
  }
  return btoa(binaryString);
}
function base64urlToUint8Array(base64url) {
  const base64 = base64url.replace(/-/g, "+").replace(/_/g, "/");
  const padding = "=".repeat((4 - base64.length % 4) % 4);
  return base64ToUint8Array(base64 + padding);
}
function uint8ArrayToBase64url(bytes) {
  return uint8ArrayToBase64(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function hexToUint8Array(hex) {
  const cleanHex = hex.replace(/^0x/, "");
  if (cleanHex.length % 2 !== 0) {
    throw new Error("Invalid hex string length");
  }
  const bytes = new Uint8Array(cleanHex.length / 2);
  for (let i = 0;i < cleanHex.length; i += 2) {
    bytes[i / 2] = Number.parseInt(cleanHex.slice(i, i + 2), 16);
  }
  return bytes;
}
function uint8ArrayToHex(bytes) {
  return Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("");
}

class Class {
  constructor(..._args) {}
}
var EVALUATING, captureStackTrace, allowsEval, getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(data) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return "promise";
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return "map";
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return "set";
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return "date";
      }
      if (typeof File !== "undefined" && data instanceof File) {
        return "file";
      }
      return "object";
    default:
      throw new Error(`Unknown data type: ${t}`);
  }
}, propertyKeyTypes, primitiveTypes, NUMBER_FORMAT_RANGES, BIGINT_FORMAT_RANGES;
var init_util = __esm(() => {
  EVALUATING = Symbol("evaluating");
  captureStackTrace = "captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => {};
  allowsEval = cached(() => {
    if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) {
      return false;
    }
    try {
      const F = Function;
      new F("");
      return true;
    } catch (_) {
      return false;
    }
  });
  propertyKeyTypes = new Set(["string", "number", "symbol"]);
  primitiveTypes = new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
  NUMBER_FORMAT_RANGES = {
    safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
    int32: [-2147483648, 2147483647],
    uint32: [0, 4294967295],
    float32: [-340282346638528860000000000000000000000, 340282346638528860000000000000000000000],
    float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
  };
  BIGINT_FORMAT_RANGES = {
    int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],
    uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]
  };
});

// node_modules/zod/v4/core/errors.js
function flattenError(error, mapper = (issue2) => issue2.message) {
  const fieldErrors = {};
  const formErrors = [];
  for (const sub of error.issues) {
    if (sub.path.length > 0) {
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
      fieldErrors[sub.path[0]].push(mapper(sub));
    } else {
      formErrors.push(mapper(sub));
    }
  }
  return { formErrors, fieldErrors };
}
function formatError(error, mapper = (issue2) => issue2.message) {
  const fieldErrors = { _errors: [] };
  const processError = (error2) => {
    for (const issue2 of error2.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues });
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues });
      } else if (issue2.path.length === 0) {
        fieldErrors._errors.push(mapper(issue2));
      } else {
        let curr = fieldErrors;
        let i = 0;
        while (i < issue2.path.length) {
          const el = issue2.path[i];
          const terminal = i === issue2.path.length - 1;
          if (!terminal) {
            curr[el] = curr[el] || { _errors: [] };
          } else {
            curr[el] = curr[el] || { _errors: [] };
            curr[el]._errors.push(mapper(issue2));
          }
          curr = curr[el];
          i++;
        }
      }
    }
  };
  processError(error);
  return fieldErrors;
}
function treeifyError(error, mapper = (issue2) => issue2.message) {
  const result = { errors: [] };
  const processError = (error2, path = []) => {
    var _a, _b;
    for (const issue2 of error2.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }, issue2.path));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues }, issue2.path);
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues }, issue2.path);
      } else {
        const fullpath = [...path, ...issue2.path];
        if (fullpath.length === 0) {
          result.errors.push(mapper(issue2));
          continue;
        }
        let curr = result;
        let i = 0;
        while (i < fullpath.length) {
          const el = fullpath[i];
          const terminal = i === fullpath.length - 1;
          if (typeof el === "string") {
            curr.properties ?? (curr.properties = {});
            (_a = curr.properties)[el] ?? (_a[el] = { errors: [] });
            curr = curr.properties[el];
          } else {
            curr.items ?? (curr.items = []);
            (_b = curr.items)[el] ?? (_b[el] = { errors: [] });
            curr = curr.items[el];
          }
          if (terminal) {
            curr.errors.push(mapper(issue2));
          }
          i++;
        }
      }
    }
  };
  processError(error);
  return result;
}
function toDotPath(_path) {
  const segs = [];
  const path = _path.map((seg) => typeof seg === "object" ? seg.key : seg);
  for (const seg of path) {
    if (typeof seg === "number")
      segs.push(`[${seg}]`);
    else if (typeof seg === "symbol")
      segs.push(`[${JSON.stringify(String(seg))}]`);
    else if (/[^\w$]/.test(seg))
      segs.push(`[${JSON.stringify(seg)}]`);
    else {
      if (segs.length)
        segs.push(".");
      segs.push(seg);
    }
  }
  return segs.join("");
}
function prettifyError(error) {
  const lines = [];
  const issues = [...error.issues].sort((a, b) => (a.path ?? []).length - (b.path ?? []).length);
  for (const issue2 of issues) {
    lines.push(`\u2716 ${issue2.message}`);
    if (issue2.path?.length)
      lines.push(`  \u2192 at ${toDotPath(issue2.path)}`);
  }
  return lines.join(`
`);
}
var initializer = (inst, def) => {
  inst.name = "$ZodError";
  Object.defineProperty(inst, "_zod", {
    value: inst._zod,
    enumerable: false
  });
  Object.defineProperty(inst, "issues", {
    value: def,
    enumerable: false
  });
  inst.message = JSON.stringify(def, jsonStringifyReplacer, 2);
  Object.defineProperty(inst, "toString", {
    value: () => inst.message,
    enumerable: false
  });
}, $ZodError, $ZodRealError;
var init_errors = __esm(() => {
  init_core();
  init_util();
  $ZodError = $constructor("$ZodError", initializer);
  $ZodRealError = $constructor("$ZodError", initializer, { Parent: Error });
});

// node_modules/zod/v4/core/parse.js
var _parse = (_Err) => (schema, value, _ctx, _params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError;
  }
  if (result.issues.length) {
    const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e, _params?.callee);
    throw e;
  }
  return result.value;
}, parse2, _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  if (result.issues.length) {
    const e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e, params?.callee);
    throw e;
  }
  return result.value;
}, parseAsync, _safeParse = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError;
  }
  return result.issues.length ? {
    success: false,
    error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
}, safeParse, _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  return result.issues.length ? {
    success: false,
    error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
}, safeParseAsync, _encode = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parse(_Err)(schema, value, ctx);
}, encode, _decode = (_Err) => (schema, value, _ctx) => {
  return _parse(_Err)(schema, value, _ctx);
}, decode, _encodeAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parseAsync(_Err)(schema, value, ctx);
}, encodeAsync, _decodeAsync = (_Err) => async (schema, value, _ctx) => {
  return _parseAsync(_Err)(schema, value, _ctx);
}, decodeAsync, _safeEncode = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParse(_Err)(schema, value, ctx);
}, safeEncode, _safeDecode = (_Err) => (schema, value, _ctx) => {
  return _safeParse(_Err)(schema, value, _ctx);
}, safeDecode, _safeEncodeAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParseAsync(_Err)(schema, value, ctx);
}, safeEncodeAsync, _safeDecodeAsync = (_Err) => async (schema, value, _ctx) => {
  return _safeParseAsync(_Err)(schema, value, _ctx);
}, safeDecodeAsync;
var init_parse = __esm(() => {
  init_core();
  init_errors();
  init_util();
  parse2 = /* @__PURE__ */ _parse($ZodRealError);
  parseAsync = /* @__PURE__ */ _parseAsync($ZodRealError);
  safeParse = /* @__PURE__ */ _safeParse($ZodRealError);
  safeParseAsync = /* @__PURE__ */ _safeParseAsync($ZodRealError);
  encode = /* @__PURE__ */ _encode($ZodRealError);
  decode = /* @__PURE__ */ _decode($ZodRealError);
  encodeAsync = /* @__PURE__ */ _encodeAsync($ZodRealError);
  decodeAsync = /* @__PURE__ */ _decodeAsync($ZodRealError);
  safeEncode = /* @__PURE__ */ _safeEncode($ZodRealError);
  safeDecode = /* @__PURE__ */ _safeDecode($ZodRealError);
  safeEncodeAsync = /* @__PURE__ */ _safeEncodeAsync($ZodRealError);
  safeDecodeAsync = /* @__PURE__ */ _safeDecodeAsync($ZodRealError);
});

// node_modules/zod/v4/core/regexes.js
var exports_regexes = {};
__export(exports_regexes, {
  xid: () => xid,
  uuid7: () => uuid7,
  uuid6: () => uuid6,
  uuid4: () => uuid4,
  uuid: () => uuid,
  uppercase: () => uppercase,
  unicodeEmail: () => unicodeEmail,
  undefined: () => _undefined,
  ulid: () => ulid,
  time: () => time,
  string: () => string,
  sha512_hex: () => sha512_hex,
  sha512_base64url: () => sha512_base64url,
  sha512_base64: () => sha512_base64,
  sha384_hex: () => sha384_hex,
  sha384_base64url: () => sha384_base64url,
  sha384_base64: () => sha384_base64,
  sha256_hex: () => sha256_hex,
  sha256_base64url: () => sha256_base64url,
  sha256_base64: () => sha256_base64,
  sha1_hex: () => sha1_hex,
  sha1_base64url: () => sha1_base64url,
  sha1_base64: () => sha1_base64,
  rfc5322Email: () => rfc5322Email,
  number: () => number,
  null: () => _null,
  nanoid: () => nanoid,
  md5_hex: () => md5_hex,
  md5_base64url: () => md5_base64url,
  md5_base64: () => md5_base64,
  mac: () => mac,
  lowercase: () => lowercase,
  ksuid: () => ksuid,
  ipv6: () => ipv6,
  ipv4: () => ipv4,
  integer: () => integer,
  idnEmail: () => idnEmail,
  html5Email: () => html5Email,
  hostname: () => hostname,
  hex: () => hex,
  guid: () => guid,
  extendedDuration: () => extendedDuration,
  emoji: () => emoji,
  email: () => email,
  e164: () => e164,
  duration: () => duration,
  domain: () => domain,
  datetime: () => datetime,
  date: () => date,
  cuid2: () => cuid2,
  cuid: () => cuid,
  cidrv6: () => cidrv6,
  cidrv4: () => cidrv4,
  browserEmail: () => browserEmail,
  boolean: () => boolean,
  bigint: () => bigint,
  base64url: () => base64url,
  base64: () => base64
});
function emoji() {
  return new RegExp(_emoji, "u");
}
function timeSource(args) {
  const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
  const regex = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  return regex;
}
function time(args) {
  return new RegExp(`^${timeSource(args)}$`);
}
function datetime(args) {
  const time2 = timeSource({ precision: args.precision });
  const opts = ["Z"];
  if (args.local)
    opts.push("");
  if (args.offset)
    opts.push(`([+-](?:[01]\\d|2[0-3]):[0-5]\\d)`);
  const timeRegex = `${time2}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource}T(?:${timeRegex})$`);
}
function fixedBase64(bodyLength, padding) {
  return new RegExp(`^[A-Za-z0-9+/]{${bodyLength}}${padding}$`);
}
function fixedBase64url(length) {
  return new RegExp(`^[A-Za-z0-9_-]{${length}}$`);
}
var cuid, cuid2, ulid, xid, ksuid, nanoid, duration, extendedDuration, guid, uuid = (version) => {
  if (!version)
    return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
}, uuid4, uuid6, uuid7, email, html5Email, rfc5322Email, unicodeEmail, idnEmail, browserEmail, _emoji = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`, ipv4, ipv6, mac = (delimiter) => {
  const escapedDelim = escapeRegex(delimiter ?? ":");
  return new RegExp(`^(?:[0-9A-F]{2}${escapedDelim}){5}[0-9A-F]{2}$|^(?:[0-9a-f]{2}${escapedDelim}){5}[0-9a-f]{2}$`);
}, cidrv4, cidrv6, base64, base64url, hostname, domain, e164, dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`, date, string = (params) => {
  const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
  return new RegExp(`^${regex}$`);
}, bigint, integer, number, boolean, _null, _undefined, lowercase, uppercase, hex, md5_hex, md5_base64, md5_base64url, sha1_hex, sha1_base64, sha1_base64url, sha256_hex, sha256_base64, sha256_base64url, sha384_hex, sha384_base64, sha384_base64url, sha512_hex, sha512_base64, sha512_base64url;
var init_regexes = __esm(() => {
  init_util();
  cuid = /^[cC][^\s-]{8,}$/;
  cuid2 = /^[0-9a-z]+$/;
  ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
  xid = /^[0-9a-vA-V]{20}$/;
  ksuid = /^[A-Za-z0-9]{27}$/;
  nanoid = /^[a-zA-Z0-9_-]{21}$/;
  duration = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
  extendedDuration = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
  guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
  uuid4 = /* @__PURE__ */ uuid(4);
  uuid6 = /* @__PURE__ */ uuid(6);
  uuid7 = /* @__PURE__ */ uuid(7);
  email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
  html5Email = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
  rfc5322Email = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
  unicodeEmail = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
  idnEmail = unicodeEmail;
  browserEmail = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
  ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
  ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/;
  cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
  cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
  base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
  base64url = /^[A-Za-z0-9_-]*$/;
  hostname = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/;
  domain = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
  e164 = /^\+[1-9]\d{6,14}$/;
  date = /* @__PURE__ */ new RegExp(`^${dateSource}$`);
  bigint = /^-?\d+n?$/;
  integer = /^-?\d+$/;
  number = /^-?\d+(?:\.\d+)?$/;
  boolean = /^(?:true|false)$/i;
  _null = /^null$/i;
  _undefined = /^undefined$/i;
  lowercase = /^[^A-Z]*$/;
  uppercase = /^[^a-z]*$/;
  hex = /^[0-9a-fA-F]*$/;
  md5_hex = /^[0-9a-fA-F]{32}$/;
  md5_base64 = /* @__PURE__ */ fixedBase64(22, "==");
  md5_base64url = /* @__PURE__ */ fixedBase64url(22);
  sha1_hex = /^[0-9a-fA-F]{40}$/;
  sha1_base64 = /* @__PURE__ */ fixedBase64(27, "=");
  sha1_base64url = /* @__PURE__ */ fixedBase64url(27);
  sha256_hex = /^[0-9a-fA-F]{64}$/;
  sha256_base64 = /* @__PURE__ */ fixedBase64(43, "=");
  sha256_base64url = /* @__PURE__ */ fixedBase64url(43);
  sha384_hex = /^[0-9a-fA-F]{96}$/;
  sha384_base64 = /* @__PURE__ */ fixedBase64(64, "");
  sha384_base64url = /* @__PURE__ */ fixedBase64url(64);
  sha512_hex = /^[0-9a-fA-F]{128}$/;
  sha512_base64 = /* @__PURE__ */ fixedBase64(86, "==");
  sha512_base64url = /* @__PURE__ */ fixedBase64url(86);
});

// node_modules/zod/v4/core/checks.js
function handleCheckPropertyResult(result, payload, property) {
  if (result.issues.length) {
    payload.issues.push(...prefixIssues(property, result.issues));
  }
}
var $ZodCheck, numericOriginMap, $ZodCheckLessThan, $ZodCheckGreaterThan, $ZodCheckMultipleOf, $ZodCheckNumberFormat, $ZodCheckBigIntFormat, $ZodCheckMaxSize, $ZodCheckMinSize, $ZodCheckSizeEquals, $ZodCheckMaxLength, $ZodCheckMinLength, $ZodCheckLengthEquals, $ZodCheckStringFormat, $ZodCheckRegex, $ZodCheckLowerCase, $ZodCheckUpperCase, $ZodCheckIncludes, $ZodCheckStartsWith, $ZodCheckEndsWith, $ZodCheckProperty, $ZodCheckMimeType, $ZodCheckOverwrite;
var init_checks = __esm(() => {
  init_core();
  init_regexes();
  init_util();
  $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {
    var _a;
    inst._zod ?? (inst._zod = {});
    inst._zod.def = def;
    (_a = inst._zod).onattach ?? (_a.onattach = []);
  });
  numericOriginMap = {
    number: "number",
    bigint: "bigint",
    object: "date"
  };
  $ZodCheckLessThan = /* @__PURE__ */ $constructor("$ZodCheckLessThan", (inst, def) => {
    $ZodCheck.init(inst, def);
    const origin = numericOriginMap[typeof def.value];
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
      if (def.value < curr) {
        if (def.inclusive)
          bag.maximum = def.value;
        else
          bag.exclusiveMaximum = def.value;
      }
    });
    inst._zod.check = (payload) => {
      if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
        return;
      }
      payload.issues.push({
        origin,
        code: "too_big",
        maximum: typeof def.value === "object" ? def.value.getTime() : def.value,
        input: payload.value,
        inclusive: def.inclusive,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckGreaterThan = /* @__PURE__ */ $constructor("$ZodCheckGreaterThan", (inst, def) => {
    $ZodCheck.init(inst, def);
    const origin = numericOriginMap[typeof def.value];
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
      if (def.value > curr) {
        if (def.inclusive)
          bag.minimum = def.value;
        else
          bag.exclusiveMinimum = def.value;
      }
    });
    inst._zod.check = (payload) => {
      if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
        return;
      }
      payload.issues.push({
        origin,
        code: "too_small",
        minimum: typeof def.value === "object" ? def.value.getTime() : def.value,
        input: payload.value,
        inclusive: def.inclusive,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckMultipleOf = /* @__PURE__ */ $constructor("$ZodCheckMultipleOf", (inst, def) => {
    $ZodCheck.init(inst, def);
    inst._zod.onattach.push((inst2) => {
      var _a;
      (_a = inst2._zod.bag).multipleOf ?? (_a.multipleOf = def.value);
    });
    inst._zod.check = (payload) => {
      if (typeof payload.value !== typeof def.value)
        throw new Error("Cannot mix number and bigint in multiple_of check.");
      const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder(payload.value, def.value) === 0;
      if (isMultiple)
        return;
      payload.issues.push({
        origin: typeof payload.value,
        code: "not_multiple_of",
        divisor: def.value,
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckNumberFormat = /* @__PURE__ */ $constructor("$ZodCheckNumberFormat", (inst, def) => {
    $ZodCheck.init(inst, def);
    def.format = def.format || "float64";
    const isInt = def.format?.includes("int");
    const origin = isInt ? "int" : "number";
    const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.format = def.format;
      bag.minimum = minimum;
      bag.maximum = maximum;
      if (isInt)
        bag.pattern = integer;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      if (isInt) {
        if (!Number.isInteger(input)) {
          payload.issues.push({
            expected: origin,
            format: def.format,
            code: "invalid_type",
            continue: false,
            input,
            inst
          });
          return;
        }
        if (!Number.isSafeInteger(input)) {
          if (input > 0) {
            payload.issues.push({
              input,
              code: "too_big",
              maximum: Number.MAX_SAFE_INTEGER,
              note: "Integers must be within the safe integer range.",
              inst,
              origin,
              inclusive: true,
              continue: !def.abort
            });
          } else {
            payload.issues.push({
              input,
              code: "too_small",
              minimum: Number.MIN_SAFE_INTEGER,
              note: "Integers must be within the safe integer range.",
              inst,
              origin,
              inclusive: true,
              continue: !def.abort
            });
          }
          return;
        }
      }
      if (input < minimum) {
        payload.issues.push({
          origin: "number",
          input,
          code: "too_small",
          minimum,
          inclusive: true,
          inst,
          continue: !def.abort
        });
      }
      if (input > maximum) {
        payload.issues.push({
          origin: "number",
          input,
          code: "too_big",
          maximum,
          inclusive: true,
          inst,
          continue: !def.abort
        });
      }
    };
  });
  $ZodCheckBigIntFormat = /* @__PURE__ */ $constructor("$ZodCheckBigIntFormat", (inst, def) => {
    $ZodCheck.init(inst, def);
    const [minimum, maximum] = BIGINT_FORMAT_RANGES[def.format];
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.format = def.format;
      bag.minimum = minimum;
      bag.maximum = maximum;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      if (input < minimum) {
        payload.issues.push({
          origin: "bigint",
          input,
          code: "too_small",
          minimum,
          inclusive: true,
          inst,
          continue: !def.abort
        });
      }
      if (input > maximum) {
        payload.issues.push({
          origin: "bigint",
          input,
          code: "too_big",
          maximum,
          inclusive: true,
          inst,
          continue: !def.abort
        });
      }
    };
  });
  $ZodCheckMaxSize = /* @__PURE__ */ $constructor("$ZodCheckMaxSize", (inst, def) => {
    var _a;
    $ZodCheck.init(inst, def);
    (_a = inst._zod.def).when ?? (_a.when = (payload) => {
      const val = payload.value;
      return !nullish(val) && val.size !== undefined;
    });
    inst._zod.onattach.push((inst2) => {
      const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
      if (def.maximum < curr)
        inst2._zod.bag.maximum = def.maximum;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      const size = input.size;
      if (size <= def.maximum)
        return;
      payload.issues.push({
        origin: getSizableOrigin(input),
        code: "too_big",
        maximum: def.maximum,
        inclusive: true,
        input,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckMinSize = /* @__PURE__ */ $constructor("$ZodCheckMinSize", (inst, def) => {
    var _a;
    $ZodCheck.init(inst, def);
    (_a = inst._zod.def).when ?? (_a.when = (payload) => {
      const val = payload.value;
      return !nullish(val) && val.size !== undefined;
    });
    inst._zod.onattach.push((inst2) => {
      const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
      if (def.minimum > curr)
        inst2._zod.bag.minimum = def.minimum;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      const size = input.size;
      if (size >= def.minimum)
        return;
      payload.issues.push({
        origin: getSizableOrigin(input),
        code: "too_small",
        minimum: def.minimum,
        inclusive: true,
        input,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckSizeEquals = /* @__PURE__ */ $constructor("$ZodCheckSizeEquals", (inst, def) => {
    var _a;
    $ZodCheck.init(inst, def);
    (_a = inst._zod.def).when ?? (_a.when = (payload) => {
      const val = payload.value;
      return !nullish(val) && val.size !== undefined;
    });
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.minimum = def.size;
      bag.maximum = def.size;
      bag.size = def.size;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      const size = input.size;
      if (size === def.size)
        return;
      const tooBig = size > def.size;
      payload.issues.push({
        origin: getSizableOrigin(input),
        ...tooBig ? { code: "too_big", maximum: def.size } : { code: "too_small", minimum: def.size },
        inclusive: true,
        exact: true,
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {
    var _a;
    $ZodCheck.init(inst, def);
    (_a = inst._zod.def).when ?? (_a.when = (payload) => {
      const val = payload.value;
      return !nullish(val) && val.length !== undefined;
    });
    inst._zod.onattach.push((inst2) => {
      const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
      if (def.maximum < curr)
        inst2._zod.bag.maximum = def.maximum;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      const length = input.length;
      if (length <= def.maximum)
        return;
      const origin = getLengthableOrigin(input);
      payload.issues.push({
        origin,
        code: "too_big",
        maximum: def.maximum,
        inclusive: true,
        input,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {
    var _a;
    $ZodCheck.init(inst, def);
    (_a = inst._zod.def).when ?? (_a.when = (payload) => {
      const val = payload.value;
      return !nullish(val) && val.length !== undefined;
    });
    inst._zod.onattach.push((inst2) => {
      const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
      if (def.minimum > curr)
        inst2._zod.bag.minimum = def.minimum;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      const length = input.length;
      if (length >= def.minimum)
        return;
      const origin = getLengthableOrigin(input);
      payload.issues.push({
        origin,
        code: "too_small",
        minimum: def.minimum,
        inclusive: true,
        input,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {
    var _a;
    $ZodCheck.init(inst, def);
    (_a = inst._zod.def).when ?? (_a.when = (payload) => {
      const val = payload.value;
      return !nullish(val) && val.length !== undefined;
    });
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.minimum = def.length;
      bag.maximum = def.length;
      bag.length = def.length;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      const length = input.length;
      if (length === def.length)
        return;
      const origin = getLengthableOrigin(input);
      const tooBig = length > def.length;
      payload.issues.push({
        origin,
        ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
        inclusive: true,
        exact: true,
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {
    var _a, _b;
    $ZodCheck.init(inst, def);
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.format = def.format;
      if (def.pattern) {
        bag.patterns ?? (bag.patterns = new Set);
        bag.patterns.add(def.pattern);
      }
    });
    if (def.pattern)
      (_a = inst._zod).check ?? (_a.check = (payload) => {
        def.pattern.lastIndex = 0;
        if (def.pattern.test(payload.value))
          return;
        payload.issues.push({
          origin: "string",
          code: "invalid_format",
          format: def.format,
          input: payload.value,
          ...def.pattern ? { pattern: def.pattern.toString() } : {},
          inst,
          continue: !def.abort
        });
      });
    else
      (_b = inst._zod).check ?? (_b.check = () => {});
  });
  $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {
    $ZodCheckStringFormat.init(inst, def);
    inst._zod.check = (payload) => {
      def.pattern.lastIndex = 0;
      if (def.pattern.test(payload.value))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: "regex",
        input: payload.value,
        pattern: def.pattern.toString(),
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {
    def.pattern ?? (def.pattern = lowercase);
    $ZodCheckStringFormat.init(inst, def);
  });
  $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {
    def.pattern ?? (def.pattern = uppercase);
    $ZodCheckStringFormat.init(inst, def);
  });
  $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {
    $ZodCheck.init(inst, def);
    const escapedRegex = escapeRegex(def.includes);
    const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
    def.pattern = pattern;
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.patterns ?? (bag.patterns = new Set);
      bag.patterns.add(pattern);
    });
    inst._zod.check = (payload) => {
      if (payload.value.includes(def.includes, def.position))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: "includes",
        includes: def.includes,
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {
    $ZodCheck.init(inst, def);
    const pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
    def.pattern ?? (def.pattern = pattern);
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.patterns ?? (bag.patterns = new Set);
      bag.patterns.add(pattern);
    });
    inst._zod.check = (payload) => {
      if (payload.value.startsWith(def.prefix))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: "starts_with",
        prefix: def.prefix,
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {
    $ZodCheck.init(inst, def);
    const pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
    def.pattern ?? (def.pattern = pattern);
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.patterns ?? (bag.patterns = new Set);
      bag.patterns.add(pattern);
    });
    inst._zod.check = (payload) => {
      if (payload.value.endsWith(def.suffix))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: "ends_with",
        suffix: def.suffix,
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckProperty = /* @__PURE__ */ $constructor("$ZodCheckProperty", (inst, def) => {
    $ZodCheck.init(inst, def);
    inst._zod.check = (payload) => {
      const result = def.schema._zod.run({
        value: payload.value[def.property],
        issues: []
      }, {});
      if (result instanceof Promise) {
        return result.then((result2) => handleCheckPropertyResult(result2, payload, def.property));
      }
      handleCheckPropertyResult(result, payload, def.property);
      return;
    };
  });
  $ZodCheckMimeType = /* @__PURE__ */ $constructor("$ZodCheckMimeType", (inst, def) => {
    $ZodCheck.init(inst, def);
    const mimeSet = new Set(def.mime);
    inst._zod.onattach.push((inst2) => {
      inst2._zod.bag.mime = def.mime;
    });
    inst._zod.check = (payload) => {
      if (mimeSet.has(payload.value.type))
        return;
      payload.issues.push({
        code: "invalid_value",
        values: def.mime,
        input: payload.value.type,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {
    $ZodCheck.init(inst, def);
    inst._zod.check = (payload) => {
      payload.value = def.tx(payload.value);
    };
  });
});

// node_modules/zod/v4/core/doc.js
class Doc {
  constructor(args = []) {
    this.content = [];
    this.indent = 0;
    if (this)
      this.args = args;
  }
  indented(fn) {
    this.indent += 1;
    fn(this);
    this.indent -= 1;
  }
  write(arg) {
    if (typeof arg === "function") {
      arg(this, { execution: "sync" });
      arg(this, { execution: "async" });
      return;
    }
    const content = arg;
    const lines = content.split(`
`).filter((x) => x);
    const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
    const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
    for (const line of dedented) {
      this.content.push(line);
    }
  }
  compile() {
    const F = Function;
    const args = this?.args;
    const content = this?.content ?? [``];
    const lines = [...content.map((x) => `  ${x}`)];
    return new F(...args, lines.join(`
`));
  }
}

// node_modules/zod/v4/core/versions.js
var version;
var init_versions = __esm(() => {
  version = {
    major: 4,
    minor: 3,
    patch: 5
  };
});

// node_modules/zod/v4/core/schemas.js
function isValidBase64(data) {
  if (data === "")
    return true;
  if (data.length % 4 !== 0)
    return false;
  try {
    atob(data);
    return true;
  } catch {
    return false;
  }
}
function isValidBase64URL(data) {
  if (!base64url.test(data))
    return false;
  const base642 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
  const padded = base642.padEnd(Math.ceil(base642.length / 4) * 4, "=");
  return isValidBase64(padded);
}
function isValidJWT(token, algorithm = null) {
  try {
    const tokensParts = token.split(".");
    if (tokensParts.length !== 3)
      return false;
    const [header] = tokensParts;
    if (!header)
      return false;
    const parsedHeader = JSON.parse(atob(header));
    if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")
      return false;
    if (!parsedHeader.alg)
      return false;
    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
      return false;
    return true;
  } catch {
    return false;
  }
}
function handleArrayResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
function handlePropertyResult(result, final, key, input, isOptionalOut) {
  if (result.issues.length) {
    if (isOptionalOut && !(key in input)) {
      return;
    }
    final.issues.push(...prefixIssues(key, result.issues));
  }
  if (result.value === undefined) {
    if (key in input) {
      final.value[key] = undefined;
    }
  } else {
    final.value[key] = result.value;
  }
}
function normalizeDef(def) {
  const keys = Object.keys(def.shape);
  for (const k of keys) {
    if (!def.shape?.[k]?._zod?.traits?.has("$ZodType")) {
      throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
    }
  }
  const okeys = optionalKeys(def.shape);
  return {
    ...def,
    keys,
    keySet: new Set(keys),
    numKeys: keys.length,
    optionalKeys: new Set(okeys)
  };
}
function handleCatchall(proms, input, payload, ctx, def, inst) {
  const unrecognized = [];
  const keySet = def.keySet;
  const _catchall = def.catchall._zod;
  const t = _catchall.def.type;
  const isOptionalOut = _catchall.optout === "optional";
  for (const key in input) {
    if (keySet.has(key))
      continue;
    if (t === "never") {
      unrecognized.push(key);
      continue;
    }
    const r = _catchall.run({ value: input[key], issues: [] }, ctx);
    if (r instanceof Promise) {
      proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input, isOptionalOut)));
    } else {
      handlePropertyResult(r, payload, key, input, isOptionalOut);
    }
  }
  if (unrecognized.length) {
    payload.issues.push({
      code: "unrecognized_keys",
      keys: unrecognized,
      input,
      inst
    });
  }
  if (!proms.length)
    return payload;
  return Promise.all(proms).then(() => {
    return payload;
  });
}
function handleUnionResults(results, final, inst, ctx) {
  for (const result of results) {
    if (result.issues.length === 0) {
      final.value = result.value;
      return final;
    }
  }
  const nonaborted = results.filter((r) => !aborted(r));
  if (nonaborted.length === 1) {
    final.value = nonaborted[0].value;
    return nonaborted[0];
  }
  final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  });
  return final;
}
function handleExclusiveUnionResults(results, final, inst, ctx) {
  const successes = results.filter((r) => r.issues.length === 0);
  if (successes.length === 1) {
    final.value = successes[0].value;
    return final;
  }
  if (successes.length === 0) {
    final.issues.push({
      code: "invalid_union",
      input: final.value,
      inst,
      errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
    });
  } else {
    final.issues.push({
      code: "invalid_union",
      input: final.value,
      inst,
      errors: [],
      inclusive: false
    });
  }
  return final;
}
function mergeValues(a, b) {
  if (a === b) {
    return { valid: true, data: a };
  }
  if (a instanceof Date && b instanceof Date && +a === +b) {
    return { valid: true, data: a };
  }
  if (isPlainObject(a) && isPlainObject(b)) {
    const bKeys = Object.keys(b);
    const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
        };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) {
      return { valid: false, mergeErrorPath: [] };
    }
    const newArray = [];
    for (let index = 0;index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
        };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  }
  return { valid: false, mergeErrorPath: [] };
}
function handleIntersectionResults(result, left, right) {
  const unrecKeys = new Map;
  let unrecIssue;
  for (const iss of left.issues) {
    if (iss.code === "unrecognized_keys") {
      unrecIssue ?? (unrecIssue = iss);
      for (const k of iss.keys) {
        if (!unrecKeys.has(k))
          unrecKeys.set(k, {});
        unrecKeys.get(k).l = true;
      }
    } else {
      result.issues.push(iss);
    }
  }
  for (const iss of right.issues) {
    if (iss.code === "unrecognized_keys") {
      for (const k of iss.keys) {
        if (!unrecKeys.has(k))
          unrecKeys.set(k, {});
        unrecKeys.get(k).r = true;
      }
    } else {
      result.issues.push(iss);
    }
  }
  const bothKeys = [...unrecKeys].filter(([, f]) => f.l && f.r).map(([k]) => k);
  if (bothKeys.length && unrecIssue) {
    result.issues.push({ ...unrecIssue, keys: bothKeys });
  }
  if (aborted(result))
    return result;
  const merged = mergeValues(left.value, right.value);
  if (!merged.valid) {
    throw new Error(`Unmergable intersection. Error path: ` + `${JSON.stringify(merged.mergeErrorPath)}`);
  }
  result.value = merged.data;
  return result;
}
function handleTupleResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
function handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {
  if (keyResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, keyResult.issues));
    } else {
      final.issues.push({
        code: "invalid_key",
        origin: "map",
        input,
        inst,
        issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  if (valueResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, valueResult.issues));
    } else {
      final.issues.push({
        origin: "map",
        code: "invalid_element",
        input,
        inst,
        key,
        issues: valueResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  final.value.set(keyResult.value, valueResult.value);
}
function handleSetResult(result, final) {
  if (result.issues.length) {
    final.issues.push(...result.issues);
  }
  final.value.add(result.value);
}
function handleOptionalResult(result, input) {
  if (result.issues.length && input === undefined) {
    return { issues: [], value: undefined };
  }
  return result;
}
function handleDefaultResult(payload, def) {
  if (payload.value === undefined) {
    payload.value = def.defaultValue;
  }
  return payload;
}
function handleNonOptionalResult(payload, inst) {
  if (!payload.issues.length && payload.value === undefined) {
    payload.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: payload.value,
      inst
    });
  }
  return payload;
}
function handlePipeResult(left, next, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return next._zod.run({ value: left.value, issues: left.issues }, ctx);
}
function handleCodecAResult(result, def, ctx) {
  if (result.issues.length) {
    result.aborted = true;
    return result;
  }
  const direction = ctx.direction || "forward";
  if (direction === "forward") {
    const transformed = def.transform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult(result, value, def.out, ctx));
    }
    return handleCodecTxResult(result, transformed, def.out, ctx);
  } else {
    const transformed = def.reverseTransform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult(result, value, def.in, ctx));
    }
    return handleCodecTxResult(result, transformed, def.in, ctx);
  }
}
function handleCodecTxResult(left, value, nextSchema, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return nextSchema._zod.run({ value, issues: left.issues }, ctx);
}
function handleReadonlyResult(payload) {
  payload.value = Object.freeze(payload.value);
  return payload;
}
function handleRefineResult(result, payload, input, inst) {
  if (!result) {
    const _iss = {
      code: "custom",
      input,
      inst,
      path: [...inst._zod.def.path ?? []],
      continue: !inst._zod.def.abort
    };
    if (inst._zod.def.params)
      _iss.params = inst._zod.def.params;
    payload.issues.push(issue(_iss));
  }
}
var $ZodType, $ZodString, $ZodStringFormat, $ZodGUID, $ZodUUID, $ZodEmail, $ZodURL, $ZodEmoji, $ZodNanoID, $ZodCUID, $ZodCUID2, $ZodULID, $ZodXID, $ZodKSUID, $ZodISODateTime, $ZodISODate, $ZodISOTime, $ZodISODuration, $ZodIPv4, $ZodIPv6, $ZodMAC, $ZodCIDRv4, $ZodCIDRv6, $ZodBase64, $ZodBase64URL, $ZodE164, $ZodJWT, $ZodCustomStringFormat, $ZodNumber, $ZodNumberFormat, $ZodBoolean, $ZodBigInt, $ZodBigIntFormat, $ZodSymbol, $ZodUndefined, $ZodNull, $ZodAny, $ZodUnknown, $ZodNever, $ZodVoid, $ZodDate, $ZodArray, $ZodObject, $ZodObjectJIT, $ZodUnion, $ZodXor, $ZodDiscriminatedUnion, $ZodIntersection, $ZodTuple, $ZodRecord, $ZodMap, $ZodSet, $ZodEnum, $ZodLiteral, $ZodFile, $ZodTransform, $ZodOptional, $ZodExactOptional, $ZodNullable, $ZodDefault, $ZodPrefault, $ZodNonOptional, $ZodSuccess, $ZodCatch, $ZodNaN, $ZodPipe, $ZodCodec, $ZodReadonly, $ZodTemplateLiteral, $ZodFunction, $ZodPromise, $ZodLazy, $ZodCustom;
var init_schemas = __esm(() => {
  init_checks();
  init_core();
  init_parse();
  init_regexes();
  init_util();
  init_versions();
  init_util();
  $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {
    var _a;
    inst ?? (inst = {});
    inst._zod.def = def;
    inst._zod.bag = inst._zod.bag || {};
    inst._zod.version = version;
    const checks = [...inst._zod.def.checks ?? []];
    if (inst._zod.traits.has("$ZodCheck")) {
      checks.unshift(inst);
    }
    for (const ch of checks) {
      for (const fn of ch._zod.onattach) {
        fn(inst);
      }
    }
    if (checks.length === 0) {
      (_a = inst._zod).deferred ?? (_a.deferred = []);
      inst._zod.deferred?.push(() => {
        inst._zod.run = inst._zod.parse;
      });
    } else {
      const runChecks = (payload, checks2, ctx) => {
        let isAborted = aborted(payload);
        let asyncResult;
        for (const ch of checks2) {
          if (ch._zod.def.when) {
            const shouldRun = ch._zod.def.when(payload);
            if (!shouldRun)
              continue;
          } else if (isAborted) {
            continue;
          }
          const currLen = payload.issues.length;
          const _ = ch._zod.check(payload);
          if (_ instanceof Promise && ctx?.async === false) {
            throw new $ZodAsyncError;
          }
          if (asyncResult || _ instanceof Promise) {
            asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
              await _;
              const nextLen = payload.issues.length;
              if (nextLen === currLen)
                return;
              if (!isAborted)
                isAborted = aborted(payload, currLen);
            });
          } else {
            const nextLen = payload.issues.length;
            if (nextLen === currLen)
              continue;
            if (!isAborted)
              isAborted = aborted(payload, currLen);
          }
        }
        if (asyncResult) {
          return asyncResult.then(() => {
            return payload;
          });
        }
        return payload;
      };
      const handleCanaryResult = (canary, payload, ctx) => {
        if (aborted(canary)) {
          canary.aborted = true;
          return canary;
        }
        const checkResult = runChecks(payload, checks, ctx);
        if (checkResult instanceof Promise) {
          if (ctx.async === false)
            throw new $ZodAsyncError;
          return checkResult.then((checkResult2) => inst._zod.parse(checkResult2, ctx));
        }
        return inst._zod.parse(checkResult, ctx);
      };
      inst._zod.run = (payload, ctx) => {
        if (ctx.skipChecks) {
          return inst._zod.parse(payload, ctx);
        }
        if (ctx.direction === "backward") {
          const canary = inst._zod.parse({ value: payload.value, issues: [] }, { ...ctx, skipChecks: true });
          if (canary instanceof Promise) {
            return canary.then((canary2) => {
              return handleCanaryResult(canary2, payload, ctx);
            });
          }
          return handleCanaryResult(canary, payload, ctx);
        }
        const result = inst._zod.parse(payload, ctx);
        if (result instanceof Promise) {
          if (ctx.async === false)
            throw new $ZodAsyncError;
          return result.then((result2) => runChecks(result2, checks, ctx));
        }
        return runChecks(result, checks, ctx);
      };
    }
    defineLazy(inst, "~standard", () => ({
      validate: (value) => {
        try {
          const r = safeParse(inst, value);
          return r.success ? { value: r.data } : { issues: r.error?.issues };
        } catch (_) {
          return safeParseAsync(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });
        }
      },
      vendor: "zod",
      version: 1
    }));
  });
  $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string(inst._zod.bag);
    inst._zod.parse = (payload, _) => {
      if (def.coerce)
        try {
          payload.value = String(payload.value);
        } catch (_2) {}
      if (typeof payload.value === "string")
        return payload;
      payload.issues.push({
        expected: "string",
        code: "invalid_type",
        input: payload.value,
        inst
      });
      return payload;
    };
  });
  $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {
    $ZodCheckStringFormat.init(inst, def);
    $ZodString.init(inst, def);
  });
  $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {
    def.pattern ?? (def.pattern = guid);
    $ZodStringFormat.init(inst, def);
  });
  $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {
    if (def.version) {
      const versionMap = {
        v1: 1,
        v2: 2,
        v3: 3,
        v4: 4,
        v5: 5,
        v6: 6,
        v7: 7,
        v8: 8
      };
      const v = versionMap[def.version];
      if (v === undefined)
        throw new Error(`Invalid UUID version: "${def.version}"`);
      def.pattern ?? (def.pattern = uuid(v));
    } else
      def.pattern ?? (def.pattern = uuid());
    $ZodStringFormat.init(inst, def);
  });
  $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {
    def.pattern ?? (def.pattern = email);
    $ZodStringFormat.init(inst, def);
  });
  $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {
    $ZodStringFormat.init(inst, def);
    inst._zod.check = (payload) => {
      try {
        const trimmed = payload.value.trim();
        const url = new URL(trimmed);
        if (def.hostname) {
          def.hostname.lastIndex = 0;
          if (!def.hostname.test(url.hostname)) {
            payload.issues.push({
              code: "invalid_format",
              format: "url",
              note: "Invalid hostname",
              pattern: def.hostname.source,
              input: payload.value,
              inst,
              continue: !def.abort
            });
          }
        }
        if (def.protocol) {
          def.protocol.lastIndex = 0;
          if (!def.protocol.test(url.protocol.endsWith(":") ? url.protocol.slice(0, -1) : url.protocol)) {
            payload.issues.push({
              code: "invalid_format",
              format: "url",
              note: "Invalid protocol",
              pattern: def.protocol.source,
              input: payload.value,
              inst,
              continue: !def.abort
            });
          }
        }
        if (def.normalize) {
          payload.value = url.href;
        } else {
          payload.value = trimmed;
        }
        return;
      } catch (_) {
        payload.issues.push({
          code: "invalid_format",
          format: "url",
          input: payload.value,
          inst,
          continue: !def.abort
        });
      }
    };
  });
  $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {
    def.pattern ?? (def.pattern = emoji());
    $ZodStringFormat.init(inst, def);
  });
  $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {
    def.pattern ?? (def.pattern = nanoid);
    $ZodStringFormat.init(inst, def);
  });
  $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {
    def.pattern ?? (def.pattern = cuid);
    $ZodStringFormat.init(inst, def);
  });
  $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {
    def.pattern ?? (def.pattern = cuid2);
    $ZodStringFormat.init(inst, def);
  });
  $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {
    def.pattern ?? (def.pattern = ulid);
    $ZodStringFormat.init(inst, def);
  });
  $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {
    def.pattern ?? (def.pattern = xid);
    $ZodStringFormat.init(inst, def);
  });
  $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {
    def.pattern ?? (def.pattern = ksuid);
    $ZodStringFormat.init(inst, def);
  });
  $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {
    def.pattern ?? (def.pattern = datetime(def));
    $ZodStringFormat.init(inst, def);
  });
  $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {
    def.pattern ?? (def.pattern = date);
    $ZodStringFormat.init(inst, def);
  });
  $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {
    def.pattern ?? (def.pattern = time(def));
    $ZodStringFormat.init(inst, def);
  });
  $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {
    def.pattern ?? (def.pattern = duration);
    $ZodStringFormat.init(inst, def);
  });
  $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {
    def.pattern ?? (def.pattern = ipv4);
    $ZodStringFormat.init(inst, def);
    inst._zod.bag.format = `ipv4`;
  });
  $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {
    def.pattern ?? (def.pattern = ipv6);
    $ZodStringFormat.init(inst, def);
    inst._zod.bag.format = `ipv6`;
    inst._zod.check = (payload) => {
      try {
        new URL(`http://[${payload.value}]`);
      } catch {
        payload.issues.push({
          code: "invalid_format",
          format: "ipv6",
          input: payload.value,
          inst,
          continue: !def.abort
        });
      }
    };
  });
  $ZodMAC = /* @__PURE__ */ $constructor("$ZodMAC", (inst, def) => {
    def.pattern ?? (def.pattern = mac(def.delimiter));
    $ZodStringFormat.init(inst, def);
    inst._zod.bag.format = `mac`;
  });
  $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {
    def.pattern ?? (def.pattern = cidrv4);
    $ZodStringFormat.init(inst, def);
  });
  $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {
    def.pattern ?? (def.pattern = cidrv6);
    $ZodStringFormat.init(inst, def);
    inst._zod.check = (payload) => {
      const parts = payload.value.split("/");
      try {
        if (parts.length !== 2)
          throw new Error;
        const [address, prefix] = parts;
        if (!prefix)
          throw new Error;
        const prefixNum = Number(prefix);
        if (`${prefixNum}` !== prefix)
          throw new Error;
        if (prefixNum < 0 || prefixNum > 128)
          throw new Error;
        new URL(`http://[${address}]`);
      } catch {
        payload.issues.push({
          code: "invalid_format",
          format: "cidrv6",
          input: payload.value,
          inst,
          continue: !def.abort
        });
      }
    };
  });
  $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {
    def.pattern ?? (def.pattern = base64);
    $ZodStringFormat.init(inst, def);
    inst._zod.bag.contentEncoding = "base64";
    inst._zod.check = (payload) => {
      if (isValidBase64(payload.value))
        return;
      payload.issues.push({
        code: "invalid_format",
        format: "base64",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {
    def.pattern ?? (def.pattern = base64url);
    $ZodStringFormat.init(inst, def);
    inst._zod.bag.contentEncoding = "base64url";
    inst._zod.check = (payload) => {
      if (isValidBase64URL(payload.value))
        return;
      payload.issues.push({
        code: "invalid_format",
        format: "base64url",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {
    def.pattern ?? (def.pattern = e164);
    $ZodStringFormat.init(inst, def);
  });
  $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {
    $ZodStringFormat.init(inst, def);
    inst._zod.check = (payload) => {
      if (isValidJWT(payload.value, def.alg))
        return;
      payload.issues.push({
        code: "invalid_format",
        format: "jwt",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCustomStringFormat = /* @__PURE__ */ $constructor("$ZodCustomStringFormat", (inst, def) => {
    $ZodStringFormat.init(inst, def);
    inst._zod.check = (payload) => {
      if (def.fn(payload.value))
        return;
      payload.issues.push({
        code: "invalid_format",
        format: def.format,
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.pattern = inst._zod.bag.pattern ?? number;
    inst._zod.parse = (payload, _ctx) => {
      if (def.coerce)
        try {
          payload.value = Number(payload.value);
        } catch (_) {}
      const input = payload.value;
      if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
        return payload;
      }
      const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : undefined : undefined;
      payload.issues.push({
        expected: "number",
        code: "invalid_type",
        input,
        inst,
        ...received ? { received } : {}
      });
      return payload;
    };
  });
  $ZodNumberFormat = /* @__PURE__ */ $constructor("$ZodNumberFormat", (inst, def) => {
    $ZodCheckNumberFormat.init(inst, def);
    $ZodNumber.init(inst, def);
  });
  $ZodBoolean = /* @__PURE__ */ $constructor("$ZodBoolean", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.pattern = boolean;
    inst._zod.parse = (payload, _ctx) => {
      if (def.coerce)
        try {
          payload.value = Boolean(payload.value);
        } catch (_) {}
      const input = payload.value;
      if (typeof input === "boolean")
        return payload;
      payload.issues.push({
        expected: "boolean",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    };
  });
  $ZodBigInt = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.pattern = bigint;
    inst._zod.parse = (payload, _ctx) => {
      if (def.coerce)
        try {
          payload.value = BigInt(payload.value);
        } catch (_) {}
      if (typeof payload.value === "bigint")
        return payload;
      payload.issues.push({
        expected: "bigint",
        code: "invalid_type",
        input: payload.value,
        inst
      });
      return payload;
    };
  });
  $ZodBigIntFormat = /* @__PURE__ */ $constructor("$ZodBigIntFormat", (inst, def) => {
    $ZodCheckBigIntFormat.init(inst, def);
    $ZodBigInt.init(inst, def);
  });
  $ZodSymbol = /* @__PURE__ */ $constructor("$ZodSymbol", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
      const input = payload.value;
      if (typeof input === "symbol")
        return payload;
      payload.issues.push({
        expected: "symbol",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    };
  });
  $ZodUndefined = /* @__PURE__ */ $constructor("$ZodUndefined", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.pattern = _undefined;
    inst._zod.values = new Set([undefined]);
    inst._zod.optin = "optional";
    inst._zod.optout = "optional";
    inst._zod.parse = (payload, _ctx) => {
      const input = payload.value;
      if (typeof input === "undefined")
        return payload;
      payload.issues.push({
        expected: "undefined",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    };
  });
  $ZodNull = /* @__PURE__ */ $constructor("$ZodNull", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.pattern = _null;
    inst._zod.values = new Set([null]);
    inst._zod.parse = (payload, _ctx) => {
      const input = payload.value;
      if (input === null)
        return payload;
      payload.issues.push({
        expected: "null",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    };
  });
  $ZodAny = /* @__PURE__ */ $constructor("$ZodAny", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload) => payload;
  });
  $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload) => payload;
  });
  $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
      payload.issues.push({
        expected: "never",
        code: "invalid_type",
        input: payload.value,
        inst
      });
      return payload;
    };
  });
  $ZodVoid = /* @__PURE__ */ $constructor("$ZodVoid", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
      const input = payload.value;
      if (typeof input === "undefined")
        return payload;
      payload.issues.push({
        expected: "void",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    };
  });
  $ZodDate = /* @__PURE__ */ $constructor("$ZodDate", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
      if (def.coerce) {
        try {
          payload.value = new Date(payload.value);
        } catch (_err) {}
      }
      const input = payload.value;
      const isDate = input instanceof Date;
      const isValidDate = isDate && !Number.isNaN(input.getTime());
      if (isValidDate)
        return payload;
      payload.issues.push({
        expected: "date",
        code: "invalid_type",
        input,
        ...isDate ? { received: "Invalid Date" } : {},
        inst
      });
      return payload;
    };
  });
  $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      const input = payload.value;
      if (!Array.isArray(input)) {
        payload.issues.push({
          expected: "array",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      }
      payload.value = Array(input.length);
      const proms = [];
      for (let i = 0;i < input.length; i++) {
        const item = input[i];
        const result = def.element._zod.run({
          value: item,
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => handleArrayResult(result2, payload, i)));
        } else {
          handleArrayResult(result, payload, i);
        }
      }
      if (proms.length) {
        return Promise.all(proms).then(() => payload);
      }
      return payload;
    };
  });
  $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {
    $ZodType.init(inst, def);
    const desc = Object.getOwnPropertyDescriptor(def, "shape");
    if (!desc?.get) {
      const sh = def.shape;
      Object.defineProperty(def, "shape", {
        get: () => {
          const newSh = { ...sh };
          Object.defineProperty(def, "shape", {
            value: newSh
          });
          return newSh;
        }
      });
    }
    const _normalized = cached(() => normalizeDef(def));
    defineLazy(inst._zod, "propValues", () => {
      const shape = def.shape;
      const propValues = {};
      for (const key in shape) {
        const field = shape[key]._zod;
        if (field.values) {
          propValues[key] ?? (propValues[key] = new Set);
          for (const v of field.values)
            propValues[key].add(v);
        }
      }
      return propValues;
    });
    const isObject2 = isObject;
    const catchall = def.catchall;
    let value;
    inst._zod.parse = (payload, ctx) => {
      value ?? (value = _normalized.value);
      const input = payload.value;
      if (!isObject2(input)) {
        payload.issues.push({
          expected: "object",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      }
      payload.value = {};
      const proms = [];
      const shape = value.shape;
      for (const key of value.keys) {
        const el = shape[key];
        const isOptionalOut = el._zod.optout === "optional";
        const r = el._zod.run({ value: input[key], issues: [] }, ctx);
        if (r instanceof Promise) {
          proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input, isOptionalOut)));
        } else {
          handlePropertyResult(r, payload, key, input, isOptionalOut);
        }
      }
      if (!catchall) {
        return proms.length ? Promise.all(proms).then(() => payload) : payload;
      }
      return handleCatchall(proms, input, payload, ctx, _normalized.value, inst);
    };
  });
  $ZodObjectJIT = /* @__PURE__ */ $constructor("$ZodObjectJIT", (inst, def) => {
    $ZodObject.init(inst, def);
    const superParse = inst._zod.parse;
    const _normalized = cached(() => normalizeDef(def));
    const generateFastpass = (shape) => {
      const doc = new Doc(["shape", "payload", "ctx"]);
      const normalized = _normalized.value;
      const parseStr = (key) => {
        const k = esc(key);
        return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
      };
      doc.write(`const input = payload.value;`);
      const ids = Object.create(null);
      let counter = 0;
      for (const key of normalized.keys) {
        ids[key] = `key_${counter++}`;
      }
      doc.write(`const newResult = {};`);
      for (const key of normalized.keys) {
        const id = ids[key];
        const k = esc(key);
        const schema = shape[key];
        const isOptionalOut = schema?._zod?.optout === "optional";
        doc.write(`const ${id} = ${parseStr(key)};`);
        if (isOptionalOut) {
          doc.write(`
        if (${id}.issues.length) {
          if (${k} in input) {
            payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
              ...iss,
              path: iss.path ? [${k}, ...iss.path] : [${k}]
            })));
          }
        }
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
        } else {
          doc.write(`
        if (${id}.issues.length) {
          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k}, ...iss.path] : [${k}]
          })));
        }
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
        }
      }
      doc.write(`payload.value = newResult;`);
      doc.write(`return payload;`);
      const fn = doc.compile();
      return (payload, ctx) => fn(shape, payload, ctx);
    };
    let fastpass;
    const isObject2 = isObject;
    const jit = !globalConfig.jitless;
    const allowsEval2 = allowsEval;
    const fastEnabled = jit && allowsEval2.value;
    const catchall = def.catchall;
    let value;
    inst._zod.parse = (payload, ctx) => {
      value ?? (value = _normalized.value);
      const input = payload.value;
      if (!isObject2(input)) {
        payload.issues.push({
          expected: "object",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      }
      if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
        if (!fastpass)
          fastpass = generateFastpass(def.shape);
        payload = fastpass(payload, ctx);
        if (!catchall)
          return payload;
        return handleCatchall([], input, payload, ctx, value, inst);
      }
      return superParse(payload, ctx);
    };
  });
  $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : undefined);
    defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : undefined);
    defineLazy(inst._zod, "values", () => {
      if (def.options.every((o) => o._zod.values)) {
        return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
      }
      return;
    });
    defineLazy(inst._zod, "pattern", () => {
      if (def.options.every((o) => o._zod.pattern)) {
        const patterns = def.options.map((o) => o._zod.pattern);
        return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);
      }
      return;
    });
    const single = def.options.length === 1;
    const first = def.options[0]._zod.run;
    inst._zod.parse = (payload, ctx) => {
      if (single) {
        return first(payload, ctx);
      }
      let async = false;
      const results = [];
      for (const option of def.options) {
        const result = option._zod.run({
          value: payload.value,
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          results.push(result);
          async = true;
        } else {
          if (result.issues.length === 0)
            return result;
          results.push(result);
        }
      }
      if (!async)
        return handleUnionResults(results, payload, inst, ctx);
      return Promise.all(results).then((results2) => {
        return handleUnionResults(results2, payload, inst, ctx);
      });
    };
  });
  $ZodXor = /* @__PURE__ */ $constructor("$ZodXor", (inst, def) => {
    $ZodUnion.init(inst, def);
    def.inclusive = false;
    const single = def.options.length === 1;
    const first = def.options[0]._zod.run;
    inst._zod.parse = (payload, ctx) => {
      if (single) {
        return first(payload, ctx);
      }
      let async = false;
      const results = [];
      for (const option of def.options) {
        const result = option._zod.run({
          value: payload.value,
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          results.push(result);
          async = true;
        } else {
          results.push(result);
        }
      }
      if (!async)
        return handleExclusiveUnionResults(results, payload, inst, ctx);
      return Promise.all(results).then((results2) => {
        return handleExclusiveUnionResults(results2, payload, inst, ctx);
      });
    };
  });
  $ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("$ZodDiscriminatedUnion", (inst, def) => {
    def.inclusive = false;
    $ZodUnion.init(inst, def);
    const _super = inst._zod.parse;
    defineLazy(inst._zod, "propValues", () => {
      const propValues = {};
      for (const option of def.options) {
        const pv = option._zod.propValues;
        if (!pv || Object.keys(pv).length === 0)
          throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
        for (const [k, v] of Object.entries(pv)) {
          if (!propValues[k])
            propValues[k] = new Set;
          for (const val of v) {
            propValues[k].add(val);
          }
        }
      }
      return propValues;
    });
    const disc = cached(() => {
      const opts = def.options;
      const map = new Map;
      for (const o of opts) {
        const values = o._zod.propValues?.[def.discriminator];
        if (!values || values.size === 0)
          throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
        for (const v of values) {
          if (map.has(v)) {
            throw new Error(`Duplicate discriminator value "${String(v)}"`);
          }
          map.set(v, o);
        }
      }
      return map;
    });
    inst._zod.parse = (payload, ctx) => {
      const input = payload.value;
      if (!isObject(input)) {
        payload.issues.push({
          code: "invalid_type",
          expected: "object",
          input,
          inst
        });
        return payload;
      }
      const opt = disc.value.get(input?.[def.discriminator]);
      if (opt) {
        return opt._zod.run(payload, ctx);
      }
      if (def.unionFallback) {
        return _super(payload, ctx);
      }
      payload.issues.push({
        code: "invalid_union",
        errors: [],
        note: "No matching discriminator",
        discriminator: def.discriminator,
        input,
        path: [def.discriminator],
        inst
      });
      return payload;
    };
  });
  $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      const input = payload.value;
      const left = def.left._zod.run({ value: input, issues: [] }, ctx);
      const right = def.right._zod.run({ value: input, issues: [] }, ctx);
      const async = left instanceof Promise || right instanceof Promise;
      if (async) {
        return Promise.all([left, right]).then(([left2, right2]) => {
          return handleIntersectionResults(payload, left2, right2);
        });
      }
      return handleIntersectionResults(payload, left, right);
    };
  });
  $ZodTuple = /* @__PURE__ */ $constructor("$ZodTuple", (inst, def) => {
    $ZodType.init(inst, def);
    const items = def.items;
    inst._zod.parse = (payload, ctx) => {
      const input = payload.value;
      if (!Array.isArray(input)) {
        payload.issues.push({
          input,
          inst,
          expected: "tuple",
          code: "invalid_type"
        });
        return payload;
      }
      payload.value = [];
      const proms = [];
      const reversedIndex = [...items].reverse().findIndex((item) => item._zod.optin !== "optional");
      const optStart = reversedIndex === -1 ? 0 : items.length - reversedIndex;
      if (!def.rest) {
        const tooBig = input.length > items.length;
        const tooSmall = input.length < optStart - 1;
        if (tooBig || tooSmall) {
          payload.issues.push({
            ...tooBig ? { code: "too_big", maximum: items.length, inclusive: true } : { code: "too_small", minimum: items.length },
            input,
            inst,
            origin: "array"
          });
          return payload;
        }
      }
      let i = -1;
      for (const item of items) {
        i++;
        if (i >= input.length) {
          if (i >= optStart)
            continue;
        }
        const result = item._zod.run({
          value: input[i],
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
        } else {
          handleTupleResult(result, payload, i);
        }
      }
      if (def.rest) {
        const rest = input.slice(items.length);
        for (const el of rest) {
          i++;
          const result = def.rest._zod.run({
            value: el,
            issues: []
          }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
          } else {
            handleTupleResult(result, payload, i);
          }
        }
      }
      if (proms.length)
        return Promise.all(proms).then(() => payload);
      return payload;
    };
  });
  $ZodRecord = /* @__PURE__ */ $constructor("$ZodRecord", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      const input = payload.value;
      if (!isPlainObject(input)) {
        payload.issues.push({
          expected: "record",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      }
      const proms = [];
      const values = def.keyType._zod.values;
      if (values) {
        payload.value = {};
        const recordKeys = new Set;
        for (const key of values) {
          if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
            recordKeys.add(typeof key === "number" ? key.toString() : key);
            const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
            if (result instanceof Promise) {
              proms.push(result.then((result2) => {
                if (result2.issues.length) {
                  payload.issues.push(...prefixIssues(key, result2.issues));
                }
                payload.value[key] = result2.value;
              }));
            } else {
              if (result.issues.length) {
                payload.issues.push(...prefixIssues(key, result.issues));
              }
              payload.value[key] = result.value;
            }
          }
        }
        let unrecognized;
        for (const key in input) {
          if (!recordKeys.has(key)) {
            unrecognized = unrecognized ?? [];
            unrecognized.push(key);
          }
        }
        if (unrecognized && unrecognized.length > 0) {
          payload.issues.push({
            code: "unrecognized_keys",
            input,
            inst,
            keys: unrecognized
          });
        }
      } else {
        payload.value = {};
        for (const key of Reflect.ownKeys(input)) {
          if (key === "__proto__")
            continue;
          let keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
          if (keyResult instanceof Promise) {
            throw new Error("Async schemas not supported in object keys currently");
          }
          const checkNumericKey = typeof key === "string" && number.test(key) && keyResult.issues.length && keyResult.issues.some((iss) => iss.code === "invalid_type" && iss.expected === "number");
          if (checkNumericKey) {
            const retryResult = def.keyType._zod.run({ value: Number(key), issues: [] }, ctx);
            if (retryResult instanceof Promise) {
              throw new Error("Async schemas not supported in object keys currently");
            }
            if (retryResult.issues.length === 0) {
              keyResult = retryResult;
            }
          }
          if (keyResult.issues.length) {
            if (def.mode === "loose") {
              payload.value[key] = input[key];
            } else {
              payload.issues.push({
                code: "invalid_key",
                origin: "record",
                issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config())),
                input: key,
                path: [key],
                inst
              });
            }
            continue;
          }
          const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => {
              if (result2.issues.length) {
                payload.issues.push(...prefixIssues(key, result2.issues));
              }
              payload.value[keyResult.value] = result2.value;
            }));
          } else {
            if (result.issues.length) {
              payload.issues.push(...prefixIssues(key, result.issues));
            }
            payload.value[keyResult.value] = result.value;
          }
        }
      }
      if (proms.length) {
        return Promise.all(proms).then(() => payload);
      }
      return payload;
    };
  });
  $ZodMap = /* @__PURE__ */ $constructor("$ZodMap", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      const input = payload.value;
      if (!(input instanceof Map)) {
        payload.issues.push({
          expected: "map",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      }
      const proms = [];
      payload.value = new Map;
      for (const [key, value] of input) {
        const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
        const valueResult = def.valueType._zod.run({ value, issues: [] }, ctx);
        if (keyResult instanceof Promise || valueResult instanceof Promise) {
          proms.push(Promise.all([keyResult, valueResult]).then(([keyResult2, valueResult2]) => {
            handleMapResult(keyResult2, valueResult2, payload, key, input, inst, ctx);
          }));
        } else {
          handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);
        }
      }
      if (proms.length)
        return Promise.all(proms).then(() => payload);
      return payload;
    };
  });
  $ZodSet = /* @__PURE__ */ $constructor("$ZodSet", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      const input = payload.value;
      if (!(input instanceof Set)) {
        payload.issues.push({
          input,
          inst,
          expected: "set",
          code: "invalid_type"
        });
        return payload;
      }
      const proms = [];
      payload.value = new Set;
      for (const item of input) {
        const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => handleSetResult(result2, payload)));
        } else
          handleSetResult(result, payload);
      }
      if (proms.length)
        return Promise.all(proms).then(() => payload);
      return payload;
    };
  });
  $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {
    $ZodType.init(inst, def);
    const values = getEnumValues(def.entries);
    const valuesSet = new Set(values);
    inst._zod.values = valuesSet;
    inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o === "string" ? escapeRegex(o) : o.toString()).join("|")})$`);
    inst._zod.parse = (payload, _ctx) => {
      const input = payload.value;
      if (valuesSet.has(input)) {
        return payload;
      }
      payload.issues.push({
        code: "invalid_value",
        values,
        input,
        inst
      });
      return payload;
    };
  });
  $ZodLiteral = /* @__PURE__ */ $constructor("$ZodLiteral", (inst, def) => {
    $ZodType.init(inst, def);
    if (def.values.length === 0) {
      throw new Error("Cannot create literal schema with no valid values");
    }
    const values = new Set(def.values);
    inst._zod.values = values;
    inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o === "string" ? escapeRegex(o) : o ? escapeRegex(o.toString()) : String(o)).join("|")})$`);
    inst._zod.parse = (payload, _ctx) => {
      const input = payload.value;
      if (values.has(input)) {
        return payload;
      }
      payload.issues.push({
        code: "invalid_value",
        values: def.values,
        input,
        inst
      });
      return payload;
    };
  });
  $ZodFile = /* @__PURE__ */ $constructor("$ZodFile", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
      const input = payload.value;
      if (input instanceof File)
        return payload;
      payload.issues.push({
        expected: "file",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    };
  });
  $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      if (ctx.direction === "backward") {
        throw new $ZodEncodeError(inst.constructor.name);
      }
      const _out = def.transform(payload.value, payload);
      if (ctx.async) {
        const output = _out instanceof Promise ? _out : Promise.resolve(_out);
        return output.then((output2) => {
          payload.value = output2;
          return payload;
        });
      }
      if (_out instanceof Promise) {
        throw new $ZodAsyncError;
      }
      payload.value = _out;
      return payload;
    };
  });
  $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.optin = "optional";
    inst._zod.optout = "optional";
    defineLazy(inst._zod, "values", () => {
      return def.innerType._zod.values ? new Set([...def.innerType._zod.values, undefined]) : undefined;
    });
    defineLazy(inst._zod, "pattern", () => {
      const pattern = def.innerType._zod.pattern;
      return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : undefined;
    });
    inst._zod.parse = (payload, ctx) => {
      if (def.innerType._zod.optin === "optional") {
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise)
          return result.then((r) => handleOptionalResult(r, payload.value));
        return handleOptionalResult(result, payload.value);
      }
      if (payload.value === undefined) {
        return payload;
      }
      return def.innerType._zod.run(payload, ctx);
    };
  });
  $ZodExactOptional = /* @__PURE__ */ $constructor("$ZodExactOptional", (inst, def) => {
    $ZodOptional.init(inst, def);
    defineLazy(inst._zod, "values", () => def.innerType._zod.values);
    defineLazy(inst._zod, "pattern", () => def.innerType._zod.pattern);
    inst._zod.parse = (payload, ctx) => {
      return def.innerType._zod.run(payload, ctx);
    };
  });
  $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
    defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
    defineLazy(inst._zod, "pattern", () => {
      const pattern = def.innerType._zod.pattern;
      return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : undefined;
    });
    defineLazy(inst._zod, "values", () => {
      return def.innerType._zod.values ? new Set([...def.innerType._zod.values, null]) : undefined;
    });
    inst._zod.parse = (payload, ctx) => {
      if (payload.value === null)
        return payload;
      return def.innerType._zod.run(payload, ctx);
    };
  });
  $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.optin = "optional";
    defineLazy(inst._zod, "values", () => def.innerType._zod.values);
    inst._zod.parse = (payload, ctx) => {
      if (ctx.direction === "backward") {
        return def.innerType._zod.run(payload, ctx);
      }
      if (payload.value === undefined) {
        payload.value = def.defaultValue;
        return payload;
      }
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise) {
        return result.then((result2) => handleDefaultResult(result2, def));
      }
      return handleDefaultResult(result, def);
    };
  });
  $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.optin = "optional";
    defineLazy(inst._zod, "values", () => def.innerType._zod.values);
    inst._zod.parse = (payload, ctx) => {
      if (ctx.direction === "backward") {
        return def.innerType._zod.run(payload, ctx);
      }
      if (payload.value === undefined) {
        payload.value = def.defaultValue;
      }
      return def.innerType._zod.run(payload, ctx);
    };
  });
  $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "values", () => {
      const v = def.innerType._zod.values;
      return v ? new Set([...v].filter((x) => x !== undefined)) : undefined;
    });
    inst._zod.parse = (payload, ctx) => {
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise) {
        return result.then((result2) => handleNonOptionalResult(result2, inst));
      }
      return handleNonOptionalResult(result, inst);
    };
  });
  $ZodSuccess = /* @__PURE__ */ $constructor("$ZodSuccess", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      if (ctx.direction === "backward") {
        throw new $ZodEncodeError("ZodSuccess");
      }
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise) {
        return result.then((result2) => {
          payload.value = result2.issues.length === 0;
          return payload;
        });
      }
      payload.value = result.issues.length === 0;
      return payload;
    };
  });
  $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
    defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
    defineLazy(inst._zod, "values", () => def.innerType._zod.values);
    inst._zod.parse = (payload, ctx) => {
      if (ctx.direction === "backward") {
        return def.innerType._zod.run(payload, ctx);
      }
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise) {
        return result.then((result2) => {
          payload.value = result2.value;
          if (result2.issues.length) {
            payload.value = def.catchValue({
              ...payload,
              error: {
                issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config()))
              },
              input: payload.value
            });
            payload.issues = [];
          }
          return payload;
        });
      }
      payload.value = result.value;
      if (result.issues.length) {
        payload.value = def.catchValue({
          ...payload,
          error: {
            issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config()))
          },
          input: payload.value
        });
        payload.issues = [];
      }
      return payload;
    };
  });
  $ZodNaN = /* @__PURE__ */ $constructor("$ZodNaN", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
      if (typeof payload.value !== "number" || !Number.isNaN(payload.value)) {
        payload.issues.push({
          input: payload.value,
          inst,
          expected: "nan",
          code: "invalid_type"
        });
        return payload;
      }
      return payload;
    };
  });
  $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "values", () => def.in._zod.values);
    defineLazy(inst._zod, "optin", () => def.in._zod.optin);
    defineLazy(inst._zod, "optout", () => def.out._zod.optout);
    defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
    inst._zod.parse = (payload, ctx) => {
      if (ctx.direction === "backward") {
        const right = def.out._zod.run(payload, ctx);
        if (right instanceof Promise) {
          return right.then((right2) => handlePipeResult(right2, def.in, ctx));
        }
        return handlePipeResult(right, def.in, ctx);
      }
      const left = def.in._zod.run(payload, ctx);
      if (left instanceof Promise) {
        return left.then((left2) => handlePipeResult(left2, def.out, ctx));
      }
      return handlePipeResult(left, def.out, ctx);
    };
  });
  $ZodCodec = /* @__PURE__ */ $constructor("$ZodCodec", (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "values", () => def.in._zod.values);
    defineLazy(inst._zod, "optin", () => def.in._zod.optin);
    defineLazy(inst._zod, "optout", () => def.out._zod.optout);
    defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
    inst._zod.parse = (payload, ctx) => {
      const direction = ctx.direction || "forward";
      if (direction === "forward") {
        const left = def.in._zod.run(payload, ctx);
        if (left instanceof Promise) {
          return left.then((left2) => handleCodecAResult(left2, def, ctx));
        }
        return handleCodecAResult(left, def, ctx);
      } else {
        const right = def.out._zod.run(payload, ctx);
        if (right instanceof Promise) {
          return right.then((right2) => handleCodecAResult(right2, def, ctx));
        }
        return handleCodecAResult(right, def, ctx);
      }
    };
  });
  $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
    defineLazy(inst._zod, "values", () => def.innerType._zod.values);
    defineLazy(inst._zod, "optin", () => def.innerType?._zod?.optin);
    defineLazy(inst._zod, "optout", () => def.innerType?._zod?.optout);
    inst._zod.parse = (payload, ctx) => {
      if (ctx.direction === "backward") {
        return def.innerType._zod.run(payload, ctx);
      }
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise) {
        return result.then(handleReadonlyResult);
      }
      return handleReadonlyResult(result);
    };
  });
  $ZodTemplateLiteral = /* @__PURE__ */ $constructor("$ZodTemplateLiteral", (inst, def) => {
    $ZodType.init(inst, def);
    const regexParts = [];
    for (const part of def.parts) {
      if (typeof part === "object" && part !== null) {
        if (!part._zod.pattern) {
          throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
        }
        const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
        if (!source)
          throw new Error(`Invalid template literal part: ${part._zod.traits}`);
        const start = source.startsWith("^") ? 1 : 0;
        const end = source.endsWith("$") ? source.length - 1 : source.length;
        regexParts.push(source.slice(start, end));
      } else if (part === null || primitiveTypes.has(typeof part)) {
        regexParts.push(escapeRegex(`${part}`));
      } else {
        throw new Error(`Invalid template literal part: ${part}`);
      }
    }
    inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`);
    inst._zod.parse = (payload, _ctx) => {
      if (typeof payload.value !== "string") {
        payload.issues.push({
          input: payload.value,
          inst,
          expected: "string",
          code: "invalid_type"
        });
        return payload;
      }
      inst._zod.pattern.lastIndex = 0;
      if (!inst._zod.pattern.test(payload.value)) {
        payload.issues.push({
          input: payload.value,
          inst,
          code: "invalid_format",
          format: def.format ?? "template_literal",
          pattern: inst._zod.pattern.source
        });
        return payload;
      }
      return payload;
    };
  });
  $ZodFunction = /* @__PURE__ */ $constructor("$ZodFunction", (inst, def) => {
    $ZodType.init(inst, def);
    inst._def = def;
    inst._zod.def = def;
    inst.implement = (func) => {
      if (typeof func !== "function") {
        throw new Error("implement() must be called with a function");
      }
      return function(...args) {
        const parsedArgs = inst._def.input ? parse2(inst._def.input, args) : args;
        const result = Reflect.apply(func, this, parsedArgs);
        if (inst._def.output) {
          return parse2(inst._def.output, result);
        }
        return result;
      };
    };
    inst.implementAsync = (func) => {
      if (typeof func !== "function") {
        throw new Error("implementAsync() must be called with a function");
      }
      return async function(...args) {
        const parsedArgs = inst._def.input ? await parseAsync(inst._def.input, args) : args;
        const result = await Reflect.apply(func, this, parsedArgs);
        if (inst._def.output) {
          return await parseAsync(inst._def.output, result);
        }
        return result;
      };
    };
    inst._zod.parse = (payload, _ctx) => {
      if (typeof payload.value !== "function") {
        payload.issues.push({
          code: "invalid_type",
          expected: "function",
          input: payload.value,
          inst
        });
        return payload;
      }
      const hasPromiseOutput = inst._def.output && inst._def.output._zod.def.type === "promise";
      if (hasPromiseOutput) {
        payload.value = inst.implementAsync(payload.value);
      } else {
        payload.value = inst.implement(payload.value);
      }
      return payload;
    };
    inst.input = (...args) => {
      const F = inst.constructor;
      if (Array.isArray(args[0])) {
        return new F({
          type: "function",
          input: new $ZodTuple({
            type: "tuple",
            items: args[0],
            rest: args[1]
          }),
          output: inst._def.output
        });
      }
      return new F({
        type: "function",
        input: args[0],
        output: inst._def.output
      });
    };
    inst.output = (output) => {
      const F = inst.constructor;
      return new F({
        type: "function",
        input: inst._def.input,
        output
      });
    };
    return inst;
  });
  $ZodPromise = /* @__PURE__ */ $constructor("$ZodPromise", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));
    };
  });
  $ZodLazy = /* @__PURE__ */ $constructor("$ZodLazy", (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "innerType", () => def.getter());
    defineLazy(inst._zod, "pattern", () => inst._zod.innerType?._zod?.pattern);
    defineLazy(inst._zod, "propValues", () => inst._zod.innerType?._zod?.propValues);
    defineLazy(inst._zod, "optin", () => inst._zod.innerType?._zod?.optin ?? undefined);
    defineLazy(inst._zod, "optout", () => inst._zod.innerType?._zod?.optout ?? undefined);
    inst._zod.parse = (payload, ctx) => {
      const inner = inst._zod.innerType;
      return inner._zod.run(payload, ctx);
    };
  });
  $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {
    $ZodCheck.init(inst, def);
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, _) => {
      return payload;
    };
    inst._zod.check = (payload) => {
      const input = payload.value;
      const r = def.fn(input);
      if (r instanceof Promise) {
        return r.then((r2) => handleRefineResult(r2, payload, input, inst));
      }
      handleRefineResult(r, payload, input, inst);
      return;
    };
  });
});

// node_modules/zod/v4/locales/ar.js
function ar_default() {
  return {
    localeError: error()
  };
}
var error = () => {
  const Sizable = {
    string: { unit: "\u062D\u0631\u0641", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
    file: { unit: "\u0628\u0627\u064A\u062A", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
    array: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
    set: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0645\u062F\u062E\u0644",
    email: "\u0628\u0631\u064A\u062F \u0625\u0644\u0643\u062A\u0631\u0648\u0646\u064A",
    url: "\u0631\u0627\u0628\u0637",
    emoji: "\u0625\u064A\u0645\u0648\u062C\u064A",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u062A\u0627\u0631\u064A\u062E \u0648\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    date: "\u062A\u0627\u0631\u064A\u062E \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    time: "\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    duration: "\u0645\u062F\u0629 \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    ipv4: "\u0639\u0646\u0648\u0627\u0646 IPv4",
    ipv6: "\u0639\u0646\u0648\u0627\u0646 IPv6",
    cidrv4: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv4",
    cidrv6: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv6",
    base64: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64-encoded",
    base64url: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64url-encoded",
    json_string: "\u0646\u064E\u0635 \u0639\u0644\u0649 \u0647\u064A\u0626\u0629 JSON",
    e164: "\u0631\u0642\u0645 \u0647\u0627\u062A\u0641 \u0628\u0645\u0639\u064A\u0627\u0631 E.164",
    jwt: "JWT",
    template_literal: "\u0645\u062F\u062E\u0644"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 instanceof ${issue2.expected}\u060C \u0648\u0644\u0643\u0646 \u062A\u0645 \u0625\u062F\u062E\u0627\u0644 ${received}`;
        }
        return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${expected}\u060C \u0648\u0644\u0643\u0646 \u062A\u0645 \u0625\u062F\u062E\u0627\u0644 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0627\u062E\u062A\u064A\u0627\u0631 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062A\u0648\u0642\u0639 \u0627\u0646\u062A\u0642\u0627\u0621 \u0623\u062D\u062F \u0647\u0630\u0647 \u0627\u0644\u062E\u064A\u0627\u0631\u0627\u062A: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return ` \u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue2.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"}`;
        return `\u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue2.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue2.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue2.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0628\u062F\u0623 \u0628\u0640 "${issue2.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0646\u062A\u0647\u064A \u0628\u0640 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u062A\u0636\u0645\u0651\u064E\u0646 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0637\u0627\u0628\u0642 \u0627\u0644\u0646\u0645\u0637 ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644`;
      }
      case "not_multiple_of":
        return `\u0631\u0642\u0645 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 \u0645\u0646 \u0645\u0636\u0627\u0639\u0641\u0627\u062A ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u0645\u0639\u0631\u0641${issue2.keys.length > 1 ? "\u0627\u062A" : ""} \u063A\u0631\u064A\u0628${issue2.keys.length > 1 ? "\u0629" : ""}: ${joinValues(issue2.keys, "\u060C ")}`;
      case "invalid_key":
        return `\u0645\u0639\u0631\u0641 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue2.origin}`;
      case "invalid_union":
        return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
      case "invalid_element":
        return `\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue2.origin}`;
      default:
        return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
    }
  };
};
var init_ar = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/az.js
function az_default() {
  return {
    localeError: error2()
  };
}
var error2 = () => {
  const Sizable = {
    string: { unit: "simvol", verb: "olmal\u0131d\u0131r" },
    file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
    array: { unit: "element", verb: "olmal\u0131d\u0131r" },
    set: { unit: "element", verb: "olmal\u0131d\u0131r" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n instanceof ${issue2.expected}, daxil olan ${received}`;
        }
        return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${expected}, daxil olan ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${stringifyPrimitive(issue2.values[0])}`;
        return `Yanl\u0131\u015F se\xE7im: a\u015Fa\u011F\u0131dak\u0131lardan biri olmal\u0131d\u0131r: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue2.origin ?? "d\u0259y\u0259r"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue2.origin ?? "d\u0259y\u0259r"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Yanl\u0131\u015F m\u0259tn: "${_issue.prefix}" il\u0259 ba\u015Flamal\u0131d\u0131r`;
        if (_issue.format === "ends_with")
          return `Yanl\u0131\u015F m\u0259tn: "${_issue.suffix}" il\u0259 bitm\u0259lidir`;
        if (_issue.format === "includes")
          return `Yanl\u0131\u015F m\u0259tn: "${_issue.includes}" daxil olmal\u0131d\u0131r`;
        if (_issue.format === "regex")
          return `Yanl\u0131\u015F m\u0259tn: ${_issue.pattern} \u015Fablonuna uy\u011Fun olmal\u0131d\u0131r`;
        return `Yanl\u0131\u015F ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Yanl\u0131\u015F \u0259d\u0259d: ${issue2.divisor} il\u0259 b\xF6l\xFCn\u0259 bil\u0259n olmal\u0131d\u0131r`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan a\xE7ar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} daxilind\u0259 yanl\u0131\u015F a\xE7ar`;
      case "invalid_union":
        return "Yanl\u0131\u015F d\u0259y\u0259r";
      case "invalid_element":
        return `${issue2.origin} daxilind\u0259 yanl\u0131\u015F d\u0259y\u0259r`;
      default:
        return `Yanl\u0131\u015F d\u0259y\u0259r`;
    }
  };
};
var init_az = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/be.js
function getBelarusianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
function be_default() {
  return {
    localeError: error3()
  };
}
var error3 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "\u0441\u0456\u043C\u0432\u0430\u043B",
        few: "\u0441\u0456\u043C\u0432\u0430\u043B\u044B",
        many: "\u0441\u0456\u043C\u0432\u0430\u043B\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    array: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    set: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    file: {
      unit: {
        one: "\u0431\u0430\u0439\u0442",
        few: "\u0431\u0430\u0439\u0442\u044B",
        many: "\u0431\u0430\u0439\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0443\u0432\u043E\u0434",
    email: "email \u0430\u0434\u0440\u0430\u0441",
    url: "URL",
    emoji: "\u044D\u043C\u043E\u0434\u0437\u0456",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0430 \u0456 \u0447\u0430\u0441",
    date: "ISO \u0434\u0430\u0442\u0430",
    time: "ISO \u0447\u0430\u0441",
    duration: "ISO \u043F\u0440\u0430\u0446\u044F\u0433\u043B\u0430\u0441\u0446\u044C",
    ipv4: "IPv4 \u0430\u0434\u0440\u0430\u0441",
    ipv6: "IPv6 \u0430\u0434\u0440\u0430\u0441",
    cidrv4: "IPv4 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
    cidrv6: "IPv6 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
    base64: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64",
    base64url: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64url",
    json_string: "JSON \u0440\u0430\u0434\u043E\u043A",
    e164: "\u043D\u0443\u043C\u0430\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0443\u0432\u043E\u0434"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u043B\u0456\u043A",
    array: "\u043C\u0430\u0441\u0456\u045E"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u045E\u0441\u044F instanceof ${issue2.expected}, \u0430\u0442\u0440\u044B\u043C\u0430\u043D\u0430 ${received}`;
        }
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u045E\u0441\u044F ${expected}, \u0430\u0442\u0440\u044B\u043C\u0430\u043D\u0430 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F ${stringifyPrimitive(issue2.values[0])}`;
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0432\u0430\u0440\u044B\u044F\u043D\u0442: \u0447\u0430\u043A\u0430\u045E\u0441\u044F \u0430\u0434\u0437\u0456\u043D \u0437 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getBelarusianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getBelarusianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u043F\u0430\u0447\u044B\u043D\u0430\u0446\u0446\u0430 \u0437 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u0430\u043A\u0430\u043D\u0447\u0432\u0430\u0446\u0446\u0430 \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u043C\u044F\u0448\u0447\u0430\u0446\u044C "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0430\u0434\u043F\u0430\u0432\u044F\u0434\u0430\u0446\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043B\u0456\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0431\u044B\u0446\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0441\u043F\u0430\u0437\u043D\u0430\u043D\u044B ${issue2.keys.length > 1 ? "\u043A\u043B\u044E\u0447\u044B" : "\u043A\u043B\u044E\u0447"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043A\u043B\u044E\u0447 \u0443 ${issue2.origin}`;
      case "invalid_union":
        return "\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434";
      case "invalid_element":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u0430\u0435 \u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435 \u045E ${issue2.origin}`;
      default:
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434`;
    }
  };
};
var init_be = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/bg.js
function bg_default() {
  return {
    localeError: error4()
  };
}
var error4 = () => {
  const Sizable = {
    string: { unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
    file: { unit: "\u0431\u0430\u0439\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
    array: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
    set: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0432\u0445\u043E\u0434",
    email: "\u0438\u043C\u0435\u0439\u043B \u0430\u0434\u0440\u0435\u0441",
    url: "URL",
    emoji: "\u0435\u043C\u043E\u0434\u0436\u0438",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0432\u0440\u0435\u043C\u0435",
    date: "ISO \u0434\u0430\u0442\u0430",
    time: "ISO \u0432\u0440\u0435\u043C\u0435",
    duration: "ISO \u043F\u0440\u043E\u0434\u044A\u043B\u0436\u0438\u0442\u0435\u043B\u043D\u043E\u0441\u0442",
    ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
    ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
    cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    base64: "base64-\u043A\u043E\u0434\u0438\u0440\u0430\u043D \u043D\u0438\u0437",
    base64url: "base64url-\u043A\u043E\u0434\u0438\u0440\u0430\u043D \u043D\u0438\u0437",
    json_string: "JSON \u043D\u0438\u0437",
    e164: "E.164 \u043D\u043E\u043C\u0435\u0440",
    jwt: "JWT",
    template_literal: "\u0432\u0445\u043E\u0434"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0447\u0438\u0441\u043B\u043E",
    array: "\u043C\u0430\u0441\u0438\u0432"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D instanceof ${issue2.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D ${received}`;
        }
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D ${expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D ${stringifyPrimitive(issue2.values[0])}`;
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430 \u043E\u043F\u0446\u0438\u044F: \u043E\u0447\u0430\u043A\u0432\u0430\u043D\u043E \u0435\u0434\u043D\u043E \u043E\u0442 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u0422\u0432\u044A\u0440\u0434\u0435 \u0433\u043E\u043B\u044F\u043C\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin ?? "\u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442"} \u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430"}`;
        return `\u0422\u0432\u044A\u0440\u0434\u0435 \u0433\u043E\u043B\u044F\u043C\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin ?? "\u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442"} \u0434\u0430 \u0431\u044A\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0422\u0432\u044A\u0440\u0434\u0435 \u043C\u0430\u043B\u043A\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin} \u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430 ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0422\u0432\u044A\u0440\u0434\u0435 \u043C\u0430\u043B\u043A\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin} \u0434\u0430 \u0431\u044A\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u0432\u0430 \u0441 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0437\u0430\u0432\u044A\u0440\u0448\u0432\u0430 \u0441 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0432\u043A\u043B\u044E\u0447\u0432\u0430 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0441\u044A\u0432\u043F\u0430\u0434\u0430 \u0441 ${_issue.pattern}`;
        let invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D";
        if (_issue.format === "emoji")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
        if (_issue.format === "datetime")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
        if (_issue.format === "date")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430";
        if (_issue.format === "time")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
        if (_issue.format === "duration")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430";
        return `${invalid_adj} ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E \u0447\u0438\u0441\u043B\u043E: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0431\u044A\u0434\u0435 \u043A\u0440\u0430\u0442\u043D\u043E \u043D\u0430 ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0437\u043F\u043E\u0437\u043D\u0430\u0442${issue2.keys.length > 1 ? "\u0438" : ""} \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u043E\u0432\u0435" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043A\u043B\u044E\u0447 \u0432 ${issue2.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434";
      case "invalid_element":
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430 \u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442 \u0432 ${issue2.origin}`;
      default:
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434`;
    }
  };
};
var init_bg = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/ca.js
function ca_default() {
  return {
    localeError: error5()
  };
}
var error5 = () => {
  const Sizable = {
    string: { unit: "car\xE0cters", verb: "contenir" },
    file: { unit: "bytes", verb: "contenir" },
    array: { unit: "elements", verb: "contenir" },
    set: { unit: "elements", verb: "contenir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "entrada",
    email: "adre\xE7a electr\xF2nica",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "durada ISO",
    ipv4: "adre\xE7a IPv4",
    ipv6: "adre\xE7a IPv6",
    cidrv4: "rang IPv4",
    cidrv6: "rang IPv6",
    base64: "cadena codificada en base64",
    base64url: "cadena codificada en base64url",
    json_string: "cadena JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Tipus inv\xE0lid: s'esperava instanceof ${issue2.expected}, s'ha rebut ${received}`;
        }
        return `Tipus inv\xE0lid: s'esperava ${expected}, s'ha rebut ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Valor inv\xE0lid: s'esperava ${stringifyPrimitive(issue2.values[0])}`;
        return `Opci\xF3 inv\xE0lida: s'esperava una de ${joinValues(issue2.values, " o ")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "com a m\xE0xim" : "menys de";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} contingu\xE9s ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} fos ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "com a m\xEDnim" : "m\xE9s de";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Massa petit: s'esperava que ${issue2.origin} contingu\xE9s ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Massa petit: s'esperava que ${issue2.origin} fos ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Format inv\xE0lid: ha de comen\xE7ar amb "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Format inv\xE0lid: ha d'acabar amb "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Format inv\xE0lid: ha d'incloure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Format inv\xE0lid: ha de coincidir amb el patr\xF3 ${_issue.pattern}`;
        return `Format inv\xE0lid per a ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE0lid: ha de ser m\xFAltiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Clau${issue2.keys.length > 1 ? "s" : ""} no reconeguda${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Clau inv\xE0lida a ${issue2.origin}`;
      case "invalid_union":
        return "Entrada inv\xE0lida";
      case "invalid_element":
        return `Element inv\xE0lid a ${issue2.origin}`;
      default:
        return `Entrada inv\xE0lida`;
    }
  };
};
var init_ca = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/cs.js
function cs_default() {
  return {
    localeError: error6()
  };
}
var error6 = () => {
  const Sizable = {
    string: { unit: "znak\u016F", verb: "m\xEDt" },
    file: { unit: "bajt\u016F", verb: "m\xEDt" },
    array: { unit: "prvk\u016F", verb: "m\xEDt" },
    set: { unit: "prvk\u016F", verb: "m\xEDt" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "regul\xE1rn\xED v\xFDraz",
    email: "e-mailov\xE1 adresa",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "datum a \u010Das ve form\xE1tu ISO",
    date: "datum ve form\xE1tu ISO",
    time: "\u010Das ve form\xE1tu ISO",
    duration: "doba trv\xE1n\xED ISO",
    ipv4: "IPv4 adresa",
    ipv6: "IPv6 adresa",
    cidrv4: "rozsah IPv4",
    cidrv6: "rozsah IPv6",
    base64: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64",
    base64url: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64url",
    json_string: "\u0159et\u011Bzec ve form\xE1tu JSON",
    e164: "\u010D\xEDslo E.164",
    jwt: "JWT",
    template_literal: "vstup"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u010D\xEDslo",
    string: "\u0159et\u011Bzec",
    function: "funkce",
    array: "pole"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no instanceof ${issue2.expected}, obdr\u017Eeno ${received}`;
        }
        return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${expected}, obdr\u017Eeno ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${stringifyPrimitive(issue2.values[0])}`;
        return `Neplatn\xE1 mo\u017Enost: o\u010Dek\xE1v\xE1na jedna z hodnot ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue2.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
        }
        return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue2.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue2.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
        }
        return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue2.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED za\u010D\xEDnat na "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED kon\u010Dit na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED obsahovat "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED odpov\xEDdat vzoru ${_issue.pattern}`;
        return `Neplatn\xFD form\xE1t ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Neplatn\xE9 \u010D\xEDslo: mus\xED b\xFDt n\xE1sobkem ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nezn\xE1m\xE9 kl\xED\u010De: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Neplatn\xFD kl\xED\u010D v ${issue2.origin}`;
      case "invalid_union":
        return "Neplatn\xFD vstup";
      case "invalid_element":
        return `Neplatn\xE1 hodnota v ${issue2.origin}`;
      default:
        return `Neplatn\xFD vstup`;
    }
  };
};
var init_cs = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/da.js
function da_default() {
  return {
    localeError: error7()
  };
}
var error7 = () => {
  const Sizable = {
    string: { unit: "tegn", verb: "havde" },
    file: { unit: "bytes", verb: "havde" },
    array: { unit: "elementer", verb: "indeholdt" },
    set: { unit: "elementer", verb: "indeholdt" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "e-mailadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkesl\xE6t",
    date: "ISO-dato",
    time: "ISO-klokkesl\xE6t",
    duration: "ISO-varighed",
    ipv4: "IPv4-omr\xE5de",
    ipv6: "IPv6-omr\xE5de",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodet streng",
    base64url: "base64url-kodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    string: "streng",
    number: "tal",
    boolean: "boolean",
    array: "liste",
    object: "objekt",
    set: "s\xE6t",
    file: "fil"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ugyldigt input: forventede instanceof ${issue2.expected}, fik ${received}`;
        }
        return `Ugyldigt input: forventede ${expected}, fik ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ugyldig v\xE6rdi: forventede ${stringifyPrimitive(issue2.values[0])}`;
        return `Ugyldigt valg: forventede en af f\xF8lgende ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        if (sizing)
          return `For stor: forventede ${origin ?? "value"} ${sizing.verb} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor: forventede ${origin ?? "value"} havde ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        if (sizing) {
          return `For lille: forventede ${origin} ${sizing.verb} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `For lille: forventede ${origin} havde ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: skal starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: skal ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: skal indeholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: skal matche m\xF8nsteret ${_issue.pattern}`;
        return `Ugyldig ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ugyldigt tal: skal v\xE6re deleligt med ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ukendte n\xF8gler" : "Ukendt n\xF8gle"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig n\xF8gle i ${issue2.origin}`;
      case "invalid_union":
        return "Ugyldigt input: matcher ingen af de tilladte typer";
      case "invalid_element":
        return `Ugyldig v\xE6rdi i ${issue2.origin}`;
      default:
        return `Ugyldigt input`;
    }
  };
};
var init_da = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/de.js
function de_default() {
  return {
    localeError: error8()
  };
}
var error8 = () => {
  const Sizable = {
    string: { unit: "Zeichen", verb: "zu haben" },
    file: { unit: "Bytes", verb: "zu haben" },
    array: { unit: "Elemente", verb: "zu haben" },
    set: { unit: "Elemente", verb: "zu haben" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "Eingabe",
    email: "E-Mail-Adresse",
    url: "URL",
    emoji: "Emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-Datum und -Uhrzeit",
    date: "ISO-Datum",
    time: "ISO-Uhrzeit",
    duration: "ISO-Dauer",
    ipv4: "IPv4-Adresse",
    ipv6: "IPv6-Adresse",
    cidrv4: "IPv4-Bereich",
    cidrv6: "IPv6-Bereich",
    base64: "Base64-codierter String",
    base64url: "Base64-URL-codierter String",
    json_string: "JSON-String",
    e164: "E.164-Nummer",
    jwt: "JWT",
    template_literal: "Eingabe"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "Zahl",
    array: "Array"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ung\xFCltige Eingabe: erwartet instanceof ${issue2.expected}, erhalten ${received}`;
        }
        return `Ung\xFCltige Eingabe: erwartet ${expected}, erhalten ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ung\xFCltige Eingabe: erwartet ${stringifyPrimitive(issue2.values[0])}`;
        return `Ung\xFCltige Option: erwartet eine von ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Zu gro\xDF: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "Elemente"} hat`;
        return `Zu gro\xDF: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ist`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} hat`;
        }
        return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ist`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ung\xFCltiger String: muss mit "${_issue.prefix}" beginnen`;
        if (_issue.format === "ends_with")
          return `Ung\xFCltiger String: muss mit "${_issue.suffix}" enden`;
        if (_issue.format === "includes")
          return `Ung\xFCltiger String: muss "${_issue.includes}" enthalten`;
        if (_issue.format === "regex")
          return `Ung\xFCltiger String: muss dem Muster ${_issue.pattern} entsprechen`;
        return `Ung\xFCltig: ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ung\xFCltige Zahl: muss ein Vielfaches von ${issue2.divisor} sein`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Unbekannte Schl\xFCssel" : "Unbekannter Schl\xFCssel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ung\xFCltiger Schl\xFCssel in ${issue2.origin}`;
      case "invalid_union":
        return "Ung\xFCltige Eingabe";
      case "invalid_element":
        return `Ung\xFCltiger Wert in ${issue2.origin}`;
      default:
        return `Ung\xFCltige Eingabe`;
    }
  };
};
var init_de = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/en.js
function en_default() {
  return {
    localeError: error9()
  };
}
var error9 = () => {
  const Sizable = {
    string: { unit: "characters", verb: "to have" },
    file: { unit: "bytes", verb: "to have" },
    array: { unit: "items", verb: "to have" },
    set: { unit: "items", verb: "to have" },
    map: { unit: "entries", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    mac: "MAC address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        return `Invalid input: expected ${expected}, received ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
        return `Invalid option: expected one of ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Too big: expected ${issue2.origin ?? "value"} to have ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Too big: expected ${issue2.origin ?? "value"} to be ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Too small: expected ${issue2.origin} to have ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Too small: expected ${issue2.origin} to be ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Invalid string: must start with "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Invalid string: must end with "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Invalid string: must include "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Invalid string: must match pattern ${_issue.pattern}`;
        return `Invalid ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Invalid number: must be a multiple of ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Unrecognized key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Invalid key in ${issue2.origin}`;
      case "invalid_union":
        return "Invalid input";
      case "invalid_element":
        return `Invalid value in ${issue2.origin}`;
      default:
        return `Invalid input`;
    }
  };
};
var init_en = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/eo.js
function eo_default() {
  return {
    localeError: error10()
  };
}
var error10 = () => {
  const Sizable = {
    string: { unit: "karaktrojn", verb: "havi" },
    file: { unit: "bajtojn", verb: "havi" },
    array: { unit: "elementojn", verb: "havi" },
    set: { unit: "elementojn", verb: "havi" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "enigo",
    email: "retadreso",
    url: "URL",
    emoji: "emo\u011Dio",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datotempo",
    date: "ISO-dato",
    time: "ISO-tempo",
    duration: "ISO-da\u016Dro",
    ipv4: "IPv4-adreso",
    ipv6: "IPv6-adreso",
    cidrv4: "IPv4-rango",
    cidrv6: "IPv6-rango",
    base64: "64-ume kodita karaktraro",
    base64url: "URL-64-ume kodita karaktraro",
    json_string: "JSON-karaktraro",
    e164: "E.164-nombro",
    jwt: "JWT",
    template_literal: "enigo"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "nombro",
    array: "tabelo",
    null: "senvalora"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Nevalida enigo: atendi\u011Dis instanceof ${issue2.expected}, ricevi\u011Dis ${received}`;
        }
        return `Nevalida enigo: atendi\u011Dis ${expected}, ricevi\u011Dis ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Nevalida enigo: atendi\u011Dis ${stringifyPrimitive(issue2.values[0])}`;
        return `Nevalida opcio: atendi\u011Dis unu el ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Tro granda: atendi\u011Dis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementojn"}`;
        return `Tro granda: atendi\u011Dis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Tro malgranda: atendi\u011Dis ke ${issue2.origin} havu ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Tro malgranda: atendi\u011Dis ke ${issue2.origin} estu ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Nevalida karaktraro: devas komenci\u011Di per "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nevalida karaktraro: devas fini\u011Di per "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nevalida karaktraro: devas inkluzivi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;
        return `Nevalida ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nevalida nombro: devas esti oblo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nekonata${issue2.keys.length > 1 ? "j" : ""} \u015Dlosilo${issue2.keys.length > 1 ? "j" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Nevalida \u015Dlosilo en ${issue2.origin}`;
      case "invalid_union":
        return "Nevalida enigo";
      case "invalid_element":
        return `Nevalida valoro en ${issue2.origin}`;
      default:
        return `Nevalida enigo`;
    }
  };
};
var init_eo = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/es.js
function es_default() {
  return {
    localeError: error11()
  };
}
var error11 = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "tener" },
    file: { unit: "bytes", verb: "tener" },
    array: { unit: "elementos", verb: "tener" },
    set: { unit: "elementos", verb: "tener" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "entrada",
    email: "direcci\xF3n de correo electr\xF3nico",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "fecha y hora ISO",
    date: "fecha ISO",
    time: "hora ISO",
    duration: "duraci\xF3n ISO",
    ipv4: "direcci\xF3n IPv4",
    ipv6: "direcci\xF3n IPv6",
    cidrv4: "rango IPv4",
    cidrv6: "rango IPv6",
    base64: "cadena codificada en base64",
    base64url: "URL codificada en base64",
    json_string: "cadena JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  const TypeDictionary = {
    nan: "NaN",
    string: "texto",
    number: "n\xFAmero",
    boolean: "booleano",
    array: "arreglo",
    object: "objeto",
    set: "conjunto",
    file: "archivo",
    date: "fecha",
    bigint: "n\xFAmero grande",
    symbol: "s\xEDmbolo",
    undefined: "indefinido",
    null: "nulo",
    function: "funci\xF3n",
    map: "mapa",
    record: "registro",
    tuple: "tupla",
    enum: "enumeraci\xF3n",
    union: "uni\xF3n",
    literal: "literal",
    promise: "promesa",
    void: "vac\xEDo",
    never: "nunca",
    unknown: "desconocido",
    any: "cualquiera"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Entrada inv\xE1lida: se esperaba instanceof ${issue2.expected}, recibido ${received}`;
        }
        return `Entrada inv\xE1lida: se esperaba ${expected}, recibido ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrada inv\xE1lida: se esperaba ${stringifyPrimitive(issue2.values[0])}`;
        return `Opci\xF3n inv\xE1lida: se esperaba una de ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        if (sizing)
          return `Demasiado grande: se esperaba que ${origin ?? "valor"} tuviera ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Demasiado grande: se esperaba que ${origin ?? "valor"} fuera ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        if (sizing) {
          return `Demasiado peque\xF1o: se esperaba que ${origin} tuviera ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Demasiado peque\xF1o: se esperaba que ${origin} fuera ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Cadena inv\xE1lida: debe comenzar con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Cadena inv\xE1lida: debe terminar en "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cadena inv\xE1lida: debe incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cadena inv\xE1lida: debe coincidir con el patr\xF3n ${_issue.pattern}`;
        return `Inv\xE1lido ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE1lido: debe ser m\xFAltiplo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Llave${issue2.keys.length > 1 ? "s" : ""} desconocida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Llave inv\xE1lida en ${TypeDictionary[issue2.origin] ?? issue2.origin}`;
      case "invalid_union":
        return "Entrada inv\xE1lida";
      case "invalid_element":
        return `Valor inv\xE1lido en ${TypeDictionary[issue2.origin] ?? issue2.origin}`;
      default:
        return `Entrada inv\xE1lida`;
    }
  };
};
var init_es = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/fa.js
function fa_default() {
  return {
    localeError: error12()
  };
}
var error12 = () => {
  const Sizable = {
    string: { unit: "\u06A9\u0627\u0631\u0627\u06A9\u062A\u0631", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
    file: { unit: "\u0628\u0627\u06CC\u062A", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
    array: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
    set: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0648\u0631\u0648\u062F\u06CC",
    email: "\u0622\u062F\u0631\u0633 \u0627\u06CC\u0645\u06CC\u0644",
    url: "URL",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u062A\u0627\u0631\u06CC\u062E \u0648 \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    date: "\u062A\u0627\u0631\u06CC\u062E \u0627\u06CC\u0632\u0648",
    time: "\u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    duration: "\u0645\u062F\u062A \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    ipv4: "IPv4 \u0622\u062F\u0631\u0633",
    ipv6: "IPv6 \u0622\u062F\u0631\u0633",
    cidrv4: "IPv4 \u062F\u0627\u0645\u0646\u0647",
    cidrv6: "IPv6 \u062F\u0627\u0645\u0646\u0647",
    base64: "base64-encoded \u0631\u0634\u062A\u0647",
    base64url: "base64url-encoded \u0631\u0634\u062A\u0647",
    json_string: "JSON \u0631\u0634\u062A\u0647",
    e164: "E.164 \u0639\u062F\u062F",
    jwt: "JWT",
    template_literal: "\u0648\u0631\u0648\u062F\u06CC"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0639\u062F\u062F",
    array: "\u0622\u0631\u0627\u06CC\u0647"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A instanceof ${issue2.expected} \u0645\u06CC\u200C\u0628\u0648\u062F\u060C ${received} \u062F\u0631\u06CC\u0627\u0641\u062A \u0634\u062F`;
        }
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${expected} \u0645\u06CC\u200C\u0628\u0648\u062F\u060C ${received} \u062F\u0631\u06CC\u0627\u0641\u062A \u0634\u062F`;
      }
      case "invalid_value":
        if (issue2.values.length === 1) {
          return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${stringifyPrimitive(issue2.values[0])} \u0645\u06CC\u200C\u0628\u0648\u062F`;
        }
        return `\u06AF\u0632\u06CC\u0646\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A \u06CC\u06A9\u06CC \u0627\u0632 ${joinValues(issue2.values, "|")} \u0645\u06CC\u200C\u0628\u0648\u062F`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue2.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"} \u0628\u0627\u0634\u062F`;
        }
        return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue2.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} \u0628\u0627\u0634\u062F`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0628\u0627\u0634\u062F`;
        }
        return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} \u0628\u0627\u0634\u062F`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.prefix}" \u0634\u0631\u0648\u0639 \u0634\u0648\u062F`;
        }
        if (_issue.format === "ends_with") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.suffix}" \u062A\u0645\u0627\u0645 \u0634\u0648\u062F`;
        }
        if (_issue.format === "includes") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0634\u0627\u0645\u0644 "${_issue.includes}" \u0628\u0627\u0634\u062F`;
        }
        if (_issue.format === "regex") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 \u0627\u0644\u06AF\u0648\u06CC ${_issue.pattern} \u0645\u0637\u0627\u0628\u0642\u062A \u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F`;
        }
        return `${FormatDictionary[_issue.format] ?? issue2.format} \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
      }
      case "not_multiple_of":
        return `\u0639\u062F\u062F \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0645\u0636\u0631\u0628 ${issue2.divisor} \u0628\u0627\u0634\u062F`;
      case "unrecognized_keys":
        return `\u06A9\u0644\u06CC\u062F${issue2.keys.length > 1 ? "\u0647\u0627\u06CC" : ""} \u0646\u0627\u0634\u0646\u0627\u0633: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u06A9\u0644\u06CC\u062F \u0646\u0627\u0634\u0646\u0627\u0633 \u062F\u0631 ${issue2.origin}`;
      case "invalid_union":
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
      case "invalid_element":
        return `\u0645\u0642\u062F\u0627\u0631 \u0646\u0627\u0645\u0639\u062A\u0628\u0631 \u062F\u0631 ${issue2.origin}`;
      default:
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
    }
  };
};
var init_fa = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/fi.js
function fi_default() {
  return {
    localeError: error13()
  };
}
var error13 = () => {
  const Sizable = {
    string: { unit: "merkki\xE4", subject: "merkkijonon" },
    file: { unit: "tavua", subject: "tiedoston" },
    array: { unit: "alkiota", subject: "listan" },
    set: { unit: "alkiota", subject: "joukon" },
    number: { unit: "", subject: "luvun" },
    bigint: { unit: "", subject: "suuren kokonaisluvun" },
    int: { unit: "", subject: "kokonaisluvun" },
    date: { unit: "", subject: "p\xE4iv\xE4m\xE4\xE4r\xE4n" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "s\xE4\xE4nn\xF6llinen lauseke",
    email: "s\xE4hk\xF6postiosoite",
    url: "URL-osoite",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-aikaleima",
    date: "ISO-p\xE4iv\xE4m\xE4\xE4r\xE4",
    time: "ISO-aika",
    duration: "ISO-kesto",
    ipv4: "IPv4-osoite",
    ipv6: "IPv6-osoite",
    cidrv4: "IPv4-alue",
    cidrv6: "IPv6-alue",
    base64: "base64-koodattu merkkijono",
    base64url: "base64url-koodattu merkkijono",
    json_string: "JSON-merkkijono",
    e164: "E.164-luku",
    jwt: "JWT",
    template_literal: "templaattimerkkijono"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Virheellinen tyyppi: odotettiin instanceof ${issue2.expected}, oli ${received}`;
        }
        return `Virheellinen tyyppi: odotettiin ${expected}, oli ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Virheellinen sy\xF6te: t\xE4ytyy olla ${stringifyPrimitive(issue2.values[0])}`;
        return `Virheellinen valinta: t\xE4ytyy olla yksi seuraavista: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Liian suuri: ${sizing.subject} t\xE4ytyy olla ${adj}${issue2.maximum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian suuri: arvon t\xE4ytyy olla ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Liian pieni: ${sizing.subject} t\xE4ytyy olla ${adj}${issue2.minimum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian pieni: arvon t\xE4ytyy olla ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Virheellinen sy\xF6te: t\xE4ytyy alkaa "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Virheellinen sy\xF6te: t\xE4ytyy loppua "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Virheellinen sy\xF6te: t\xE4ytyy sis\xE4lt\xE4\xE4 "${_issue.includes}"`;
        if (_issue.format === "regex") {
          return `Virheellinen sy\xF6te: t\xE4ytyy vastata s\xE4\xE4nn\xF6llist\xE4 lauseketta ${_issue.pattern}`;
        }
        return `Virheellinen ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Virheellinen luku: t\xE4ytyy olla luvun ${issue2.divisor} monikerta`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return "Virheellinen avain tietueessa";
      case "invalid_union":
        return "Virheellinen unioni";
      case "invalid_element":
        return "Virheellinen arvo joukossa";
      default:
        return `Virheellinen sy\xF6te`;
    }
  };
};
var init_fi = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/fr.js
function fr_default() {
  return {
    localeError: error14()
  };
}
var error14 = () => {
  const Sizable = {
    string: { unit: "caract\xE8res", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "\xE9l\xE9ments", verb: "avoir" },
    set: { unit: "\xE9l\xE9ments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "entr\xE9e",
    email: "adresse e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date et heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dur\xE9e ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "cha\xEEne encod\xE9e en base64",
    base64url: "cha\xEEne encod\xE9e en base64url",
    json_string: "cha\xEEne JSON",
    e164: "num\xE9ro E.164",
    jwt: "JWT",
    template_literal: "entr\xE9e"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "nombre",
    array: "tableau"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Entr\xE9e invalide : instanceof ${issue2.expected} attendu, ${received} re\xE7u`;
        }
        return `Entr\xE9e invalide : ${expected} attendu, ${received} re\xE7u`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entr\xE9e invalide : ${stringifyPrimitive(issue2.values[0])} attendu`;
        return `Option invalide : une valeur parmi ${joinValues(issue2.values, "|")} attendue`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Trop grand : ${issue2.origin ?? "valeur"} doit ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\xE9l\xE9ment(s)"}`;
        return `Trop grand : ${issue2.origin ?? "valeur"} doit \xEAtre ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Trop petit : ${issue2.origin} doit ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : ${issue2.origin} doit \xEAtre ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cha\xEEne invalide : doit correspondre au mod\xE8le ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit \xEAtre un multiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Cl\xE9${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Cl\xE9 invalide dans ${issue2.origin}`;
      case "invalid_union":
        return "Entr\xE9e invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue2.origin}`;
      default:
        return `Entr\xE9e invalide`;
    }
  };
};
var init_fr = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/fr-CA.js
function fr_CA_default() {
  return {
    localeError: error15()
  };
}
var error15 = () => {
  const Sizable = {
    string: { unit: "caract\xE8res", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "\xE9l\xE9ments", verb: "avoir" },
    set: { unit: "\xE9l\xE9ments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "entr\xE9e",
    email: "adresse courriel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date-heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dur\xE9e ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "cha\xEEne encod\xE9e en base64",
    base64url: "cha\xEEne encod\xE9e en base64url",
    json_string: "cha\xEEne JSON",
    e164: "num\xE9ro E.164",
    jwt: "JWT",
    template_literal: "entr\xE9e"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Entr\xE9e invalide : attendu instanceof ${issue2.expected}, re\xE7u ${received}`;
        }
        return `Entr\xE9e invalide : attendu ${expected}, re\xE7u ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entr\xE9e invalide : attendu ${stringifyPrimitive(issue2.values[0])}`;
        return `Option invalide : attendu l'une des valeurs suivantes ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "\u2264" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} ait ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} soit ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\u2265" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Trop petit : attendu que ${issue2.origin} ait ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : attendu que ${issue2.origin} soit ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cha\xEEne invalide : doit correspondre au motif ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit \xEAtre un multiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Cl\xE9${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Cl\xE9 invalide dans ${issue2.origin}`;
      case "invalid_union":
        return "Entr\xE9e invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue2.origin}`;
      default:
        return `Entr\xE9e invalide`;
    }
  };
};
var init_fr_CA = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/he.js
function he_default() {
  return {
    localeError: error16()
  };
}
var error16 = () => {
  const TypeNames = {
    string: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA", gender: "f" },
    number: { label: "\u05DE\u05E1\u05E4\u05E8", gender: "m" },
    boolean: { label: "\u05E2\u05E8\u05DA \u05D1\u05D5\u05DC\u05D9\u05D0\u05E0\u05D9", gender: "m" },
    bigint: { label: "BigInt", gender: "m" },
    date: { label: "\u05EA\u05D0\u05E8\u05D9\u05DA", gender: "m" },
    array: { label: "\u05DE\u05E2\u05E8\u05DA", gender: "m" },
    object: { label: "\u05D0\u05D5\u05D1\u05D9\u05D9\u05E7\u05D8", gender: "m" },
    null: { label: "\u05E2\u05E8\u05DA \u05E8\u05D9\u05E7 (null)", gender: "m" },
    undefined: { label: "\u05E2\u05E8\u05DA \u05DC\u05D0 \u05DE\u05D5\u05D2\u05D3\u05E8 (undefined)", gender: "m" },
    symbol: { label: "\u05E1\u05D9\u05DE\u05D1\u05D5\u05DC (Symbol)", gender: "m" },
    function: { label: "\u05E4\u05D5\u05E0\u05E7\u05E6\u05D9\u05D4", gender: "f" },
    map: { label: "\u05DE\u05E4\u05D4 (Map)", gender: "f" },
    set: { label: "\u05E7\u05D1\u05D5\u05E6\u05D4 (Set)", gender: "f" },
    file: { label: "\u05E7\u05D5\u05D1\u05E5", gender: "m" },
    promise: { label: "Promise", gender: "m" },
    NaN: { label: "NaN", gender: "m" },
    unknown: { label: "\u05E2\u05E8\u05DA \u05DC\u05D0 \u05D9\u05D3\u05D5\u05E2", gender: "m" },
    value: { label: "\u05E2\u05E8\u05DA", gender: "m" }
  };
  const Sizable = {
    string: { unit: "\u05EA\u05D5\u05D5\u05D9\u05DD", shortLabel: "\u05E7\u05E6\u05E8", longLabel: "\u05D0\u05E8\u05D5\u05DA" },
    file: { unit: "\u05D1\u05D9\u05D9\u05D8\u05D9\u05DD", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" },
    array: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" },
    set: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" },
    number: { unit: "", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" }
  };
  const typeEntry = (t) => t ? TypeNames[t] : undefined;
  const typeLabel = (t) => {
    const e = typeEntry(t);
    if (e)
      return e.label;
    return t ?? TypeNames.unknown.label;
  };
  const withDefinite = (t) => `\u05D4${typeLabel(t)}`;
  const verbFor = (t) => {
    const e = typeEntry(t);
    const gender = e?.gender ?? "m";
    return gender === "f" ? "\u05E6\u05E8\u05D9\u05DB\u05D4 \u05DC\u05D4\u05D9\u05D5\u05EA" : "\u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA";
  };
  const getSizing = (origin) => {
    if (!origin)
      return null;
    return Sizable[origin] ?? null;
  };
  const FormatDictionary = {
    regex: { label: "\u05E7\u05DC\u05D8", gender: "m" },
    email: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05D0\u05D9\u05DE\u05D9\u05D9\u05DC", gender: "f" },
    url: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05E8\u05E9\u05EA", gender: "f" },
    emoji: { label: "\u05D0\u05D9\u05DE\u05D5\u05D2'\u05D9", gender: "m" },
    uuid: { label: "UUID", gender: "m" },
    nanoid: { label: "nanoid", gender: "m" },
    guid: { label: "GUID", gender: "m" },
    cuid: { label: "cuid", gender: "m" },
    cuid2: { label: "cuid2", gender: "m" },
    ulid: { label: "ULID", gender: "m" },
    xid: { label: "XID", gender: "m" },
    ksuid: { label: "KSUID", gender: "m" },
    datetime: { label: "\u05EA\u05D0\u05E8\u05D9\u05DA \u05D5\u05D6\u05DE\u05DF ISO", gender: "m" },
    date: { label: "\u05EA\u05D0\u05E8\u05D9\u05DA ISO", gender: "m" },
    time: { label: "\u05D6\u05DE\u05DF ISO", gender: "m" },
    duration: { label: "\u05DE\u05E9\u05DA \u05D6\u05DE\u05DF ISO", gender: "m" },
    ipv4: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv4", gender: "f" },
    ipv6: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv6", gender: "f" },
    cidrv4: { label: "\u05D8\u05D5\u05D5\u05D7 IPv4", gender: "m" },
    cidrv6: { label: "\u05D8\u05D5\u05D5\u05D7 IPv6", gender: "m" },
    base64: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64", gender: "f" },
    base64url: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64 \u05DC\u05DB\u05EA\u05D5\u05D1\u05D5\u05EA \u05E8\u05E9\u05EA", gender: "f" },
    json_string: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA JSON", gender: "f" },
    e164: { label: "\u05DE\u05E1\u05E4\u05E8 E.164", gender: "m" },
    jwt: { label: "JWT", gender: "m" },
    ends_with: { label: "\u05E7\u05DC\u05D8", gender: "m" },
    includes: { label: "\u05E7\u05DC\u05D8", gender: "m" },
    lowercase: { label: "\u05E7\u05DC\u05D8", gender: "m" },
    starts_with: { label: "\u05E7\u05DC\u05D8", gender: "m" },
    uppercase: { label: "\u05E7\u05DC\u05D8", gender: "m" }
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expectedKey = issue2.expected;
        const expected = TypeDictionary[expectedKey ?? ""] ?? typeLabel(expectedKey);
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? TypeNames[receivedType]?.label ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA instanceof ${issue2.expected}, \u05D4\u05EA\u05E7\u05D1\u05DC ${received}`;
        }
        return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${expected}, \u05D4\u05EA\u05E7\u05D1\u05DC ${received}`;
      }
      case "invalid_value": {
        if (issue2.values.length === 1) {
          return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D4\u05E2\u05E8\u05DA \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA ${stringifyPrimitive(issue2.values[0])}`;
        }
        const stringified = issue2.values.map((v) => stringifyPrimitive(v));
        if (issue2.values.length === 2) {
          return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D4\u05D0\u05E4\u05E9\u05E8\u05D5\u05D9\u05D5\u05EA \u05D4\u05DE\u05EA\u05D0\u05D9\u05DE\u05D5\u05EA \u05D4\u05DF ${stringified[0]} \u05D0\u05D5 ${stringified[1]}`;
        }
        const lastValue = stringified[stringified.length - 1];
        const restValues = stringified.slice(0, -1).join(", ");
        return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D4\u05D0\u05E4\u05E9\u05E8\u05D5\u05D9\u05D5\u05EA \u05D4\u05DE\u05EA\u05D0\u05D9\u05DE\u05D5\u05EA \u05D4\u05DF ${restValues} \u05D0\u05D5 ${lastValue}`;
      }
      case "too_big": {
        const sizing = getSizing(issue2.origin);
        const subject = withDefinite(issue2.origin ?? "value");
        if (issue2.origin === "string") {
          return `${sizing?.longLabel ?? "\u05D0\u05E8\u05D5\u05DA"} \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DB\u05D4 \u05DC\u05D4\u05DB\u05D9\u05DC ${issue2.maximum.toString()} ${sizing?.unit ?? ""} ${issue2.inclusive ? "\u05D0\u05D5 \u05E4\u05D7\u05D5\u05EA" : "\u05DC\u05DB\u05DC \u05D4\u05D9\u05D5\u05EA\u05E8"}`.trim();
        }
        if (issue2.origin === "number") {
          const comparison = issue2.inclusive ? `\u05E7\u05D8\u05DF \u05D0\u05D5 \u05E9\u05D5\u05D5\u05D4 \u05DC-${issue2.maximum}` : `\u05E7\u05D8\u05DF \u05DE-${issue2.maximum}`;
          return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${comparison}`;
        }
        if (issue2.origin === "array" || issue2.origin === "set") {
          const verb = issue2.origin === "set" ? "\u05E6\u05E8\u05D9\u05DB\u05D4" : "\u05E6\u05E8\u05D9\u05DA";
          const comparison = issue2.inclusive ? `${issue2.maximum} ${sizing?.unit ?? ""} \u05D0\u05D5 \u05E4\u05D7\u05D5\u05EA` : `\u05E4\u05D7\u05D5\u05EA \u05DE-${issue2.maximum} ${sizing?.unit ?? ""}`;
          return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${subject} ${verb} \u05DC\u05D4\u05DB\u05D9\u05DC ${comparison}`.trim();
        }
        const adj = issue2.inclusive ? "<=" : "<";
        const be = verbFor(issue2.origin ?? "value");
        if (sizing?.unit) {
          return `${sizing.longLabel} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        }
        return `${sizing?.longLabel ?? "\u05D2\u05D3\u05D5\u05DC"} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const sizing = getSizing(issue2.origin);
        const subject = withDefinite(issue2.origin ?? "value");
        if (issue2.origin === "string") {
          return `${sizing?.shortLabel ?? "\u05E7\u05E6\u05E8"} \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DB\u05D4 \u05DC\u05D4\u05DB\u05D9\u05DC ${issue2.minimum.toString()} ${sizing?.unit ?? ""} ${issue2.inclusive ? "\u05D0\u05D5 \u05D9\u05D5\u05EA\u05E8" : "\u05DC\u05E4\u05D7\u05D5\u05EA"}`.trim();
        }
        if (issue2.origin === "number") {
          const comparison = issue2.inclusive ? `\u05D2\u05D3\u05D5\u05DC \u05D0\u05D5 \u05E9\u05D5\u05D5\u05D4 \u05DC-${issue2.minimum}` : `\u05D2\u05D3\u05D5\u05DC \u05DE-${issue2.minimum}`;
          return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${comparison}`;
        }
        if (issue2.origin === "array" || issue2.origin === "set") {
          const verb = issue2.origin === "set" ? "\u05E6\u05E8\u05D9\u05DB\u05D4" : "\u05E6\u05E8\u05D9\u05DA";
          if (issue2.minimum === 1 && issue2.inclusive) {
            const singularPhrase = issue2.origin === "set" ? "\u05DC\u05E4\u05D7\u05D5\u05EA \u05E4\u05E8\u05D9\u05D8 \u05D0\u05D7\u05D3" : "\u05DC\u05E4\u05D7\u05D5\u05EA \u05E4\u05E8\u05D9\u05D8 \u05D0\u05D7\u05D3";
            return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${subject} ${verb} \u05DC\u05D4\u05DB\u05D9\u05DC ${singularPhrase}`;
          }
          const comparison = issue2.inclusive ? `${issue2.minimum} ${sizing?.unit ?? ""} \u05D0\u05D5 \u05D9\u05D5\u05EA\u05E8` : `\u05D9\u05D5\u05EA\u05E8 \u05DE-${issue2.minimum} ${sizing?.unit ?? ""}`;
          return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${subject} ${verb} \u05DC\u05D4\u05DB\u05D9\u05DC ${comparison}`.trim();
        }
        const adj = issue2.inclusive ? ">=" : ">";
        const be = verbFor(issue2.origin ?? "value");
        if (sizing?.unit) {
          return `${sizing.shortLabel} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `${sizing?.shortLabel ?? "\u05E7\u05D8\u05DF"} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D7\u05D9\u05DC \u05D1 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05E1\u05EA\u05D9\u05D9\u05DD \u05D1 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05DB\u05DC\u05D5\u05DC "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D0\u05D9\u05DD \u05DC\u05EA\u05D1\u05E0\u05D9\u05EA ${_issue.pattern}`;
        const nounEntry = FormatDictionary[_issue.format];
        const noun = nounEntry?.label ?? _issue.format;
        const gender = nounEntry?.gender ?? "m";
        const adjective = gender === "f" ? "\u05EA\u05E7\u05D9\u05E0\u05D4" : "\u05EA\u05E7\u05D9\u05DF";
        return `${noun} \u05DC\u05D0 ${adjective}`;
      }
      case "not_multiple_of":
        return `\u05DE\u05E1\u05E4\u05E8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05DE\u05DB\u05E4\u05DC\u05D4 \u05E9\u05DC ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u05DE\u05E4\u05EA\u05D7${issue2.keys.length > 1 ? "\u05D5\u05EA" : ""} \u05DC\u05D0 \u05DE\u05D6\u05D5\u05D4${issue2.keys.length > 1 ? "\u05D9\u05DD" : "\u05D4"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key": {
        return `\u05E9\u05D3\u05D4 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1\u05D0\u05D5\u05D1\u05D9\u05D9\u05E7\u05D8`;
      }
      case "invalid_union":
        return "\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF";
      case "invalid_element": {
        const place = withDefinite(issue2.origin ?? "array");
        return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1${place}`;
      }
      default:
        return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF`;
    }
  };
};
var init_he = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/hu.js
function hu_default() {
  return {
    localeError: error17()
  };
}
var error17 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "legyen" },
    file: { unit: "byte", verb: "legyen" },
    array: { unit: "elem", verb: "legyen" },
    set: { unit: "elem", verb: "legyen" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "bemenet",
    email: "email c\xEDm",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO id\u0151b\xE9lyeg",
    date: "ISO d\xE1tum",
    time: "ISO id\u0151",
    duration: "ISO id\u0151intervallum",
    ipv4: "IPv4 c\xEDm",
    ipv6: "IPv6 c\xEDm",
    cidrv4: "IPv4 tartom\xE1ny",
    cidrv6: "IPv6 tartom\xE1ny",
    base64: "base64-k\xF3dolt string",
    base64url: "base64url-k\xF3dolt string",
    json_string: "JSON string",
    e164: "E.164 sz\xE1m",
    jwt: "JWT",
    template_literal: "bemenet"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "sz\xE1m",
    array: "t\xF6mb"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k instanceof ${issue2.expected}, a kapott \xE9rt\xE9k ${received}`;
        }
        return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${expected}, a kapott \xE9rt\xE9k ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${stringifyPrimitive(issue2.values[0])}`;
        return `\xC9rv\xE9nytelen opci\xF3: valamelyik \xE9rt\xE9k v\xE1rt ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `T\xFAl nagy: ${issue2.origin ?? "\xE9rt\xE9k"} m\xE9rete t\xFAl nagy ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elem"}`;
        return `T\xFAl nagy: a bemeneti \xE9rt\xE9k ${issue2.origin ?? "\xE9rt\xE9k"} t\xFAl nagy: ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue2.origin} m\xE9rete t\xFAl kicsi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue2.origin} t\xFAl kicsi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\xC9rv\xE9nytelen string: "${_issue.prefix}" \xE9rt\xE9kkel kell kezd\u0151dnie`;
        if (_issue.format === "ends_with")
          return `\xC9rv\xE9nytelen string: "${_issue.suffix}" \xE9rt\xE9kkel kell v\xE9gz\u0151dnie`;
        if (_issue.format === "includes")
          return `\xC9rv\xE9nytelen string: "${_issue.includes}" \xE9rt\xE9ket kell tartalmaznia`;
        if (_issue.format === "regex")
          return `\xC9rv\xE9nytelen string: ${_issue.pattern} mint\xE1nak kell megfelelnie`;
        return `\xC9rv\xE9nytelen ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\xC9rv\xE9nytelen sz\xE1m: ${issue2.divisor} t\xF6bbsz\xF6r\xF6s\xE9nek kell lennie`;
      case "unrecognized_keys":
        return `Ismeretlen kulcs${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\xC9rv\xE9nytelen kulcs ${issue2.origin}`;
      case "invalid_union":
        return "\xC9rv\xE9nytelen bemenet";
      case "invalid_element":
        return `\xC9rv\xE9nytelen \xE9rt\xE9k: ${issue2.origin}`;
      default:
        return `\xC9rv\xE9nytelen bemenet`;
    }
  };
};
var init_hu = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/hy.js
function getArmenianPlural(count, one, many) {
  return Math.abs(count) === 1 ? one : many;
}
function withDefiniteArticle(word) {
  if (!word)
    return "";
  const vowels = ["\u0561", "\u0565", "\u0568", "\u056B", "\u0578", "\u0578\u0582", "\u0585"];
  const lastChar = word[word.length - 1];
  return word + (vowels.includes(lastChar) ? "\u0576" : "\u0568");
}
function hy_default() {
  return {
    localeError: error18()
  };
}
var error18 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "\u0576\u0577\u0561\u0576",
        many: "\u0576\u0577\u0561\u0576\u0576\u0565\u0580"
      },
      verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
    },
    file: {
      unit: {
        one: "\u0562\u0561\u0575\u0569",
        many: "\u0562\u0561\u0575\u0569\u0565\u0580"
      },
      verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
    },
    array: {
      unit: {
        one: "\u057F\u0561\u0580\u0580",
        many: "\u057F\u0561\u0580\u0580\u0565\u0580"
      },
      verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
    },
    set: {
      unit: {
        one: "\u057F\u0561\u0580\u0580",
        many: "\u057F\u0561\u0580\u0580\u0565\u0580"
      },
      verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0574\u0578\u0582\u057F\u0584",
    email: "\u0567\u056C. \u0570\u0561\u057D\u0581\u0565",
    url: "URL",
    emoji: "\u0567\u0574\u0578\u057B\u056B",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0561\u0574\u057D\u0561\u0569\u056B\u057E \u0587 \u056A\u0561\u0574",
    date: "ISO \u0561\u0574\u057D\u0561\u0569\u056B\u057E",
    time: "ISO \u056A\u0561\u0574",
    duration: "ISO \u057F\u0587\u0578\u0572\u0578\u0582\u0569\u0575\u0578\u0582\u0576",
    ipv4: "IPv4 \u0570\u0561\u057D\u0581\u0565",
    ipv6: "IPv6 \u0570\u0561\u057D\u0581\u0565",
    cidrv4: "IPv4 \u0574\u056B\u057B\u0561\u056F\u0561\u0575\u0584",
    cidrv6: "IPv6 \u0574\u056B\u057B\u0561\u056F\u0561\u0575\u0584",
    base64: "base64 \u0571\u0587\u0561\u0579\u0561\u0583\u0578\u057E \u057F\u0578\u0572",
    base64url: "base64url \u0571\u0587\u0561\u0579\u0561\u0583\u0578\u057E \u057F\u0578\u0572",
    json_string: "JSON \u057F\u0578\u0572",
    e164: "E.164 \u0570\u0561\u0574\u0561\u0580",
    jwt: "JWT",
    template_literal: "\u0574\u0578\u0582\u057F\u0584"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0569\u056B\u057E",
    array: "\u0566\u0561\u0576\u0563\u057E\u0561\u056E"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 instanceof ${issue2.expected}, \u057D\u057F\u0561\u0581\u057E\u0565\u056C \u0567 ${received}`;
        }
        return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 ${expected}, \u057D\u057F\u0561\u0581\u057E\u0565\u056C \u0567 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 ${stringifyPrimitive(issue2.values[1])}`;
        return `\u054D\u056D\u0561\u056C \u057F\u0561\u0580\u0562\u0565\u0580\u0561\u056F\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 \u0570\u0565\u057F\u0587\u0575\u0561\u056C\u0576\u0565\u0580\u056B\u0581 \u0574\u0565\u056F\u0568\u055D ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getArmenianPlural(maxValue, sizing.unit.one, sizing.unit.many);
          return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0574\u0565\u056E \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue2.origin ?? "\u0561\u0580\u056A\u0565\u0584")} \u056F\u0578\u0582\u0576\u0565\u0576\u0561 ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0574\u0565\u056E \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue2.origin ?? "\u0561\u0580\u056A\u0565\u0584")} \u056C\u056B\u0576\u056B ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getArmenianPlural(minValue, sizing.unit.one, sizing.unit.many);
          return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0583\u0578\u0584\u0580 \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue2.origin)} \u056F\u0578\u0582\u0576\u0565\u0576\u0561 ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0583\u0578\u0584\u0580 \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue2.origin)} \u056C\u056B\u0576\u056B ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u057D\u056F\u057D\u057E\u056B "${_issue.prefix}"-\u0578\u057E`;
        if (_issue.format === "ends_with")
          return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u0561\u057E\u0561\u0580\u057F\u057E\u056B "${_issue.suffix}"-\u0578\u057E`;
        if (_issue.format === "includes")
          return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u057A\u0561\u0580\u0578\u0582\u0576\u0561\u056F\u056B "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u0570\u0561\u0574\u0561\u057A\u0561\u057F\u0561\u057D\u056D\u0561\u0576\u056B ${_issue.pattern} \u0571\u0587\u0561\u0579\u0561\u0583\u056B\u0576`;
        return `\u054D\u056D\u0561\u056C ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u054D\u056D\u0561\u056C \u0569\u056B\u057E\u2024 \u057A\u0565\u057F\u0584 \u0567 \u0562\u0561\u0566\u0574\u0561\u057A\u0561\u057F\u056B\u056F \u056C\u056B\u0576\u056B ${issue2.divisor}-\u056B`;
      case "unrecognized_keys":
        return `\u0549\u0573\u0561\u0576\u0561\u0579\u057E\u0561\u056E \u0562\u0561\u0576\u0561\u056C\u056B${issue2.keys.length > 1 ? "\u0576\u0565\u0580" : ""}. ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u054D\u056D\u0561\u056C \u0562\u0561\u0576\u0561\u056C\u056B ${withDefiniteArticle(issue2.origin)}-\u0578\u0582\u0574`;
      case "invalid_union":
        return "\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574";
      case "invalid_element":
        return `\u054D\u056D\u0561\u056C \u0561\u0580\u056A\u0565\u0584 ${withDefiniteArticle(issue2.origin)}-\u0578\u0582\u0574`;
      default:
        return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574`;
    }
  };
};
var init_hy = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/id.js
function id_default() {
  return {
    localeError: error19()
  };
}
var error19 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "memiliki" },
    file: { unit: "byte", verb: "memiliki" },
    array: { unit: "item", verb: "memiliki" },
    set: { unit: "item", verb: "memiliki" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "alamat email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tanggal dan waktu format ISO",
    date: "tanggal format ISO",
    time: "jam format ISO",
    duration: "durasi format ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "rentang alamat IPv4",
    cidrv6: "rentang alamat IPv6",
    base64: "string dengan enkode base64",
    base64url: "string dengan enkode base64url",
    json_string: "string JSON",
    e164: "angka E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Input tidak valid: diharapkan instanceof ${issue2.expected}, diterima ${received}`;
        }
        return `Input tidak valid: diharapkan ${expected}, diterima ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input tidak valid: diharapkan ${stringifyPrimitive(issue2.values[0])}`;
        return `Pilihan tidak valid: diharapkan salah satu dari ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} memiliki ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} menjadi ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Terlalu kecil: diharapkan ${issue2.origin} memiliki ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: diharapkan ${issue2.origin} menjadi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `String tidak valid: harus dimulai dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak valid: harus berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak valid: harus menyertakan "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak valid: harus sesuai pola ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} tidak valid`;
      }
      case "not_multiple_of":
        return `Angka tidak valid: harus kelipatan dari ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak valid di ${issue2.origin}`;
      case "invalid_union":
        return "Input tidak valid";
      case "invalid_element":
        return `Nilai tidak valid di ${issue2.origin}`;
      default:
        return `Input tidak valid`;
    }
  };
};
var init_id = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/is.js
function is_default() {
  return {
    localeError: error20()
  };
}
var error20 = () => {
  const Sizable = {
    string: { unit: "stafi", verb: "a\xF0 hafa" },
    file: { unit: "b\xE6ti", verb: "a\xF0 hafa" },
    array: { unit: "hluti", verb: "a\xF0 hafa" },
    set: { unit: "hluti", verb: "a\xF0 hafa" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "gildi",
    email: "netfang",
    url: "vefsl\xF3\xF0",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dagsetning og t\xEDmi",
    date: "ISO dagsetning",
    time: "ISO t\xEDmi",
    duration: "ISO t\xEDmalengd",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded strengur",
    base64url: "base64url-encoded strengur",
    json_string: "JSON strengur",
    e164: "E.164 t\xF6lugildi",
    jwt: "JWT",
    template_literal: "gildi"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "n\xFAmer",
    array: "fylki"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Rangt gildi: \xDE\xFA sl\xF3st inn ${received} \xFEar sem \xE1 a\xF0 vera instanceof ${issue2.expected}`;
        }
        return `Rangt gildi: \xDE\xFA sl\xF3st inn ${received} \xFEar sem \xE1 a\xF0 vera ${expected}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Rangt gildi: gert r\xE1\xF0 fyrir ${stringifyPrimitive(issue2.values[0])}`;
        return `\xD3gilt val: m\xE1 vera eitt af eftirfarandi ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Of st\xF3rt: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin ?? "gildi"} hafi ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "hluti"}`;
        return `Of st\xF3rt: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin ?? "gildi"} s\xE9 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Of l\xEDti\xF0: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin} hafi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Of l\xEDti\xF0: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin} s\xE9 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\xD3gildur strengur: ver\xF0ur a\xF0 byrja \xE1 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\xD3gildur strengur: ver\xF0ur a\xF0 enda \xE1 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\xD3gildur strengur: ver\xF0ur a\xF0 innihalda "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\xD3gildur strengur: ver\xF0ur a\xF0 fylgja mynstri ${_issue.pattern}`;
        return `Rangt ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `R\xF6ng tala: ver\xF0ur a\xF0 vera margfeldi af ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\xD3\xFEekkt ${issue2.keys.length > 1 ? "ir lyklar" : "ur lykill"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Rangur lykill \xED ${issue2.origin}`;
      case "invalid_union":
        return "Rangt gildi";
      case "invalid_element":
        return `Rangt gildi \xED ${issue2.origin}`;
      default:
        return `Rangt gildi`;
    }
  };
};
var init_is = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/it.js
function it_default() {
  return {
    localeError: error21()
  };
}
var error21 = () => {
  const Sizable = {
    string: { unit: "caratteri", verb: "avere" },
    file: { unit: "byte", verb: "avere" },
    array: { unit: "elementi", verb: "avere" },
    set: { unit: "elementi", verb: "avere" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "indirizzo email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e ora ISO",
    date: "data ISO",
    time: "ora ISO",
    duration: "durata ISO",
    ipv4: "indirizzo IPv4",
    ipv6: "indirizzo IPv6",
    cidrv4: "intervallo IPv4",
    cidrv6: "intervallo IPv6",
    base64: "stringa codificata in base64",
    base64url: "URL codificata in base64",
    json_string: "stringa JSON",
    e164: "numero E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "numero",
    array: "vettore"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Input non valido: atteso instanceof ${issue2.expected}, ricevuto ${received}`;
        }
        return `Input non valido: atteso ${expected}, ricevuto ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input non valido: atteso ${stringifyPrimitive(issue2.values[0])}`;
        return `Opzione non valida: atteso uno tra ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Troppo grande: ${issue2.origin ?? "valore"} deve avere ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementi"}`;
        return `Troppo grande: ${issue2.origin ?? "valore"} deve essere ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Troppo piccolo: ${issue2.origin} deve avere ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Troppo piccolo: ${issue2.origin} deve essere ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Stringa non valida: deve iniziare con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Stringa non valida: deve terminare con "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Stringa non valida: deve includere "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;
        return `Invalid ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Numero non valido: deve essere un multiplo di ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Chiav${issue2.keys.length > 1 ? "i" : "e"} non riconosciut${issue2.keys.length > 1 ? "e" : "a"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Chiave non valida in ${issue2.origin}`;
      case "invalid_union":
        return "Input non valido";
      case "invalid_element":
        return `Valore non valido in ${issue2.origin}`;
      default:
        return `Input non valido`;
    }
  };
};
var init_it = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/ja.js
function ja_default() {
  return {
    localeError: error22()
  };
}
var error22 = () => {
  const Sizable = {
    string: { unit: "\u6587\u5B57", verb: "\u3067\u3042\u308B" },
    file: { unit: "\u30D0\u30A4\u30C8", verb: "\u3067\u3042\u308B" },
    array: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" },
    set: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u5165\u529B\u5024",
    email: "\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9",
    url: "URL",
    emoji: "\u7D75\u6587\u5B57",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO\u65E5\u6642",
    date: "ISO\u65E5\u4ED8",
    time: "ISO\u6642\u523B",
    duration: "ISO\u671F\u9593",
    ipv4: "IPv4\u30A2\u30C9\u30EC\u30B9",
    ipv6: "IPv6\u30A2\u30C9\u30EC\u30B9",
    cidrv4: "IPv4\u7BC4\u56F2",
    cidrv6: "IPv6\u7BC4\u56F2",
    base64: "base64\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
    base64url: "base64url\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
    json_string: "JSON\u6587\u5B57\u5217",
    e164: "E.164\u756A\u53F7",
    jwt: "JWT",
    template_literal: "\u5165\u529B\u5024"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u6570\u5024",
    array: "\u914D\u5217"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u7121\u52B9\u306A\u5165\u529B: instanceof ${issue2.expected}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F\u304C\u3001${received}\u304C\u5165\u529B\u3055\u308C\u307E\u3057\u305F`;
        }
        return `\u7121\u52B9\u306A\u5165\u529B: ${expected}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F\u304C\u3001${received}\u304C\u5165\u529B\u3055\u308C\u307E\u3057\u305F`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u7121\u52B9\u306A\u5165\u529B: ${stringifyPrimitive(issue2.values[0])}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F`;
        return `\u7121\u52B9\u306A\u9078\u629E: ${joinValues(issue2.values, "\u3001")}\u306E\u3044\u305A\u308C\u304B\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      case "too_big": {
        const adj = issue2.inclusive ? "\u4EE5\u4E0B\u3067\u3042\u308B" : "\u3088\u308A\u5C0F\u3055\u3044";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue2.origin ?? "\u5024"}\u306F${issue2.maximum.toString()}${sizing.unit ?? "\u8981\u7D20"}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue2.origin ?? "\u5024"}\u306F${issue2.maximum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\u4EE5\u4E0A\u3067\u3042\u308B" : "\u3088\u308A\u5927\u304D\u3044";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue2.origin}\u306F${issue2.minimum.toString()}${sizing.unit}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue2.origin}\u306F${issue2.minimum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.prefix}"\u3067\u59CB\u307E\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "ends_with")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.suffix}"\u3067\u7D42\u308F\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "includes")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.includes}"\u3092\u542B\u3080\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "regex")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: \u30D1\u30BF\u30FC\u30F3${_issue.pattern}\u306B\u4E00\u81F4\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u7121\u52B9\u306A${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u7121\u52B9\u306A\u6570\u5024: ${issue2.divisor}\u306E\u500D\u6570\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      case "unrecognized_keys":
        return `\u8A8D\u8B58\u3055\u308C\u3066\u3044\u306A\u3044\u30AD\u30FC${issue2.keys.length > 1 ? "\u7FA4" : ""}: ${joinValues(issue2.keys, "\u3001")}`;
      case "invalid_key":
        return `${issue2.origin}\u5185\u306E\u7121\u52B9\u306A\u30AD\u30FC`;
      case "invalid_union":
        return "\u7121\u52B9\u306A\u5165\u529B";
      case "invalid_element":
        return `${issue2.origin}\u5185\u306E\u7121\u52B9\u306A\u5024`;
      default:
        return `\u7121\u52B9\u306A\u5165\u529B`;
    }
  };
};
var init_ja = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/ka.js
function ka_default() {
  return {
    localeError: error23()
  };
}
var error23 = () => {
  const Sizable = {
    string: { unit: "\u10E1\u10D8\u10DB\u10D1\u10DD\u10DA\u10DD", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
    file: { unit: "\u10D1\u10D0\u10D8\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
    array: { unit: "\u10D4\u10DA\u10D4\u10DB\u10D4\u10DC\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
    set: { unit: "\u10D4\u10DA\u10D4\u10DB\u10D4\u10DC\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0",
    email: "\u10D4\u10DA-\u10E4\u10DD\u10E1\u10E2\u10D8\u10E1 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
    url: "URL",
    emoji: "\u10D4\u10DB\u10DD\u10EF\u10D8",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u10D7\u10D0\u10E0\u10D8\u10E6\u10D8-\u10D3\u10E0\u10DD",
    date: "\u10D7\u10D0\u10E0\u10D8\u10E6\u10D8",
    time: "\u10D3\u10E0\u10DD",
    duration: "\u10EE\u10D0\u10DC\u10D2\u10E0\u10EB\u10DA\u10D8\u10D5\u10DD\u10D1\u10D0",
    ipv4: "IPv4 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
    ipv6: "IPv6 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
    cidrv4: "IPv4 \u10D3\u10D8\u10D0\u10DE\u10D0\u10D6\u10DD\u10DC\u10D8",
    cidrv6: "IPv6 \u10D3\u10D8\u10D0\u10DE\u10D0\u10D6\u10DD\u10DC\u10D8",
    base64: "base64-\u10D9\u10DD\u10D3\u10D8\u10E0\u10D4\u10D1\u10E3\u10DA\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    base64url: "base64url-\u10D9\u10DD\u10D3\u10D8\u10E0\u10D4\u10D1\u10E3\u10DA\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    json_string: "JSON \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    e164: "E.164 \u10DC\u10DD\u10DB\u10D4\u10E0\u10D8",
    jwt: "JWT",
    template_literal: "\u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u10E0\u10D8\u10EA\u10EE\u10D5\u10D8",
    string: "\u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    boolean: "\u10D1\u10E3\u10DA\u10D4\u10D0\u10DC\u10D8",
    function: "\u10E4\u10E3\u10DC\u10E5\u10EA\u10D8\u10D0",
    array: "\u10DB\u10D0\u10E1\u10D8\u10D5\u10D8"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 instanceof ${issue2.expected}, \u10DB\u10D8\u10E6\u10D4\u10D1\u10E3\u10DA\u10D8 ${received}`;
        }
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${expected}, \u10DB\u10D8\u10E6\u10D4\u10D1\u10E3\u10DA\u10D8 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${stringifyPrimitive(issue2.values[0])}`;
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10D5\u10D0\u10E0\u10D8\u10D0\u10DC\u10E2\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8\u10D0 \u10D4\u10E0\u10D7-\u10D4\u10E0\u10D7\u10D8 ${joinValues(issue2.values, "|")}-\u10D3\u10D0\u10DC`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10D3\u10D8\u10D3\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin ?? "\u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10D3\u10D8\u10D3\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin ?? "\u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0"} \u10D8\u10E7\u10DD\u10E1 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10DE\u10D0\u10E2\u10D0\u10E0\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10DE\u10D0\u10E2\u10D0\u10E0\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin} \u10D8\u10E7\u10DD\u10E1 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10D8\u10EC\u10E7\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 "${_issue.prefix}"-\u10D8\u10D7`;
        }
        if (_issue.format === "ends_with")
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10DB\u10D7\u10D0\u10D5\u10E0\u10D3\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 "${_issue.suffix}"-\u10D8\u10D7`;
        if (_issue.format === "includes")
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1 "${_issue.includes}"-\u10E1`;
        if (_issue.format === "regex")
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D4\u10E1\u10D0\u10D1\u10D0\u10DB\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 \u10E8\u10D0\u10D1\u10DA\u10DD\u10DC\u10E1 ${_issue.pattern}`;
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E0\u10D8\u10EA\u10EE\u10D5\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10D8\u10E7\u10DD\u10E1 ${issue2.divisor}-\u10D8\u10E1 \u10EF\u10D4\u10E0\u10D0\u10D3\u10D8`;
      case "unrecognized_keys":
        return `\u10E3\u10EA\u10DC\u10DD\u10D1\u10D8 \u10D2\u10D0\u10E1\u10D0\u10E6\u10D4\u10D1${issue2.keys.length > 1 ? "\u10D4\u10D1\u10D8" : "\u10D8"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10D2\u10D0\u10E1\u10D0\u10E6\u10D4\u10D1\u10D8 ${issue2.origin}-\u10E8\u10D8`;
      case "invalid_union":
        return "\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0";
      case "invalid_element":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0 ${issue2.origin}-\u10E8\u10D8`;
      default:
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0`;
    }
  };
};
var init_ka = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/km.js
function km_default() {
  return {
    localeError: error24()
  };
}
var error24 = () => {
  const Sizable = {
    string: { unit: "\u178F\u17BD\u17A2\u1780\u17D2\u179F\u179A", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
    file: { unit: "\u1794\u17C3", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
    array: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
    set: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B",
    email: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793\u17A2\u17CA\u17B8\u1798\u17C2\u179B",
    url: "URL",
    emoji: "\u179F\u1789\u17D2\u1789\u17B6\u17A2\u17B6\u179A\u1798\u17D2\u1798\u178E\u17CD",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 \u1793\u17B7\u1784\u1798\u17C9\u17C4\u1784 ISO",
    date: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 ISO",
    time: "\u1798\u17C9\u17C4\u1784 ISO",
    duration: "\u179A\u1799\u17C8\u1796\u17C1\u179B ISO",
    ipv4: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
    ipv6: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
    cidrv4: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
    cidrv6: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
    base64: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64",
    base64url: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64url",
    json_string: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A JSON",
    e164: "\u179B\u17C1\u1781 E.164",
    jwt: "JWT",
    template_literal: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u179B\u17C1\u1781",
    array: "\u17A2\u17B6\u179A\u17C1 (Array)",
    null: "\u1782\u17D2\u1798\u17B6\u1793\u178F\u1798\u17D2\u179B\u17C3 (null)"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A instanceof ${issue2.expected} \u1794\u17C9\u17BB\u1793\u17D2\u178F\u17C2\u1791\u1791\u17BD\u179B\u1794\u17B6\u1793 ${received}`;
        }
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${expected} \u1794\u17C9\u17BB\u1793\u17D2\u178F\u17C2\u1791\u1791\u17BD\u179B\u1794\u17B6\u1793 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${stringifyPrimitive(issue2.values[0])}`;
        return `\u1787\u1798\u17D2\u179A\u17BE\u179F\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1787\u17B6\u1798\u17BD\u1799\u1780\u17D2\u1793\u17BB\u1784\u1785\u17C6\u178E\u17C4\u1798 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u1792\u17B6\u178F\u17BB"}`;
        return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin} ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1785\u17B6\u1794\u17CB\u1795\u17D2\u178F\u17BE\u1798\u178A\u17C4\u1799 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1794\u1789\u17D2\u1785\u1794\u17CB\u178A\u17C4\u1799 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1798\u17B6\u1793 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1795\u17D2\u1782\u17BC\u1795\u17D2\u1782\u1784\u1793\u17B9\u1784\u1791\u1798\u17D2\u179A\u1784\u17CB\u178A\u17C2\u179B\u1794\u17B6\u1793\u1780\u17C6\u178E\u178F\u17CB ${_issue.pattern}`;
        return `\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u179B\u17C1\u1781\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1787\u17B6\u1796\u17A0\u17BB\u1782\u17BB\u178E\u1793\u17C3 ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u179A\u1780\u1783\u17BE\u1789\u179F\u17C4\u1798\u17B7\u1793\u179F\u17D2\u1782\u17B6\u179B\u17CB\u17D6 ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u179F\u17C4\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue2.origin}`;
      case "invalid_union":
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
      case "invalid_element":
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue2.origin}`;
      default:
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
    }
  };
};
var init_km = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/kh.js
function kh_default() {
  return km_default();
}
var init_kh = __esm(() => {
  init_km();
});

// node_modules/zod/v4/locales/ko.js
function ko_default() {
  return {
    localeError: error25()
  };
}
var error25 = () => {
  const Sizable = {
    string: { unit: "\uBB38\uC790", verb: "to have" },
    file: { unit: "\uBC14\uC774\uD2B8", verb: "to have" },
    array: { unit: "\uAC1C", verb: "to have" },
    set: { unit: "\uAC1C", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\uC785\uB825",
    email: "\uC774\uBA54\uC77C \uC8FC\uC18C",
    url: "URL",
    emoji: "\uC774\uBAA8\uC9C0",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \uB0A0\uC9DC\uC2DC\uAC04",
    date: "ISO \uB0A0\uC9DC",
    time: "ISO \uC2DC\uAC04",
    duration: "ISO \uAE30\uAC04",
    ipv4: "IPv4 \uC8FC\uC18C",
    ipv6: "IPv6 \uC8FC\uC18C",
    cidrv4: "IPv4 \uBC94\uC704",
    cidrv6: "IPv6 \uBC94\uC704",
    base64: "base64 \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
    base64url: "base64url \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
    json_string: "JSON \uBB38\uC790\uC5F4",
    e164: "E.164 \uBC88\uD638",
    jwt: "JWT",
    template_literal: "\uC785\uB825"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\uC798\uBABB\uB41C \uC785\uB825: \uC608\uC0C1 \uD0C0\uC785\uC740 instanceof ${issue2.expected}, \uBC1B\uC740 \uD0C0\uC785\uC740 ${received}\uC785\uB2C8\uB2E4`;
        }
        return `\uC798\uBABB\uB41C \uC785\uB825: \uC608\uC0C1 \uD0C0\uC785\uC740 ${expected}, \uBC1B\uC740 \uD0C0\uC785\uC740 ${received}\uC785\uB2C8\uB2E4`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\uC798\uBABB\uB41C \uC785\uB825: \uAC12\uC740 ${stringifyPrimitive(issue2.values[0])} \uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4`;
        return `\uC798\uBABB\uB41C \uC635\uC158: ${joinValues(issue2.values, "\uB610\uB294 ")} \uC911 \uD558\uB098\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
      case "too_big": {
        const adj = issue2.inclusive ? "\uC774\uD558" : "\uBBF8\uB9CC";
        const suffix = adj === "\uBBF8\uB9CC" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
        const sizing = getSizing(issue2.origin);
        const unit = sizing?.unit ?? "\uC694\uC18C";
        if (sizing)
          return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue2.maximum.toString()}${unit} ${adj}${suffix}`;
        return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue2.maximum.toString()} ${adj}${suffix}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\uC774\uC0C1" : "\uCD08\uACFC";
        const suffix = adj === "\uC774\uC0C1" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
        const sizing = getSizing(issue2.origin);
        const unit = sizing?.unit ?? "\uC694\uC18C";
        if (sizing) {
          return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue2.minimum.toString()}${unit} ${adj}${suffix}`;
        }
        return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue2.minimum.toString()} ${adj}${suffix}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.prefix}"(\uC73C)\uB85C \uC2DC\uC791\uD574\uC57C \uD569\uB2C8\uB2E4`;
        }
        if (_issue.format === "ends_with")
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.suffix}"(\uC73C)\uB85C \uB05D\uB098\uC57C \uD569\uB2C8\uB2E4`;
        if (_issue.format === "includes")
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.includes}"\uC744(\uB97C) \uD3EC\uD568\uD574\uC57C \uD569\uB2C8\uB2E4`;
        if (_issue.format === "regex")
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: \uC815\uADDC\uC2DD ${_issue.pattern} \uD328\uD134\uACFC \uC77C\uCE58\uD574\uC57C \uD569\uB2C8\uB2E4`;
        return `\uC798\uBABB\uB41C ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\uC798\uBABB\uB41C \uC22B\uC790: ${issue2.divisor}\uC758 \uBC30\uC218\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
      case "unrecognized_keys":
        return `\uC778\uC2DD\uD560 \uC218 \uC5C6\uB294 \uD0A4: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\uC798\uBABB\uB41C \uD0A4: ${issue2.origin}`;
      case "invalid_union":
        return `\uC798\uBABB\uB41C \uC785\uB825`;
      case "invalid_element":
        return `\uC798\uBABB\uB41C \uAC12: ${issue2.origin}`;
      default:
        return `\uC798\uBABB\uB41C \uC785\uB825`;
    }
  };
};
var init_ko = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/lt.js
function getUnitTypeFromNumber(number2) {
  const abs = Math.abs(number2);
  const last = abs % 10;
  const last2 = abs % 100;
  if (last2 >= 11 && last2 <= 19 || last === 0)
    return "many";
  if (last === 1)
    return "one";
  return "few";
}
function lt_default() {
  return {
    localeError: error26()
  };
}
var capitalizeFirstCharacter = (text) => {
  return text.charAt(0).toUpperCase() + text.slice(1);
}, error26 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "simbolis",
        few: "simboliai",
        many: "simboli\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi b\u016Bti ne ilgesn\u0117 kaip",
          notInclusive: "turi b\u016Bti trumpesn\u0117 kaip"
        },
        bigger: {
          inclusive: "turi b\u016Bti ne trumpesn\u0117 kaip",
          notInclusive: "turi b\u016Bti ilgesn\u0117 kaip"
        }
      }
    },
    file: {
      unit: {
        one: "baitas",
        few: "baitai",
        many: "bait\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi b\u016Bti ne didesnis kaip",
          notInclusive: "turi b\u016Bti ma\u017Eesnis kaip"
        },
        bigger: {
          inclusive: "turi b\u016Bti ne ma\u017Eesnis kaip",
          notInclusive: "turi b\u016Bti didesnis kaip"
        }
      }
    },
    array: {
      unit: {
        one: "element\u0105",
        few: "elementus",
        many: "element\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi tur\u0117ti ne daugiau kaip",
          notInclusive: "turi tur\u0117ti ma\u017Eiau kaip"
        },
        bigger: {
          inclusive: "turi tur\u0117ti ne ma\u017Eiau kaip",
          notInclusive: "turi tur\u0117ti daugiau kaip"
        }
      }
    },
    set: {
      unit: {
        one: "element\u0105",
        few: "elementus",
        many: "element\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi tur\u0117ti ne daugiau kaip",
          notInclusive: "turi tur\u0117ti ma\u017Eiau kaip"
        },
        bigger: {
          inclusive: "turi tur\u0117ti ne ma\u017Eiau kaip",
          notInclusive: "turi tur\u0117ti daugiau kaip"
        }
      }
    }
  };
  function getSizing(origin, unitType, inclusive, targetShouldBe) {
    const result = Sizable[origin] ?? null;
    if (result === null)
      return result;
    return {
      unit: result.unit[unitType],
      verb: result.verb[targetShouldBe][inclusive ? "inclusive" : "notInclusive"]
    };
  }
  const FormatDictionary = {
    regex: "\u012Fvestis",
    email: "el. pa\u0161to adresas",
    url: "URL",
    emoji: "jaustukas",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO data ir laikas",
    date: "ISO data",
    time: "ISO laikas",
    duration: "ISO trukm\u0117",
    ipv4: "IPv4 adresas",
    ipv6: "IPv6 adresas",
    cidrv4: "IPv4 tinklo prefiksas (CIDR)",
    cidrv6: "IPv6 tinklo prefiksas (CIDR)",
    base64: "base64 u\u017Ekoduota eilut\u0117",
    base64url: "base64url u\u017Ekoduota eilut\u0117",
    json_string: "JSON eilut\u0117",
    e164: "E.164 numeris",
    jwt: "JWT",
    template_literal: "\u012Fvestis"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "skai\u010Dius",
    bigint: "sveikasis skai\u010Dius",
    string: "eilut\u0117",
    boolean: "login\u0117 reik\u0161m\u0117",
    undefined: "neapibr\u0117\u017Eta reik\u0161m\u0117",
    function: "funkcija",
    symbol: "simbolis",
    array: "masyvas",
    object: "objektas",
    null: "nulin\u0117 reik\u0161m\u0117"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Gautas tipas ${received}, o tik\u0117tasi - instanceof ${issue2.expected}`;
        }
        return `Gautas tipas ${received}, o tik\u0117tasi - ${expected}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Privalo b\u016Bti ${stringifyPrimitive(issue2.values[0])}`;
        return `Privalo b\u016Bti vienas i\u0161 ${joinValues(issue2.values, "|")} pasirinkim\u0173`;
      case "too_big": {
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        const sizing = getSizing(issue2.origin, getUnitTypeFromNumber(Number(issue2.maximum)), issue2.inclusive ?? false, "smaller");
        if (sizing?.verb)
          return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} ${sizing.verb} ${issue2.maximum.toString()} ${sizing.unit ?? "element\u0173"}`;
        const adj = issue2.inclusive ? "ne didesnis kaip" : "ma\u017Eesnis kaip";
        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} turi b\u016Bti ${adj} ${issue2.maximum.toString()} ${sizing?.unit}`;
      }
      case "too_small": {
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        const sizing = getSizing(issue2.origin, getUnitTypeFromNumber(Number(issue2.minimum)), issue2.inclusive ?? false, "bigger");
        if (sizing?.verb)
          return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} ${sizing.verb} ${issue2.minimum.toString()} ${sizing.unit ?? "element\u0173"}`;
        const adj = issue2.inclusive ? "ne ma\u017Eesnis kaip" : "didesnis kaip";
        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} turi b\u016Bti ${adj} ${issue2.minimum.toString()} ${sizing?.unit}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Eilut\u0117 privalo prasid\u0117ti "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Eilut\u0117 privalo pasibaigti "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Eilut\u0117 privalo \u012Ftraukti "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Eilut\u0117 privalo atitikti ${_issue.pattern}`;
        return `Neteisingas ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Skai\u010Dius privalo b\u016Bti ${issue2.divisor} kartotinis.`;
      case "unrecognized_keys":
        return `Neatpa\u017Eint${issue2.keys.length > 1 ? "i" : "as"} rakt${issue2.keys.length > 1 ? "ai" : "as"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return "Rastas klaidingas raktas";
      case "invalid_union":
        return "Klaidinga \u012Fvestis";
      case "invalid_element": {
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} turi klaiding\u0105 \u012Fvest\u012F`;
      }
      default:
        return "Klaidinga \u012Fvestis";
    }
  };
};
var init_lt = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/mk.js
function mk_default() {
  return {
    localeError: error27()
  };
}
var error27 = () => {
  const Sizable = {
    string: { unit: "\u0437\u043D\u0430\u0446\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
    file: { unit: "\u0431\u0430\u0458\u0442\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
    array: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
    set: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0432\u043D\u0435\u0441",
    email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u043D\u0430 \u0435-\u043F\u043E\u0448\u0442\u0430",
    url: "URL",
    emoji: "\u0435\u043C\u043E\u045F\u0438",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0443\u043C \u0438 \u0432\u0440\u0435\u043C\u0435",
    date: "ISO \u0434\u0430\u0442\u0443\u043C",
    time: "ISO \u0432\u0440\u0435\u043C\u0435",
    duration: "ISO \u0432\u0440\u0435\u043C\u0435\u0442\u0440\u0430\u0435\u045A\u0435",
    ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441\u0430",
    ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441\u0430",
    cidrv4: "IPv4 \u043E\u043F\u0441\u0435\u0433",
    cidrv6: "IPv6 \u043E\u043F\u0441\u0435\u0433",
    base64: "base64-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
    base64url: "base64url-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
    json_string: "JSON \u043D\u0438\u0437\u0430",
    e164: "E.164 \u0431\u0440\u043E\u0458",
    jwt: "JWT",
    template_literal: "\u0432\u043D\u0435\u0441"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0431\u0440\u043E\u0458",
    array: "\u043D\u0438\u0437\u0430"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 instanceof ${issue2.expected}, \u043F\u0440\u0438\u043C\u0435\u043D\u043E ${received}`;
        }
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${expected}, \u043F\u0440\u0438\u043C\u0435\u043D\u043E ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0413\u0440\u0435\u0448\u0430\u043D\u0430 \u043E\u043F\u0446\u0438\u0458\u0430: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 \u0435\u0434\u043D\u0430 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0438"}`;
        return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u043D\u0443\u0432\u0430 \u0441\u043E "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u0432\u0440\u0448\u0443\u0432\u0430 \u0441\u043E "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0432\u043A\u043B\u0443\u0447\u0443\u0432\u0430 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u043E\u0434\u0433\u043E\u0430\u0440\u0430 \u043D\u0430 \u043F\u0430\u0442\u0435\u0440\u043D\u043E\u0442 ${_issue.pattern}`;
        return `Invalid ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0431\u0440\u043E\u0458: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0431\u0438\u0434\u0435 \u0434\u0435\u043B\u0438\u0432 \u0441\u043E ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D\u0438 \u043A\u043B\u0443\u0447\u0435\u0432\u0438" : "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D \u043A\u043B\u0443\u0447"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u043A\u043B\u0443\u0447 \u0432\u043E ${issue2.origin}`;
      case "invalid_union":
        return "\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441";
      case "invalid_element":
        return `\u0413\u0440\u0435\u0448\u043D\u0430 \u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442 \u0432\u043E ${issue2.origin}`;
      default:
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441`;
    }
  };
};
var init_mk = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/ms.js
function ms_default() {
  return {
    localeError: error28()
  };
}
var error28 = () => {
  const Sizable = {
    string: { unit: "aksara", verb: "mempunyai" },
    file: { unit: "bait", verb: "mempunyai" },
    array: { unit: "elemen", verb: "mempunyai" },
    set: { unit: "elemen", verb: "mempunyai" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "alamat e-mel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tarikh masa ISO",
    date: "tarikh ISO",
    time: "masa ISO",
    duration: "tempoh ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "julat IPv4",
    cidrv6: "julat IPv6",
    base64: "string dikodkan base64",
    base64url: "string dikodkan base64url",
    json_string: "string JSON",
    e164: "nombor E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "nombor"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Input tidak sah: dijangka instanceof ${issue2.expected}, diterima ${received}`;
        }
        return `Input tidak sah: dijangka ${expected}, diterima ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input tidak sah: dijangka ${stringifyPrimitive(issue2.values[0])}`;
        return `Pilihan tidak sah: dijangka salah satu daripada ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} adalah ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Terlalu kecil: dijangka ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: dijangka ${issue2.origin} adalah ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `String tidak sah: mesti bermula dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak sah: mesti berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak sah: mesti mengandungi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} tidak sah`;
      }
      case "not_multiple_of":
        return `Nombor tidak sah: perlu gandaan ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak sah dalam ${issue2.origin}`;
      case "invalid_union":
        return "Input tidak sah";
      case "invalid_element":
        return `Nilai tidak sah dalam ${issue2.origin}`;
      default:
        return `Input tidak sah`;
    }
  };
};
var init_ms = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/nl.js
function nl_default() {
  return {
    localeError: error29()
  };
}
var error29 = () => {
  const Sizable = {
    string: { unit: "tekens", verb: "heeft" },
    file: { unit: "bytes", verb: "heeft" },
    array: { unit: "elementen", verb: "heeft" },
    set: { unit: "elementen", verb: "heeft" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "invoer",
    email: "emailadres",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum en tijd",
    date: "ISO datum",
    time: "ISO tijd",
    duration: "ISO duur",
    ipv4: "IPv4-adres",
    ipv6: "IPv6-adres",
    cidrv4: "IPv4-bereik",
    cidrv6: "IPv6-bereik",
    base64: "base64-gecodeerde tekst",
    base64url: "base64 URL-gecodeerde tekst",
    json_string: "JSON string",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "invoer"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "getal"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ongeldige invoer: verwacht instanceof ${issue2.expected}, ontving ${received}`;
        }
        return `Ongeldige invoer: verwacht ${expected}, ontving ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ongeldige invoer: verwacht ${stringifyPrimitive(issue2.values[0])}`;
        return `Ongeldige optie: verwacht \xE9\xE9n van ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        const longName = issue2.origin === "date" ? "laat" : issue2.origin === "string" ? "lang" : "groot";
        if (sizing)
          return `Te ${longName}: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementen"} ${sizing.verb}`;
        return `Te ${longName}: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} is`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        const shortName = issue2.origin === "date" ? "vroeg" : issue2.origin === "string" ? "kort" : "klein";
        if (sizing) {
          return `Te ${shortName}: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} ${sizing.verb}`;
        }
        return `Te ${shortName}: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} is`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Ongeldige tekst: moet met "${_issue.prefix}" beginnen`;
        }
        if (_issue.format === "ends_with")
          return `Ongeldige tekst: moet op "${_issue.suffix}" eindigen`;
        if (_issue.format === "includes")
          return `Ongeldige tekst: moet "${_issue.includes}" bevatten`;
        if (_issue.format === "regex")
          return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;
        return `Ongeldig: ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ongeldig getal: moet een veelvoud van ${issue2.divisor} zijn`;
      case "unrecognized_keys":
        return `Onbekende key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ongeldige key in ${issue2.origin}`;
      case "invalid_union":
        return "Ongeldige invoer";
      case "invalid_element":
        return `Ongeldige waarde in ${issue2.origin}`;
      default:
        return `Ongeldige invoer`;
    }
  };
};
var init_nl = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/no.js
function no_default() {
  return {
    localeError: error30()
  };
}
var error30 = () => {
  const Sizable = {
    string: { unit: "tegn", verb: "\xE5 ha" },
    file: { unit: "bytes", verb: "\xE5 ha" },
    array: { unit: "elementer", verb: "\xE5 inneholde" },
    set: { unit: "elementer", verb: "\xE5 inneholde" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "e-postadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkeslett",
    date: "ISO-dato",
    time: "ISO-klokkeslett",
    duration: "ISO-varighet",
    ipv4: "IPv4-omr\xE5de",
    ipv6: "IPv6-omr\xE5de",
    cidrv4: "IPv4-spekter",
    cidrv6: "IPv6-spekter",
    base64: "base64-enkodet streng",
    base64url: "base64url-enkodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "tall",
    array: "liste"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ugyldig input: forventet instanceof ${issue2.expected}, fikk ${received}`;
        }
        return `Ugyldig input: forventet ${expected}, fikk ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ugyldig verdi: forventet ${stringifyPrimitive(issue2.values[0])}`;
        return `Ugyldig valg: forventet en av ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `For stor(t): forventet ${issue2.origin ?? "value"} til \xE5 ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor(t): forventet ${issue2.origin ?? "value"} til \xE5 ha ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `For lite(n): forventet ${issue2.origin} til \xE5 ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `For lite(n): forventet ${issue2.origin} til \xE5 ha ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: m\xE5 starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: m\xE5 ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: m\xE5 inneholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: m\xE5 matche m\xF8nsteret ${_issue.pattern}`;
        return `Ugyldig ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ugyldig tall: m\xE5 v\xE6re et multiplum av ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ukjente n\xF8kler" : "Ukjent n\xF8kkel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig n\xF8kkel i ${issue2.origin}`;
      case "invalid_union":
        return "Ugyldig input";
      case "invalid_element":
        return `Ugyldig verdi i ${issue2.origin}`;
      default:
        return `Ugyldig input`;
    }
  };
};
var init_no = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/ota.js
function ota_default() {
  return {
    localeError: error31()
  };
}
var error31 = () => {
  const Sizable = {
    string: { unit: "harf", verb: "olmal\u0131d\u0131r" },
    file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
    array: { unit: "unsur", verb: "olmal\u0131d\u0131r" },
    set: { unit: "unsur", verb: "olmal\u0131d\u0131r" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "giren",
    email: "epostag\xE2h",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO heng\xE2m\u0131",
    date: "ISO tarihi",
    time: "ISO zaman\u0131",
    duration: "ISO m\xFCddeti",
    ipv4: "IPv4 ni\u015F\xE2n\u0131",
    ipv6: "IPv6 ni\u015F\xE2n\u0131",
    cidrv4: "IPv4 menzili",
    cidrv6: "IPv6 menzili",
    base64: "base64-\u015Fifreli metin",
    base64url: "base64url-\u015Fifreli metin",
    json_string: "JSON metin",
    e164: "E.164 say\u0131s\u0131",
    jwt: "JWT",
    template_literal: "giren"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "numara",
    array: "saf",
    null: "gayb"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `F\xE2sit giren: umulan instanceof ${issue2.expected}, al\u0131nan ${received}`;
        }
        return `F\xE2sit giren: umulan ${expected}, al\u0131nan ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `F\xE2sit giren: umulan ${stringifyPrimitive(issue2.values[0])}`;
        return `F\xE2sit tercih: m\xFBteberler ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Fazla b\xFCy\xFCk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"} sahip olmal\u0131yd\u0131.`;
        return `Fazla b\xFCy\xFCk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} olmal\u0131yd\u0131.`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Fazla k\xFC\xE7\xFCk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} ${sizing.unit} sahip olmal\u0131yd\u0131.`;
        }
        return `Fazla k\xFC\xE7\xFCk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} olmal\u0131yd\u0131.`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `F\xE2sit metin: "${_issue.prefix}" ile ba\u015Flamal\u0131.`;
        if (_issue.format === "ends_with")
          return `F\xE2sit metin: "${_issue.suffix}" ile bitmeli.`;
        if (_issue.format === "includes")
          return `F\xE2sit metin: "${_issue.includes}" ihtiv\xE2 etmeli.`;
        if (_issue.format === "regex")
          return `F\xE2sit metin: ${_issue.pattern} nak\u015F\u0131na uymal\u0131.`;
        return `F\xE2sit ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `F\xE2sit say\u0131: ${issue2.divisor} kat\u0131 olmal\u0131yd\u0131.`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan anahtar ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} i\xE7in tan\u0131nmayan anahtar var.`;
      case "invalid_union":
        return "Giren tan\u0131namad\u0131.";
      case "invalid_element":
        return `${issue2.origin} i\xE7in tan\u0131nmayan k\u0131ymet var.`;
      default:
        return `K\u0131ymet tan\u0131namad\u0131.`;
    }
  };
};
var init_ota = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/ps.js
function ps_default() {
  return {
    localeError: error32()
  };
}
var error32 = () => {
  const Sizable = {
    string: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
    file: { unit: "\u0628\u0627\u06CC\u067C\u0633", verb: "\u0648\u0644\u0631\u064A" },
    array: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
    set: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0648\u0631\u0648\u062F\u064A",
    email: "\u0628\u0631\u06CC\u069A\u0646\u0627\u0644\u06CC\u06A9",
    url: "\u06CC\u0648 \u0622\u0631 \u0627\u0644",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u064A",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0646\u06CC\u067C\u0647 \u0627\u0648 \u0648\u062E\u062A",
    date: "\u0646\u06D0\u067C\u0647",
    time: "\u0648\u062E\u062A",
    duration: "\u0645\u0648\u062F\u0647",
    ipv4: "\u062F IPv4 \u067E\u062A\u0647",
    ipv6: "\u062F IPv6 \u067E\u062A\u0647",
    cidrv4: "\u062F IPv4 \u0633\u0627\u062D\u0647",
    cidrv6: "\u062F IPv6 \u0633\u0627\u062D\u0647",
    base64: "base64-encoded \u0645\u062A\u0646",
    base64url: "base64url-encoded \u0645\u062A\u0646",
    json_string: "JSON \u0645\u062A\u0646",
    e164: "\u062F E.164 \u0634\u0645\u06D0\u0631\u0647",
    jwt: "JWT",
    template_literal: "\u0648\u0631\u0648\u062F\u064A"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0639\u062F\u062F",
    array: "\u0627\u0631\u06D0"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F instanceof ${issue2.expected} \u0648\u0627\u06CC, \u0645\u06AB\u0631 ${received} \u062A\u0631\u0644\u0627\u0633\u0647 \u0634\u0648`;
        }
        return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${expected} \u0648\u0627\u06CC, \u0645\u06AB\u0631 ${received} \u062A\u0631\u0644\u0627\u0633\u0647 \u0634\u0648`;
      }
      case "invalid_value":
        if (issue2.values.length === 1) {
          return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${stringifyPrimitive(issue2.values[0])} \u0648\u0627\u06CC`;
        }
        return `\u0646\u0627\u0633\u0645 \u0627\u0646\u062A\u062E\u0627\u0628: \u0628\u0627\u06CC\u062F \u06CC\u0648 \u0644\u0647 ${joinValues(issue2.values, "|")} \u0685\u062E\u0647 \u0648\u0627\u06CC`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue2.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631\u0648\u0646\u0647"} \u0648\u0644\u0631\u064A`;
        }
        return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue2.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} \u0648\u064A`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0648\u0644\u0631\u064A`;
        }
        return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} \u0648\u064A`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.prefix}" \u0633\u0631\u0647 \u067E\u06CC\u0644 \u0634\u064A`;
        }
        if (_issue.format === "ends_with") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.suffix}" \u0633\u0631\u0647 \u067E\u0627\u06CC \u062A\u0647 \u0648\u0631\u0633\u064A\u0696\u064A`;
        }
        if (_issue.format === "includes") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F "${_issue.includes}" \u0648\u0644\u0631\u064A`;
        }
        if (_issue.format === "regex") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F ${_issue.pattern} \u0633\u0631\u0647 \u0645\u0637\u0627\u0628\u0642\u062A \u0648\u0644\u0631\u064A`;
        }
        return `${FormatDictionary[_issue.format] ?? issue2.format} \u0646\u0627\u0633\u0645 \u062F\u06CC`;
      }
      case "not_multiple_of":
        return `\u0646\u0627\u0633\u0645 \u0639\u062F\u062F: \u0628\u0627\u06CC\u062F \u062F ${issue2.divisor} \u0645\u0636\u0631\u0628 \u0648\u064A`;
      case "unrecognized_keys":
        return `\u0646\u0627\u0633\u0645 ${issue2.keys.length > 1 ? "\u06A9\u0644\u06CC\u0689\u0648\u0646\u0647" : "\u06A9\u0644\u06CC\u0689"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u0646\u0627\u0633\u0645 \u06A9\u0644\u06CC\u0689 \u067E\u0647 ${issue2.origin} \u06A9\u06D0`;
      case "invalid_union":
        return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
      case "invalid_element":
        return `\u0646\u0627\u0633\u0645 \u0639\u0646\u0635\u0631 \u067E\u0647 ${issue2.origin} \u06A9\u06D0`;
      default:
        return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
    }
  };
};
var init_ps = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/pl.js
function pl_default() {
  return {
    localeError: error33()
  };
}
var error33 = () => {
  const Sizable = {
    string: { unit: "znak\xF3w", verb: "mie\u0107" },
    file: { unit: "bajt\xF3w", verb: "mie\u0107" },
    array: { unit: "element\xF3w", verb: "mie\u0107" },
    set: { unit: "element\xF3w", verb: "mie\u0107" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "wyra\u017Cenie",
    email: "adres email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i godzina w formacie ISO",
    date: "data w formacie ISO",
    time: "godzina w formacie ISO",
    duration: "czas trwania ISO",
    ipv4: "adres IPv4",
    ipv6: "adres IPv6",
    cidrv4: "zakres IPv4",
    cidrv6: "zakres IPv6",
    base64: "ci\u0105g znak\xF3w zakodowany w formacie base64",
    base64url: "ci\u0105g znak\xF3w zakodowany w formacie base64url",
    json_string: "ci\u0105g znak\xF3w w formacie JSON",
    e164: "liczba E.164",
    jwt: "JWT",
    template_literal: "wej\u015Bcie"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "liczba",
    array: "tablica"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano instanceof ${issue2.expected}, otrzymano ${received}`;
        }
        return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${expected}, otrzymano ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${stringifyPrimitive(issue2.values[0])}`;
        return `Nieprawid\u0142owa opcja: oczekiwano jednej z warto\u015Bci ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Za du\u017Ca warto\u015B\u0107: oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element\xF3w"}`;
        }
        return `Zbyt du\u017C(y/a/e): oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Za ma\u0142a warto\u015B\u0107: oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "element\xF3w"}`;
        }
        return `Zbyt ma\u0142(y/a/e): oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zaczyna\u0107 si\u0119 od "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi ko\u0144czy\u0107 si\u0119 na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zawiera\u0107 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi odpowiada\u0107 wzorcowi ${_issue.pattern}`;
        return `Nieprawid\u0142ow(y/a/e) ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nieprawid\u0142owa liczba: musi by\u0107 wielokrotno\u015Bci\u0105 ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nierozpoznane klucze${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Nieprawid\u0142owy klucz w ${issue2.origin}`;
      case "invalid_union":
        return "Nieprawid\u0142owe dane wej\u015Bciowe";
      case "invalid_element":
        return `Nieprawid\u0142owa warto\u015B\u0107 w ${issue2.origin}`;
      default:
        return `Nieprawid\u0142owe dane wej\u015Bciowe`;
    }
  };
};
var init_pl = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/pt.js
function pt_default() {
  return {
    localeError: error34()
  };
}
var error34 = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "ter" },
    file: { unit: "bytes", verb: "ter" },
    array: { unit: "itens", verb: "ter" },
    set: { unit: "itens", verb: "ter" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "padr\xE3o",
    email: "endere\xE7o de e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "dura\xE7\xE3o ISO",
    ipv4: "endere\xE7o IPv4",
    ipv6: "endere\xE7o IPv6",
    cidrv4: "faixa de IPv4",
    cidrv6: "faixa de IPv6",
    base64: "texto codificado em base64",
    base64url: "URL codificada em base64",
    json_string: "texto JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "n\xFAmero",
    null: "nulo"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Tipo inv\xE1lido: esperado instanceof ${issue2.expected}, recebido ${received}`;
        }
        return `Tipo inv\xE1lido: esperado ${expected}, recebido ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrada inv\xE1lida: esperado ${stringifyPrimitive(issue2.values[0])}`;
        return `Op\xE7\xE3o inv\xE1lida: esperada uma das ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Muito grande: esperado que ${issue2.origin ?? "valor"} tivesse ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Muito grande: esperado que ${issue2.origin ?? "valor"} fosse ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Muito pequeno: esperado que ${issue2.origin} tivesse ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Muito pequeno: esperado que ${issue2.origin} fosse ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Texto inv\xE1lido: deve come\xE7ar com "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Texto inv\xE1lido: deve terminar com "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Texto inv\xE1lido: deve incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Texto inv\xE1lido: deve corresponder ao padr\xE3o ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} inv\xE1lido`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE1lido: deve ser m\xFAltiplo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Chave${issue2.keys.length > 1 ? "s" : ""} desconhecida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Chave inv\xE1lida em ${issue2.origin}`;
      case "invalid_union":
        return "Entrada inv\xE1lida";
      case "invalid_element":
        return `Valor inv\xE1lido em ${issue2.origin}`;
      default:
        return `Campo inv\xE1lido`;
    }
  };
};
var init_pt = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/ru.js
function getRussianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
function ru_default() {
  return {
    localeError: error35()
  };
}
var error35 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "\u0441\u0438\u043C\u0432\u043E\u043B",
        few: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430",
        many: "\u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    file: {
      unit: {
        one: "\u0431\u0430\u0439\u0442",
        few: "\u0431\u0430\u0439\u0442\u0430",
        many: "\u0431\u0430\u0439\u0442"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    array: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    set: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0432\u0432\u043E\u0434",
    email: "email \u0430\u0434\u0440\u0435\u0441",
    url: "URL",
    emoji: "\u044D\u043C\u043E\u0434\u0437\u0438",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0430 \u0438 \u0432\u0440\u0435\u043C\u044F",
    date: "ISO \u0434\u0430\u0442\u0430",
    time: "ISO \u0432\u0440\u0435\u043C\u044F",
    duration: "ISO \u0434\u043B\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u044C",
    ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
    ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
    cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    base64: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64",
    base64url: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64url",
    json_string: "JSON \u0441\u0442\u0440\u043E\u043A\u0430",
    e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0432\u0432\u043E\u0434"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0447\u0438\u0441\u043B\u043E",
    array: "\u043C\u0430\u0441\u0441\u0438\u0432"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C instanceof ${issue2.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u043E ${received}`;
        }
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u043E ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${stringifyPrimitive(issue2.values[0])}`;
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0430\u0440\u0438\u0430\u043D\u0442: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C \u043E\u0434\u043D\u043E \u0438\u0437 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getRussianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getRussianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u043D\u0430\u0447\u0438\u043D\u0430\u0442\u044C\u0441\u044F \u0441 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0437\u0430\u043A\u0430\u043D\u0447\u0438\u0432\u0430\u0442\u044C\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u043E\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u043E\u0432\u0430\u0442\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0447\u0438\u0441\u043B\u043E: \u0434\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0441\u043F\u043E\u0437\u043D\u0430\u043D\u043D${issue2.keys.length > 1 ? "\u044B\u0435" : "\u044B\u0439"} \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u0438" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u043A\u043B\u044E\u0447 \u0432 ${issue2.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435";
      case "invalid_element":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u0432 ${issue2.origin}`;
      default:
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435`;
    }
  };
};
var init_ru = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/sl.js
function sl_default() {
  return {
    localeError: error36()
  };
}
var error36 = () => {
  const Sizable = {
    string: { unit: "znakov", verb: "imeti" },
    file: { unit: "bajtov", verb: "imeti" },
    array: { unit: "elementov", verb: "imeti" },
    set: { unit: "elementov", verb: "imeti" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "vnos",
    email: "e-po\u0161tni naslov",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum in \u010Das",
    date: "ISO datum",
    time: "ISO \u010Das",
    duration: "ISO trajanje",
    ipv4: "IPv4 naslov",
    ipv6: "IPv6 naslov",
    cidrv4: "obseg IPv4",
    cidrv6: "obseg IPv6",
    base64: "base64 kodiran niz",
    base64url: "base64url kodiran niz",
    json_string: "JSON niz",
    e164: "E.164 \u0161tevilka",
    jwt: "JWT",
    template_literal: "vnos"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0161tevilo",
    array: "tabela"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Neveljaven vnos: pri\u010Dakovano instanceof ${issue2.expected}, prejeto ${received}`;
        }
        return `Neveljaven vnos: pri\u010Dakovano ${expected}, prejeto ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Neveljaven vnos: pri\u010Dakovano ${stringifyPrimitive(issue2.values[0])}`;
        return `Neveljavna mo\u017Enost: pri\u010Dakovano eno izmed ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Preveliko: pri\u010Dakovano, da bo ${issue2.origin ?? "vrednost"} imelo ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementov"}`;
        return `Preveliko: pri\u010Dakovano, da bo ${issue2.origin ?? "vrednost"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Premajhno: pri\u010Dakovano, da bo ${issue2.origin} imelo ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Premajhno: pri\u010Dakovano, da bo ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Neveljaven niz: mora se za\u010Deti z "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Neveljaven niz: mora se kon\u010Dati z "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neveljaven niz: mora vsebovati "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;
        return `Neveljaven ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Neveljavno \u0161tevilo: mora biti ve\u010Dkratnik ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Neprepoznan${issue2.keys.length > 1 ? "i klju\u010Di" : " klju\u010D"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Neveljaven klju\u010D v ${issue2.origin}`;
      case "invalid_union":
        return "Neveljaven vnos";
      case "invalid_element":
        return `Neveljavna vrednost v ${issue2.origin}`;
      default:
        return "Neveljaven vnos";
    }
  };
};
var init_sl = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/sv.js
function sv_default() {
  return {
    localeError: error37()
  };
}
var error37 = () => {
  const Sizable = {
    string: { unit: "tecken", verb: "att ha" },
    file: { unit: "bytes", verb: "att ha" },
    array: { unit: "objekt", verb: "att inneh\xE5lla" },
    set: { unit: "objekt", verb: "att inneh\xE5lla" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "regulj\xE4rt uttryck",
    email: "e-postadress",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datum och tid",
    date: "ISO-datum",
    time: "ISO-tid",
    duration: "ISO-varaktighet",
    ipv4: "IPv4-intervall",
    ipv6: "IPv6-intervall",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodad str\xE4ng",
    base64url: "base64url-kodad str\xE4ng",
    json_string: "JSON-str\xE4ng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "mall-literal"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "antal",
    array: "lista"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ogiltig inmatning: f\xF6rv\xE4ntat instanceof ${issue2.expected}, fick ${received}`;
        }
        return `Ogiltig inmatning: f\xF6rv\xE4ntat ${expected}, fick ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ogiltig inmatning: f\xF6rv\xE4ntat ${stringifyPrimitive(issue2.values[0])}`;
        return `Ogiltigt val: f\xF6rv\xE4ntade en av ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `F\xF6r stor(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        }
        return `F\xF6r stor(t): f\xF6rv\xE4ntat ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Ogiltig str\xE4ng: m\xE5ste b\xF6rja med "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Ogiltig str\xE4ng: m\xE5ste sluta med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ogiltig str\xE4ng: m\xE5ste inneh\xE5lla "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ogiltig str\xE4ng: m\xE5ste matcha m\xF6nstret "${_issue.pattern}"`;
        return `Ogiltig(t) ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ogiltigt tal: m\xE5ste vara en multipel av ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ok\xE4nda nycklar" : "Ok\xE4nd nyckel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ogiltig nyckel i ${issue2.origin ?? "v\xE4rdet"}`;
      case "invalid_union":
        return "Ogiltig input";
      case "invalid_element":
        return `Ogiltigt v\xE4rde i ${issue2.origin ?? "v\xE4rdet"}`;
      default:
        return `Ogiltig input`;
    }
  };
};
var init_sv = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/ta.js
function ta_default() {
  return {
    localeError: error38()
  };
}
var error38 = () => {
  const Sizable = {
    string: { unit: "\u0B8E\u0BB4\u0BC1\u0BA4\u0BCD\u0BA4\u0BC1\u0B95\u0BCD\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
    file: { unit: "\u0BAA\u0BC8\u0B9F\u0BCD\u0B9F\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
    array: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
    set: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1",
    email: "\u0BAE\u0BBF\u0BA9\u0BCD\u0BA9\u0B9E\u0BCD\u0B9A\u0BB2\u0BCD \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0BA4\u0BC7\u0BA4\u0BBF \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
    date: "ISO \u0BA4\u0BC7\u0BA4\u0BBF",
    time: "ISO \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
    duration: "ISO \u0B95\u0BBE\u0BB2 \u0B85\u0BB3\u0BB5\u0BC1",
    ipv4: "IPv4 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    ipv6: "IPv6 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    cidrv4: "IPv4 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
    cidrv6: "IPv6 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
    base64: "base64-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
    base64url: "base64url-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
    json_string: "JSON \u0B9A\u0BB0\u0BAE\u0BCD",
    e164: "E.164 \u0B8E\u0BA3\u0BCD",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0B8E\u0BA3\u0BCD",
    array: "\u0B85\u0BA3\u0BBF",
    null: "\u0BB5\u0BC6\u0BB1\u0BC1\u0BAE\u0BC8"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 instanceof ${issue2.expected}, \u0BAA\u0BC6\u0BB1\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${received}`;
        }
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${expected}, \u0BAA\u0BC6\u0BB1\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0BB0\u0BC1\u0BAA\u0BCD\u0BAA\u0BAE\u0BCD: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${joinValues(issue2.values, "|")} \u0B87\u0BB2\u0BCD \u0B92\u0BA9\u0BCD\u0BB1\u0BC1`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD"} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        }
        return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue2.maximum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        }
        return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin} ${adj}${issue2.minimum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.prefix}" \u0B87\u0BB2\u0BCD \u0BA4\u0BCA\u0B9F\u0B99\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "ends_with")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.suffix}" \u0B87\u0BB2\u0BCD \u0BAE\u0BC1\u0B9F\u0BBF\u0BB5\u0B9F\u0BC8\u0BAF \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "includes")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.includes}" \u0B90 \u0B89\u0BB3\u0BCD\u0BB3\u0B9F\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "regex")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: ${_issue.pattern} \u0BAE\u0BC1\u0BB1\u0BC8\u0BAA\u0BBE\u0B9F\u0BCD\u0B9F\u0BC1\u0B9F\u0BA9\u0BCD \u0BAA\u0BCA\u0BB0\u0BC1\u0BA8\u0BCD\u0BA4 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B8E\u0BA3\u0BCD: ${issue2.divisor} \u0B87\u0BA9\u0BCD \u0BAA\u0BB2\u0BAE\u0BBE\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      case "unrecognized_keys":
        return `\u0B85\u0B9F\u0BC8\u0BAF\u0BBE\u0BB3\u0BAE\u0BCD \u0BA4\u0BC6\u0BB0\u0BBF\u0BAF\u0BBE\u0BA4 \u0BB5\u0BBF\u0B9A\u0BC8${issue2.keys.length > 1 ? "\u0B95\u0BB3\u0BCD" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0B9A\u0BC8`;
      case "invalid_union":
        return "\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1";
      case "invalid_element":
        return `${issue2.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1`;
      default:
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1`;
    }
  };
};
var init_ta = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/th.js
function th_default() {
  return {
    localeError: error39()
  };
}
var error39 = () => {
  const Sizable = {
    string: { unit: "\u0E15\u0E31\u0E27\u0E2D\u0E31\u0E01\u0E29\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
    file: { unit: "\u0E44\u0E1A\u0E15\u0E4C", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
    array: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
    set: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19",
    email: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48\u0E2D\u0E35\u0E40\u0E21\u0E25",
    url: "URL",
    emoji: "\u0E2D\u0E34\u0E42\u0E21\u0E08\u0E34",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    date: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E41\u0E1A\u0E1A ISO",
    time: "\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    duration: "\u0E0A\u0E48\u0E27\u0E07\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    ipv4: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv4",
    ipv6: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv6",
    cidrv4: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv4",
    cidrv6: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv6",
    base64: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64",
    base64url: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64 \u0E2A\u0E33\u0E2B\u0E23\u0E31\u0E1A URL",
    json_string: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A JSON",
    e164: "\u0E40\u0E1A\u0E2D\u0E23\u0E4C\u0E42\u0E17\u0E23\u0E28\u0E31\u0E1E\u0E17\u0E4C\u0E23\u0E30\u0E2B\u0E27\u0E48\u0E32\u0E07\u0E1B\u0E23\u0E30\u0E40\u0E17\u0E28 (E.164)",
    jwt: "\u0E42\u0E17\u0E40\u0E04\u0E19 JWT",
    template_literal: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02",
    array: "\u0E2D\u0E32\u0E23\u0E4C\u0E40\u0E23\u0E22\u0E4C (Array)",
    null: "\u0E44\u0E21\u0E48\u0E21\u0E35\u0E04\u0E48\u0E32 (null)"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 instanceof ${issue2.expected} \u0E41\u0E15\u0E48\u0E44\u0E14\u0E49\u0E23\u0E31\u0E1A ${received}`;
        }
        return `\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${expected} \u0E41\u0E15\u0E48\u0E44\u0E14\u0E49\u0E23\u0E31\u0E1A ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u0E04\u0E48\u0E32\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E37\u0E2D\u0E01\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19\u0E2B\u0E19\u0E36\u0E48\u0E07\u0E43\u0E19 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "\u0E44\u0E21\u0E48\u0E40\u0E01\u0E34\u0E19" : "\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23"}`;
        return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\u0E2D\u0E22\u0E48\u0E32\u0E07\u0E19\u0E49\u0E2D\u0E22" : "\u0E21\u0E32\u0E01\u0E01\u0E27\u0E48\u0E32";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E02\u0E36\u0E49\u0E19\u0E15\u0E49\u0E19\u0E14\u0E49\u0E27\u0E22 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E25\u0E07\u0E17\u0E49\u0E32\u0E22\u0E14\u0E49\u0E27\u0E22 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E21\u0E35 "${_issue.includes}" \u0E2D\u0E22\u0E39\u0E48\u0E43\u0E19\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21`;
        if (_issue.format === "regex")
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14 ${_issue.pattern}`;
        return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E40\u0E1B\u0E47\u0E19\u0E08\u0E33\u0E19\u0E27\u0E19\u0E17\u0E35\u0E48\u0E2B\u0E32\u0E23\u0E14\u0E49\u0E27\u0E22 ${issue2.divisor} \u0E44\u0E14\u0E49\u0E25\u0E07\u0E15\u0E31\u0E27`;
      case "unrecognized_keys":
        return `\u0E1E\u0E1A\u0E04\u0E35\u0E22\u0E4C\u0E17\u0E35\u0E48\u0E44\u0E21\u0E48\u0E23\u0E39\u0E49\u0E08\u0E31\u0E01: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u0E04\u0E35\u0E22\u0E4C\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue2.origin}`;
      case "invalid_union":
        return "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E44\u0E21\u0E48\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E22\u0E39\u0E40\u0E19\u0E35\u0E22\u0E19\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14\u0E44\u0E27\u0E49";
      case "invalid_element":
        return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue2.origin}`;
      default:
        return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07`;
    }
  };
};
var init_th = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/tr.js
function tr_default() {
  return {
    localeError: error40()
  };
}
var error40 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "olmal\u0131" },
    file: { unit: "bayt", verb: "olmal\u0131" },
    array: { unit: "\xF6\u011Fe", verb: "olmal\u0131" },
    set: { unit: "\xF6\u011Fe", verb: "olmal\u0131" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "girdi",
    email: "e-posta adresi",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO tarih ve saat",
    date: "ISO tarih",
    time: "ISO saat",
    duration: "ISO s\xFCre",
    ipv4: "IPv4 adresi",
    ipv6: "IPv6 adresi",
    cidrv4: "IPv4 aral\u0131\u011F\u0131",
    cidrv6: "IPv6 aral\u0131\u011F\u0131",
    base64: "base64 ile \u015Fifrelenmi\u015F metin",
    base64url: "base64url ile \u015Fifrelenmi\u015F metin",
    json_string: "JSON dizesi",
    e164: "E.164 say\u0131s\u0131",
    jwt: "JWT",
    template_literal: "\u015Eablon dizesi"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ge\xE7ersiz de\u011Fer: beklenen instanceof ${issue2.expected}, al\u0131nan ${received}`;
        }
        return `Ge\xE7ersiz de\u011Fer: beklenen ${expected}, al\u0131nan ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ge\xE7ersiz de\u011Fer: beklenen ${stringifyPrimitive(issue2.values[0])}`;
        return `Ge\xE7ersiz se\xE7enek: a\u015Fa\u011F\u0131dakilerden biri olmal\u0131: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\xC7ok b\xFCy\xFCk: beklenen ${issue2.origin ?? "de\u011Fer"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\xF6\u011Fe"}`;
        return `\xC7ok b\xFCy\xFCk: beklenen ${issue2.origin ?? "de\u011Fer"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ge\xE7ersiz metin: "${_issue.prefix}" ile ba\u015Flamal\u0131`;
        if (_issue.format === "ends_with")
          return `Ge\xE7ersiz metin: "${_issue.suffix}" ile bitmeli`;
        if (_issue.format === "includes")
          return `Ge\xE7ersiz metin: "${_issue.includes}" i\xE7ermeli`;
        if (_issue.format === "regex")
          return `Ge\xE7ersiz metin: ${_issue.pattern} desenine uymal\u0131`;
        return `Ge\xE7ersiz ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ge\xE7ersiz say\u0131: ${issue2.divisor} ile tam b\xF6l\xFCnebilmeli`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan anahtar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} i\xE7inde ge\xE7ersiz anahtar`;
      case "invalid_union":
        return "Ge\xE7ersiz de\u011Fer";
      case "invalid_element":
        return `${issue2.origin} i\xE7inde ge\xE7ersiz de\u011Fer`;
      default:
        return `Ge\xE7ersiz de\u011Fer`;
    }
  };
};
var init_tr = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/uk.js
function uk_default() {
  return {
    localeError: error41()
  };
}
var error41 = () => {
  const Sizable = {
    string: { unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
    file: { unit: "\u0431\u0430\u0439\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
    array: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
    set: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456",
    email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u0435\u043B\u0435\u043A\u0442\u0440\u043E\u043D\u043D\u043E\u0457 \u043F\u043E\u0448\u0442\u0438",
    url: "URL",
    emoji: "\u0435\u043C\u043E\u0434\u0437\u0456",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0434\u0430\u0442\u0430 \u0442\u0430 \u0447\u0430\u0441 ISO",
    date: "\u0434\u0430\u0442\u0430 ISO",
    time: "\u0447\u0430\u0441 ISO",
    duration: "\u0442\u0440\u0438\u0432\u0430\u043B\u0456\u0441\u0442\u044C ISO",
    ipv4: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv4",
    ipv6: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv6",
    cidrv4: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv4",
    cidrv6: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv6",
    base64: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64",
    base64url: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64url",
    json_string: "\u0440\u044F\u0434\u043E\u043A JSON",
    e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0447\u0438\u0441\u043B\u043E",
    array: "\u043C\u0430\u0441\u0438\u0432"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F instanceof ${issue2.expected}, \u043E\u0442\u0440\u0438\u043C\u0430\u043D\u043E ${received}`;
        }
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${expected}, \u043E\u0442\u0440\u0438\u043C\u0430\u043D\u043E ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${stringifyPrimitive(issue2.values[0])}`;
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0430 \u043E\u043F\u0446\u0456\u044F: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F \u043E\u0434\u043D\u0435 \u0437 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432"}`;
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} \u0431\u0443\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin} \u0431\u0443\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043F\u043E\u0447\u0438\u043D\u0430\u0442\u0438\u0441\u044F \u0437 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0437\u0430\u043A\u0456\u043D\u0447\u0443\u0432\u0430\u0442\u0438\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043C\u0456\u0441\u0442\u0438\u0442\u0438 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0432\u0456\u0434\u043F\u043E\u0432\u0456\u0434\u0430\u0442\u0438 \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0447\u0438\u0441\u043B\u043E: \u043F\u043E\u0432\u0438\u043D\u043D\u043E \u0431\u0443\u0442\u0438 \u043A\u0440\u0430\u0442\u043D\u0438\u043C ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u043E\u0437\u043F\u0456\u0437\u043D\u0430\u043D\u0438\u0439 \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u0456" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u043A\u043B\u044E\u0447 \u0443 ${issue2.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456";
      case "invalid_element":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F \u0443 ${issue2.origin}`;
      default:
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456`;
    }
  };
};
var init_uk = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/ua.js
function ua_default() {
  return uk_default();
}
var init_ua = __esm(() => {
  init_uk();
});

// node_modules/zod/v4/locales/ur.js
function ur_default() {
  return {
    localeError: error42()
  };
}
var error42 = () => {
  const Sizable = {
    string: { unit: "\u062D\u0631\u0648\u0641", verb: "\u06C1\u0648\u0646\u0627" },
    file: { unit: "\u0628\u0627\u0626\u0679\u0633", verb: "\u06C1\u0648\u0646\u0627" },
    array: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" },
    set: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0627\u0646 \u067E\u0679",
    email: "\u0627\u06CC \u0645\u06CC\u0644 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    url: "\u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
    uuid: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    uuidv4: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 4",
    uuidv6: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 6",
    nanoid: "\u0646\u06CC\u0646\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    guid: "\u062C\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    cuid: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    cuid2: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC 2",
    ulid: "\u06CC\u0648 \u0627\u06CC\u0644 \u0622\u0626\u06CC \u0688\u06CC",
    xid: "\u0627\u06CC\u06A9\u0633 \u0622\u0626\u06CC \u0688\u06CC",
    ksuid: "\u06A9\u06D2 \u0627\u06CC\u0633 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    datetime: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0688\u06CC\u0679 \u0679\u0627\u0626\u0645",
    date: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u062A\u0627\u0631\u06CC\u062E",
    time: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0648\u0642\u062A",
    duration: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0645\u062F\u062A",
    ipv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    ipv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    cidrv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0631\u06CC\u0646\u062C",
    cidrv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0631\u06CC\u0646\u062C",
    base64: "\u0628\u06CC\u0633 64 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
    base64url: "\u0628\u06CC\u0633 64 \u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
    json_string: "\u062C\u06D2 \u0627\u06CC\u0633 \u0627\u0648 \u0627\u06CC\u0646 \u0633\u0679\u0631\u0646\u06AF",
    e164: "\u0627\u06CC 164 \u0646\u0645\u0628\u0631",
    jwt: "\u062C\u06D2 \u0688\u0628\u0644\u06CC\u0648 \u0679\u06CC",
    template_literal: "\u0627\u0646 \u067E\u0679"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0646\u0645\u0628\u0631",
    array: "\u0622\u0631\u06D2",
    null: "\u0646\u0644"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: instanceof ${issue2.expected} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627\u060C ${received} \u0645\u0648\u0635\u0648\u0644 \u06C1\u0648\u0627`;
        }
        return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${expected} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627\u060C ${received} \u0645\u0648\u0635\u0648\u0644 \u06C1\u0648\u0627`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${stringifyPrimitive(issue2.values[0])} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
        return `\u063A\u0644\u0637 \u0622\u067E\u0634\u0646: ${joinValues(issue2.values, "|")} \u0645\u06CC\u06BA \u0633\u06D2 \u0627\u06CC\u06A9 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue2.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u06D2 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0627\u0635\u0631"} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
        return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue2.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u0627 ${adj}${issue2.maximum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue2.origin} \u06A9\u06D2 ${adj}${issue2.minimum.toString()} ${sizing.unit} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
        }
        return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue2.origin} \u06A9\u0627 ${adj}${issue2.minimum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.prefix}" \u0633\u06D2 \u0634\u0631\u0648\u0639 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        }
        if (_issue.format === "ends_with")
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.suffix}" \u067E\u0631 \u062E\u062A\u0645 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        if (_issue.format === "includes")
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.includes}" \u0634\u0627\u0645\u0644 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        if (_issue.format === "regex")
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: \u067E\u06CC\u0679\u0631\u0646 ${_issue.pattern} \u0633\u06D2 \u0645\u06CC\u0686 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        return `\u063A\u0644\u0637 ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u063A\u0644\u0637 \u0646\u0645\u0628\u0631: ${issue2.divisor} \u06A9\u0627 \u0645\u0636\u0627\u0639\u0641 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
      case "unrecognized_keys":
        return `\u063A\u06CC\u0631 \u062A\u0633\u0644\u06CC\u0645 \u0634\u062F\u06C1 \u06A9\u06CC${issue2.keys.length > 1 ? "\u0632" : ""}: ${joinValues(issue2.keys, "\u060C ")}`;
      case "invalid_key":
        return `${issue2.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u06A9\u06CC`;
      case "invalid_union":
        return "\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679";
      case "invalid_element":
        return `${issue2.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u0648\u06CC\u0644\u06CC\u0648`;
      default:
        return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679`;
    }
  };
};
var init_ur = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/uz.js
function uz_default() {
  return {
    localeError: error43()
  };
}
var error43 = () => {
  const Sizable = {
    string: { unit: "belgi", verb: "bo\u2018lishi kerak" },
    file: { unit: "bayt", verb: "bo\u2018lishi kerak" },
    array: { unit: "element", verb: "bo\u2018lishi kerak" },
    set: { unit: "element", verb: "bo\u2018lishi kerak" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "kirish",
    email: "elektron pochta manzili",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO sana va vaqti",
    date: "ISO sana",
    time: "ISO vaqt",
    duration: "ISO davomiylik",
    ipv4: "IPv4 manzil",
    ipv6: "IPv6 manzil",
    mac: "MAC manzil",
    cidrv4: "IPv4 diapazon",
    cidrv6: "IPv6 diapazon",
    base64: "base64 kodlangan satr",
    base64url: "base64url kodlangan satr",
    json_string: "JSON satr",
    e164: "E.164 raqam",
    jwt: "JWT",
    template_literal: "kirish"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "raqam",
    array: "massiv"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Noto\u2018g\u2018ri kirish: kutilgan instanceof ${issue2.expected}, qabul qilingan ${received}`;
        }
        return `Noto\u2018g\u2018ri kirish: kutilgan ${expected}, qabul qilingan ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Noto\u2018g\u2018ri kirish: kutilgan ${stringifyPrimitive(issue2.values[0])}`;
        return `Noto\u2018g\u2018ri variant: quyidagilardan biri kutilgan ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Juda katta: kutilgan ${issue2.origin ?? "qiymat"} ${adj}${issue2.maximum.toString()} ${sizing.unit} ${sizing.verb}`;
        return `Juda katta: kutilgan ${issue2.origin ?? "qiymat"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Juda kichik: kutilgan ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} ${sizing.verb}`;
        }
        return `Juda kichik: kutilgan ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Noto\u2018g\u2018ri satr: "${_issue.prefix}" bilan boshlanishi kerak`;
        if (_issue.format === "ends_with")
          return `Noto\u2018g\u2018ri satr: "${_issue.suffix}" bilan tugashi kerak`;
        if (_issue.format === "includes")
          return `Noto\u2018g\u2018ri satr: "${_issue.includes}" ni o\u2018z ichiga olishi kerak`;
        if (_issue.format === "regex")
          return `Noto\u2018g\u2018ri satr: ${_issue.pattern} shabloniga mos kelishi kerak`;
        return `Noto\u2018g\u2018ri ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Noto\u2018g\u2018ri raqam: ${issue2.divisor} ning karralisi bo\u2018lishi kerak`;
      case "unrecognized_keys":
        return `Noma\u2019lum kalit${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} dagi kalit noto\u2018g\u2018ri`;
      case "invalid_union":
        return "Noto\u2018g\u2018ri kirish";
      case "invalid_element":
        return `${issue2.origin} da noto\u2018g\u2018ri qiymat`;
      default:
        return `Noto\u2018g\u2018ri kirish`;
    }
  };
};
var init_uz = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/vi.js
function vi_default() {
  return {
    localeError: error44()
  };
}
var error44 = () => {
  const Sizable = {
    string: { unit: "k\xFD t\u1EF1", verb: "c\xF3" },
    file: { unit: "byte", verb: "c\xF3" },
    array: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" },
    set: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u0111\u1EA7u v\xE0o",
    email: "\u0111\u1ECBa ch\u1EC9 email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ng\xE0y gi\u1EDD ISO",
    date: "ng\xE0y ISO",
    time: "gi\u1EDD ISO",
    duration: "kho\u1EA3ng th\u1EDDi gian ISO",
    ipv4: "\u0111\u1ECBa ch\u1EC9 IPv4",
    ipv6: "\u0111\u1ECBa ch\u1EC9 IPv6",
    cidrv4: "d\u1EA3i IPv4",
    cidrv6: "d\u1EA3i IPv6",
    base64: "chu\u1ED7i m\xE3 h\xF3a base64",
    base64url: "chu\u1ED7i m\xE3 h\xF3a base64url",
    json_string: "chu\u1ED7i JSON",
    e164: "s\u1ED1 E.164",
    jwt: "JWT",
    template_literal: "\u0111\u1EA7u v\xE0o"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "s\u1ED1",
    array: "m\u1EA3ng"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i instanceof ${issue2.expected}, nh\u1EADn \u0111\u01B0\u1EE3c ${received}`;
        }
        return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${expected}, nh\u1EADn \u0111\u01B0\u1EE3c ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${stringifyPrimitive(issue2.values[0])}`;
        return `T\xF9y ch\u1ECDn kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i m\u1ED9t trong c\xE1c gi\xE1 tr\u1ECB ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue2.origin ?? "gi\xE1 tr\u1ECB"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "ph\u1EA7n t\u1EED"}`;
        return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue2.origin ?? "gi\xE1 tr\u1ECB"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i b\u1EAFt \u0111\u1EA7u b\u1EB1ng "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i k\u1EBFt th\xFAc b\u1EB1ng "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i bao g\u1ED3m "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i kh\u1EDBp v\u1EDBi m\u1EABu ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} kh\xF4ng h\u1EE3p l\u1EC7`;
      }
      case "not_multiple_of":
        return `S\u1ED1 kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i l\xE0 b\u1ED9i s\u1ED1 c\u1EE7a ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kh\xF3a kh\xF4ng \u0111\u01B0\u1EE3c nh\u1EADn d\u1EA1ng: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kh\xF3a kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue2.origin}`;
      case "invalid_union":
        return "\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7";
      case "invalid_element":
        return `Gi\xE1 tr\u1ECB kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue2.origin}`;
      default:
        return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7`;
    }
  };
};
var init_vi = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/zh-CN.js
function zh_CN_default() {
  return {
    localeError: error45()
  };
}
var error45 = () => {
  const Sizable = {
    string: { unit: "\u5B57\u7B26", verb: "\u5305\u542B" },
    file: { unit: "\u5B57\u8282", verb: "\u5305\u542B" },
    array: { unit: "\u9879", verb: "\u5305\u542B" },
    set: { unit: "\u9879", verb: "\u5305\u542B" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u8F93\u5165",
    email: "\u7535\u5B50\u90AE\u4EF6",
    url: "URL",
    emoji: "\u8868\u60C5\u7B26\u53F7",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO\u65E5\u671F\u65F6\u95F4",
    date: "ISO\u65E5\u671F",
    time: "ISO\u65F6\u95F4",
    duration: "ISO\u65F6\u957F",
    ipv4: "IPv4\u5730\u5740",
    ipv6: "IPv6\u5730\u5740",
    cidrv4: "IPv4\u7F51\u6BB5",
    cidrv6: "IPv6\u7F51\u6BB5",
    base64: "base64\u7F16\u7801\u5B57\u7B26\u4E32",
    base64url: "base64url\u7F16\u7801\u5B57\u7B26\u4E32",
    json_string: "JSON\u5B57\u7B26\u4E32",
    e164: "E.164\u53F7\u7801",
    jwt: "JWT",
    template_literal: "\u8F93\u5165"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u6570\u5B57",
    array: "\u6570\u7EC4",
    null: "\u7A7A\u503C(null)"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B instanceof ${issue2.expected}\uFF0C\u5B9E\u9645\u63A5\u6536 ${received}`;
        }
        return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${expected}\uFF0C\u5B9E\u9645\u63A5\u6536 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${stringifyPrimitive(issue2.values[0])}`;
        return `\u65E0\u6548\u9009\u9879\uFF1A\u671F\u671B\u4EE5\u4E0B\u4E4B\u4E00 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue2.origin ?? "\u503C"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u4E2A\u5143\u7D20"}`;
        return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue2.origin ?? "\u503C"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.prefix}" \u5F00\u5934`;
        if (_issue.format === "ends_with")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.suffix}" \u7ED3\u5C3E`;
        if (_issue.format === "includes")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u5305\u542B "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u6EE1\u8DB3\u6B63\u5219\u8868\u8FBE\u5F0F ${_issue.pattern}`;
        return `\u65E0\u6548${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u65E0\u6548\u6570\u5B57\uFF1A\u5FC5\u987B\u662F ${issue2.divisor} \u7684\u500D\u6570`;
      case "unrecognized_keys":
        return `\u51FA\u73B0\u672A\u77E5\u7684\u952E(key): ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} \u4E2D\u7684\u952E(key)\u65E0\u6548`;
      case "invalid_union":
        return "\u65E0\u6548\u8F93\u5165";
      case "invalid_element":
        return `${issue2.origin} \u4E2D\u5305\u542B\u65E0\u6548\u503C(value)`;
      default:
        return `\u65E0\u6548\u8F93\u5165`;
    }
  };
};
var init_zh_CN = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/zh-TW.js
function zh_TW_default() {
  return {
    localeError: error46()
  };
}
var error46 = () => {
  const Sizable = {
    string: { unit: "\u5B57\u5143", verb: "\u64C1\u6709" },
    file: { unit: "\u4F4D\u5143\u7D44", verb: "\u64C1\u6709" },
    array: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" },
    set: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u8F38\u5165",
    email: "\u90F5\u4EF6\u5730\u5740",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u65E5\u671F\u6642\u9593",
    date: "ISO \u65E5\u671F",
    time: "ISO \u6642\u9593",
    duration: "ISO \u671F\u9593",
    ipv4: "IPv4 \u4F4D\u5740",
    ipv6: "IPv6 \u4F4D\u5740",
    cidrv4: "IPv4 \u7BC4\u570D",
    cidrv6: "IPv6 \u7BC4\u570D",
    base64: "base64 \u7DE8\u78BC\u5B57\u4E32",
    base64url: "base64url \u7DE8\u78BC\u5B57\u4E32",
    json_string: "JSON \u5B57\u4E32",
    e164: "E.164 \u6578\u503C",
    jwt: "JWT",
    template_literal: "\u8F38\u5165"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA instanceof ${issue2.expected}\uFF0C\u4F46\u6536\u5230 ${received}`;
        }
        return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${expected}\uFF0C\u4F46\u6536\u5230 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${stringifyPrimitive(issue2.values[0])}`;
        return `\u7121\u6548\u7684\u9078\u9805\uFF1A\u9810\u671F\u70BA\u4EE5\u4E0B\u5176\u4E2D\u4E4B\u4E00 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue2.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u500B\u5143\u7D20"}`;
        return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue2.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue2.origin} \u61C9\u70BA ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue2.origin} \u61C9\u70BA ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.prefix}" \u958B\u982D`;
        }
        if (_issue.format === "ends_with")
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.suffix}" \u7D50\u5C3E`;
        if (_issue.format === "includes")
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u5305\u542B "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u7B26\u5408\u683C\u5F0F ${_issue.pattern}`;
        return `\u7121\u6548\u7684 ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u7121\u6548\u7684\u6578\u5B57\uFF1A\u5FC5\u9808\u70BA ${issue2.divisor} \u7684\u500D\u6578`;
      case "unrecognized_keys":
        return `\u7121\u6CD5\u8B58\u5225\u7684\u9375\u503C${issue2.keys.length > 1 ? "\u5011" : ""}\uFF1A${joinValues(issue2.keys, "\u3001")}`;
      case "invalid_key":
        return `${issue2.origin} \u4E2D\u6709\u7121\u6548\u7684\u9375\u503C`;
      case "invalid_union":
        return "\u7121\u6548\u7684\u8F38\u5165\u503C";
      case "invalid_element":
        return `${issue2.origin} \u4E2D\u6709\u7121\u6548\u7684\u503C`;
      default:
        return `\u7121\u6548\u7684\u8F38\u5165\u503C`;
    }
  };
};
var init_zh_TW = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/yo.js
function yo_default() {
  return {
    localeError: error47()
  };
}
var error47 = () => {
  const Sizable = {
    string: { unit: "\xE0mi", verb: "n\xED" },
    file: { unit: "bytes", verb: "n\xED" },
    array: { unit: "nkan", verb: "n\xED" },
    set: { unit: "nkan", verb: "n\xED" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "\u1EB9\u0300r\u1ECD \xECb\xE1w\u1ECDl\xE9",
    email: "\xE0d\xEDr\u1EB9\u0301s\xEC \xECm\u1EB9\u0301l\xEC",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\xE0k\xF3k\xF2 ISO",
    date: "\u1ECDj\u1ECD\u0301 ISO",
    time: "\xE0k\xF3k\xF2 ISO",
    duration: "\xE0k\xF3k\xF2 t\xF3 p\xE9 ISO",
    ipv4: "\xE0d\xEDr\u1EB9\u0301s\xEC IPv4",
    ipv6: "\xE0d\xEDr\u1EB9\u0301s\xEC IPv6",
    cidrv4: "\xE0gb\xE8gb\xE8 IPv4",
    cidrv6: "\xE0gb\xE8gb\xE8 IPv6",
    base64: "\u1ECD\u0300r\u1ECD\u0300 t\xED a k\u1ECD\u0301 n\xED base64",
    base64url: "\u1ECD\u0300r\u1ECD\u0300 base64url",
    json_string: "\u1ECD\u0300r\u1ECD\u0300 JSON",
    e164: "n\u1ECD\u0301mb\xE0 E.164",
    jwt: "JWT",
    template_literal: "\u1EB9\u0300r\u1ECD \xECb\xE1w\u1ECDl\xE9"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "n\u1ECD\u0301mb\xE0",
    array: "akop\u1ECD"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi instanceof ${issue2.expected}, \xE0m\u1ECD\u0300 a r\xED ${received}`;
        }
        return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi ${expected}, \xE0m\u1ECD\u0300 a r\xED ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi ${stringifyPrimitive(issue2.values[0])}`;
        return `\xC0\u1E63\xE0y\xE0n a\u1E63\xEC\u1E63e: yan \u1ECD\u0300kan l\xE1ra ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `T\xF3 p\u1ECD\u0300 j\xF9: a n\xED l\xE1ti j\u1EB9\u0301 p\xE9 ${issue2.origin ?? "iye"} ${sizing.verb} ${adj}${issue2.maximum} ${sizing.unit}`;
        return `T\xF3 p\u1ECD\u0300 j\xF9: a n\xED l\xE1ti j\u1EB9\u0301 ${adj}${issue2.maximum}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `K\xE9r\xE9 ju: a n\xED l\xE1ti j\u1EB9\u0301 p\xE9 ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum} ${sizing.unit}`;
        return `K\xE9r\xE9 ju: a n\xED l\xE1ti j\u1EB9\u0301 ${adj}${issue2.minimum}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 b\u1EB9\u0300r\u1EB9\u0300 p\u1EB9\u0300l\xFA "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 par\xED p\u1EB9\u0300l\xFA "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 n\xED "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 b\xE1 \xE0p\u1EB9\u1EB9r\u1EB9 mu ${_issue.pattern}`;
        return `A\u1E63\xEC\u1E63e: ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `N\u1ECD\u0301mb\xE0 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 j\u1EB9\u0301 \xE8y\xE0 p\xEDp\xEDn ti ${issue2.divisor}`;
      case "unrecognized_keys":
        return `B\u1ECDt\xECn\xEC \xE0\xECm\u1ECD\u0300: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `B\u1ECDt\xECn\xEC a\u1E63\xEC\u1E63e n\xEDn\xFA ${issue2.origin}`;
      case "invalid_union":
        return "\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e";
      case "invalid_element":
        return `Iye a\u1E63\xEC\u1E63e n\xEDn\xFA ${issue2.origin}`;
      default:
        return "\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e";
    }
  };
};
var init_yo = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/index.js
var exports_locales = {};
__export(exports_locales, {
  zhTW: () => zh_TW_default,
  zhCN: () => zh_CN_default,
  yo: () => yo_default,
  vi: () => vi_default,
  uz: () => uz_default,
  ur: () => ur_default,
  uk: () => uk_default,
  ua: () => ua_default,
  tr: () => tr_default,
  th: () => th_default,
  ta: () => ta_default,
  sv: () => sv_default,
  sl: () => sl_default,
  ru: () => ru_default,
  pt: () => pt_default,
  ps: () => ps_default,
  pl: () => pl_default,
  ota: () => ota_default,
  no: () => no_default,
  nl: () => nl_default,
  ms: () => ms_default,
  mk: () => mk_default,
  lt: () => lt_default,
  ko: () => ko_default,
  km: () => km_default,
  kh: () => kh_default,
  ka: () => ka_default,
  ja: () => ja_default,
  it: () => it_default,
  is: () => is_default,
  id: () => id_default,
  hy: () => hy_default,
  hu: () => hu_default,
  he: () => he_default,
  frCA: () => fr_CA_default,
  fr: () => fr_default,
  fi: () => fi_default,
  fa: () => fa_default,
  es: () => es_default,
  eo: () => eo_default,
  en: () => en_default,
  de: () => de_default,
  da: () => da_default,
  cs: () => cs_default,
  ca: () => ca_default,
  bg: () => bg_default,
  be: () => be_default,
  az: () => az_default,
  ar: () => ar_default
});
var init_locales = __esm(() => {
  init_ar();
  init_az();
  init_be();
  init_bg();
  init_ca();
  init_cs();
  init_da();
  init_de();
  init_en();
  init_eo();
  init_es();
  init_fa();
  init_fi();
  init_fr();
  init_fr_CA();
  init_he();
  init_hu();
  init_hy();
  init_id();
  init_is();
  init_it();
  init_ja();
  init_ka();
  init_kh();
  init_km();
  init_ko();
  init_lt();
  init_mk();
  init_ms();
  init_nl();
  init_no();
  init_ota();
  init_ps();
  init_pl();
  init_pt();
  init_ru();
  init_sl();
  init_sv();
  init_ta();
  init_th();
  init_tr();
  init_ua();
  init_uk();
  init_ur();
  init_uz();
  init_vi();
  init_zh_CN();
  init_zh_TW();
  init_yo();
});

// node_modules/zod/v4/core/registries.js
class $ZodRegistry {
  constructor() {
    this._map = new WeakMap;
    this._idmap = new Map;
  }
  add(schema, ..._meta) {
    const meta = _meta[0];
    this._map.set(schema, meta);
    if (meta && typeof meta === "object" && "id" in meta) {
      this._idmap.set(meta.id, schema);
    }
    return this;
  }
  clear() {
    this._map = new WeakMap;
    this._idmap = new Map;
    return this;
  }
  remove(schema) {
    const meta = this._map.get(schema);
    if (meta && typeof meta === "object" && "id" in meta) {
      this._idmap.delete(meta.id);
    }
    this._map.delete(schema);
    return this;
  }
  get(schema) {
    const p = schema._zod.parent;
    if (p) {
      const pm = { ...this.get(p) ?? {} };
      delete pm.id;
      const f = { ...pm, ...this._map.get(schema) };
      return Object.keys(f).length ? f : undefined;
    }
    return this._map.get(schema);
  }
  has(schema) {
    return this._map.has(schema);
  }
}
function registry() {
  return new $ZodRegistry;
}
var _a, $output, $input, globalRegistry;
var init_registries = __esm(() => {
  $output = Symbol("ZodOutput");
  $input = Symbol("ZodInput");
  (_a = globalThis).__zod_globalRegistry ?? (_a.__zod_globalRegistry = registry());
  globalRegistry = globalThis.__zod_globalRegistry;
});

// node_modules/zod/v4/core/api.js
function _string(Class2, params) {
  return new Class2({
    type: "string",
    ...normalizeParams(params)
  });
}
function _coercedString(Class2, params) {
  return new Class2({
    type: "string",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _email(Class2, params) {
  return new Class2({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _guid(Class2, params) {
  return new Class2({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuidv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...normalizeParams(params)
  });
}
function _uuidv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...normalizeParams(params)
  });
}
function _uuidv7(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...normalizeParams(params)
  });
}
function _url(Class2, params) {
  return new Class2({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _emoji2(Class2, params) {
  return new Class2({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _nanoid(Class2, params) {
  return new Class2({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid2(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ulid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _xid(Class2, params) {
  return new Class2({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ksuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _mac(Class2, params) {
  return new Class2({
    type: "string",
    format: "mac",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64url(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _e164(Class2, params) {
  return new Class2({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _jwt(Class2, params) {
  return new Class2({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _isoDateTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDate(Class2, params) {
  return new Class2({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _isoTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDuration(Class2, params) {
  return new Class2({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _number(Class2, params) {
  return new Class2({
    type: "number",
    checks: [],
    ...normalizeParams(params)
  });
}
function _coercedNumber(Class2, params) {
  return new Class2({
    type: "number",
    coerce: true,
    checks: [],
    ...normalizeParams(params)
  });
}
function _int(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "safeint",
    ...normalizeParams(params)
  });
}
function _float32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float32",
    ...normalizeParams(params)
  });
}
function _float64(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float64",
    ...normalizeParams(params)
  });
}
function _int32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "int32",
    ...normalizeParams(params)
  });
}
function _uint32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "uint32",
    ...normalizeParams(params)
  });
}
function _boolean(Class2, params) {
  return new Class2({
    type: "boolean",
    ...normalizeParams(params)
  });
}
function _coercedBoolean(Class2, params) {
  return new Class2({
    type: "boolean",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _bigint(Class2, params) {
  return new Class2({
    type: "bigint",
    ...normalizeParams(params)
  });
}
function _coercedBigint(Class2, params) {
  return new Class2({
    type: "bigint",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _int64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "int64",
    ...normalizeParams(params)
  });
}
function _uint64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "uint64",
    ...normalizeParams(params)
  });
}
function _symbol(Class2, params) {
  return new Class2({
    type: "symbol",
    ...normalizeParams(params)
  });
}
function _undefined2(Class2, params) {
  return new Class2({
    type: "undefined",
    ...normalizeParams(params)
  });
}
function _null2(Class2, params) {
  return new Class2({
    type: "null",
    ...normalizeParams(params)
  });
}
function _any(Class2) {
  return new Class2({
    type: "any"
  });
}
function _unknown(Class2) {
  return new Class2({
    type: "unknown"
  });
}
function _never(Class2, params) {
  return new Class2({
    type: "never",
    ...normalizeParams(params)
  });
}
function _void(Class2, params) {
  return new Class2({
    type: "void",
    ...normalizeParams(params)
  });
}
function _date(Class2, params) {
  return new Class2({
    type: "date",
    ...normalizeParams(params)
  });
}
function _coercedDate(Class2, params) {
  return new Class2({
    type: "date",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _nan(Class2, params) {
  return new Class2({
    type: "nan",
    ...normalizeParams(params)
  });
}
function _lt(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _lte(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _gt(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _gte(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _positive(params) {
  return _gt(0, params);
}
function _negative(params) {
  return _lt(0, params);
}
function _nonpositive(params) {
  return _lte(0, params);
}
function _nonnegative(params) {
  return _gte(0, params);
}
function _multipleOf(value, params) {
  return new $ZodCheckMultipleOf({
    check: "multiple_of",
    ...normalizeParams(params),
    value
  });
}
function _maxSize(maximum, params) {
  return new $ZodCheckMaxSize({
    check: "max_size",
    ...normalizeParams(params),
    maximum
  });
}
function _minSize(minimum, params) {
  return new $ZodCheckMinSize({
    check: "min_size",
    ...normalizeParams(params),
    minimum
  });
}
function _size(size, params) {
  return new $ZodCheckSizeEquals({
    check: "size_equals",
    ...normalizeParams(params),
    size
  });
}
function _maxLength(maximum, params) {
  const ch = new $ZodCheckMaxLength({
    check: "max_length",
    ...normalizeParams(params),
    maximum
  });
  return ch;
}
function _minLength(minimum, params) {
  return new $ZodCheckMinLength({
    check: "min_length",
    ...normalizeParams(params),
    minimum
  });
}
function _length(length, params) {
  return new $ZodCheckLengthEquals({
    check: "length_equals",
    ...normalizeParams(params),
    length
  });
}
function _regex(pattern, params) {
  return new $ZodCheckRegex({
    check: "string_format",
    format: "regex",
    ...normalizeParams(params),
    pattern
  });
}
function _lowercase(params) {
  return new $ZodCheckLowerCase({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams(params)
  });
}
function _uppercase(params) {
  return new $ZodCheckUpperCase({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams(params)
  });
}
function _includes(includes, params) {
  return new $ZodCheckIncludes({
    check: "string_format",
    format: "includes",
    ...normalizeParams(params),
    includes
  });
}
function _startsWith(prefix, params) {
  return new $ZodCheckStartsWith({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams(params),
    prefix
  });
}
function _endsWith(suffix, params) {
  return new $ZodCheckEndsWith({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams(params),
    suffix
  });
}
function _property(property, schema, params) {
  return new $ZodCheckProperty({
    check: "property",
    property,
    schema,
    ...normalizeParams(params)
  });
}
function _mime(types, params) {
  return new $ZodCheckMimeType({
    check: "mime_type",
    mime: types,
    ...normalizeParams(params)
  });
}
function _overwrite(tx) {
  return new $ZodCheckOverwrite({
    check: "overwrite",
    tx
  });
}
function _normalize(form) {
  return _overwrite((input) => input.normalize(form));
}
function _trim() {
  return _overwrite((input) => input.trim());
}
function _toLowerCase() {
  return _overwrite((input) => input.toLowerCase());
}
function _toUpperCase() {
  return _overwrite((input) => input.toUpperCase());
}
function _slugify() {
  return _overwrite((input) => slugify(input));
}
function _array(Class2, element, params) {
  return new Class2({
    type: "array",
    element,
    ...normalizeParams(params)
  });
}
function _union(Class2, options2, params) {
  return new Class2({
    type: "union",
    options: options2,
    ...normalizeParams(params)
  });
}
function _xor(Class2, options2, params) {
  return new Class2({
    type: "union",
    options: options2,
    inclusive: false,
    ...normalizeParams(params)
  });
}
function _discriminatedUnion(Class2, discriminator, options2, params) {
  return new Class2({
    type: "union",
    options: options2,
    discriminator,
    ...normalizeParams(params)
  });
}
function _intersection(Class2, left, right) {
  return new Class2({
    type: "intersection",
    left,
    right
  });
}
function _tuple(Class2, items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new Class2({
    type: "tuple",
    items,
    rest,
    ...normalizeParams(params)
  });
}
function _record(Class2, keyType, valueType, params) {
  return new Class2({
    type: "record",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
function _map(Class2, keyType, valueType, params) {
  return new Class2({
    type: "map",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
function _set(Class2, valueType, params) {
  return new Class2({
    type: "set",
    valueType,
    ...normalizeParams(params)
  });
}
function _enum(Class2, values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
function _nativeEnum(Class2, entries, params) {
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
function _literal(Class2, value, params) {
  return new Class2({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...normalizeParams(params)
  });
}
function _file(Class2, params) {
  return new Class2({
    type: "file",
    ...normalizeParams(params)
  });
}
function _transform(Class2, fn) {
  return new Class2({
    type: "transform",
    transform: fn
  });
}
function _optional(Class2, innerType) {
  return new Class2({
    type: "optional",
    innerType
  });
}
function _nullable(Class2, innerType) {
  return new Class2({
    type: "nullable",
    innerType
  });
}
function _default(Class2, innerType, defaultValue) {
  return new Class2({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
    }
  });
}
function _nonoptional(Class2, innerType, params) {
  return new Class2({
    type: "nonoptional",
    innerType,
    ...normalizeParams(params)
  });
}
function _success(Class2, innerType) {
  return new Class2({
    type: "success",
    innerType
  });
}
function _catch(Class2, innerType, catchValue) {
  return new Class2({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
function _pipe(Class2, in_, out) {
  return new Class2({
    type: "pipe",
    in: in_,
    out
  });
}
function _readonly(Class2, innerType) {
  return new Class2({
    type: "readonly",
    innerType
  });
}
function _templateLiteral(Class2, parts, params) {
  return new Class2({
    type: "template_literal",
    parts,
    ...normalizeParams(params)
  });
}
function _lazy(Class2, getter) {
  return new Class2({
    type: "lazy",
    getter
  });
}
function _promise(Class2, innerType) {
  return new Class2({
    type: "promise",
    innerType
  });
}
function _custom(Class2, fn, _params) {
  const norm = normalizeParams(_params);
  norm.abort ?? (norm.abort = true);
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...norm
  });
  return schema;
}
function _refine(Class2, fn, _params) {
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...normalizeParams(_params)
  });
  return schema;
}
function _superRefine(fn) {
  const ch = _check((payload) => {
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(issue(issue2, payload.value, ch._zod.def));
      } else {
        const _issue = issue2;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = ch);
        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
        payload.issues.push(issue(_issue));
      }
    };
    return fn(payload.value, payload);
  });
  return ch;
}
function _check(fn, params) {
  const ch = new $ZodCheck({
    check: "custom",
    ...normalizeParams(params)
  });
  ch._zod.check = fn;
  return ch;
}
function describe(description) {
  const ch = new $ZodCheck({ check: "describe" });
  ch._zod.onattach = [
    (inst) => {
      const existing = globalRegistry.get(inst) ?? {};
      globalRegistry.add(inst, { ...existing, description });
    }
  ];
  ch._zod.check = () => {};
  return ch;
}
function meta(metadata) {
  const ch = new $ZodCheck({ check: "meta" });
  ch._zod.onattach = [
    (inst) => {
      const existing = globalRegistry.get(inst) ?? {};
      globalRegistry.add(inst, { ...existing, ...metadata });
    }
  ];
  ch._zod.check = () => {};
  return ch;
}
function _stringbool(Classes, _params) {
  const params = normalizeParams(_params);
  let truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"];
  let falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  if (params.case !== "sensitive") {
    truthyArray = truthyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
    falsyArray = falsyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
  }
  const truthySet = new Set(truthyArray);
  const falsySet = new Set(falsyArray);
  const _Codec = Classes.Codec ?? $ZodCodec;
  const _Boolean = Classes.Boolean ?? $ZodBoolean;
  const _String = Classes.String ?? $ZodString;
  const stringSchema = new _String({ type: "string", error: params.error });
  const booleanSchema = new _Boolean({ type: "boolean", error: params.error });
  const codec = new _Codec({
    type: "pipe",
    in: stringSchema,
    out: booleanSchema,
    transform: (input, payload) => {
      let data = input;
      if (params.case !== "sensitive")
        data = data.toLowerCase();
      if (truthySet.has(data)) {
        return true;
      } else if (falsySet.has(data)) {
        return false;
      } else {
        payload.issues.push({
          code: "invalid_value",
          expected: "stringbool",
          values: [...truthySet, ...falsySet],
          input: payload.value,
          inst: codec,
          continue: false
        });
        return {};
      }
    },
    reverseTransform: (input, _payload) => {
      if (input === true) {
        return truthyArray[0] || "true";
      } else {
        return falsyArray[0] || "false";
      }
    },
    error: params.error
  });
  return codec;
}
function _stringFormat(Class2, format, fnOrRegex, _params = {}) {
  const params = normalizeParams(_params);
  const def = {
    ...normalizeParams(_params),
    check: "string_format",
    type: "string",
    format,
    fn: typeof fnOrRegex === "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
    ...params
  };
  if (fnOrRegex instanceof RegExp) {
    def.pattern = fnOrRegex;
  }
  const inst = new Class2(def);
  return inst;
}
var TimePrecision;
var init_api = __esm(() => {
  init_checks();
  init_registries();
  init_schemas();
  init_util();
  TimePrecision = {
    Any: null,
    Minute: -1,
    Second: 0,
    Millisecond: 3,
    Microsecond: 6
  };
});

// node_modules/zod/v4/core/to-json-schema.js
function initializeContext(params) {
  let target = params?.target ?? "draft-2020-12";
  if (target === "draft-4")
    target = "draft-04";
  if (target === "draft-7")
    target = "draft-07";
  return {
    processors: params.processors ?? {},
    metadataRegistry: params?.metadata ?? globalRegistry,
    target,
    unrepresentable: params?.unrepresentable ?? "throw",
    override: params?.override ?? (() => {}),
    io: params?.io ?? "output",
    counter: 0,
    seen: new Map,
    cycles: params?.cycles ?? "ref",
    reused: params?.reused ?? "inline",
    external: params?.external ?? undefined
  };
}
function process2(schema, ctx, _params = { path: [], schemaPath: [] }) {
  var _a2;
  const def = schema._zod.def;
  const seen = ctx.seen.get(schema);
  if (seen) {
    seen.count++;
    const isCycle = _params.schemaPath.includes(schema);
    if (isCycle) {
      seen.cycle = _params.path;
    }
    return seen.schema;
  }
  const result = { schema: {}, count: 1, cycle: undefined, path: _params.path };
  ctx.seen.set(schema, result);
  const overrideSchema = schema._zod.toJSONSchema?.();
  if (overrideSchema) {
    result.schema = overrideSchema;
  } else {
    const params = {
      ..._params,
      schemaPath: [..._params.schemaPath, schema],
      path: _params.path
    };
    if (schema._zod.processJSONSchema) {
      schema._zod.processJSONSchema(ctx, result.schema, params);
    } else {
      const _json = result.schema;
      const processor = ctx.processors[def.type];
      if (!processor) {
        throw new Error(`[toJSONSchema]: Non-representable type encountered: ${def.type}`);
      }
      processor(schema, ctx, _json, params);
    }
    const parent = schema._zod.parent;
    if (parent) {
      if (!result.ref)
        result.ref = parent;
      process2(parent, ctx, params);
      ctx.seen.get(parent).isParent = true;
    }
  }
  const meta2 = ctx.metadataRegistry.get(schema);
  if (meta2)
    Object.assign(result.schema, meta2);
  if (ctx.io === "input" && isTransforming(schema)) {
    delete result.schema.examples;
    delete result.schema.default;
  }
  if (ctx.io === "input" && result.schema._prefault)
    (_a2 = result.schema).default ?? (_a2.default = result.schema._prefault);
  delete result.schema._prefault;
  const _result = ctx.seen.get(schema);
  return _result.schema;
}
function extractDefs(ctx, schema) {
  const root = ctx.seen.get(schema);
  if (!root)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  const idToSchema = new Map;
  for (const entry of ctx.seen.entries()) {
    const id = ctx.metadataRegistry.get(entry[0])?.id;
    if (id) {
      const existing = idToSchema.get(id);
      if (existing && existing !== entry[0]) {
        throw new Error(`Duplicate schema id "${id}" detected during JSON Schema conversion. Two different schemas cannot share the same id when converted together.`);
      }
      idToSchema.set(id, entry[0]);
    }
  }
  const makeURI = (entry) => {
    const defsSegment = ctx.target === "draft-2020-12" ? "$defs" : "definitions";
    if (ctx.external) {
      const externalId = ctx.external.registry.get(entry[0])?.id;
      const uriGenerator = ctx.external.uri ?? ((id2) => id2);
      if (externalId) {
        return { ref: uriGenerator(externalId) };
      }
      const id = entry[1].defId ?? entry[1].schema.id ?? `schema${ctx.counter++}`;
      entry[1].defId = id;
      return { defId: id, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}` };
    }
    if (entry[1] === root) {
      return { ref: "#" };
    }
    const uriPrefix = `#`;
    const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
    const defId = entry[1].schema.id ?? `__schema${ctx.counter++}`;
    return { defId, ref: defUriPrefix + defId };
  };
  const extractToDef = (entry) => {
    if (entry[1].schema.$ref) {
      return;
    }
    const seen = entry[1];
    const { ref, defId } = makeURI(entry);
    seen.def = { ...seen.schema };
    if (defId)
      seen.defId = defId;
    const schema2 = seen.schema;
    for (const key in schema2) {
      delete schema2[key];
    }
    schema2.$ref = ref;
  };
  if (ctx.cycles === "throw") {
    for (const entry of ctx.seen.entries()) {
      const seen = entry[1];
      if (seen.cycle) {
        throw new Error("Cycle detected: " + `#/${seen.cycle?.join("/")}/<root>` + '\n\nSet the `cycles` parameter to `"ref"` to resolve cyclical schemas with defs.');
      }
    }
  }
  for (const entry of ctx.seen.entries()) {
    const seen = entry[1];
    if (schema === entry[0]) {
      extractToDef(entry);
      continue;
    }
    if (ctx.external) {
      const ext = ctx.external.registry.get(entry[0])?.id;
      if (schema !== entry[0] && ext) {
        extractToDef(entry);
        continue;
      }
    }
    const id = ctx.metadataRegistry.get(entry[0])?.id;
    if (id) {
      extractToDef(entry);
      continue;
    }
    if (seen.cycle) {
      extractToDef(entry);
      continue;
    }
    if (seen.count > 1) {
      if (ctx.reused === "ref") {
        extractToDef(entry);
        continue;
      }
    }
  }
}
function finalize(ctx, schema) {
  const root = ctx.seen.get(schema);
  if (!root)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  const flattenRef = (zodSchema) => {
    const seen = ctx.seen.get(zodSchema);
    if (seen.ref === null)
      return;
    const schema2 = seen.def ?? seen.schema;
    const _cached = { ...schema2 };
    const ref = seen.ref;
    seen.ref = null;
    if (ref) {
      flattenRef(ref);
      const refSeen = ctx.seen.get(ref);
      const refSchema = refSeen.schema;
      if (refSchema.$ref && (ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0")) {
        schema2.allOf = schema2.allOf ?? [];
        schema2.allOf.push(refSchema);
      } else {
        Object.assign(schema2, refSchema);
      }
      Object.assign(schema2, _cached);
      const isParentRef = zodSchema._zod.parent === ref;
      if (isParentRef) {
        for (const key in schema2) {
          if (key === "$ref" || key === "allOf")
            continue;
          if (!(key in _cached)) {
            delete schema2[key];
          }
        }
      }
      if (refSchema.$ref) {
        for (const key in schema2) {
          if (key === "$ref" || key === "allOf")
            continue;
          if (key in refSeen.def && JSON.stringify(schema2[key]) === JSON.stringify(refSeen.def[key])) {
            delete schema2[key];
          }
        }
      }
    }
    const parent = zodSchema._zod.parent;
    if (parent && parent !== ref) {
      flattenRef(parent);
      const parentSeen = ctx.seen.get(parent);
      if (parentSeen?.schema.$ref) {
        schema2.$ref = parentSeen.schema.$ref;
        if (parentSeen.def) {
          for (const key in schema2) {
            if (key === "$ref" || key === "allOf")
              continue;
            if (key in parentSeen.def && JSON.stringify(schema2[key]) === JSON.stringify(parentSeen.def[key])) {
              delete schema2[key];
            }
          }
        }
      }
    }
    ctx.override({
      zodSchema,
      jsonSchema: schema2,
      path: seen.path ?? []
    });
  };
  for (const entry of [...ctx.seen.entries()].reverse()) {
    flattenRef(entry[0]);
  }
  const result = {};
  if (ctx.target === "draft-2020-12") {
    result.$schema = "https://json-schema.org/draft/2020-12/schema";
  } else if (ctx.target === "draft-07") {
    result.$schema = "http://json-schema.org/draft-07/schema#";
  } else if (ctx.target === "draft-04") {
    result.$schema = "http://json-schema.org/draft-04/schema#";
  } else if (ctx.target === "openapi-3.0") {} else {}
  if (ctx.external?.uri) {
    const id = ctx.external.registry.get(schema)?.id;
    if (!id)
      throw new Error("Schema is missing an `id` property");
    result.$id = ctx.external.uri(id);
  }
  Object.assign(result, root.def ?? root.schema);
  const defs = ctx.external?.defs ?? {};
  for (const entry of ctx.seen.entries()) {
    const seen = entry[1];
    if (seen.def && seen.defId) {
      defs[seen.defId] = seen.def;
    }
  }
  if (ctx.external) {} else {
    if (Object.keys(defs).length > 0) {
      if (ctx.target === "draft-2020-12") {
        result.$defs = defs;
      } else {
        result.definitions = defs;
      }
    }
  }
  try {
    const finalized = JSON.parse(JSON.stringify(result));
    Object.defineProperty(finalized, "~standard", {
      value: {
        ...schema["~standard"],
        jsonSchema: {
          input: createStandardJSONSchemaMethod(schema, "input", ctx.processors),
          output: createStandardJSONSchemaMethod(schema, "output", ctx.processors)
        }
      },
      enumerable: false,
      writable: false
    });
    return finalized;
  } catch (_err) {
    throw new Error("Error converting schema to JSON.");
  }
}
function isTransforming(_schema, _ctx) {
  const ctx = _ctx ?? { seen: new Set };
  if (ctx.seen.has(_schema))
    return false;
  ctx.seen.add(_schema);
  const def = _schema._zod.def;
  if (def.type === "transform")
    return true;
  if (def.type === "array")
    return isTransforming(def.element, ctx);
  if (def.type === "set")
    return isTransforming(def.valueType, ctx);
  if (def.type === "lazy")
    return isTransforming(def.getter(), ctx);
  if (def.type === "promise" || def.type === "optional" || def.type === "nonoptional" || def.type === "nullable" || def.type === "readonly" || def.type === "default" || def.type === "prefault") {
    return isTransforming(def.innerType, ctx);
  }
  if (def.type === "intersection") {
    return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
  }
  if (def.type === "record" || def.type === "map") {
    return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
  }
  if (def.type === "pipe") {
    return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
  }
  if (def.type === "object") {
    for (const key in def.shape) {
      if (isTransforming(def.shape[key], ctx))
        return true;
    }
    return false;
  }
  if (def.type === "union") {
    for (const option of def.options) {
      if (isTransforming(option, ctx))
        return true;
    }
    return false;
  }
  if (def.type === "tuple") {
    for (const item of def.items) {
      if (isTransforming(item, ctx))
        return true;
    }
    if (def.rest && isTransforming(def.rest, ctx))
      return true;
    return false;
  }
  return false;
}
var createToJSONSchemaMethod = (schema, processors = {}) => (params) => {
  const ctx = initializeContext({ ...params, processors });
  process2(schema, ctx);
  extractDefs(ctx, schema);
  return finalize(ctx, schema);
}, createStandardJSONSchemaMethod = (schema, io, processors = {}) => (params) => {
  const { libraryOptions, target } = params ?? {};
  const ctx = initializeContext({ ...libraryOptions ?? {}, target, io, processors });
  process2(schema, ctx);
  extractDefs(ctx, schema);
  return finalize(ctx, schema);
};
var init_to_json_schema = __esm(() => {
  init_registries();
});

// node_modules/zod/v4/core/json-schema-processors.js
function toJSONSchema(input, params) {
  if ("_idmap" in input) {
    const registry2 = input;
    const ctx2 = initializeContext({ ...params, processors: allProcessors });
    const defs = {};
    for (const entry of registry2._idmap.entries()) {
      const [_, schema] = entry;
      process2(schema, ctx2);
    }
    const schemas = {};
    const external = {
      registry: registry2,
      uri: params?.uri,
      defs
    };
    ctx2.external = external;
    for (const entry of registry2._idmap.entries()) {
      const [key, schema] = entry;
      extractDefs(ctx2, schema);
      schemas[key] = finalize(ctx2, schema);
    }
    if (Object.keys(defs).length > 0) {
      const defsSegment = ctx2.target === "draft-2020-12" ? "$defs" : "definitions";
      schemas.__shared = {
        [defsSegment]: defs
      };
    }
    return { schemas };
  }
  const ctx = initializeContext({ ...params, processors: allProcessors });
  process2(input, ctx);
  extractDefs(ctx, input);
  return finalize(ctx, input);
}
var formatMap, stringProcessor = (schema, ctx, _json, _params) => {
  const json = _json;
  json.type = "string";
  const { minimum, maximum, format, patterns, contentEncoding } = schema._zod.bag;
  if (typeof minimum === "number")
    json.minLength = minimum;
  if (typeof maximum === "number")
    json.maxLength = maximum;
  if (format) {
    json.format = formatMap[format] ?? format;
    if (json.format === "")
      delete json.format;
    if (format === "time") {
      delete json.format;
    }
  }
  if (contentEncoding)
    json.contentEncoding = contentEncoding;
  if (patterns && patterns.size > 0) {
    const regexes = [...patterns];
    if (regexes.length === 1)
      json.pattern = regexes[0].source;
    else if (regexes.length > 1) {
      json.allOf = [
        ...regexes.map((regex) => ({
          ...ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0" ? { type: "string" } : {},
          pattern: regex.source
        }))
      ];
    }
  }
}, numberProcessor = (schema, ctx, _json, _params) => {
  const json = _json;
  const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
  if (typeof format === "string" && format.includes("int"))
    json.type = "integer";
  else
    json.type = "number";
  if (typeof exclusiveMinimum === "number") {
    if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
      json.minimum = exclusiveMinimum;
      json.exclusiveMinimum = true;
    } else {
      json.exclusiveMinimum = exclusiveMinimum;
    }
  }
  if (typeof minimum === "number") {
    json.minimum = minimum;
    if (typeof exclusiveMinimum === "number" && ctx.target !== "draft-04") {
      if (exclusiveMinimum >= minimum)
        delete json.minimum;
      else
        delete json.exclusiveMinimum;
    }
  }
  if (typeof exclusiveMaximum === "number") {
    if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
      json.maximum = exclusiveMaximum;
      json.exclusiveMaximum = true;
    } else {
      json.exclusiveMaximum = exclusiveMaximum;
    }
  }
  if (typeof maximum === "number") {
    json.maximum = maximum;
    if (typeof exclusiveMaximum === "number" && ctx.target !== "draft-04") {
      if (exclusiveMaximum <= maximum)
        delete json.maximum;
      else
        delete json.exclusiveMaximum;
    }
  }
  if (typeof multipleOf === "number")
    json.multipleOf = multipleOf;
}, booleanProcessor = (_schema, _ctx, json, _params) => {
  json.type = "boolean";
}, bigintProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("BigInt cannot be represented in JSON Schema");
  }
}, symbolProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Symbols cannot be represented in JSON Schema");
  }
}, nullProcessor = (_schema, ctx, json, _params) => {
  if (ctx.target === "openapi-3.0") {
    json.type = "string";
    json.nullable = true;
    json.enum = [null];
  } else {
    json.type = "null";
  }
}, undefinedProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Undefined cannot be represented in JSON Schema");
  }
}, voidProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Void cannot be represented in JSON Schema");
  }
}, neverProcessor = (_schema, _ctx, json, _params) => {
  json.not = {};
}, anyProcessor = (_schema, _ctx, _json, _params) => {}, unknownProcessor = (_schema, _ctx, _json, _params) => {}, dateProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Date cannot be represented in JSON Schema");
  }
}, enumProcessor = (schema, _ctx, json, _params) => {
  const def = schema._zod.def;
  const values = getEnumValues(def.entries);
  if (values.every((v) => typeof v === "number"))
    json.type = "number";
  if (values.every((v) => typeof v === "string"))
    json.type = "string";
  json.enum = values;
}, literalProcessor = (schema, ctx, json, _params) => {
  const def = schema._zod.def;
  const vals = [];
  for (const val of def.values) {
    if (val === undefined) {
      if (ctx.unrepresentable === "throw") {
        throw new Error("Literal `undefined` cannot be represented in JSON Schema");
      } else {}
    } else if (typeof val === "bigint") {
      if (ctx.unrepresentable === "throw") {
        throw new Error("BigInt literals cannot be represented in JSON Schema");
      } else {
        vals.push(Number(val));
      }
    } else {
      vals.push(val);
    }
  }
  if (vals.length === 0) {} else if (vals.length === 1) {
    const val = vals[0];
    json.type = val === null ? "null" : typeof val;
    if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
      json.enum = [val];
    } else {
      json.const = val;
    }
  } else {
    if (vals.every((v) => typeof v === "number"))
      json.type = "number";
    if (vals.every((v) => typeof v === "string"))
      json.type = "string";
    if (vals.every((v) => typeof v === "boolean"))
      json.type = "boolean";
    if (vals.every((v) => v === null))
      json.type = "null";
    json.enum = vals;
  }
}, nanProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("NaN cannot be represented in JSON Schema");
  }
}, templateLiteralProcessor = (schema, _ctx, json, _params) => {
  const _json = json;
  const pattern = schema._zod.pattern;
  if (!pattern)
    throw new Error("Pattern not found in template literal");
  _json.type = "string";
  _json.pattern = pattern.source;
}, fileProcessor = (schema, _ctx, json, _params) => {
  const _json = json;
  const file = {
    type: "string",
    format: "binary",
    contentEncoding: "binary"
  };
  const { minimum, maximum, mime } = schema._zod.bag;
  if (minimum !== undefined)
    file.minLength = minimum;
  if (maximum !== undefined)
    file.maxLength = maximum;
  if (mime) {
    if (mime.length === 1) {
      file.contentMediaType = mime[0];
      Object.assign(_json, file);
    } else {
      Object.assign(_json, file);
      _json.anyOf = mime.map((m) => ({ contentMediaType: m }));
    }
  } else {
    Object.assign(_json, file);
  }
}, successProcessor = (_schema, _ctx, json, _params) => {
  json.type = "boolean";
}, customProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Custom types cannot be represented in JSON Schema");
  }
}, functionProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Function types cannot be represented in JSON Schema");
  }
}, transformProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Transforms cannot be represented in JSON Schema");
  }
}, mapProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Map cannot be represented in JSON Schema");
  }
}, setProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Set cannot be represented in JSON Schema");
  }
}, arrayProcessor = (schema, ctx, _json, params) => {
  const json = _json;
  const def = schema._zod.def;
  const { minimum, maximum } = schema._zod.bag;
  if (typeof minimum === "number")
    json.minItems = minimum;
  if (typeof maximum === "number")
    json.maxItems = maximum;
  json.type = "array";
  json.items = process2(def.element, ctx, { ...params, path: [...params.path, "items"] });
}, objectProcessor = (schema, ctx, _json, params) => {
  const json = _json;
  const def = schema._zod.def;
  json.type = "object";
  json.properties = {};
  const shape = def.shape;
  for (const key in shape) {
    json.properties[key] = process2(shape[key], ctx, {
      ...params,
      path: [...params.path, "properties", key]
    });
  }
  const allKeys = new Set(Object.keys(shape));
  const requiredKeys = new Set([...allKeys].filter((key) => {
    const v = def.shape[key]._zod;
    if (ctx.io === "input") {
      return v.optin === undefined;
    } else {
      return v.optout === undefined;
    }
  }));
  if (requiredKeys.size > 0) {
    json.required = Array.from(requiredKeys);
  }
  if (def.catchall?._zod.def.type === "never") {
    json.additionalProperties = false;
  } else if (!def.catchall) {
    if (ctx.io === "output")
      json.additionalProperties = false;
  } else if (def.catchall) {
    json.additionalProperties = process2(def.catchall, ctx, {
      ...params,
      path: [...params.path, "additionalProperties"]
    });
  }
}, unionProcessor = (schema, ctx, json, params) => {
  const def = schema._zod.def;
  const isExclusive = def.inclusive === false;
  const options2 = def.options.map((x, i) => process2(x, ctx, {
    ...params,
    path: [...params.path, isExclusive ? "oneOf" : "anyOf", i]
  }));
  if (isExclusive) {
    json.oneOf = options2;
  } else {
    json.anyOf = options2;
  }
}, intersectionProcessor = (schema, ctx, json, params) => {
  const def = schema._zod.def;
  const a = process2(def.left, ctx, {
    ...params,
    path: [...params.path, "allOf", 0]
  });
  const b = process2(def.right, ctx, {
    ...params,
    path: [...params.path, "allOf", 1]
  });
  const isSimpleIntersection = (val) => ("allOf" in val) && Object.keys(val).length === 1;
  const allOf = [
    ...isSimpleIntersection(a) ? a.allOf : [a],
    ...isSimpleIntersection(b) ? b.allOf : [b]
  ];
  json.allOf = allOf;
}, tupleProcessor = (schema, ctx, _json, params) => {
  const json = _json;
  const def = schema._zod.def;
  json.type = "array";
  const prefixPath = ctx.target === "draft-2020-12" ? "prefixItems" : "items";
  const restPath = ctx.target === "draft-2020-12" ? "items" : ctx.target === "openapi-3.0" ? "items" : "additionalItems";
  const prefixItems = def.items.map((x, i) => process2(x, ctx, {
    ...params,
    path: [...params.path, prefixPath, i]
  }));
  const rest = def.rest ? process2(def.rest, ctx, {
    ...params,
    path: [...params.path, restPath, ...ctx.target === "openapi-3.0" ? [def.items.length] : []]
  }) : null;
  if (ctx.target === "draft-2020-12") {
    json.prefixItems = prefixItems;
    if (rest) {
      json.items = rest;
    }
  } else if (ctx.target === "openapi-3.0") {
    json.items = {
      anyOf: prefixItems
    };
    if (rest) {
      json.items.anyOf.push(rest);
    }
    json.minItems = prefixItems.length;
    if (!rest) {
      json.maxItems = prefixItems.length;
    }
  } else {
    json.items = prefixItems;
    if (rest) {
      json.additionalItems = rest;
    }
  }
  const { minimum, maximum } = schema._zod.bag;
  if (typeof minimum === "number")
    json.minItems = minimum;
  if (typeof maximum === "number")
    json.maxItems = maximum;
}, recordProcessor = (schema, ctx, _json, params) => {
  const json = _json;
  const def = schema._zod.def;
  json.type = "object";
  const keyType = def.keyType;
  const keyBag = keyType._zod.bag;
  const patterns = keyBag?.patterns;
  if (def.mode === "loose" && patterns && patterns.size > 0) {
    const valueSchema = process2(def.valueType, ctx, {
      ...params,
      path: [...params.path, "patternProperties", "*"]
    });
    json.patternProperties = {};
    for (const pattern of patterns) {
      json.patternProperties[pattern.source] = valueSchema;
    }
  } else {
    if (ctx.target === "draft-07" || ctx.target === "draft-2020-12") {
      json.propertyNames = process2(def.keyType, ctx, {
        ...params,
        path: [...params.path, "propertyNames"]
      });
    }
    json.additionalProperties = process2(def.valueType, ctx, {
      ...params,
      path: [...params.path, "additionalProperties"]
    });
  }
  const keyValues = keyType._zod.values;
  if (keyValues) {
    const validKeyValues = [...keyValues].filter((v) => typeof v === "string" || typeof v === "number");
    if (validKeyValues.length > 0) {
      json.required = validKeyValues;
    }
  }
}, nullableProcessor = (schema, ctx, json, params) => {
  const def = schema._zod.def;
  const inner = process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  if (ctx.target === "openapi-3.0") {
    seen.ref = def.innerType;
    json.nullable = true;
  } else {
    json.anyOf = [inner, { type: "null" }];
  }
}, nonoptionalProcessor = (schema, ctx, _json, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
}, defaultProcessor = (schema, ctx, json, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  json.default = JSON.parse(JSON.stringify(def.defaultValue));
}, prefaultProcessor = (schema, ctx, json, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  if (ctx.io === "input")
    json._prefault = JSON.parse(JSON.stringify(def.defaultValue));
}, catchProcessor = (schema, ctx, json, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  let catchValue;
  try {
    catchValue = def.catchValue(undefined);
  } catch {
    throw new Error("Dynamic catch values are not supported in JSON Schema");
  }
  json.default = catchValue;
}, pipeProcessor = (schema, ctx, _json, params) => {
  const def = schema._zod.def;
  const innerType = ctx.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
  process2(innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = innerType;
}, readonlyProcessor = (schema, ctx, json, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  json.readOnly = true;
}, promiseProcessor = (schema, ctx, _json, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
}, optionalProcessor = (schema, ctx, _json, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
}, lazyProcessor = (schema, ctx, _json, params) => {
  const innerType = schema._zod.innerType;
  process2(innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = innerType;
}, allProcessors;
var init_json_schema_processors = __esm(() => {
  init_to_json_schema();
  init_util();
  formatMap = {
    guid: "uuid",
    url: "uri",
    datetime: "date-time",
    json_string: "json-string",
    regex: ""
  };
  allProcessors = {
    string: stringProcessor,
    number: numberProcessor,
    boolean: booleanProcessor,
    bigint: bigintProcessor,
    symbol: symbolProcessor,
    null: nullProcessor,
    undefined: undefinedProcessor,
    void: voidProcessor,
    never: neverProcessor,
    any: anyProcessor,
    unknown: unknownProcessor,
    date: dateProcessor,
    enum: enumProcessor,
    literal: literalProcessor,
    nan: nanProcessor,
    template_literal: templateLiteralProcessor,
    file: fileProcessor,
    success: successProcessor,
    custom: customProcessor,
    function: functionProcessor,
    transform: transformProcessor,
    map: mapProcessor,
    set: setProcessor,
    array: arrayProcessor,
    object: objectProcessor,
    union: unionProcessor,
    intersection: intersectionProcessor,
    tuple: tupleProcessor,
    record: recordProcessor,
    nullable: nullableProcessor,
    nonoptional: nonoptionalProcessor,
    default: defaultProcessor,
    prefault: prefaultProcessor,
    catch: catchProcessor,
    pipe: pipeProcessor,
    readonly: readonlyProcessor,
    promise: promiseProcessor,
    optional: optionalProcessor,
    lazy: lazyProcessor
  };
});

// node_modules/zod/v4/core/json-schema-generator.js
class JSONSchemaGenerator {
  get metadataRegistry() {
    return this.ctx.metadataRegistry;
  }
  get target() {
    return this.ctx.target;
  }
  get unrepresentable() {
    return this.ctx.unrepresentable;
  }
  get override() {
    return this.ctx.override;
  }
  get io() {
    return this.ctx.io;
  }
  get counter() {
    return this.ctx.counter;
  }
  set counter(value) {
    this.ctx.counter = value;
  }
  get seen() {
    return this.ctx.seen;
  }
  constructor(params) {
    let normalizedTarget = params?.target ?? "draft-2020-12";
    if (normalizedTarget === "draft-4")
      normalizedTarget = "draft-04";
    if (normalizedTarget === "draft-7")
      normalizedTarget = "draft-07";
    this.ctx = initializeContext({
      processors: allProcessors,
      target: normalizedTarget,
      ...params?.metadata && { metadata: params.metadata },
      ...params?.unrepresentable && { unrepresentable: params.unrepresentable },
      ...params?.override && { override: params.override },
      ...params?.io && { io: params.io }
    });
  }
  process(schema, _params = { path: [], schemaPath: [] }) {
    return process2(schema, this.ctx, _params);
  }
  emit(schema, _params) {
    if (_params) {
      if (_params.cycles)
        this.ctx.cycles = _params.cycles;
      if (_params.reused)
        this.ctx.reused = _params.reused;
      if (_params.external)
        this.ctx.external = _params.external;
    }
    extractDefs(this.ctx, schema);
    const result = finalize(this.ctx, schema);
    const { "~standard": _, ...plainResult } = result;
    return plainResult;
  }
}
var init_json_schema_generator = __esm(() => {
  init_json_schema_processors();
  init_to_json_schema();
});

// node_modules/zod/v4/core/json-schema.js
var exports_json_schema = {};
var init_json_schema = () => {};

// node_modules/zod/v4/core/index.js
var exports_core2 = {};
__export(exports_core2, {
  version: () => version,
  util: () => exports_util,
  treeifyError: () => treeifyError,
  toJSONSchema: () => toJSONSchema,
  toDotPath: () => toDotPath,
  safeParseAsync: () => safeParseAsync,
  safeParse: () => safeParse,
  safeEncodeAsync: () => safeEncodeAsync,
  safeEncode: () => safeEncode,
  safeDecodeAsync: () => safeDecodeAsync,
  safeDecode: () => safeDecode,
  registry: () => registry,
  regexes: () => exports_regexes,
  process: () => process2,
  prettifyError: () => prettifyError,
  parseAsync: () => parseAsync,
  parse: () => parse2,
  meta: () => meta,
  locales: () => exports_locales,
  isValidJWT: () => isValidJWT,
  isValidBase64URL: () => isValidBase64URL,
  isValidBase64: () => isValidBase64,
  initializeContext: () => initializeContext,
  globalRegistry: () => globalRegistry,
  globalConfig: () => globalConfig,
  formatError: () => formatError,
  flattenError: () => flattenError,
  finalize: () => finalize,
  extractDefs: () => extractDefs,
  encodeAsync: () => encodeAsync,
  encode: () => encode,
  describe: () => describe,
  decodeAsync: () => decodeAsync,
  decode: () => decode,
  createToJSONSchemaMethod: () => createToJSONSchemaMethod,
  createStandardJSONSchemaMethod: () => createStandardJSONSchemaMethod,
  config: () => config,
  clone: () => clone,
  _xor: () => _xor,
  _xid: () => _xid,
  _void: () => _void,
  _uuidv7: () => _uuidv7,
  _uuidv6: () => _uuidv6,
  _uuidv4: () => _uuidv4,
  _uuid: () => _uuid,
  _url: () => _url,
  _uppercase: () => _uppercase,
  _unknown: () => _unknown,
  _union: () => _union,
  _undefined: () => _undefined2,
  _ulid: () => _ulid,
  _uint64: () => _uint64,
  _uint32: () => _uint32,
  _tuple: () => _tuple,
  _trim: () => _trim,
  _transform: () => _transform,
  _toUpperCase: () => _toUpperCase,
  _toLowerCase: () => _toLowerCase,
  _templateLiteral: () => _templateLiteral,
  _symbol: () => _symbol,
  _superRefine: () => _superRefine,
  _success: () => _success,
  _stringbool: () => _stringbool,
  _stringFormat: () => _stringFormat,
  _string: () => _string,
  _startsWith: () => _startsWith,
  _slugify: () => _slugify,
  _size: () => _size,
  _set: () => _set,
  _safeParseAsync: () => _safeParseAsync,
  _safeParse: () => _safeParse,
  _safeEncodeAsync: () => _safeEncodeAsync,
  _safeEncode: () => _safeEncode,
  _safeDecodeAsync: () => _safeDecodeAsync,
  _safeDecode: () => _safeDecode,
  _regex: () => _regex,
  _refine: () => _refine,
  _record: () => _record,
  _readonly: () => _readonly,
  _property: () => _property,
  _promise: () => _promise,
  _positive: () => _positive,
  _pipe: () => _pipe,
  _parseAsync: () => _parseAsync,
  _parse: () => _parse,
  _overwrite: () => _overwrite,
  _optional: () => _optional,
  _number: () => _number,
  _nullable: () => _nullable,
  _null: () => _null2,
  _normalize: () => _normalize,
  _nonpositive: () => _nonpositive,
  _nonoptional: () => _nonoptional,
  _nonnegative: () => _nonnegative,
  _never: () => _never,
  _negative: () => _negative,
  _nativeEnum: () => _nativeEnum,
  _nanoid: () => _nanoid,
  _nan: () => _nan,
  _multipleOf: () => _multipleOf,
  _minSize: () => _minSize,
  _minLength: () => _minLength,
  _min: () => _gte,
  _mime: () => _mime,
  _maxSize: () => _maxSize,
  _maxLength: () => _maxLength,
  _max: () => _lte,
  _map: () => _map,
  _mac: () => _mac,
  _lte: () => _lte,
  _lt: () => _lt,
  _lowercase: () => _lowercase,
  _literal: () => _literal,
  _length: () => _length,
  _lazy: () => _lazy,
  _ksuid: () => _ksuid,
  _jwt: () => _jwt,
  _isoTime: () => _isoTime,
  _isoDuration: () => _isoDuration,
  _isoDateTime: () => _isoDateTime,
  _isoDate: () => _isoDate,
  _ipv6: () => _ipv6,
  _ipv4: () => _ipv4,
  _intersection: () => _intersection,
  _int64: () => _int64,
  _int32: () => _int32,
  _int: () => _int,
  _includes: () => _includes,
  _guid: () => _guid,
  _gte: () => _gte,
  _gt: () => _gt,
  _float64: () => _float64,
  _float32: () => _float32,
  _file: () => _file,
  _enum: () => _enum,
  _endsWith: () => _endsWith,
  _encodeAsync: () => _encodeAsync,
  _encode: () => _encode,
  _emoji: () => _emoji2,
  _email: () => _email,
  _e164: () => _e164,
  _discriminatedUnion: () => _discriminatedUnion,
  _default: () => _default,
  _decodeAsync: () => _decodeAsync,
  _decode: () => _decode,
  _date: () => _date,
  _custom: () => _custom,
  _cuid2: () => _cuid2,
  _cuid: () => _cuid,
  _coercedString: () => _coercedString,
  _coercedNumber: () => _coercedNumber,
  _coercedDate: () => _coercedDate,
  _coercedBoolean: () => _coercedBoolean,
  _coercedBigint: () => _coercedBigint,
  _cidrv6: () => _cidrv6,
  _cidrv4: () => _cidrv4,
  _check: () => _check,
  _catch: () => _catch,
  _boolean: () => _boolean,
  _bigint: () => _bigint,
  _base64url: () => _base64url,
  _base64: () => _base64,
  _array: () => _array,
  _any: () => _any,
  TimePrecision: () => TimePrecision,
  NEVER: () => NEVER,
  JSONSchemaGenerator: () => JSONSchemaGenerator,
  JSONSchema: () => exports_json_schema,
  Doc: () => Doc,
  $output: () => $output,
  $input: () => $input,
  $constructor: () => $constructor,
  $brand: () => $brand,
  $ZodXor: () => $ZodXor,
  $ZodXID: () => $ZodXID,
  $ZodVoid: () => $ZodVoid,
  $ZodUnknown: () => $ZodUnknown,
  $ZodUnion: () => $ZodUnion,
  $ZodUndefined: () => $ZodUndefined,
  $ZodUUID: () => $ZodUUID,
  $ZodURL: () => $ZodURL,
  $ZodULID: () => $ZodULID,
  $ZodType: () => $ZodType,
  $ZodTuple: () => $ZodTuple,
  $ZodTransform: () => $ZodTransform,
  $ZodTemplateLiteral: () => $ZodTemplateLiteral,
  $ZodSymbol: () => $ZodSymbol,
  $ZodSuccess: () => $ZodSuccess,
  $ZodStringFormat: () => $ZodStringFormat,
  $ZodString: () => $ZodString,
  $ZodSet: () => $ZodSet,
  $ZodRegistry: () => $ZodRegistry,
  $ZodRecord: () => $ZodRecord,
  $ZodRealError: () => $ZodRealError,
  $ZodReadonly: () => $ZodReadonly,
  $ZodPromise: () => $ZodPromise,
  $ZodPrefault: () => $ZodPrefault,
  $ZodPipe: () => $ZodPipe,
  $ZodOptional: () => $ZodOptional,
  $ZodObjectJIT: () => $ZodObjectJIT,
  $ZodObject: () => $ZodObject,
  $ZodNumberFormat: () => $ZodNumberFormat,
  $ZodNumber: () => $ZodNumber,
  $ZodNullable: () => $ZodNullable,
  $ZodNull: () => $ZodNull,
  $ZodNonOptional: () => $ZodNonOptional,
  $ZodNever: () => $ZodNever,
  $ZodNanoID: () => $ZodNanoID,
  $ZodNaN: () => $ZodNaN,
  $ZodMap: () => $ZodMap,
  $ZodMAC: () => $ZodMAC,
  $ZodLiteral: () => $ZodLiteral,
  $ZodLazy: () => $ZodLazy,
  $ZodKSUID: () => $ZodKSUID,
  $ZodJWT: () => $ZodJWT,
  $ZodIntersection: () => $ZodIntersection,
  $ZodISOTime: () => $ZodISOTime,
  $ZodISODuration: () => $ZodISODuration,
  $ZodISODateTime: () => $ZodISODateTime,
  $ZodISODate: () => $ZodISODate,
  $ZodIPv6: () => $ZodIPv6,
  $ZodIPv4: () => $ZodIPv4,
  $ZodGUID: () => $ZodGUID,
  $ZodFunction: () => $ZodFunction,
  $ZodFile: () => $ZodFile,
  $ZodExactOptional: () => $ZodExactOptional,
  $ZodError: () => $ZodError,
  $ZodEnum: () => $ZodEnum,
  $ZodEncodeError: () => $ZodEncodeError,
  $ZodEmoji: () => $ZodEmoji,
  $ZodEmail: () => $ZodEmail,
  $ZodE164: () => $ZodE164,
  $ZodDiscriminatedUnion: () => $ZodDiscriminatedUnion,
  $ZodDefault: () => $ZodDefault,
  $ZodDate: () => $ZodDate,
  $ZodCustomStringFormat: () => $ZodCustomStringFormat,
  $ZodCustom: () => $ZodCustom,
  $ZodCodec: () => $ZodCodec,
  $ZodCheckUpperCase: () => $ZodCheckUpperCase,
  $ZodCheckStringFormat: () => $ZodCheckStringFormat,
  $ZodCheckStartsWith: () => $ZodCheckStartsWith,
  $ZodCheckSizeEquals: () => $ZodCheckSizeEquals,
  $ZodCheckRegex: () => $ZodCheckRegex,
  $ZodCheckProperty: () => $ZodCheckProperty,
  $ZodCheckOverwrite: () => $ZodCheckOverwrite,
  $ZodCheckNumberFormat: () => $ZodCheckNumberFormat,
  $ZodCheckMultipleOf: () => $ZodCheckMultipleOf,
  $ZodCheckMinSize: () => $ZodCheckMinSize,
  $ZodCheckMinLength: () => $ZodCheckMinLength,
  $ZodCheckMimeType: () => $ZodCheckMimeType,
  $ZodCheckMaxSize: () => $ZodCheckMaxSize,
  $ZodCheckMaxLength: () => $ZodCheckMaxLength,
  $ZodCheckLowerCase: () => $ZodCheckLowerCase,
  $ZodCheckLessThan: () => $ZodCheckLessThan,
  $ZodCheckLengthEquals: () => $ZodCheckLengthEquals,
  $ZodCheckIncludes: () => $ZodCheckIncludes,
  $ZodCheckGreaterThan: () => $ZodCheckGreaterThan,
  $ZodCheckEndsWith: () => $ZodCheckEndsWith,
  $ZodCheckBigIntFormat: () => $ZodCheckBigIntFormat,
  $ZodCheck: () => $ZodCheck,
  $ZodCatch: () => $ZodCatch,
  $ZodCUID2: () => $ZodCUID2,
  $ZodCUID: () => $ZodCUID,
  $ZodCIDRv6: () => $ZodCIDRv6,
  $ZodCIDRv4: () => $ZodCIDRv4,
  $ZodBoolean: () => $ZodBoolean,
  $ZodBigIntFormat: () => $ZodBigIntFormat,
  $ZodBigInt: () => $ZodBigInt,
  $ZodBase64URL: () => $ZodBase64URL,
  $ZodBase64: () => $ZodBase64,
  $ZodAsyncError: () => $ZodAsyncError,
  $ZodArray: () => $ZodArray,
  $ZodAny: () => $ZodAny
});
var init_core2 = __esm(() => {
  init_util();
  init_regexes();
  init_locales();
  init_json_schema_processors();
  init_json_schema_generator();
  init_json_schema();
  init_core();
  init_parse();
  init_errors();
  init_schemas();
  init_checks();
  init_versions();
  init_registries();
  init_api();
  init_to_json_schema();
});

// node_modules/zod/v4/classic/checks.js
var exports_checks2 = {};
__export(exports_checks2, {
  uppercase: () => _uppercase,
  trim: () => _trim,
  toUpperCase: () => _toUpperCase,
  toLowerCase: () => _toLowerCase,
  startsWith: () => _startsWith,
  slugify: () => _slugify,
  size: () => _size,
  regex: () => _regex,
  property: () => _property,
  positive: () => _positive,
  overwrite: () => _overwrite,
  normalize: () => _normalize,
  nonpositive: () => _nonpositive,
  nonnegative: () => _nonnegative,
  negative: () => _negative,
  multipleOf: () => _multipleOf,
  minSize: () => _minSize,
  minLength: () => _minLength,
  mime: () => _mime,
  maxSize: () => _maxSize,
  maxLength: () => _maxLength,
  lte: () => _lte,
  lt: () => _lt,
  lowercase: () => _lowercase,
  length: () => _length,
  includes: () => _includes,
  gte: () => _gte,
  gt: () => _gt,
  endsWith: () => _endsWith
});
var init_checks2 = __esm(() => {
  init_core2();
});

// node_modules/zod/v4/classic/iso.js
var exports_iso = {};
__export(exports_iso, {
  time: () => time2,
  duration: () => duration2,
  datetime: () => datetime2,
  date: () => date2,
  ZodISOTime: () => ZodISOTime,
  ZodISODuration: () => ZodISODuration,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODate: () => ZodISODate
});
function datetime2(params) {
  return _isoDateTime(ZodISODateTime, params);
}
function date2(params) {
  return _isoDate(ZodISODate, params);
}
function time2(params) {
  return _isoTime(ZodISOTime, params);
}
function duration2(params) {
  return _isoDuration(ZodISODuration, params);
}
var ZodISODateTime, ZodISODate, ZodISOTime, ZodISODuration;
var init_iso = __esm(() => {
  init_core2();
  init_schemas2();
  ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {
    $ZodISODateTime.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {
    $ZodISODate.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {
    $ZodISOTime.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {
    $ZodISODuration.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
});

// node_modules/zod/v4/classic/errors.js
var initializer2 = (inst, issues) => {
  $ZodError.init(inst, issues);
  inst.name = "ZodError";
  Object.defineProperties(inst, {
    format: {
      value: (mapper) => formatError(inst, mapper)
    },
    flatten: {
      value: (mapper) => flattenError(inst, mapper)
    },
    addIssue: {
      value: (issue2) => {
        inst.issues.push(issue2);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      }
    },
    addIssues: {
      value: (issues2) => {
        inst.issues.push(...issues2);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      }
    },
    isEmpty: {
      get() {
        return inst.issues.length === 0;
      }
    }
  });
}, ZodError, ZodRealError;
var init_errors2 = __esm(() => {
  init_core2();
  init_core2();
  init_util();
  ZodError = $constructor("ZodError", initializer2);
  ZodRealError = $constructor("ZodError", initializer2, {
    Parent: Error
  });
});

// node_modules/zod/v4/classic/parse.js
var parse4, parseAsync2, safeParse2, safeParseAsync2, encode2, decode2, encodeAsync2, decodeAsync2, safeEncode2, safeDecode2, safeEncodeAsync2, safeDecodeAsync2;
var init_parse2 = __esm(() => {
  init_core2();
  init_errors2();
  parse4 = /* @__PURE__ */ _parse(ZodRealError);
  parseAsync2 = /* @__PURE__ */ _parseAsync(ZodRealError);
  safeParse2 = /* @__PURE__ */ _safeParse(ZodRealError);
  safeParseAsync2 = /* @__PURE__ */ _safeParseAsync(ZodRealError);
  encode2 = /* @__PURE__ */ _encode(ZodRealError);
  decode2 = /* @__PURE__ */ _decode(ZodRealError);
  encodeAsync2 = /* @__PURE__ */ _encodeAsync(ZodRealError);
  decodeAsync2 = /* @__PURE__ */ _decodeAsync(ZodRealError);
  safeEncode2 = /* @__PURE__ */ _safeEncode(ZodRealError);
  safeDecode2 = /* @__PURE__ */ _safeDecode(ZodRealError);
  safeEncodeAsync2 = /* @__PURE__ */ _safeEncodeAsync(ZodRealError);
  safeDecodeAsync2 = /* @__PURE__ */ _safeDecodeAsync(ZodRealError);
});

// node_modules/zod/v4/classic/schemas.js
var exports_schemas2 = {};
__export(exports_schemas2, {
  xor: () => xor,
  xid: () => xid2,
  void: () => _void2,
  uuidv7: () => uuidv7,
  uuidv6: () => uuidv6,
  uuidv4: () => uuidv4,
  uuid: () => uuid2,
  url: () => url,
  unknown: () => unknown,
  union: () => union,
  undefined: () => _undefined3,
  ulid: () => ulid2,
  uint64: () => uint64,
  uint32: () => uint32,
  tuple: () => tuple,
  transform: () => transform,
  templateLiteral: () => templateLiteral,
  symbol: () => symbol,
  superRefine: () => superRefine,
  success: () => success,
  stringbool: () => stringbool,
  stringFormat: () => stringFormat,
  string: () => string2,
  strictObject: () => strictObject,
  set: () => set,
  refine: () => refine,
  record: () => record,
  readonly: () => readonly,
  promise: () => promise,
  preprocess: () => preprocess,
  prefault: () => prefault,
  pipe: () => pipe,
  partialRecord: () => partialRecord,
  optional: () => optional,
  object: () => object,
  number: () => number2,
  nullish: () => nullish2,
  nullable: () => nullable,
  null: () => _null3,
  nonoptional: () => nonoptional,
  never: () => never,
  nativeEnum: () => nativeEnum,
  nanoid: () => nanoid2,
  nan: () => nan,
  meta: () => meta2,
  map: () => map,
  mac: () => mac2,
  looseRecord: () => looseRecord,
  looseObject: () => looseObject,
  literal: () => literal,
  lazy: () => lazy,
  ksuid: () => ksuid2,
  keyof: () => keyof,
  jwt: () => jwt,
  json: () => json,
  ipv6: () => ipv62,
  ipv4: () => ipv42,
  intersection: () => intersection,
  int64: () => int64,
  int32: () => int32,
  int: () => int,
  instanceof: () => _instanceof,
  httpUrl: () => httpUrl,
  hostname: () => hostname2,
  hex: () => hex2,
  hash: () => hash,
  guid: () => guid2,
  function: () => _function,
  float64: () => float64,
  float32: () => float32,
  file: () => file,
  exactOptional: () => exactOptional,
  enum: () => _enum2,
  emoji: () => emoji2,
  email: () => email2,
  e164: () => e1642,
  discriminatedUnion: () => discriminatedUnion,
  describe: () => describe2,
  date: () => date3,
  custom: () => custom,
  cuid2: () => cuid22,
  cuid: () => cuid3,
  codec: () => codec,
  cidrv6: () => cidrv62,
  cidrv4: () => cidrv42,
  check: () => check,
  catch: () => _catch2,
  boolean: () => boolean2,
  bigint: () => bigint2,
  base64url: () => base64url2,
  base64: () => base642,
  array: () => array,
  any: () => any,
  _function: () => _function,
  _default: () => _default2,
  _ZodString: () => _ZodString,
  ZodXor: () => ZodXor,
  ZodXID: () => ZodXID,
  ZodVoid: () => ZodVoid,
  ZodUnknown: () => ZodUnknown,
  ZodUnion: () => ZodUnion,
  ZodUndefined: () => ZodUndefined,
  ZodUUID: () => ZodUUID,
  ZodURL: () => ZodURL,
  ZodULID: () => ZodULID,
  ZodType: () => ZodType,
  ZodTuple: () => ZodTuple,
  ZodTransform: () => ZodTransform,
  ZodTemplateLiteral: () => ZodTemplateLiteral,
  ZodSymbol: () => ZodSymbol,
  ZodSuccess: () => ZodSuccess,
  ZodStringFormat: () => ZodStringFormat,
  ZodString: () => ZodString,
  ZodSet: () => ZodSet,
  ZodRecord: () => ZodRecord,
  ZodReadonly: () => ZodReadonly,
  ZodPromise: () => ZodPromise,
  ZodPrefault: () => ZodPrefault,
  ZodPipe: () => ZodPipe,
  ZodOptional: () => ZodOptional,
  ZodObject: () => ZodObject,
  ZodNumberFormat: () => ZodNumberFormat,
  ZodNumber: () => ZodNumber,
  ZodNullable: () => ZodNullable,
  ZodNull: () => ZodNull,
  ZodNonOptional: () => ZodNonOptional,
  ZodNever: () => ZodNever,
  ZodNanoID: () => ZodNanoID,
  ZodNaN: () => ZodNaN,
  ZodMap: () => ZodMap,
  ZodMAC: () => ZodMAC,
  ZodLiteral: () => ZodLiteral,
  ZodLazy: () => ZodLazy,
  ZodKSUID: () => ZodKSUID,
  ZodJWT: () => ZodJWT,
  ZodIntersection: () => ZodIntersection,
  ZodIPv6: () => ZodIPv6,
  ZodIPv4: () => ZodIPv4,
  ZodGUID: () => ZodGUID,
  ZodFunction: () => ZodFunction,
  ZodFile: () => ZodFile,
  ZodExactOptional: () => ZodExactOptional,
  ZodEnum: () => ZodEnum,
  ZodEmoji: () => ZodEmoji,
  ZodEmail: () => ZodEmail,
  ZodE164: () => ZodE164,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodDefault: () => ZodDefault,
  ZodDate: () => ZodDate,
  ZodCustomStringFormat: () => ZodCustomStringFormat,
  ZodCustom: () => ZodCustom,
  ZodCodec: () => ZodCodec,
  ZodCatch: () => ZodCatch,
  ZodCUID2: () => ZodCUID2,
  ZodCUID: () => ZodCUID,
  ZodCIDRv6: () => ZodCIDRv6,
  ZodCIDRv4: () => ZodCIDRv4,
  ZodBoolean: () => ZodBoolean,
  ZodBigIntFormat: () => ZodBigIntFormat,
  ZodBigInt: () => ZodBigInt,
  ZodBase64URL: () => ZodBase64URL,
  ZodBase64: () => ZodBase64,
  ZodArray: () => ZodArray,
  ZodAny: () => ZodAny
});
function string2(params) {
  return _string(ZodString, params);
}
function email2(params) {
  return _email(ZodEmail, params);
}
function guid2(params) {
  return _guid(ZodGUID, params);
}
function uuid2(params) {
  return _uuid(ZodUUID, params);
}
function uuidv4(params) {
  return _uuidv4(ZodUUID, params);
}
function uuidv6(params) {
  return _uuidv6(ZodUUID, params);
}
function uuidv7(params) {
  return _uuidv7(ZodUUID, params);
}
function url(params) {
  return _url(ZodURL, params);
}
function httpUrl(params) {
  return _url(ZodURL, {
    protocol: /^https?$/,
    hostname: exports_regexes.domain,
    ...exports_util.normalizeParams(params)
  });
}
function emoji2(params) {
  return _emoji2(ZodEmoji, params);
}
function nanoid2(params) {
  return _nanoid(ZodNanoID, params);
}
function cuid3(params) {
  return _cuid(ZodCUID, params);
}
function cuid22(params) {
  return _cuid2(ZodCUID2, params);
}
function ulid2(params) {
  return _ulid(ZodULID, params);
}
function xid2(params) {
  return _xid(ZodXID, params);
}
function ksuid2(params) {
  return _ksuid(ZodKSUID, params);
}
function ipv42(params) {
  return _ipv4(ZodIPv4, params);
}
function mac2(params) {
  return _mac(ZodMAC, params);
}
function ipv62(params) {
  return _ipv6(ZodIPv6, params);
}
function cidrv42(params) {
  return _cidrv4(ZodCIDRv4, params);
}
function cidrv62(params) {
  return _cidrv6(ZodCIDRv6, params);
}
function base642(params) {
  return _base64(ZodBase64, params);
}
function base64url2(params) {
  return _base64url(ZodBase64URL, params);
}
function e1642(params) {
  return _e164(ZodE164, params);
}
function jwt(params) {
  return _jwt(ZodJWT, params);
}
function stringFormat(format, fnOrRegex, _params = {}) {
  return _stringFormat(ZodCustomStringFormat, format, fnOrRegex, _params);
}
function hostname2(_params) {
  return _stringFormat(ZodCustomStringFormat, "hostname", exports_regexes.hostname, _params);
}
function hex2(_params) {
  return _stringFormat(ZodCustomStringFormat, "hex", exports_regexes.hex, _params);
}
function hash(alg, params) {
  const enc = params?.enc ?? "hex";
  const format = `${alg}_${enc}`;
  const regex = exports_regexes[format];
  if (!regex)
    throw new Error(`Unrecognized hash format: ${format}`);
  return _stringFormat(ZodCustomStringFormat, format, regex, params);
}
function number2(params) {
  return _number(ZodNumber, params);
}
function int(params) {
  return _int(ZodNumberFormat, params);
}
function float32(params) {
  return _float32(ZodNumberFormat, params);
}
function float64(params) {
  return _float64(ZodNumberFormat, params);
}
function int32(params) {
  return _int32(ZodNumberFormat, params);
}
function uint32(params) {
  return _uint32(ZodNumberFormat, params);
}
function boolean2(params) {
  return _boolean(ZodBoolean, params);
}
function bigint2(params) {
  return _bigint(ZodBigInt, params);
}
function int64(params) {
  return _int64(ZodBigIntFormat, params);
}
function uint64(params) {
  return _uint64(ZodBigIntFormat, params);
}
function symbol(params) {
  return _symbol(ZodSymbol, params);
}
function _undefined3(params) {
  return _undefined2(ZodUndefined, params);
}
function _null3(params) {
  return _null2(ZodNull, params);
}
function any() {
  return _any(ZodAny);
}
function unknown() {
  return _unknown(ZodUnknown);
}
function never(params) {
  return _never(ZodNever, params);
}
function _void2(params) {
  return _void(ZodVoid, params);
}
function date3(params) {
  return _date(ZodDate, params);
}
function array(element, params) {
  return _array(ZodArray, element, params);
}
function keyof(schema) {
  const shape = schema._zod.def.shape;
  return _enum2(Object.keys(shape));
}
function object(shape, params) {
  const def = {
    type: "object",
    shape: shape ?? {},
    ...exports_util.normalizeParams(params)
  };
  return new ZodObject(def);
}
function strictObject(shape, params) {
  return new ZodObject({
    type: "object",
    shape,
    catchall: never(),
    ...exports_util.normalizeParams(params)
  });
}
function looseObject(shape, params) {
  return new ZodObject({
    type: "object",
    shape,
    catchall: unknown(),
    ...exports_util.normalizeParams(params)
  });
}
function union(options2, params) {
  return new ZodUnion({
    type: "union",
    options: options2,
    ...exports_util.normalizeParams(params)
  });
}
function xor(options2, params) {
  return new ZodXor({
    type: "union",
    options: options2,
    inclusive: false,
    ...exports_util.normalizeParams(params)
  });
}
function discriminatedUnion(discriminator, options2, params) {
  return new ZodDiscriminatedUnion({
    type: "union",
    options: options2,
    discriminator,
    ...exports_util.normalizeParams(params)
  });
}
function intersection(left, right) {
  return new ZodIntersection({
    type: "intersection",
    left,
    right
  });
}
function tuple(items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new ZodTuple({
    type: "tuple",
    items,
    rest,
    ...exports_util.normalizeParams(params)
  });
}
function record(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType,
    valueType,
    ...exports_util.normalizeParams(params)
  });
}
function partialRecord(keyType, valueType, params) {
  const k = clone(keyType);
  k._zod.values = undefined;
  return new ZodRecord({
    type: "record",
    keyType: k,
    valueType,
    ...exports_util.normalizeParams(params)
  });
}
function looseRecord(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType,
    valueType,
    mode: "loose",
    ...exports_util.normalizeParams(params)
  });
}
function map(keyType, valueType, params) {
  return new ZodMap({
    type: "map",
    keyType,
    valueType,
    ...exports_util.normalizeParams(params)
  });
}
function set(valueType, params) {
  return new ZodSet({
    type: "set",
    valueType,
    ...exports_util.normalizeParams(params)
  });
}
function _enum2(values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new ZodEnum({
    type: "enum",
    entries,
    ...exports_util.normalizeParams(params)
  });
}
function nativeEnum(entries, params) {
  return new ZodEnum({
    type: "enum",
    entries,
    ...exports_util.normalizeParams(params)
  });
}
function literal(value, params) {
  return new ZodLiteral({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...exports_util.normalizeParams(params)
  });
}
function file(params) {
  return _file(ZodFile, params);
}
function transform(fn) {
  return new ZodTransform({
    type: "transform",
    transform: fn
  });
}
function optional(innerType) {
  return new ZodOptional({
    type: "optional",
    innerType
  });
}
function exactOptional(innerType) {
  return new ZodExactOptional({
    type: "optional",
    innerType
  });
}
function nullable(innerType) {
  return new ZodNullable({
    type: "nullable",
    innerType
  });
}
function nullish2(innerType) {
  return optional(nullable(innerType));
}
function _default2(innerType, defaultValue) {
  return new ZodDefault({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : exports_util.shallowClone(defaultValue);
    }
  });
}
function prefault(innerType, defaultValue) {
  return new ZodPrefault({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : exports_util.shallowClone(defaultValue);
    }
  });
}
function nonoptional(innerType, params) {
  return new ZodNonOptional({
    type: "nonoptional",
    innerType,
    ...exports_util.normalizeParams(params)
  });
}
function success(innerType) {
  return new ZodSuccess({
    type: "success",
    innerType
  });
}
function _catch2(innerType, catchValue) {
  return new ZodCatch({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
function nan(params) {
  return _nan(ZodNaN, params);
}
function pipe(in_, out) {
  return new ZodPipe({
    type: "pipe",
    in: in_,
    out
  });
}
function codec(in_, out, params) {
  return new ZodCodec({
    type: "pipe",
    in: in_,
    out,
    transform: params.decode,
    reverseTransform: params.encode
  });
}
function readonly(innerType) {
  return new ZodReadonly({
    type: "readonly",
    innerType
  });
}
function templateLiteral(parts, params) {
  return new ZodTemplateLiteral({
    type: "template_literal",
    parts,
    ...exports_util.normalizeParams(params)
  });
}
function lazy(getter) {
  return new ZodLazy({
    type: "lazy",
    getter
  });
}
function promise(innerType) {
  return new ZodPromise({
    type: "promise",
    innerType
  });
}
function _function(params) {
  return new ZodFunction({
    type: "function",
    input: Array.isArray(params?.input) ? tuple(params?.input) : params?.input ?? array(unknown()),
    output: params?.output ?? unknown()
  });
}
function check(fn) {
  const ch = new $ZodCheck({
    check: "custom"
  });
  ch._zod.check = fn;
  return ch;
}
function custom(fn, _params) {
  return _custom(ZodCustom, fn ?? (() => true), _params);
}
function refine(fn, _params = {}) {
  return _refine(ZodCustom, fn, _params);
}
function superRefine(fn) {
  return _superRefine(fn);
}
function _instanceof(cls, params = {}) {
  const inst = new ZodCustom({
    type: "custom",
    check: "custom",
    fn: (data) => data instanceof cls,
    abort: true,
    ...exports_util.normalizeParams(params)
  });
  inst._zod.bag.Class = cls;
  inst._zod.check = (payload) => {
    if (!(payload.value instanceof cls)) {
      payload.issues.push({
        code: "invalid_type",
        expected: cls.name,
        input: payload.value,
        inst,
        path: [...inst._zod.def.path ?? []]
      });
    }
  };
  return inst;
}
function json(params) {
  const jsonSchema = lazy(() => {
    return union([string2(params), number2(), boolean2(), _null3(), array(jsonSchema), record(string2(), jsonSchema)]);
  });
  return jsonSchema;
}
function preprocess(fn, schema) {
  return pipe(transform(fn), schema);
}
var ZodType, _ZodString, ZodString, ZodStringFormat, ZodEmail, ZodGUID, ZodUUID, ZodURL, ZodEmoji, ZodNanoID, ZodCUID, ZodCUID2, ZodULID, ZodXID, ZodKSUID, ZodIPv4, ZodMAC, ZodIPv6, ZodCIDRv4, ZodCIDRv6, ZodBase64, ZodBase64URL, ZodE164, ZodJWT, ZodCustomStringFormat, ZodNumber, ZodNumberFormat, ZodBoolean, ZodBigInt, ZodBigIntFormat, ZodSymbol, ZodUndefined, ZodNull, ZodAny, ZodUnknown, ZodNever, ZodVoid, ZodDate, ZodArray, ZodObject, ZodUnion, ZodXor, ZodDiscriminatedUnion, ZodIntersection, ZodTuple, ZodRecord, ZodMap, ZodSet, ZodEnum, ZodLiteral, ZodFile, ZodTransform, ZodOptional, ZodExactOptional, ZodNullable, ZodDefault, ZodPrefault, ZodNonOptional, ZodSuccess, ZodCatch, ZodNaN, ZodPipe, ZodCodec, ZodReadonly, ZodTemplateLiteral, ZodLazy, ZodPromise, ZodFunction, ZodCustom, describe2, meta2, stringbool = (...args) => _stringbool({
  Codec: ZodCodec,
  Boolean: ZodBoolean,
  String: ZodString
}, ...args);
var init_schemas2 = __esm(() => {
  init_core2();
  init_core2();
  init_json_schema_processors();
  init_to_json_schema();
  init_checks2();
  init_iso();
  init_parse2();
  ZodType = /* @__PURE__ */ $constructor("ZodType", (inst, def) => {
    $ZodType.init(inst, def);
    Object.assign(inst["~standard"], {
      jsonSchema: {
        input: createStandardJSONSchemaMethod(inst, "input"),
        output: createStandardJSONSchemaMethod(inst, "output")
      }
    });
    inst.toJSONSchema = createToJSONSchemaMethod(inst, {});
    inst.def = def;
    inst.type = def.type;
    Object.defineProperty(inst, "_def", { value: def });
    inst.check = (...checks2) => {
      return inst.clone(exports_util.mergeDefs(def, {
        checks: [
          ...def.checks ?? [],
          ...checks2.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
        ]
      }), {
        parent: true
      });
    };
    inst.with = inst.check;
    inst.clone = (def2, params) => clone(inst, def2, params);
    inst.brand = () => inst;
    inst.register = (reg, meta2) => {
      reg.add(inst, meta2);
      return inst;
    };
    inst.parse = (data, params) => parse4(inst, data, params, { callee: inst.parse });
    inst.safeParse = (data, params) => safeParse2(inst, data, params);
    inst.parseAsync = async (data, params) => parseAsync2(inst, data, params, { callee: inst.parseAsync });
    inst.safeParseAsync = async (data, params) => safeParseAsync2(inst, data, params);
    inst.spa = inst.safeParseAsync;
    inst.encode = (data, params) => encode2(inst, data, params);
    inst.decode = (data, params) => decode2(inst, data, params);
    inst.encodeAsync = async (data, params) => encodeAsync2(inst, data, params);
    inst.decodeAsync = async (data, params) => decodeAsync2(inst, data, params);
    inst.safeEncode = (data, params) => safeEncode2(inst, data, params);
    inst.safeDecode = (data, params) => safeDecode2(inst, data, params);
    inst.safeEncodeAsync = async (data, params) => safeEncodeAsync2(inst, data, params);
    inst.safeDecodeAsync = async (data, params) => safeDecodeAsync2(inst, data, params);
    inst.refine = (check, params) => inst.check(refine(check, params));
    inst.superRefine = (refinement) => inst.check(superRefine(refinement));
    inst.overwrite = (fn) => inst.check(_overwrite(fn));
    inst.optional = () => optional(inst);
    inst.exactOptional = () => exactOptional(inst);
    inst.nullable = () => nullable(inst);
    inst.nullish = () => optional(nullable(inst));
    inst.nonoptional = (params) => nonoptional(inst, params);
    inst.array = () => array(inst);
    inst.or = (arg) => union([inst, arg]);
    inst.and = (arg) => intersection(inst, arg);
    inst.transform = (tx) => pipe(inst, transform(tx));
    inst.default = (def2) => _default2(inst, def2);
    inst.prefault = (def2) => prefault(inst, def2);
    inst.catch = (params) => _catch2(inst, params);
    inst.pipe = (target) => pipe(inst, target);
    inst.readonly = () => readonly(inst);
    inst.describe = (description) => {
      const cl = inst.clone();
      globalRegistry.add(cl, { description });
      return cl;
    };
    Object.defineProperty(inst, "description", {
      get() {
        return globalRegistry.get(inst)?.description;
      },
      configurable: true
    });
    inst.meta = (...args) => {
      if (args.length === 0) {
        return globalRegistry.get(inst);
      }
      const cl = inst.clone();
      globalRegistry.add(cl, args[0]);
      return cl;
    };
    inst.isOptional = () => inst.safeParse(undefined).success;
    inst.isNullable = () => inst.safeParse(null).success;
    inst.apply = (fn) => fn(inst);
    return inst;
  });
  _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {
    $ZodString.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => stringProcessor(inst, ctx, json, params);
    const bag = inst._zod.bag;
    inst.format = bag.format ?? null;
    inst.minLength = bag.minimum ?? null;
    inst.maxLength = bag.maximum ?? null;
    inst.regex = (...args) => inst.check(_regex(...args));
    inst.includes = (...args) => inst.check(_includes(...args));
    inst.startsWith = (...args) => inst.check(_startsWith(...args));
    inst.endsWith = (...args) => inst.check(_endsWith(...args));
    inst.min = (...args) => inst.check(_minLength(...args));
    inst.max = (...args) => inst.check(_maxLength(...args));
    inst.length = (...args) => inst.check(_length(...args));
    inst.nonempty = (...args) => inst.check(_minLength(1, ...args));
    inst.lowercase = (params) => inst.check(_lowercase(params));
    inst.uppercase = (params) => inst.check(_uppercase(params));
    inst.trim = () => inst.check(_trim());
    inst.normalize = (...args) => inst.check(_normalize(...args));
    inst.toLowerCase = () => inst.check(_toLowerCase());
    inst.toUpperCase = () => inst.check(_toUpperCase());
    inst.slugify = () => inst.check(_slugify());
  });
  ZodString = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {
    $ZodString.init(inst, def);
    _ZodString.init(inst, def);
    inst.email = (params) => inst.check(_email(ZodEmail, params));
    inst.url = (params) => inst.check(_url(ZodURL, params));
    inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
    inst.emoji = (params) => inst.check(_emoji2(ZodEmoji, params));
    inst.guid = (params) => inst.check(_guid(ZodGUID, params));
    inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
    inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
    inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
    inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
    inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
    inst.guid = (params) => inst.check(_guid(ZodGUID, params));
    inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
    inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
    inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
    inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
    inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
    inst.xid = (params) => inst.check(_xid(ZodXID, params));
    inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
    inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
    inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
    inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
    inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
    inst.e164 = (params) => inst.check(_e164(ZodE164, params));
    inst.datetime = (params) => inst.check(datetime2(params));
    inst.date = (params) => inst.check(date2(params));
    inst.time = (params) => inst.check(time2(params));
    inst.duration = (params) => inst.check(duration2(params));
  });
  ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {
    $ZodStringFormat.init(inst, def);
    _ZodString.init(inst, def);
  });
  ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {
    $ZodEmail.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {
    $ZodGUID.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {
    $ZodUUID.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {
    $ZodURL.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {
    $ZodEmoji.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {
    $ZodNanoID.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {
    $ZodCUID.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {
    $ZodCUID2.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {
    $ZodULID.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {
    $ZodXID.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {
    $ZodKSUID.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {
    $ZodIPv4.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodMAC = /* @__PURE__ */ $constructor("ZodMAC", (inst, def) => {
    $ZodMAC.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {
    $ZodIPv6.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {
    $ZodCIDRv4.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {
    $ZodCIDRv6.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {
    $ZodBase64.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {
    $ZodBase64URL.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {
    $ZodE164.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {
    $ZodJWT.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodCustomStringFormat = /* @__PURE__ */ $constructor("ZodCustomStringFormat", (inst, def) => {
    $ZodCustomStringFormat.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodNumber = /* @__PURE__ */ $constructor("ZodNumber", (inst, def) => {
    $ZodNumber.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => numberProcessor(inst, ctx, json, params);
    inst.gt = (value, params) => inst.check(_gt(value, params));
    inst.gte = (value, params) => inst.check(_gte(value, params));
    inst.min = (value, params) => inst.check(_gte(value, params));
    inst.lt = (value, params) => inst.check(_lt(value, params));
    inst.lte = (value, params) => inst.check(_lte(value, params));
    inst.max = (value, params) => inst.check(_lte(value, params));
    inst.int = (params) => inst.check(int(params));
    inst.safe = (params) => inst.check(int(params));
    inst.positive = (params) => inst.check(_gt(0, params));
    inst.nonnegative = (params) => inst.check(_gte(0, params));
    inst.negative = (params) => inst.check(_lt(0, params));
    inst.nonpositive = (params) => inst.check(_lte(0, params));
    inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
    inst.step = (value, params) => inst.check(_multipleOf(value, params));
    inst.finite = () => inst;
    const bag = inst._zod.bag;
    inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
    inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
    inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
    inst.isFinite = true;
    inst.format = bag.format ?? null;
  });
  ZodNumberFormat = /* @__PURE__ */ $constructor("ZodNumberFormat", (inst, def) => {
    $ZodNumberFormat.init(inst, def);
    ZodNumber.init(inst, def);
  });
  ZodBoolean = /* @__PURE__ */ $constructor("ZodBoolean", (inst, def) => {
    $ZodBoolean.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => booleanProcessor(inst, ctx, json, params);
  });
  ZodBigInt = /* @__PURE__ */ $constructor("ZodBigInt", (inst, def) => {
    $ZodBigInt.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => bigintProcessor(inst, ctx, json, params);
    inst.gte = (value, params) => inst.check(_gte(value, params));
    inst.min = (value, params) => inst.check(_gte(value, params));
    inst.gt = (value, params) => inst.check(_gt(value, params));
    inst.gte = (value, params) => inst.check(_gte(value, params));
    inst.min = (value, params) => inst.check(_gte(value, params));
    inst.lt = (value, params) => inst.check(_lt(value, params));
    inst.lte = (value, params) => inst.check(_lte(value, params));
    inst.max = (value, params) => inst.check(_lte(value, params));
    inst.positive = (params) => inst.check(_gt(BigInt(0), params));
    inst.negative = (params) => inst.check(_lt(BigInt(0), params));
    inst.nonpositive = (params) => inst.check(_lte(BigInt(0), params));
    inst.nonnegative = (params) => inst.check(_gte(BigInt(0), params));
    inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
    const bag = inst._zod.bag;
    inst.minValue = bag.minimum ?? null;
    inst.maxValue = bag.maximum ?? null;
    inst.format = bag.format ?? null;
  });
  ZodBigIntFormat = /* @__PURE__ */ $constructor("ZodBigIntFormat", (inst, def) => {
    $ZodBigIntFormat.init(inst, def);
    ZodBigInt.init(inst, def);
  });
  ZodSymbol = /* @__PURE__ */ $constructor("ZodSymbol", (inst, def) => {
    $ZodSymbol.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => symbolProcessor(inst, ctx, json, params);
  });
  ZodUndefined = /* @__PURE__ */ $constructor("ZodUndefined", (inst, def) => {
    $ZodUndefined.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => undefinedProcessor(inst, ctx, json, params);
  });
  ZodNull = /* @__PURE__ */ $constructor("ZodNull", (inst, def) => {
    $ZodNull.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => nullProcessor(inst, ctx, json, params);
  });
  ZodAny = /* @__PURE__ */ $constructor("ZodAny", (inst, def) => {
    $ZodAny.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => anyProcessor(inst, ctx, json, params);
  });
  ZodUnknown = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {
    $ZodUnknown.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => unknownProcessor(inst, ctx, json, params);
  });
  ZodNever = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {
    $ZodNever.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => neverProcessor(inst, ctx, json, params);
  });
  ZodVoid = /* @__PURE__ */ $constructor("ZodVoid", (inst, def) => {
    $ZodVoid.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => voidProcessor(inst, ctx, json, params);
  });
  ZodDate = /* @__PURE__ */ $constructor("ZodDate", (inst, def) => {
    $ZodDate.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => dateProcessor(inst, ctx, json, params);
    inst.min = (value, params) => inst.check(_gte(value, params));
    inst.max = (value, params) => inst.check(_lte(value, params));
    const c = inst._zod.bag;
    inst.minDate = c.minimum ? new Date(c.minimum) : null;
    inst.maxDate = c.maximum ? new Date(c.maximum) : null;
  });
  ZodArray = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {
    $ZodArray.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => arrayProcessor(inst, ctx, json, params);
    inst.element = def.element;
    inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
    inst.nonempty = (params) => inst.check(_minLength(1, params));
    inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
    inst.length = (len, params) => inst.check(_length(len, params));
    inst.unwrap = () => inst.element;
  });
  ZodObject = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {
    $ZodObjectJIT.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => objectProcessor(inst, ctx, json, params);
    exports_util.defineLazy(inst, "shape", () => {
      return def.shape;
    });
    inst.keyof = () => _enum2(Object.keys(inst._zod.def.shape));
    inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });
    inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
    inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
    inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });
    inst.strip = () => inst.clone({ ...inst._zod.def, catchall: undefined });
    inst.extend = (incoming) => {
      return exports_util.extend(inst, incoming);
    };
    inst.safeExtend = (incoming) => {
      return exports_util.safeExtend(inst, incoming);
    };
    inst.merge = (other) => exports_util.merge(inst, other);
    inst.pick = (mask) => exports_util.pick(inst, mask);
    inst.omit = (mask) => exports_util.omit(inst, mask);
    inst.partial = (...args) => exports_util.partial(ZodOptional, inst, args[0]);
    inst.required = (...args) => exports_util.required(ZodNonOptional, inst, args[0]);
  });
  ZodUnion = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {
    $ZodUnion.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => unionProcessor(inst, ctx, json, params);
    inst.options = def.options;
  });
  ZodXor = /* @__PURE__ */ $constructor("ZodXor", (inst, def) => {
    ZodUnion.init(inst, def);
    $ZodXor.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => unionProcessor(inst, ctx, json, params);
    inst.options = def.options;
  });
  ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("ZodDiscriminatedUnion", (inst, def) => {
    ZodUnion.init(inst, def);
    $ZodDiscriminatedUnion.init(inst, def);
  });
  ZodIntersection = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {
    $ZodIntersection.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => intersectionProcessor(inst, ctx, json, params);
  });
  ZodTuple = /* @__PURE__ */ $constructor("ZodTuple", (inst, def) => {
    $ZodTuple.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => tupleProcessor(inst, ctx, json, params);
    inst.rest = (rest) => inst.clone({
      ...inst._zod.def,
      rest
    });
  });
  ZodRecord = /* @__PURE__ */ $constructor("ZodRecord", (inst, def) => {
    $ZodRecord.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => recordProcessor(inst, ctx, json, params);
    inst.keyType = def.keyType;
    inst.valueType = def.valueType;
  });
  ZodMap = /* @__PURE__ */ $constructor("ZodMap", (inst, def) => {
    $ZodMap.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => mapProcessor(inst, ctx, json, params);
    inst.keyType = def.keyType;
    inst.valueType = def.valueType;
    inst.min = (...args) => inst.check(_minSize(...args));
    inst.nonempty = (params) => inst.check(_minSize(1, params));
    inst.max = (...args) => inst.check(_maxSize(...args));
    inst.size = (...args) => inst.check(_size(...args));
  });
  ZodSet = /* @__PURE__ */ $constructor("ZodSet", (inst, def) => {
    $ZodSet.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => setProcessor(inst, ctx, json, params);
    inst.min = (...args) => inst.check(_minSize(...args));
    inst.nonempty = (params) => inst.check(_minSize(1, params));
    inst.max = (...args) => inst.check(_maxSize(...args));
    inst.size = (...args) => inst.check(_size(...args));
  });
  ZodEnum = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {
    $ZodEnum.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => enumProcessor(inst, ctx, json, params);
    inst.enum = def.entries;
    inst.options = Object.values(def.entries);
    const keys = new Set(Object.keys(def.entries));
    inst.extract = (values, params) => {
      const newEntries = {};
      for (const value of values) {
        if (keys.has(value)) {
          newEntries[value] = def.entries[value];
        } else
          throw new Error(`Key ${value} not found in enum`);
      }
      return new ZodEnum({
        ...def,
        checks: [],
        ...exports_util.normalizeParams(params),
        entries: newEntries
      });
    };
    inst.exclude = (values, params) => {
      const newEntries = { ...def.entries };
      for (const value of values) {
        if (keys.has(value)) {
          delete newEntries[value];
        } else
          throw new Error(`Key ${value} not found in enum`);
      }
      return new ZodEnum({
        ...def,
        checks: [],
        ...exports_util.normalizeParams(params),
        entries: newEntries
      });
    };
  });
  ZodLiteral = /* @__PURE__ */ $constructor("ZodLiteral", (inst, def) => {
    $ZodLiteral.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => literalProcessor(inst, ctx, json, params);
    inst.values = new Set(def.values);
    Object.defineProperty(inst, "value", {
      get() {
        if (def.values.length > 1) {
          throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
        }
        return def.values[0];
      }
    });
  });
  ZodFile = /* @__PURE__ */ $constructor("ZodFile", (inst, def) => {
    $ZodFile.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => fileProcessor(inst, ctx, json, params);
    inst.min = (size, params) => inst.check(_minSize(size, params));
    inst.max = (size, params) => inst.check(_maxSize(size, params));
    inst.mime = (types, params) => inst.check(_mime(Array.isArray(types) ? types : [types], params));
  });
  ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {
    $ZodTransform.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => transformProcessor(inst, ctx, json, params);
    inst._zod.parse = (payload, _ctx) => {
      if (_ctx.direction === "backward") {
        throw new $ZodEncodeError(inst.constructor.name);
      }
      payload.addIssue = (issue2) => {
        if (typeof issue2 === "string") {
          payload.issues.push(exports_util.issue(issue2, payload.value, def));
        } else {
          const _issue = issue2;
          if (_issue.fatal)
            _issue.continue = false;
          _issue.code ?? (_issue.code = "custom");
          _issue.input ?? (_issue.input = payload.value);
          _issue.inst ?? (_issue.inst = inst);
          payload.issues.push(exports_util.issue(_issue));
        }
      };
      const output = def.transform(payload.value, payload);
      if (output instanceof Promise) {
        return output.then((output2) => {
          payload.value = output2;
          return payload;
        });
      }
      payload.value = output;
      return payload;
    };
  });
  ZodOptional = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {
    $ZodOptional.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => optionalProcessor(inst, ctx, json, params);
    inst.unwrap = () => inst._zod.def.innerType;
  });
  ZodExactOptional = /* @__PURE__ */ $constructor("ZodExactOptional", (inst, def) => {
    $ZodExactOptional.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => optionalProcessor(inst, ctx, json, params);
    inst.unwrap = () => inst._zod.def.innerType;
  });
  ZodNullable = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {
    $ZodNullable.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => nullableProcessor(inst, ctx, json, params);
    inst.unwrap = () => inst._zod.def.innerType;
  });
  ZodDefault = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {
    $ZodDefault.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => defaultProcessor(inst, ctx, json, params);
    inst.unwrap = () => inst._zod.def.innerType;
    inst.removeDefault = inst.unwrap;
  });
  ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {
    $ZodPrefault.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => prefaultProcessor(inst, ctx, json, params);
    inst.unwrap = () => inst._zod.def.innerType;
  });
  ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {
    $ZodNonOptional.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => nonoptionalProcessor(inst, ctx, json, params);
    inst.unwrap = () => inst._zod.def.innerType;
  });
  ZodSuccess = /* @__PURE__ */ $constructor("ZodSuccess", (inst, def) => {
    $ZodSuccess.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => successProcessor(inst, ctx, json, params);
    inst.unwrap = () => inst._zod.def.innerType;
  });
  ZodCatch = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {
    $ZodCatch.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => catchProcessor(inst, ctx, json, params);
    inst.unwrap = () => inst._zod.def.innerType;
    inst.removeCatch = inst.unwrap;
  });
  ZodNaN = /* @__PURE__ */ $constructor("ZodNaN", (inst, def) => {
    $ZodNaN.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => nanProcessor(inst, ctx, json, params);
  });
  ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {
    $ZodPipe.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => pipeProcessor(inst, ctx, json, params);
    inst.in = def.in;
    inst.out = def.out;
  });
  ZodCodec = /* @__PURE__ */ $constructor("ZodCodec", (inst, def) => {
    ZodPipe.init(inst, def);
    $ZodCodec.init(inst, def);
  });
  ZodReadonly = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {
    $ZodReadonly.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => readonlyProcessor(inst, ctx, json, params);
    inst.unwrap = () => inst._zod.def.innerType;
  });
  ZodTemplateLiteral = /* @__PURE__ */ $constructor("ZodTemplateLiteral", (inst, def) => {
    $ZodTemplateLiteral.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => templateLiteralProcessor(inst, ctx, json, params);
  });
  ZodLazy = /* @__PURE__ */ $constructor("ZodLazy", (inst, def) => {
    $ZodLazy.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => lazyProcessor(inst, ctx, json, params);
    inst.unwrap = () => inst._zod.def.getter();
  });
  ZodPromise = /* @__PURE__ */ $constructor("ZodPromise", (inst, def) => {
    $ZodPromise.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => promiseProcessor(inst, ctx, json, params);
    inst.unwrap = () => inst._zod.def.innerType;
  });
  ZodFunction = /* @__PURE__ */ $constructor("ZodFunction", (inst, def) => {
    $ZodFunction.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => functionProcessor(inst, ctx, json, params);
  });
  ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {
    $ZodCustom.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.processJSONSchema = (ctx, json, params) => customProcessor(inst, ctx, json, params);
  });
  describe2 = describe;
  meta2 = meta;
});

// node_modules/zod/v4/classic/compat.js
function setErrorMap(map2) {
  config({
    customError: map2
  });
}
function getErrorMap() {
  return config().customError;
}
var ZodIssueCode, ZodFirstPartyTypeKind;
var init_compat = __esm(() => {
  init_core2();
  ZodIssueCode = {
    invalid_type: "invalid_type",
    too_big: "too_big",
    too_small: "too_small",
    invalid_format: "invalid_format",
    not_multiple_of: "not_multiple_of",
    unrecognized_keys: "unrecognized_keys",
    invalid_union: "invalid_union",
    invalid_key: "invalid_key",
    invalid_element: "invalid_element",
    invalid_value: "invalid_value",
    custom: "custom"
  };
  (function(ZodFirstPartyTypeKind2) {})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
});

// node_modules/zod/v4/classic/from-json-schema.js
function detectVersion(schema, defaultTarget) {
  const $schema = schema.$schema;
  if ($schema === "https://json-schema.org/draft/2020-12/schema") {
    return "draft-2020-12";
  }
  if ($schema === "http://json-schema.org/draft-07/schema#") {
    return "draft-7";
  }
  if ($schema === "http://json-schema.org/draft-04/schema#") {
    return "draft-4";
  }
  return defaultTarget ?? "draft-2020-12";
}
function resolveRef(ref, ctx) {
  if (!ref.startsWith("#")) {
    throw new Error("External $ref is not supported, only local refs (#/...) are allowed");
  }
  const path = ref.slice(1).split("/").filter(Boolean);
  if (path.length === 0) {
    return ctx.rootSchema;
  }
  const defsKey = ctx.version === "draft-2020-12" ? "$defs" : "definitions";
  if (path[0] === defsKey) {
    const key = path[1];
    if (!key || !ctx.defs[key]) {
      throw new Error(`Reference not found: ${ref}`);
    }
    return ctx.defs[key];
  }
  throw new Error(`Reference not found: ${ref}`);
}
function convertBaseSchema(schema, ctx) {
  if (schema.not !== undefined) {
    if (typeof schema.not === "object" && Object.keys(schema.not).length === 0) {
      return z.never();
    }
    throw new Error("not is not supported in Zod (except { not: {} } for never)");
  }
  if (schema.unevaluatedItems !== undefined) {
    throw new Error("unevaluatedItems is not supported");
  }
  if (schema.unevaluatedProperties !== undefined) {
    throw new Error("unevaluatedProperties is not supported");
  }
  if (schema.if !== undefined || schema.then !== undefined || schema.else !== undefined) {
    throw new Error("Conditional schemas (if/then/else) are not supported");
  }
  if (schema.dependentSchemas !== undefined || schema.dependentRequired !== undefined) {
    throw new Error("dependentSchemas and dependentRequired are not supported");
  }
  if (schema.$ref) {
    const refPath = schema.$ref;
    if (ctx.refs.has(refPath)) {
      return ctx.refs.get(refPath);
    }
    if (ctx.processing.has(refPath)) {
      return z.lazy(() => {
        if (!ctx.refs.has(refPath)) {
          throw new Error(`Circular reference not resolved: ${refPath}`);
        }
        return ctx.refs.get(refPath);
      });
    }
    ctx.processing.add(refPath);
    const resolved = resolveRef(refPath, ctx);
    const zodSchema2 = convertSchema(resolved, ctx);
    ctx.refs.set(refPath, zodSchema2);
    ctx.processing.delete(refPath);
    return zodSchema2;
  }
  if (schema.enum !== undefined) {
    const enumValues = schema.enum;
    if (ctx.version === "openapi-3.0" && schema.nullable === true && enumValues.length === 1 && enumValues[0] === null) {
      return z.null();
    }
    if (enumValues.length === 0) {
      return z.never();
    }
    if (enumValues.length === 1) {
      return z.literal(enumValues[0]);
    }
    if (enumValues.every((v) => typeof v === "string")) {
      return z.enum(enumValues);
    }
    const literalSchemas = enumValues.map((v) => z.literal(v));
    if (literalSchemas.length < 2) {
      return literalSchemas[0];
    }
    return z.union([literalSchemas[0], literalSchemas[1], ...literalSchemas.slice(2)]);
  }
  if (schema.const !== undefined) {
    return z.literal(schema.const);
  }
  const type = schema.type;
  if (Array.isArray(type)) {
    const typeSchemas = type.map((t) => {
      const typeSchema = { ...schema, type: t };
      return convertBaseSchema(typeSchema, ctx);
    });
    if (typeSchemas.length === 0) {
      return z.never();
    }
    if (typeSchemas.length === 1) {
      return typeSchemas[0];
    }
    return z.union(typeSchemas);
  }
  if (!type) {
    return z.any();
  }
  let zodSchema;
  switch (type) {
    case "string": {
      let stringSchema = z.string();
      if (schema.format) {
        const format = schema.format;
        if (format === "email") {
          stringSchema = stringSchema.check(z.email());
        } else if (format === "uri" || format === "uri-reference") {
          stringSchema = stringSchema.check(z.url());
        } else if (format === "uuid" || format === "guid") {
          stringSchema = stringSchema.check(z.uuid());
        } else if (format === "date-time") {
          stringSchema = stringSchema.check(z.iso.datetime());
        } else if (format === "date") {
          stringSchema = stringSchema.check(z.iso.date());
        } else if (format === "time") {
          stringSchema = stringSchema.check(z.iso.time());
        } else if (format === "duration") {
          stringSchema = stringSchema.check(z.iso.duration());
        } else if (format === "ipv4") {
          stringSchema = stringSchema.check(z.ipv4());
        } else if (format === "ipv6") {
          stringSchema = stringSchema.check(z.ipv6());
        } else if (format === "mac") {
          stringSchema = stringSchema.check(z.mac());
        } else if (format === "cidr") {
          stringSchema = stringSchema.check(z.cidrv4());
        } else if (format === "cidr-v6") {
          stringSchema = stringSchema.check(z.cidrv6());
        } else if (format === "base64") {
          stringSchema = stringSchema.check(z.base64());
        } else if (format === "base64url") {
          stringSchema = stringSchema.check(z.base64url());
        } else if (format === "e164") {
          stringSchema = stringSchema.check(z.e164());
        } else if (format === "jwt") {
          stringSchema = stringSchema.check(z.jwt());
        } else if (format === "emoji") {
          stringSchema = stringSchema.check(z.emoji());
        } else if (format === "nanoid") {
          stringSchema = stringSchema.check(z.nanoid());
        } else if (format === "cuid") {
          stringSchema = stringSchema.check(z.cuid());
        } else if (format === "cuid2") {
          stringSchema = stringSchema.check(z.cuid2());
        } else if (format === "ulid") {
          stringSchema = stringSchema.check(z.ulid());
        } else if (format === "xid") {
          stringSchema = stringSchema.check(z.xid());
        } else if (format === "ksuid") {
          stringSchema = stringSchema.check(z.ksuid());
        }
      }
      if (typeof schema.minLength === "number") {
        stringSchema = stringSchema.min(schema.minLength);
      }
      if (typeof schema.maxLength === "number") {
        stringSchema = stringSchema.max(schema.maxLength);
      }
      if (schema.pattern) {
        stringSchema = stringSchema.regex(new RegExp(schema.pattern));
      }
      zodSchema = stringSchema;
      break;
    }
    case "number":
    case "integer": {
      let numberSchema = type === "integer" ? z.number().int() : z.number();
      if (typeof schema.minimum === "number") {
        numberSchema = numberSchema.min(schema.minimum);
      }
      if (typeof schema.maximum === "number") {
        numberSchema = numberSchema.max(schema.maximum);
      }
      if (typeof schema.exclusiveMinimum === "number") {
        numberSchema = numberSchema.gt(schema.exclusiveMinimum);
      } else if (schema.exclusiveMinimum === true && typeof schema.minimum === "number") {
        numberSchema = numberSchema.gt(schema.minimum);
      }
      if (typeof schema.exclusiveMaximum === "number") {
        numberSchema = numberSchema.lt(schema.exclusiveMaximum);
      } else if (schema.exclusiveMaximum === true && typeof schema.maximum === "number") {
        numberSchema = numberSchema.lt(schema.maximum);
      }
      if (typeof schema.multipleOf === "number") {
        numberSchema = numberSchema.multipleOf(schema.multipleOf);
      }
      zodSchema = numberSchema;
      break;
    }
    case "boolean": {
      zodSchema = z.boolean();
      break;
    }
    case "null": {
      zodSchema = z.null();
      break;
    }
    case "object": {
      const shape = {};
      const properties = schema.properties || {};
      const requiredSet = new Set(schema.required || []);
      for (const [key, propSchema] of Object.entries(properties)) {
        const propZodSchema = convertSchema(propSchema, ctx);
        shape[key] = requiredSet.has(key) ? propZodSchema : propZodSchema.optional();
      }
      if (schema.propertyNames) {
        const keySchema = convertSchema(schema.propertyNames, ctx);
        const valueSchema = schema.additionalProperties && typeof schema.additionalProperties === "object" ? convertSchema(schema.additionalProperties, ctx) : z.any();
        if (Object.keys(shape).length === 0) {
          zodSchema = z.record(keySchema, valueSchema);
          break;
        }
        const objectSchema2 = z.object(shape).passthrough();
        const recordSchema = z.looseRecord(keySchema, valueSchema);
        zodSchema = z.intersection(objectSchema2, recordSchema);
        break;
      }
      if (schema.patternProperties) {
        const patternProps = schema.patternProperties;
        const patternKeys = Object.keys(patternProps);
        const looseRecords = [];
        for (const pattern of patternKeys) {
          const patternValue = convertSchema(patternProps[pattern], ctx);
          const keySchema = z.string().regex(new RegExp(pattern));
          looseRecords.push(z.looseRecord(keySchema, patternValue));
        }
        const schemasToIntersect = [];
        if (Object.keys(shape).length > 0) {
          schemasToIntersect.push(z.object(shape).passthrough());
        }
        schemasToIntersect.push(...looseRecords);
        if (schemasToIntersect.length === 0) {
          zodSchema = z.object({}).passthrough();
        } else if (schemasToIntersect.length === 1) {
          zodSchema = schemasToIntersect[0];
        } else {
          let result = z.intersection(schemasToIntersect[0], schemasToIntersect[1]);
          for (let i = 2;i < schemasToIntersect.length; i++) {
            result = z.intersection(result, schemasToIntersect[i]);
          }
          zodSchema = result;
        }
        break;
      }
      const objectSchema = z.object(shape);
      if (schema.additionalProperties === false) {
        zodSchema = objectSchema.strict();
      } else if (typeof schema.additionalProperties === "object") {
        zodSchema = objectSchema.catchall(convertSchema(schema.additionalProperties, ctx));
      } else {
        zodSchema = objectSchema.passthrough();
      }
      break;
    }
    case "array": {
      const prefixItems = schema.prefixItems;
      const items = schema.items;
      if (prefixItems && Array.isArray(prefixItems)) {
        const tupleItems = prefixItems.map((item) => convertSchema(item, ctx));
        const rest = items && typeof items === "object" && !Array.isArray(items) ? convertSchema(items, ctx) : undefined;
        if (rest) {
          zodSchema = z.tuple(tupleItems).rest(rest);
        } else {
          zodSchema = z.tuple(tupleItems);
        }
        if (typeof schema.minItems === "number") {
          zodSchema = zodSchema.check(z.minLength(schema.minItems));
        }
        if (typeof schema.maxItems === "number") {
          zodSchema = zodSchema.check(z.maxLength(schema.maxItems));
        }
      } else if (Array.isArray(items)) {
        const tupleItems = items.map((item) => convertSchema(item, ctx));
        const rest = schema.additionalItems && typeof schema.additionalItems === "object" ? convertSchema(schema.additionalItems, ctx) : undefined;
        if (rest) {
          zodSchema = z.tuple(tupleItems).rest(rest);
        } else {
          zodSchema = z.tuple(tupleItems);
        }
        if (typeof schema.minItems === "number") {
          zodSchema = zodSchema.check(z.minLength(schema.minItems));
        }
        if (typeof schema.maxItems === "number") {
          zodSchema = zodSchema.check(z.maxLength(schema.maxItems));
        }
      } else if (items !== undefined) {
        const element = convertSchema(items, ctx);
        let arraySchema = z.array(element);
        if (typeof schema.minItems === "number") {
          arraySchema = arraySchema.min(schema.minItems);
        }
        if (typeof schema.maxItems === "number") {
          arraySchema = arraySchema.max(schema.maxItems);
        }
        zodSchema = arraySchema;
      } else {
        zodSchema = z.array(z.any());
      }
      break;
    }
    default:
      throw new Error(`Unsupported type: ${type}`);
  }
  if (schema.description) {
    zodSchema = zodSchema.describe(schema.description);
  }
  if (schema.default !== undefined) {
    zodSchema = zodSchema.default(schema.default);
  }
  return zodSchema;
}
function convertSchema(schema, ctx) {
  if (typeof schema === "boolean") {
    return schema ? z.any() : z.never();
  }
  let baseSchema = convertBaseSchema(schema, ctx);
  const hasExplicitType = schema.type || schema.enum !== undefined || schema.const !== undefined;
  if (schema.anyOf && Array.isArray(schema.anyOf)) {
    const options2 = schema.anyOf.map((s) => convertSchema(s, ctx));
    const anyOfUnion = z.union(options2);
    baseSchema = hasExplicitType ? z.intersection(baseSchema, anyOfUnion) : anyOfUnion;
  }
  if (schema.oneOf && Array.isArray(schema.oneOf)) {
    const options2 = schema.oneOf.map((s) => convertSchema(s, ctx));
    const oneOfUnion = z.xor(options2);
    baseSchema = hasExplicitType ? z.intersection(baseSchema, oneOfUnion) : oneOfUnion;
  }
  if (schema.allOf && Array.isArray(schema.allOf)) {
    if (schema.allOf.length === 0) {
      baseSchema = hasExplicitType ? baseSchema : z.any();
    } else {
      let result = hasExplicitType ? baseSchema : convertSchema(schema.allOf[0], ctx);
      const startIdx = hasExplicitType ? 0 : 1;
      for (let i = startIdx;i < schema.allOf.length; i++) {
        result = z.intersection(result, convertSchema(schema.allOf[i], ctx));
      }
      baseSchema = result;
    }
  }
  if (schema.nullable === true && ctx.version === "openapi-3.0") {
    baseSchema = z.nullable(baseSchema);
  }
  if (schema.readOnly === true) {
    baseSchema = z.readonly(baseSchema);
  }
  const extraMeta = {};
  const coreMetadataKeys = ["$id", "id", "$comment", "$anchor", "$vocabulary", "$dynamicRef", "$dynamicAnchor"];
  for (const key of coreMetadataKeys) {
    if (key in schema) {
      extraMeta[key] = schema[key];
    }
  }
  const contentMetadataKeys = ["contentEncoding", "contentMediaType", "contentSchema"];
  for (const key of contentMetadataKeys) {
    if (key in schema) {
      extraMeta[key] = schema[key];
    }
  }
  for (const key of Object.keys(schema)) {
    if (!RECOGNIZED_KEYS.has(key)) {
      extraMeta[key] = schema[key];
    }
  }
  if (Object.keys(extraMeta).length > 0) {
    ctx.registry.add(baseSchema, extraMeta);
  }
  return baseSchema;
}
function fromJSONSchema(schema, params) {
  if (typeof schema === "boolean") {
    return schema ? z.any() : z.never();
  }
  const version2 = detectVersion(schema, params?.defaultTarget);
  const defs = schema.$defs || schema.definitions || {};
  const ctx = {
    version: version2,
    defs,
    refs: new Map,
    processing: new Set,
    rootSchema: schema,
    registry: params?.registry ?? globalRegistry
  };
  return convertSchema(schema, ctx);
}
var z, RECOGNIZED_KEYS;
var init_from_json_schema = __esm(() => {
  init_registries();
  init_checks2();
  init_iso();
  init_schemas2();
  z = {
    ...exports_schemas2,
    ...exports_checks2,
    iso: exports_iso
  };
  RECOGNIZED_KEYS = new Set([
    "$schema",
    "$ref",
    "$defs",
    "definitions",
    "$id",
    "id",
    "$comment",
    "$anchor",
    "$vocabulary",
    "$dynamicRef",
    "$dynamicAnchor",
    "type",
    "enum",
    "const",
    "anyOf",
    "oneOf",
    "allOf",
    "not",
    "properties",
    "required",
    "additionalProperties",
    "patternProperties",
    "propertyNames",
    "minProperties",
    "maxProperties",
    "items",
    "prefixItems",
    "additionalItems",
    "minItems",
    "maxItems",
    "uniqueItems",
    "contains",
    "minContains",
    "maxContains",
    "minLength",
    "maxLength",
    "pattern",
    "format",
    "minimum",
    "maximum",
    "exclusiveMinimum",
    "exclusiveMaximum",
    "multipleOf",
    "description",
    "default",
    "contentEncoding",
    "contentMediaType",
    "contentSchema",
    "unevaluatedItems",
    "unevaluatedProperties",
    "if",
    "then",
    "else",
    "dependentSchemas",
    "dependentRequired",
    "nullable",
    "readOnly"
  ]);
});

// node_modules/zod/v4/classic/coerce.js
var exports_coerce = {};
__export(exports_coerce, {
  string: () => string3,
  number: () => number3,
  date: () => date4,
  boolean: () => boolean3,
  bigint: () => bigint3
});
function string3(params) {
  return _coercedString(ZodString, params);
}
function number3(params) {
  return _coercedNumber(ZodNumber, params);
}
function boolean3(params) {
  return _coercedBoolean(ZodBoolean, params);
}
function bigint3(params) {
  return _coercedBigint(ZodBigInt, params);
}
function date4(params) {
  return _coercedDate(ZodDate, params);
}
var init_coerce = __esm(() => {
  init_core2();
  init_schemas2();
});

// node_modules/zod/v4/classic/external.js
var exports_external = {};
__export(exports_external, {
  xor: () => xor,
  xid: () => xid2,
  void: () => _void2,
  uuidv7: () => uuidv7,
  uuidv6: () => uuidv6,
  uuidv4: () => uuidv4,
  uuid: () => uuid2,
  util: () => exports_util,
  url: () => url,
  uppercase: () => _uppercase,
  unknown: () => unknown,
  union: () => union,
  undefined: () => _undefined3,
  ulid: () => ulid2,
  uint64: () => uint64,
  uint32: () => uint32,
  tuple: () => tuple,
  trim: () => _trim,
  treeifyError: () => treeifyError,
  transform: () => transform,
  toUpperCase: () => _toUpperCase,
  toLowerCase: () => _toLowerCase,
  toJSONSchema: () => toJSONSchema,
  templateLiteral: () => templateLiteral,
  symbol: () => symbol,
  superRefine: () => superRefine,
  success: () => success,
  stringbool: () => stringbool,
  stringFormat: () => stringFormat,
  string: () => string2,
  strictObject: () => strictObject,
  startsWith: () => _startsWith,
  slugify: () => _slugify,
  size: () => _size,
  setErrorMap: () => setErrorMap,
  set: () => set,
  safeParseAsync: () => safeParseAsync2,
  safeParse: () => safeParse2,
  safeEncodeAsync: () => safeEncodeAsync2,
  safeEncode: () => safeEncode2,
  safeDecodeAsync: () => safeDecodeAsync2,
  safeDecode: () => safeDecode2,
  registry: () => registry,
  regexes: () => exports_regexes,
  regex: () => _regex,
  refine: () => refine,
  record: () => record,
  readonly: () => readonly,
  property: () => _property,
  promise: () => promise,
  prettifyError: () => prettifyError,
  preprocess: () => preprocess,
  prefault: () => prefault,
  positive: () => _positive,
  pipe: () => pipe,
  partialRecord: () => partialRecord,
  parseAsync: () => parseAsync2,
  parse: () => parse4,
  overwrite: () => _overwrite,
  optional: () => optional,
  object: () => object,
  number: () => number2,
  nullish: () => nullish2,
  nullable: () => nullable,
  null: () => _null3,
  normalize: () => _normalize,
  nonpositive: () => _nonpositive,
  nonoptional: () => nonoptional,
  nonnegative: () => _nonnegative,
  never: () => never,
  negative: () => _negative,
  nativeEnum: () => nativeEnum,
  nanoid: () => nanoid2,
  nan: () => nan,
  multipleOf: () => _multipleOf,
  minSize: () => _minSize,
  minLength: () => _minLength,
  mime: () => _mime,
  meta: () => meta2,
  maxSize: () => _maxSize,
  maxLength: () => _maxLength,
  map: () => map,
  mac: () => mac2,
  lte: () => _lte,
  lt: () => _lt,
  lowercase: () => _lowercase,
  looseRecord: () => looseRecord,
  looseObject: () => looseObject,
  locales: () => exports_locales,
  literal: () => literal,
  length: () => _length,
  lazy: () => lazy,
  ksuid: () => ksuid2,
  keyof: () => keyof,
  jwt: () => jwt,
  json: () => json,
  iso: () => exports_iso,
  ipv6: () => ipv62,
  ipv4: () => ipv42,
  intersection: () => intersection,
  int64: () => int64,
  int32: () => int32,
  int: () => int,
  instanceof: () => _instanceof,
  includes: () => _includes,
  httpUrl: () => httpUrl,
  hostname: () => hostname2,
  hex: () => hex2,
  hash: () => hash,
  guid: () => guid2,
  gte: () => _gte,
  gt: () => _gt,
  globalRegistry: () => globalRegistry,
  getErrorMap: () => getErrorMap,
  function: () => _function,
  fromJSONSchema: () => fromJSONSchema,
  formatError: () => formatError,
  float64: () => float64,
  float32: () => float32,
  flattenError: () => flattenError,
  file: () => file,
  exactOptional: () => exactOptional,
  enum: () => _enum2,
  endsWith: () => _endsWith,
  encodeAsync: () => encodeAsync2,
  encode: () => encode2,
  emoji: () => emoji2,
  email: () => email2,
  e164: () => e1642,
  discriminatedUnion: () => discriminatedUnion,
  describe: () => describe2,
  decodeAsync: () => decodeAsync2,
  decode: () => decode2,
  date: () => date3,
  custom: () => custom,
  cuid2: () => cuid22,
  cuid: () => cuid3,
  core: () => exports_core2,
  config: () => config,
  coerce: () => exports_coerce,
  codec: () => codec,
  clone: () => clone,
  cidrv6: () => cidrv62,
  cidrv4: () => cidrv42,
  check: () => check,
  catch: () => _catch2,
  boolean: () => boolean2,
  bigint: () => bigint2,
  base64url: () => base64url2,
  base64: () => base642,
  array: () => array,
  any: () => any,
  _function: () => _function,
  _default: () => _default2,
  _ZodString: () => _ZodString,
  ZodXor: () => ZodXor,
  ZodXID: () => ZodXID,
  ZodVoid: () => ZodVoid,
  ZodUnknown: () => ZodUnknown,
  ZodUnion: () => ZodUnion,
  ZodUndefined: () => ZodUndefined,
  ZodUUID: () => ZodUUID,
  ZodURL: () => ZodURL,
  ZodULID: () => ZodULID,
  ZodType: () => ZodType,
  ZodTuple: () => ZodTuple,
  ZodTransform: () => ZodTransform,
  ZodTemplateLiteral: () => ZodTemplateLiteral,
  ZodSymbol: () => ZodSymbol,
  ZodSuccess: () => ZodSuccess,
  ZodStringFormat: () => ZodStringFormat,
  ZodString: () => ZodString,
  ZodSet: () => ZodSet,
  ZodRecord: () => ZodRecord,
  ZodRealError: () => ZodRealError,
  ZodReadonly: () => ZodReadonly,
  ZodPromise: () => ZodPromise,
  ZodPrefault: () => ZodPrefault,
  ZodPipe: () => ZodPipe,
  ZodOptional: () => ZodOptional,
  ZodObject: () => ZodObject,
  ZodNumberFormat: () => ZodNumberFormat,
  ZodNumber: () => ZodNumber,
  ZodNullable: () => ZodNullable,
  ZodNull: () => ZodNull,
  ZodNonOptional: () => ZodNonOptional,
  ZodNever: () => ZodNever,
  ZodNanoID: () => ZodNanoID,
  ZodNaN: () => ZodNaN,
  ZodMap: () => ZodMap,
  ZodMAC: () => ZodMAC,
  ZodLiteral: () => ZodLiteral,
  ZodLazy: () => ZodLazy,
  ZodKSUID: () => ZodKSUID,
  ZodJWT: () => ZodJWT,
  ZodIssueCode: () => ZodIssueCode,
  ZodIntersection: () => ZodIntersection,
  ZodISOTime: () => ZodISOTime,
  ZodISODuration: () => ZodISODuration,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODate: () => ZodISODate,
  ZodIPv6: () => ZodIPv6,
  ZodIPv4: () => ZodIPv4,
  ZodGUID: () => ZodGUID,
  ZodFunction: () => ZodFunction,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodFile: () => ZodFile,
  ZodExactOptional: () => ZodExactOptional,
  ZodError: () => ZodError,
  ZodEnum: () => ZodEnum,
  ZodEmoji: () => ZodEmoji,
  ZodEmail: () => ZodEmail,
  ZodE164: () => ZodE164,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodDefault: () => ZodDefault,
  ZodDate: () => ZodDate,
  ZodCustomStringFormat: () => ZodCustomStringFormat,
  ZodCustom: () => ZodCustom,
  ZodCodec: () => ZodCodec,
  ZodCatch: () => ZodCatch,
  ZodCUID2: () => ZodCUID2,
  ZodCUID: () => ZodCUID,
  ZodCIDRv6: () => ZodCIDRv6,
  ZodCIDRv4: () => ZodCIDRv4,
  ZodBoolean: () => ZodBoolean,
  ZodBigIntFormat: () => ZodBigIntFormat,
  ZodBigInt: () => ZodBigInt,
  ZodBase64URL: () => ZodBase64URL,
  ZodBase64: () => ZodBase64,
  ZodArray: () => ZodArray,
  ZodAny: () => ZodAny,
  TimePrecision: () => TimePrecision,
  NEVER: () => NEVER,
  $output: () => $output,
  $input: () => $input,
  $brand: () => $brand
});
var init_external = __esm(() => {
  init_core2();
  init_core2();
  init_en();
  init_core2();
  init_json_schema_processors();
  init_from_json_schema();
  init_locales();
  init_iso();
  init_iso();
  init_coerce();
  init_schemas2();
  init_checks2();
  init_errors2();
  init_parse2();
  init_compat();
  config(en_default());
});

// node_modules/zod/index.js
var init_zod = __esm(() => {
  init_external();
  init_external();
});

// src/config/schema.ts
import { join } from "path";
var ProviderEnum, SonarTasksSearchSchema, SonarTasksMetadataSchema, SonarTasksContentSchema, SonarCloudSchema, SonarConfigSchema, EmberConfigSchema, LangExtractConfigSchema, ScratchpadConfigSchema, GraphTuningLouvainSchema, GraphConfigSchema, FixturesConfigSchema, AmalfaSettingsSchema, SubstrateError;
var init_schema = __esm(() => {
  init_zod();
  ProviderEnum = exports_external.enum([
    "gemini",
    "ollama",
    "ollama_cloud",
    "openrouter"
  ]);
  SonarTasksSearchSchema = exports_external.object({
    enabled: exports_external.boolean().default(true),
    timeout: exports_external.number().default(5000),
    priority: exports_external.enum(["high", "low"]).default("high")
  });
  SonarTasksMetadataSchema = exports_external.object({
    enabled: exports_external.boolean().default(true),
    timeout: exports_external.number().default(30000),
    autoEnhance: exports_external.boolean().default(true),
    batchSize: exports_external.number().default(10)
  });
  SonarTasksContentSchema = exports_external.object({
    enabled: exports_external.boolean().default(false),
    timeout: exports_external.number().default(300000),
    schedule: exports_external.string().default("daily")
  });
  SonarCloudSchema = exports_external.object({
    enabled: exports_external.boolean().default(false),
    provider: exports_external.enum(["ollama", "openrouter"]).default("openrouter"),
    host: exports_external.string().default("openrouter.ai/api/v1"),
    model: exports_external.string().default("qwen/qwen-2.5-72b-instruct"),
    apiKey: exports_external.string().optional()
  });
  SonarConfigSchema = exports_external.object({
    enabled: exports_external.boolean().default(false),
    autoDiscovery: exports_external.boolean().default(true),
    discoveryMethod: exports_external.enum(["cli", "http"]).default("cli"),
    inferenceMethod: exports_external.enum(["http", "cli"]).default("http"),
    model: exports_external.string().default("qwen2.5:1.5b"),
    modelPriority: exports_external.array(exports_external.string()).default([]),
    host: exports_external.string().default("localhost:11434"),
    port: exports_external.number().default(3012),
    tasks: exports_external.object({
      search: exports_external.object({
        enabled: exports_external.boolean().default(true),
        timeout: exports_external.number().default(5000),
        priority: exports_external.enum(["high", "low"]).default("high")
      }),
      metadata: exports_external.object({
        enabled: exports_external.boolean().default(true),
        timeout: exports_external.number().default(30000),
        autoEnhance: exports_external.boolean().default(true),
        batchSize: exports_external.number().default(10)
      }),
      content: exports_external.object({
        enabled: exports_external.boolean().default(false),
        timeout: exports_external.number().default(300000),
        schedule: exports_external.string().default("daily")
      })
    }),
    cloud: exports_external.object({
      enabled: exports_external.boolean().default(false),
      provider: exports_external.enum(["ollama", "openrouter"]).default("openrouter"),
      host: exports_external.string().default("openrouter.ai/api/v1"),
      model: exports_external.string().default("qwen/qwen-2.5-72b-instruct"),
      apiKey: exports_external.string().optional()
    })
  });
  EmberConfigSchema = exports_external.object({
    enabled: exports_external.boolean().default(true),
    minConfidence: exports_external.number().default(0.8),
    autoSquash: exports_external.boolean().default(false),
    backupDir: exports_external.string().default(join(".amalfa", "backups", "ember"))
  });
  LangExtractConfigSchema = exports_external.object({
    provider: ProviderEnum.default("openrouter"),
    fallbackOrder: exports_external.array(ProviderEnum).optional(),
    gemini: exports_external.object({ model: exports_external.string() }).optional(),
    ollama: exports_external.object({ host: exports_external.string().optional(), model: exports_external.string() }).optional(),
    ollama_cloud: exports_external.object({ host: exports_external.string().optional(), model: exports_external.string() }).optional(),
    openrouter: exports_external.object({ model: exports_external.string() }).optional()
  });
  ScratchpadConfigSchema = exports_external.object({
    enabled: exports_external.boolean().default(true),
    thresholdBytes: exports_external.number().default(4 * 1024),
    maxAgeMs: exports_external.number().default(24 * 60 * 60 * 1000),
    maxCacheSizeBytes: exports_external.number().default(50 * 1024 * 1024),
    includePreview: exports_external.boolean().default(true),
    previewLength: exports_external.number().default(200)
  });
  GraphTuningLouvainSchema = exports_external.object({
    persona: exports_external.number().default(0.3),
    experience: exports_external.number().default(0.25),
    superNodeThreshold: exports_external.number().default(50)
  });
  GraphConfigSchema = exports_external.object({
    tuning: exports_external.object({
      louvain: exports_external.object({
        persona: exports_external.number().default(0.3),
        experience: exports_external.number().default(0.25),
        superNodeThreshold: exports_external.number().default(50)
      })
    })
  });
  FixturesConfigSchema = exports_external.object({
    lexicon: exports_external.string().default(join("scripts", "fixtures", "conceptual-lexicon-ref-v1.79.json")),
    cda: exports_external.string().default(join("scripts", "fixtures", "cda-ref-v63.json"))
  });
  AmalfaSettingsSchema = exports_external.object({
    sources: exports_external.array(exports_external.string()).default([
      "./docs",
      "./*.md",
      "./src/**/*.md",
      "./scripts/**/*.md",
      "./debriefs/**/*.md"
    ]),
    excludePatterns: exports_external.array(exports_external.string()).default(["node_modules", ".git", ".amalfa", "tests"]),
    database: exports_external.string().default(join(".amalfa", "runtime", "resonance.db")),
    embeddings: exports_external.object({
      model: exports_external.string().default("BAAI/bge-small-en-v1.5"),
      dimensions: exports_external.number().default(384)
    }),
    watch: exports_external.object({
      enabled: exports_external.boolean().default(true),
      debounce: exports_external.number().default(1000),
      notifications: exports_external.boolean().default(true)
    }),
    graph: exports_external.object({
      tuning: exports_external.object({
        louvain: exports_external.object({
          persona: exports_external.number().default(0.3),
          experience: exports_external.number().default(0.25),
          superNodeThreshold: exports_external.number().default(50)
        })
      })
    }),
    fixtures: exports_external.object({
      lexicon: exports_external.string().default(join("scripts", "fixtures", "conceptual-lexicon-ref-v1.79.json")),
      cda: exports_external.string().default(join("scripts", "fixtures", "cda-ref-v63.json"))
    }),
    sonar: exports_external.object({
      enabled: exports_external.boolean().default(false),
      autoDiscovery: exports_external.boolean().default(true),
      discoveryMethod: exports_external.enum(["cli", "http"]).default("cli"),
      inferenceMethod: exports_external.enum(["http", "cli"]).default("http"),
      model: exports_external.string().default("qwen2.5:1.5b"),
      modelPriority: exports_external.array(exports_external.string()).default([]),
      host: exports_external.string().default("localhost:11434"),
      port: exports_external.number().default(3012),
      tasks: exports_external.object({
        search: exports_external.object({
          enabled: exports_external.boolean().default(true),
          timeout: exports_external.number().default(5000),
          priority: exports_external.enum(["high", "low"]).default("high")
        }),
        metadata: exports_external.object({
          enabled: exports_external.boolean().default(true),
          timeout: exports_external.number().default(30000),
          autoEnhance: exports_external.boolean().default(true),
          batchSize: exports_external.number().default(10)
        }),
        content: exports_external.object({
          enabled: exports_external.boolean().default(false),
          timeout: exports_external.number().default(300000),
          schedule: exports_external.string().default("daily")
        })
      }),
      cloud: exports_external.object({
        enabled: exports_external.boolean().default(false),
        provider: exports_external.enum(["ollama", "openrouter"]).default("openrouter"),
        host: exports_external.string().default("openrouter.ai/api/v1"),
        model: exports_external.string().default("qwen/qwen-2.5-72b-instruct"),
        apiKey: exports_external.string().optional()
      })
    }),
    ember: exports_external.object({
      enabled: exports_external.boolean().default(true),
      minConfidence: exports_external.number().default(0.8),
      autoSquash: exports_external.boolean().default(false),
      backupDir: exports_external.string().default(join(".amalfa", "backups", "ember"))
    }),
    scratchpad: exports_external.object({
      enabled: exports_external.boolean().default(true),
      thresholdBytes: exports_external.number().default(4 * 1024),
      maxAgeMs: exports_external.number().default(24 * 60 * 60 * 1000),
      maxCacheSizeBytes: exports_external.number().default(50 * 1024 * 1024),
      includePreview: exports_external.boolean().default(true),
      previewLength: exports_external.number().default(200)
    }),
    langExtract: exports_external.object({
      provider: ProviderEnum.default("openrouter"),
      fallbackOrder: exports_external.array(ProviderEnum).optional(),
      gemini: exports_external.object({ model: exports_external.string() }).optional(),
      ollama: exports_external.object({ host: exports_external.string().optional(), model: exports_external.string() }).optional(),
      ollama_cloud: exports_external.object({ host: exports_external.string().optional(), model: exports_external.string() }).optional(),
      openrouter: exports_external.object({ model: exports_external.string() }).optional()
    })
  });
  ((SubstrateError2) => {
    SubstrateError2["MISSING_API_KEY"] = "MISSING_API_KEY";
    SubstrateError2["INVALID_API_KEY"] = "INVALID_API_KEY";
    SubstrateError2["OUT_OF_CREDIT"] = "OUT_OF_CREDIT";
    SubstrateError2["NETWORK_ERROR"] = "NETWORK_ERROR";
    SubstrateError2["TIMEOUT"] = "TIMEOUT";
    SubstrateError2["UNKNOWN"] = "UNKNOWN_ERROR";
  })(SubstrateError ||= {});
});

// src/config/defaults.ts
var exports_defaults = {};
__export(exports_defaults, {
  loadSettings: () => loadSettings,
  loadConfig: () => loadConfig,
  initAmalfaDirs: () => initAmalfaDirs,
  SubstrateError: () => SubstrateError,
  AMALFA_DIRS: () => AMALFA_DIRS
});
import { existsSync, mkdirSync, readFileSync } from "fs";
import { join as join2 } from "path";
function initAmalfaDirs() {
  const dirs = [
    AMALFA_DIRS.base,
    AMALFA_DIRS.logs,
    AMALFA_DIRS.runtime,
    AMALFA_DIRS.cache,
    AMALFA_DIRS.scratchpad,
    AMALFA_DIRS.tasks.pending,
    AMALFA_DIRS.tasks.processing,
    AMALFA_DIRS.tasks.completed
  ];
  for (const dir of dirs) {
    if (!existsSync(dir)) {
      mkdirSync(dir, { recursive: true });
    }
  }
}
function loadSettings(exitOnError = true) {
  const settingsPath = join2(process.cwd(), "amalfa.settings.json");
  if (!existsSync(settingsPath)) {
    if (!exitOnError) {
      return AmalfaSettingsSchema.parse({});
    }
    console.error(`
\uD83D\uDED1 CRITICAL SYSTEM FAILURE: CONFIGURATION MISSING`);
    console.error("==================================================");
    console.error("The Single Source of Truth file is missing:");
    console.error(`   ${settingsPath}`);
    console.error("--------------------------------------------------");
    console.error("The system cannot operate without this file.");
    console.error("To fix this immediately:");
    console.error("   cp amalfa.settings.example.json amalfa.settings.json");
    console.error(`==================================================
`);
    process.exit(1);
  }
  try {
    const content = readFileSync(settingsPath, "utf-8");
    const rawUser = JSON.parse(content);
    if (rawUser.source && !rawUser.sources) {
      rawUser.sources = [rawUser.source];
      delete rawUser.source;
    }
    if (!rawUser.sources || rawUser.sources.length === 0) {
      rawUser.sources = ["./docs"];
    }
    return AmalfaSettingsSchema.parse(rawUser);
  } catch (error48) {
    if (!exitOnError)
      throw error48;
    console.error(`
\uD83D\uDED1 CONFIGURATION INVALID`);
    console.error("==================================================");
    console.error("The 'amalfa.settings.json' violates the Source of Truth schema.");
    console.error("Please fix the errors below:");
    console.error("--------------------------------------------------");
    console.error(error48);
    console.error(`==================================================
`);
    process.exit(1);
  }
}
var AMALFA_DIRS, loadConfig;
var init_defaults = __esm(() => {
  init_schema();
  init_schema();
  AMALFA_DIRS = {
    base: ".amalfa",
    get logs() {
      return join2(this.base, "logs");
    },
    get runtime() {
      return join2(this.base, "runtime");
    },
    get agent() {
      return join2(this.base, "agent");
    },
    get cache() {
      return join2(this.base, "cache");
    },
    get scratchpad() {
      return join2(this.base, "cache", "scratchpad");
    },
    get tasks() {
      return {
        pending: join2(this.base, "agent", "tasks", "pending"),
        processing: join2(this.base, "agent", "tasks", "processing"),
        completed: join2(this.base, "agent", "tasks", "completed")
      };
    }
  };
  loadConfig = loadSettings;
});

// node_modules/progress/lib/node-progress.js
var require_node_progress = __commonJS((exports, module) => {
  /*!
   * node-progress
   * Copyright(c) 2011 TJ Holowaychuk <tj@vision-media.ca>
   * MIT Licensed
   */
  exports = module.exports = ProgressBar;
  function ProgressBar(fmt, options2) {
    this.stream = options2.stream || process.stderr;
    if (typeof options2 == "number") {
      var total = options2;
      options2 = {};
      options2.total = total;
    } else {
      options2 = options2 || {};
      if (typeof fmt != "string")
        throw new Error("format required");
      if (typeof options2.total != "number")
        throw new Error("total required");
    }
    this.fmt = fmt;
    this.curr = options2.curr || 0;
    this.total = options2.total;
    this.width = options2.width || this.total;
    this.clear = options2.clear;
    this.chars = {
      complete: options2.complete || "=",
      incomplete: options2.incomplete || "-",
      head: options2.head || (options2.complete || "=")
    };
    this.renderThrottle = options2.renderThrottle !== 0 ? options2.renderThrottle || 16 : 0;
    this.lastRender = -Infinity;
    this.callback = options2.callback || function() {};
    this.tokens = {};
    this.lastDraw = "";
  }
  ProgressBar.prototype.tick = function(len, tokens) {
    if (len !== 0)
      len = len || 1;
    if (typeof len == "object")
      tokens = len, len = 1;
    if (tokens)
      this.tokens = tokens;
    if (this.curr == 0)
      this.start = new Date;
    this.curr += len;
    this.render();
    if (this.curr >= this.total) {
      this.render(undefined, true);
      this.complete = true;
      this.terminate();
      this.callback(this);
      return;
    }
  };
  ProgressBar.prototype.render = function(tokens, force) {
    force = force !== undefined ? force : false;
    if (tokens)
      this.tokens = tokens;
    if (!this.stream.isTTY)
      return;
    var now = Date.now();
    var delta = now - this.lastRender;
    if (!force && delta < this.renderThrottle) {
      return;
    } else {
      this.lastRender = now;
    }
    var ratio = this.curr / this.total;
    ratio = Math.min(Math.max(ratio, 0), 1);
    var percent = Math.floor(ratio * 100);
    var incomplete, complete, completeLength;
    var elapsed = new Date - this.start;
    var eta = percent == 100 ? 0 : elapsed * (this.total / this.curr - 1);
    var rate = this.curr / (elapsed / 1000);
    var str2 = this.fmt.replace(":current", this.curr).replace(":total", this.total).replace(":elapsed", isNaN(elapsed) ? "0.0" : (elapsed / 1000).toFixed(1)).replace(":eta", isNaN(eta) || !isFinite(eta) ? "0.0" : (eta / 1000).toFixed(1)).replace(":percent", percent.toFixed(0) + "%").replace(":rate", Math.round(rate));
    var availableSpace = Math.max(0, this.stream.columns - str2.replace(":bar", "").length);
    if (availableSpace && process.platform === "win32") {
      availableSpace = availableSpace - 1;
    }
    var width = Math.min(this.width, availableSpace);
    completeLength = Math.round(width * ratio);
    complete = Array(Math.max(0, completeLength + 1)).join(this.chars.complete);
    incomplete = Array(Math.max(0, width - completeLength + 1)).join(this.chars.incomplete);
    if (completeLength > 0)
      complete = complete.slice(0, -1) + this.chars.head;
    str2 = str2.replace(":bar", complete + incomplete);
    if (this.tokens)
      for (var key in this.tokens)
        str2 = str2.replace(":" + key, this.tokens[key]);
    if (this.lastDraw !== str2) {
      this.stream.cursorTo(0);
      this.stream.write(str2);
      this.stream.clearLine(1);
      this.lastDraw = str2;
    }
  };
  ProgressBar.prototype.update = function(ratio, tokens) {
    var goal = Math.floor(ratio * this.total);
    var delta = goal - this.curr;
    this.tick(delta, tokens);
  };
  ProgressBar.prototype.interrupt = function(message) {
    this.stream.clearLine();
    this.stream.cursorTo(0);
    this.stream.write(message);
    this.stream.write(`
`);
    this.stream.write(this.lastDraw);
  };
  ProgressBar.prototype.terminate = function() {
    if (this.clear) {
      if (this.stream.clearLine) {
        this.stream.clearLine();
        this.stream.cursorTo(0);
      }
    } else {
      this.stream.write(`
`);
    }
  };
});

// node_modules/tar/lib/high-level-opt.js
var require_high_level_opt = __commonJS((exports, module) => {
  var argmap = new Map([
    ["C", "cwd"],
    ["f", "file"],
    ["z", "gzip"],
    ["P", "preservePaths"],
    ["U", "unlink"],
    ["strip-components", "strip"],
    ["stripComponents", "strip"],
    ["keep-newer", "newer"],
    ["keepNewer", "newer"],
    ["keep-newer-files", "newer"],
    ["keepNewerFiles", "newer"],
    ["k", "keep"],
    ["keep-existing", "keep"],
    ["keepExisting", "keep"],
    ["m", "noMtime"],
    ["no-mtime", "noMtime"],
    ["p", "preserveOwner"],
    ["L", "follow"],
    ["h", "follow"]
  ]);
  module.exports = (opt) => opt ? Object.keys(opt).map((k) => [
    argmap.has(k) ? argmap.get(k) : k,
    opt[k]
  ]).reduce((set2, kv) => (set2[kv[0]] = kv[1], set2), Object.create(null)) : {};
});

// node_modules/tar/node_modules/minipass/index.js
var require_minipass = __commonJS((exports) => {
  var proc = typeof process === "object" && process ? process : {
    stdout: null,
    stderr: null
  };
  var EE = __require("events");
  var Stream = __require("stream");
  var stringdecoder = __require("string_decoder");
  var SD = stringdecoder.StringDecoder;
  var EOF = Symbol("EOF");
  var MAYBE_EMIT_END = Symbol("maybeEmitEnd");
  var EMITTED_END = Symbol("emittedEnd");
  var EMITTING_END = Symbol("emittingEnd");
  var EMITTED_ERROR = Symbol("emittedError");
  var CLOSED = Symbol("closed");
  var READ = Symbol("read");
  var FLUSH = Symbol("flush");
  var FLUSHCHUNK = Symbol("flushChunk");
  var ENCODING = Symbol("encoding");
  var DECODER = Symbol("decoder");
  var FLOWING = Symbol("flowing");
  var PAUSED = Symbol("paused");
  var RESUME = Symbol("resume");
  var BUFFER = Symbol("buffer");
  var PIPES = Symbol("pipes");
  var BUFFERLENGTH = Symbol("bufferLength");
  var BUFFERPUSH = Symbol("bufferPush");
  var BUFFERSHIFT = Symbol("bufferShift");
  var OBJECTMODE = Symbol("objectMode");
  var DESTROYED = Symbol("destroyed");
  var ERROR = Symbol("error");
  var EMITDATA = Symbol("emitData");
  var EMITEND = Symbol("emitEnd");
  var EMITEND2 = Symbol("emitEnd2");
  var ASYNC = Symbol("async");
  var ABORT = Symbol("abort");
  var ABORTED = Symbol("aborted");
  var SIGNAL = Symbol("signal");
  var defer = (fn) => Promise.resolve().then(fn);
  var doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== "1";
  var ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol("asyncIterator not implemented");
  var ITERATOR = doIter && Symbol.iterator || Symbol("iterator not implemented");
  var isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
  var isArrayBuffer = (b) => b instanceof ArrayBuffer || typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0;
  var isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);

  class Pipe {
    constructor(src, dest, opts) {
      this.src = src;
      this.dest = dest;
      this.opts = opts;
      this.ondrain = () => src[RESUME]();
      dest.on("drain", this.ondrain);
    }
    unpipe() {
      this.dest.removeListener("drain", this.ondrain);
    }
    proxyErrors() {}
    end() {
      this.unpipe();
      if (this.opts.end)
        this.dest.end();
    }
  }

  class PipeProxyErrors extends Pipe {
    unpipe() {
      this.src.removeListener("error", this.proxyErrors);
      super.unpipe();
    }
    constructor(src, dest, opts) {
      super(src, dest, opts);
      this.proxyErrors = (er) => dest.emit("error", er);
      src.on("error", this.proxyErrors);
    }
  }

  class Minipass extends Stream {
    constructor(options2) {
      super();
      this[FLOWING] = false;
      this[PAUSED] = false;
      this[PIPES] = [];
      this[BUFFER] = [];
      this[OBJECTMODE] = options2 && options2.objectMode || false;
      if (this[OBJECTMODE])
        this[ENCODING] = null;
      else
        this[ENCODING] = options2 && options2.encoding || null;
      if (this[ENCODING] === "buffer")
        this[ENCODING] = null;
      this[ASYNC] = options2 && !!options2.async || false;
      this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null;
      this[EOF] = false;
      this[EMITTED_END] = false;
      this[EMITTING_END] = false;
      this[CLOSED] = false;
      this[EMITTED_ERROR] = null;
      this.writable = true;
      this.readable = true;
      this[BUFFERLENGTH] = 0;
      this[DESTROYED] = false;
      if (options2 && options2.debugExposeBuffer === true) {
        Object.defineProperty(this, "buffer", { get: () => this[BUFFER] });
      }
      if (options2 && options2.debugExposePipes === true) {
        Object.defineProperty(this, "pipes", { get: () => this[PIPES] });
      }
      this[SIGNAL] = options2 && options2.signal;
      this[ABORTED] = false;
      if (this[SIGNAL]) {
        this[SIGNAL].addEventListener("abort", () => this[ABORT]());
        if (this[SIGNAL].aborted) {
          this[ABORT]();
        }
      }
    }
    get bufferLength() {
      return this[BUFFERLENGTH];
    }
    get encoding() {
      return this[ENCODING];
    }
    set encoding(enc) {
      if (this[OBJECTMODE])
        throw new Error("cannot set encoding in objectMode");
      if (this[ENCODING] && enc !== this[ENCODING] && (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))
        throw new Error("cannot change encoding");
      if (this[ENCODING] !== enc) {
        this[DECODER] = enc ? new SD(enc) : null;
        if (this[BUFFER].length)
          this[BUFFER] = this[BUFFER].map((chunk) => this[DECODER].write(chunk));
      }
      this[ENCODING] = enc;
    }
    setEncoding(enc) {
      this.encoding = enc;
    }
    get objectMode() {
      return this[OBJECTMODE];
    }
    set objectMode(om) {
      this[OBJECTMODE] = this[OBJECTMODE] || !!om;
    }
    get ["async"]() {
      return this[ASYNC];
    }
    set ["async"](a) {
      this[ASYNC] = this[ASYNC] || !!a;
    }
    [ABORT]() {
      this[ABORTED] = true;
      this.emit("abort", this[SIGNAL].reason);
      this.destroy(this[SIGNAL].reason);
    }
    get aborted() {
      return this[ABORTED];
    }
    set aborted(_) {}
    write(chunk, encoding, cb) {
      if (this[ABORTED])
        return false;
      if (this[EOF])
        throw new Error("write after end");
      if (this[DESTROYED]) {
        this.emit("error", Object.assign(new Error("Cannot call write after a stream was destroyed"), { code: "ERR_STREAM_DESTROYED" }));
        return true;
      }
      if (typeof encoding === "function")
        cb = encoding, encoding = "utf8";
      if (!encoding)
        encoding = "utf8";
      const fn = this[ASYNC] ? defer : (f) => f();
      if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
        if (isArrayBufferView(chunk))
          chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
        else if (isArrayBuffer(chunk))
          chunk = Buffer.from(chunk);
        else if (typeof chunk !== "string")
          this.objectMode = true;
      }
      if (this[OBJECTMODE]) {
        if (this.flowing && this[BUFFERLENGTH] !== 0)
          this[FLUSH](true);
        if (this.flowing)
          this.emit("data", chunk);
        else
          this[BUFFERPUSH](chunk);
        if (this[BUFFERLENGTH] !== 0)
          this.emit("readable");
        if (cb)
          fn(cb);
        return this.flowing;
      }
      if (!chunk.length) {
        if (this[BUFFERLENGTH] !== 0)
          this.emit("readable");
        if (cb)
          fn(cb);
        return this.flowing;
      }
      if (typeof chunk === "string" && !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {
        chunk = Buffer.from(chunk, encoding);
      }
      if (Buffer.isBuffer(chunk) && this[ENCODING])
        chunk = this[DECODER].write(chunk);
      if (this.flowing && this[BUFFERLENGTH] !== 0)
        this[FLUSH](true);
      if (this.flowing)
        this.emit("data", chunk);
      else
        this[BUFFERPUSH](chunk);
      if (this[BUFFERLENGTH] !== 0)
        this.emit("readable");
      if (cb)
        fn(cb);
      return this.flowing;
    }
    read(n) {
      if (this[DESTROYED])
        return null;
      if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {
        this[MAYBE_EMIT_END]();
        return null;
      }
      if (this[OBJECTMODE])
        n = null;
      if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {
        if (this.encoding)
          this[BUFFER] = [this[BUFFER].join("")];
        else
          this[BUFFER] = [Buffer.concat(this[BUFFER], this[BUFFERLENGTH])];
      }
      const ret = this[READ](n || null, this[BUFFER][0]);
      this[MAYBE_EMIT_END]();
      return ret;
    }
    [READ](n, chunk) {
      if (n === chunk.length || n === null)
        this[BUFFERSHIFT]();
      else {
        this[BUFFER][0] = chunk.slice(n);
        chunk = chunk.slice(0, n);
        this[BUFFERLENGTH] -= n;
      }
      this.emit("data", chunk);
      if (!this[BUFFER].length && !this[EOF])
        this.emit("drain");
      return chunk;
    }
    end(chunk, encoding, cb) {
      if (typeof chunk === "function")
        cb = chunk, chunk = null;
      if (typeof encoding === "function")
        cb = encoding, encoding = "utf8";
      if (chunk)
        this.write(chunk, encoding);
      if (cb)
        this.once("end", cb);
      this[EOF] = true;
      this.writable = false;
      if (this.flowing || !this[PAUSED])
        this[MAYBE_EMIT_END]();
      return this;
    }
    [RESUME]() {
      if (this[DESTROYED])
        return;
      this[PAUSED] = false;
      this[FLOWING] = true;
      this.emit("resume");
      if (this[BUFFER].length)
        this[FLUSH]();
      else if (this[EOF])
        this[MAYBE_EMIT_END]();
      else
        this.emit("drain");
    }
    resume() {
      return this[RESUME]();
    }
    pause() {
      this[FLOWING] = false;
      this[PAUSED] = true;
    }
    get destroyed() {
      return this[DESTROYED];
    }
    get flowing() {
      return this[FLOWING];
    }
    get paused() {
      return this[PAUSED];
    }
    [BUFFERPUSH](chunk) {
      if (this[OBJECTMODE])
        this[BUFFERLENGTH] += 1;
      else
        this[BUFFERLENGTH] += chunk.length;
      this[BUFFER].push(chunk);
    }
    [BUFFERSHIFT]() {
      if (this[OBJECTMODE])
        this[BUFFERLENGTH] -= 1;
      else
        this[BUFFERLENGTH] -= this[BUFFER][0].length;
      return this[BUFFER].shift();
    }
    [FLUSH](noDrain) {
      do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) && this[BUFFER].length);
      if (!noDrain && !this[BUFFER].length && !this[EOF])
        this.emit("drain");
    }
    [FLUSHCHUNK](chunk) {
      this.emit("data", chunk);
      return this.flowing;
    }
    pipe(dest, opts) {
      if (this[DESTROYED])
        return;
      const ended = this[EMITTED_END];
      opts = opts || {};
      if (dest === proc.stdout || dest === proc.stderr)
        opts.end = false;
      else
        opts.end = opts.end !== false;
      opts.proxyErrors = !!opts.proxyErrors;
      if (ended) {
        if (opts.end)
          dest.end();
      } else {
        this[PIPES].push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts));
        if (this[ASYNC])
          defer(() => this[RESUME]());
        else
          this[RESUME]();
      }
      return dest;
    }
    unpipe(dest) {
      const p = this[PIPES].find((p2) => p2.dest === dest);
      if (p) {
        this[PIPES].splice(this[PIPES].indexOf(p), 1);
        p.unpipe();
      }
    }
    addListener(ev, fn) {
      return this.on(ev, fn);
    }
    on(ev, fn) {
      const ret = super.on(ev, fn);
      if (ev === "data" && !this[PIPES].length && !this.flowing)
        this[RESUME]();
      else if (ev === "readable" && this[BUFFERLENGTH] !== 0)
        super.emit("readable");
      else if (isEndish(ev) && this[EMITTED_END]) {
        super.emit(ev);
        this.removeAllListeners(ev);
      } else if (ev === "error" && this[EMITTED_ERROR]) {
        if (this[ASYNC])
          defer(() => fn.call(this, this[EMITTED_ERROR]));
        else
          fn.call(this, this[EMITTED_ERROR]);
      }
      return ret;
    }
    get emittedEnd() {
      return this[EMITTED_END];
    }
    [MAYBE_EMIT_END]() {
      if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this[BUFFER].length === 0 && this[EOF]) {
        this[EMITTING_END] = true;
        this.emit("end");
        this.emit("prefinish");
        this.emit("finish");
        if (this[CLOSED])
          this.emit("close");
        this[EMITTING_END] = false;
      }
    }
    emit(ev, data, ...extra) {
      if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED])
        return;
      else if (ev === "data") {
        return !this[OBJECTMODE] && !data ? false : this[ASYNC] ? defer(() => this[EMITDATA](data)) : this[EMITDATA](data);
      } else if (ev === "end") {
        return this[EMITEND]();
      } else if (ev === "close") {
        this[CLOSED] = true;
        if (!this[EMITTED_END] && !this[DESTROYED])
          return;
        const ret2 = super.emit("close");
        this.removeAllListeners("close");
        return ret2;
      } else if (ev === "error") {
        this[EMITTED_ERROR] = data;
        super.emit(ERROR, data);
        const ret2 = !this[SIGNAL] || this.listeners("error").length ? super.emit("error", data) : false;
        this[MAYBE_EMIT_END]();
        return ret2;
      } else if (ev === "resume") {
        const ret2 = super.emit("resume");
        this[MAYBE_EMIT_END]();
        return ret2;
      } else if (ev === "finish" || ev === "prefinish") {
        const ret2 = super.emit(ev);
        this.removeAllListeners(ev);
        return ret2;
      }
      const ret = super.emit(ev, data, ...extra);
      this[MAYBE_EMIT_END]();
      return ret;
    }
    [EMITDATA](data) {
      for (const p of this[PIPES]) {
        if (p.dest.write(data) === false)
          this.pause();
      }
      const ret = super.emit("data", data);
      this[MAYBE_EMIT_END]();
      return ret;
    }
    [EMITEND]() {
      if (this[EMITTED_END])
        return;
      this[EMITTED_END] = true;
      this.readable = false;
      if (this[ASYNC])
        defer(() => this[EMITEND2]());
      else
        this[EMITEND2]();
    }
    [EMITEND2]() {
      if (this[DECODER]) {
        const data = this[DECODER].end();
        if (data) {
          for (const p of this[PIPES]) {
            p.dest.write(data);
          }
          super.emit("data", data);
        }
      }
      for (const p of this[PIPES]) {
        p.end();
      }
      const ret = super.emit("end");
      this.removeAllListeners("end");
      return ret;
    }
    collect() {
      const buf = [];
      if (!this[OBJECTMODE])
        buf.dataLength = 0;
      const p = this.promise();
      this.on("data", (c) => {
        buf.push(c);
        if (!this[OBJECTMODE])
          buf.dataLength += c.length;
      });
      return p.then(() => buf);
    }
    concat() {
      return this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this.collect().then((buf) => this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength));
    }
    promise() {
      return new Promise((resolve, reject) => {
        this.on(DESTROYED, () => reject(new Error("stream destroyed")));
        this.on("error", (er) => reject(er));
        this.on("end", () => resolve());
      });
    }
    [ASYNCITERATOR]() {
      let stopped = false;
      const stop = () => {
        this.pause();
        stopped = true;
        return Promise.resolve({ done: true });
      };
      const next = () => {
        if (stopped)
          return stop();
        const res = this.read();
        if (res !== null)
          return Promise.resolve({ done: false, value: res });
        if (this[EOF])
          return stop();
        let resolve = null;
        let reject = null;
        const onerr = (er) => {
          this.removeListener("data", ondata);
          this.removeListener("end", onend);
          this.removeListener(DESTROYED, ondestroy);
          stop();
          reject(er);
        };
        const ondata = (value) => {
          this.removeListener("error", onerr);
          this.removeListener("end", onend);
          this.removeListener(DESTROYED, ondestroy);
          this.pause();
          resolve({ value, done: !!this[EOF] });
        };
        const onend = () => {
          this.removeListener("error", onerr);
          this.removeListener("data", ondata);
          this.removeListener(DESTROYED, ondestroy);
          stop();
          resolve({ done: true });
        };
        const ondestroy = () => onerr(new Error("stream destroyed"));
        return new Promise((res2, rej) => {
          reject = rej;
          resolve = res2;
          this.once(DESTROYED, ondestroy);
          this.once("error", onerr);
          this.once("end", onend);
          this.once("data", ondata);
        });
      };
      return {
        next,
        throw: stop,
        return: stop,
        [ASYNCITERATOR]() {
          return this;
        }
      };
    }
    [ITERATOR]() {
      let stopped = false;
      const stop = () => {
        this.pause();
        this.removeListener(ERROR, stop);
        this.removeListener(DESTROYED, stop);
        this.removeListener("end", stop);
        stopped = true;
        return { done: true };
      };
      const next = () => {
        if (stopped)
          return stop();
        const value = this.read();
        return value === null ? stop() : { value };
      };
      this.once("end", stop);
      this.once(ERROR, stop);
      this.once(DESTROYED, stop);
      return {
        next,
        throw: stop,
        return: stop,
        [ITERATOR]() {
          return this;
        }
      };
    }
    destroy(er) {
      if (this[DESTROYED]) {
        if (er)
          this.emit("error", er);
        else
          this.emit(DESTROYED);
        return this;
      }
      this[DESTROYED] = true;
      this[BUFFER].length = 0;
      this[BUFFERLENGTH] = 0;
      if (typeof this.close === "function" && !this[CLOSED])
        this.close();
      if (er)
        this.emit("error", er);
      else
        this.emit(DESTROYED);
      return this;
    }
    static isStream(s) {
      return !!s && (s instanceof Minipass || s instanceof Stream || s instanceof EE && (typeof s.pipe === "function" || typeof s.write === "function" && typeof s.end === "function"));
    }
  }
  exports.Minipass = Minipass;
});

// node_modules/minizlib/constants.js
var require_constants = __commonJS((exports, module) => {
  var realZlibConstants = __require("zlib").constants || { ZLIB_VERNUM: 4736 };
  module.exports = Object.freeze(Object.assign(Object.create(null), {
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    Z_MEM_ERROR: -4,
    Z_BUF_ERROR: -5,
    Z_VERSION_ERROR: -6,
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    DEFLATE: 1,
    INFLATE: 2,
    GZIP: 3,
    GUNZIP: 4,
    DEFLATERAW: 5,
    INFLATERAW: 6,
    UNZIP: 7,
    BROTLI_DECODE: 8,
    BROTLI_ENCODE: 9,
    Z_MIN_WINDOWBITS: 8,
    Z_MAX_WINDOWBITS: 15,
    Z_DEFAULT_WINDOWBITS: 15,
    Z_MIN_CHUNK: 64,
    Z_MAX_CHUNK: Infinity,
    Z_DEFAULT_CHUNK: 16384,
    Z_MIN_MEMLEVEL: 1,
    Z_MAX_MEMLEVEL: 9,
    Z_DEFAULT_MEMLEVEL: 8,
    Z_MIN_LEVEL: -1,
    Z_MAX_LEVEL: 9,
    Z_DEFAULT_LEVEL: -1,
    BROTLI_OPERATION_PROCESS: 0,
    BROTLI_OPERATION_FLUSH: 1,
    BROTLI_OPERATION_FINISH: 2,
    BROTLI_OPERATION_EMIT_METADATA: 3,
    BROTLI_MODE_GENERIC: 0,
    BROTLI_MODE_TEXT: 1,
    BROTLI_MODE_FONT: 2,
    BROTLI_DEFAULT_MODE: 0,
    BROTLI_MIN_QUALITY: 0,
    BROTLI_MAX_QUALITY: 11,
    BROTLI_DEFAULT_QUALITY: 11,
    BROTLI_MIN_WINDOW_BITS: 10,
    BROTLI_MAX_WINDOW_BITS: 24,
    BROTLI_LARGE_MAX_WINDOW_BITS: 30,
    BROTLI_DEFAULT_WINDOW: 22,
    BROTLI_MIN_INPUT_BLOCK_BITS: 16,
    BROTLI_MAX_INPUT_BLOCK_BITS: 24,
    BROTLI_PARAM_MODE: 0,
    BROTLI_PARAM_QUALITY: 1,
    BROTLI_PARAM_LGWIN: 2,
    BROTLI_PARAM_LGBLOCK: 3,
    BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,
    BROTLI_PARAM_SIZE_HINT: 5,
    BROTLI_PARAM_LARGE_WINDOW: 6,
    BROTLI_PARAM_NPOSTFIX: 7,
    BROTLI_PARAM_NDIRECT: 8,
    BROTLI_DECODER_RESULT_ERROR: 0,
    BROTLI_DECODER_RESULT_SUCCESS: 1,
    BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,
    BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,
    BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,
    BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,
    BROTLI_DECODER_NO_ERROR: 0,
    BROTLI_DECODER_SUCCESS: 1,
    BROTLI_DECODER_NEEDS_MORE_INPUT: 2,
    BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,
    BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,
    BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,
    BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,
    BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,
    BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,
    BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,
    BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,
    BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,
    BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,
    BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,
    BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,
    BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,
    BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,
    BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,
    BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,
    BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,
    BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,
    BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,
    BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,
    BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,
    BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,
    BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,
    BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,
    BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,
    BROTLI_DECODER_ERROR_UNREACHABLE: -31
  }, realZlibConstants));
});

// node_modules/minizlib/node_modules/minipass/index.js
var require_minipass2 = __commonJS((exports, module) => {
  var proc = typeof process === "object" && process ? process : {
    stdout: null,
    stderr: null
  };
  var EE = __require("events");
  var Stream = __require("stream");
  var SD = __require("string_decoder").StringDecoder;
  var EOF = Symbol("EOF");
  var MAYBE_EMIT_END = Symbol("maybeEmitEnd");
  var EMITTED_END = Symbol("emittedEnd");
  var EMITTING_END = Symbol("emittingEnd");
  var EMITTED_ERROR = Symbol("emittedError");
  var CLOSED = Symbol("closed");
  var READ = Symbol("read");
  var FLUSH = Symbol("flush");
  var FLUSHCHUNK = Symbol("flushChunk");
  var ENCODING = Symbol("encoding");
  var DECODER = Symbol("decoder");
  var FLOWING = Symbol("flowing");
  var PAUSED = Symbol("paused");
  var RESUME = Symbol("resume");
  var BUFFERLENGTH = Symbol("bufferLength");
  var BUFFERPUSH = Symbol("bufferPush");
  var BUFFERSHIFT = Symbol("bufferShift");
  var OBJECTMODE = Symbol("objectMode");
  var DESTROYED = Symbol("destroyed");
  var EMITDATA = Symbol("emitData");
  var EMITEND = Symbol("emitEnd");
  var EMITEND2 = Symbol("emitEnd2");
  var ASYNC = Symbol("async");
  var defer = (fn) => Promise.resolve().then(fn);
  var doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== "1";
  var ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol("asyncIterator not implemented");
  var ITERATOR = doIter && Symbol.iterator || Symbol("iterator not implemented");
  var isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
  var isArrayBuffer = (b) => b instanceof ArrayBuffer || typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0;
  var isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);

  class Pipe {
    constructor(src, dest, opts) {
      this.src = src;
      this.dest = dest;
      this.opts = opts;
      this.ondrain = () => src[RESUME]();
      dest.on("drain", this.ondrain);
    }
    unpipe() {
      this.dest.removeListener("drain", this.ondrain);
    }
    proxyErrors() {}
    end() {
      this.unpipe();
      if (this.opts.end)
        this.dest.end();
    }
  }

  class PipeProxyErrors extends Pipe {
    unpipe() {
      this.src.removeListener("error", this.proxyErrors);
      super.unpipe();
    }
    constructor(src, dest, opts) {
      super(src, dest, opts);
      this.proxyErrors = (er) => dest.emit("error", er);
      src.on("error", this.proxyErrors);
    }
  }
  module.exports = class Minipass extends Stream {
    constructor(options2) {
      super();
      this[FLOWING] = false;
      this[PAUSED] = false;
      this.pipes = [];
      this.buffer = [];
      this[OBJECTMODE] = options2 && options2.objectMode || false;
      if (this[OBJECTMODE])
        this[ENCODING] = null;
      else
        this[ENCODING] = options2 && options2.encoding || null;
      if (this[ENCODING] === "buffer")
        this[ENCODING] = null;
      this[ASYNC] = options2 && !!options2.async || false;
      this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null;
      this[EOF] = false;
      this[EMITTED_END] = false;
      this[EMITTING_END] = false;
      this[CLOSED] = false;
      this[EMITTED_ERROR] = null;
      this.writable = true;
      this.readable = true;
      this[BUFFERLENGTH] = 0;
      this[DESTROYED] = false;
    }
    get bufferLength() {
      return this[BUFFERLENGTH];
    }
    get encoding() {
      return this[ENCODING];
    }
    set encoding(enc) {
      if (this[OBJECTMODE])
        throw new Error("cannot set encoding in objectMode");
      if (this[ENCODING] && enc !== this[ENCODING] && (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))
        throw new Error("cannot change encoding");
      if (this[ENCODING] !== enc) {
        this[DECODER] = enc ? new SD(enc) : null;
        if (this.buffer.length)
          this.buffer = this.buffer.map((chunk) => this[DECODER].write(chunk));
      }
      this[ENCODING] = enc;
    }
    setEncoding(enc) {
      this.encoding = enc;
    }
    get objectMode() {
      return this[OBJECTMODE];
    }
    set objectMode(om) {
      this[OBJECTMODE] = this[OBJECTMODE] || !!om;
    }
    get ["async"]() {
      return this[ASYNC];
    }
    set ["async"](a) {
      this[ASYNC] = this[ASYNC] || !!a;
    }
    write(chunk, encoding, cb) {
      if (this[EOF])
        throw new Error("write after end");
      if (this[DESTROYED]) {
        this.emit("error", Object.assign(new Error("Cannot call write after a stream was destroyed"), { code: "ERR_STREAM_DESTROYED" }));
        return true;
      }
      if (typeof encoding === "function")
        cb = encoding, encoding = "utf8";
      if (!encoding)
        encoding = "utf8";
      const fn = this[ASYNC] ? defer : (f) => f();
      if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
        if (isArrayBufferView(chunk))
          chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
        else if (isArrayBuffer(chunk))
          chunk = Buffer.from(chunk);
        else if (typeof chunk !== "string")
          this.objectMode = true;
      }
      if (this[OBJECTMODE]) {
        if (this.flowing && this[BUFFERLENGTH] !== 0)
          this[FLUSH](true);
        if (this.flowing)
          this.emit("data", chunk);
        else
          this[BUFFERPUSH](chunk);
        if (this[BUFFERLENGTH] !== 0)
          this.emit("readable");
        if (cb)
          fn(cb);
        return this.flowing;
      }
      if (!chunk.length) {
        if (this[BUFFERLENGTH] !== 0)
          this.emit("readable");
        if (cb)
          fn(cb);
        return this.flowing;
      }
      if (typeof chunk === "string" && !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {
        chunk = Buffer.from(chunk, encoding);
      }
      if (Buffer.isBuffer(chunk) && this[ENCODING])
        chunk = this[DECODER].write(chunk);
      if (this.flowing && this[BUFFERLENGTH] !== 0)
        this[FLUSH](true);
      if (this.flowing)
        this.emit("data", chunk);
      else
        this[BUFFERPUSH](chunk);
      if (this[BUFFERLENGTH] !== 0)
        this.emit("readable");
      if (cb)
        fn(cb);
      return this.flowing;
    }
    read(n) {
      if (this[DESTROYED])
        return null;
      if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {
        this[MAYBE_EMIT_END]();
        return null;
      }
      if (this[OBJECTMODE])
        n = null;
      if (this.buffer.length > 1 && !this[OBJECTMODE]) {
        if (this.encoding)
          this.buffer = [this.buffer.join("")];
        else
          this.buffer = [Buffer.concat(this.buffer, this[BUFFERLENGTH])];
      }
      const ret = this[READ](n || null, this.buffer[0]);
      this[MAYBE_EMIT_END]();
      return ret;
    }
    [READ](n, chunk) {
      if (n === chunk.length || n === null)
        this[BUFFERSHIFT]();
      else {
        this.buffer[0] = chunk.slice(n);
        chunk = chunk.slice(0, n);
        this[BUFFERLENGTH] -= n;
      }
      this.emit("data", chunk);
      if (!this.buffer.length && !this[EOF])
        this.emit("drain");
      return chunk;
    }
    end(chunk, encoding, cb) {
      if (typeof chunk === "function")
        cb = chunk, chunk = null;
      if (typeof encoding === "function")
        cb = encoding, encoding = "utf8";
      if (chunk)
        this.write(chunk, encoding);
      if (cb)
        this.once("end", cb);
      this[EOF] = true;
      this.writable = false;
      if (this.flowing || !this[PAUSED])
        this[MAYBE_EMIT_END]();
      return this;
    }
    [RESUME]() {
      if (this[DESTROYED])
        return;
      this[PAUSED] = false;
      this[FLOWING] = true;
      this.emit("resume");
      if (this.buffer.length)
        this[FLUSH]();
      else if (this[EOF])
        this[MAYBE_EMIT_END]();
      else
        this.emit("drain");
    }
    resume() {
      return this[RESUME]();
    }
    pause() {
      this[FLOWING] = false;
      this[PAUSED] = true;
    }
    get destroyed() {
      return this[DESTROYED];
    }
    get flowing() {
      return this[FLOWING];
    }
    get paused() {
      return this[PAUSED];
    }
    [BUFFERPUSH](chunk) {
      if (this[OBJECTMODE])
        this[BUFFERLENGTH] += 1;
      else
        this[BUFFERLENGTH] += chunk.length;
      this.buffer.push(chunk);
    }
    [BUFFERSHIFT]() {
      if (this.buffer.length) {
        if (this[OBJECTMODE])
          this[BUFFERLENGTH] -= 1;
        else
          this[BUFFERLENGTH] -= this.buffer[0].length;
      }
      return this.buffer.shift();
    }
    [FLUSH](noDrain) {
      do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()));
      if (!noDrain && !this.buffer.length && !this[EOF])
        this.emit("drain");
    }
    [FLUSHCHUNK](chunk) {
      return chunk ? (this.emit("data", chunk), this.flowing) : false;
    }
    pipe(dest, opts) {
      if (this[DESTROYED])
        return;
      const ended = this[EMITTED_END];
      opts = opts || {};
      if (dest === proc.stdout || dest === proc.stderr)
        opts.end = false;
      else
        opts.end = opts.end !== false;
      opts.proxyErrors = !!opts.proxyErrors;
      if (ended) {
        if (opts.end)
          dest.end();
      } else {
        this.pipes.push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts));
        if (this[ASYNC])
          defer(() => this[RESUME]());
        else
          this[RESUME]();
      }
      return dest;
    }
    unpipe(dest) {
      const p = this.pipes.find((p2) => p2.dest === dest);
      if (p) {
        this.pipes.splice(this.pipes.indexOf(p), 1);
        p.unpipe();
      }
    }
    addListener(ev, fn) {
      return this.on(ev, fn);
    }
    on(ev, fn) {
      const ret = super.on(ev, fn);
      if (ev === "data" && !this.pipes.length && !this.flowing)
        this[RESUME]();
      else if (ev === "readable" && this[BUFFERLENGTH] !== 0)
        super.emit("readable");
      else if (isEndish(ev) && this[EMITTED_END]) {
        super.emit(ev);
        this.removeAllListeners(ev);
      } else if (ev === "error" && this[EMITTED_ERROR]) {
        if (this[ASYNC])
          defer(() => fn.call(this, this[EMITTED_ERROR]));
        else
          fn.call(this, this[EMITTED_ERROR]);
      }
      return ret;
    }
    get emittedEnd() {
      return this[EMITTED_END];
    }
    [MAYBE_EMIT_END]() {
      if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this.buffer.length === 0 && this[EOF]) {
        this[EMITTING_END] = true;
        this.emit("end");
        this.emit("prefinish");
        this.emit("finish");
        if (this[CLOSED])
          this.emit("close");
        this[EMITTING_END] = false;
      }
    }
    emit(ev, data, ...extra) {
      if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED])
        return;
      else if (ev === "data") {
        return !data ? false : this[ASYNC] ? defer(() => this[EMITDATA](data)) : this[EMITDATA](data);
      } else if (ev === "end") {
        return this[EMITEND]();
      } else if (ev === "close") {
        this[CLOSED] = true;
        if (!this[EMITTED_END] && !this[DESTROYED])
          return;
        const ret2 = super.emit("close");
        this.removeAllListeners("close");
        return ret2;
      } else if (ev === "error") {
        this[EMITTED_ERROR] = data;
        const ret2 = super.emit("error", data);
        this[MAYBE_EMIT_END]();
        return ret2;
      } else if (ev === "resume") {
        const ret2 = super.emit("resume");
        this[MAYBE_EMIT_END]();
        return ret2;
      } else if (ev === "finish" || ev === "prefinish") {
        const ret2 = super.emit(ev);
        this.removeAllListeners(ev);
        return ret2;
      }
      const ret = super.emit(ev, data, ...extra);
      this[MAYBE_EMIT_END]();
      return ret;
    }
    [EMITDATA](data) {
      for (const p of this.pipes) {
        if (p.dest.write(data) === false)
          this.pause();
      }
      const ret = super.emit("data", data);
      this[MAYBE_EMIT_END]();
      return ret;
    }
    [EMITEND]() {
      if (this[EMITTED_END])
        return;
      this[EMITTED_END] = true;
      this.readable = false;
      if (this[ASYNC])
        defer(() => this[EMITEND2]());
      else
        this[EMITEND2]();
    }
    [EMITEND2]() {
      if (this[DECODER]) {
        const data = this[DECODER].end();
        if (data) {
          for (const p of this.pipes) {
            p.dest.write(data);
          }
          super.emit("data", data);
        }
      }
      for (const p of this.pipes) {
        p.end();
      }
      const ret = super.emit("end");
      this.removeAllListeners("end");
      return ret;
    }
    collect() {
      const buf = [];
      if (!this[OBJECTMODE])
        buf.dataLength = 0;
      const p = this.promise();
      this.on("data", (c) => {
        buf.push(c);
        if (!this[OBJECTMODE])
          buf.dataLength += c.length;
      });
      return p.then(() => buf);
    }
    concat() {
      return this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this.collect().then((buf) => this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength));
    }
    promise() {
      return new Promise((resolve, reject) => {
        this.on(DESTROYED, () => reject(new Error("stream destroyed")));
        this.on("error", (er) => reject(er));
        this.on("end", () => resolve());
      });
    }
    [ASYNCITERATOR]() {
      const next = () => {
        const res = this.read();
        if (res !== null)
          return Promise.resolve({ done: false, value: res });
        if (this[EOF])
          return Promise.resolve({ done: true });
        let resolve = null;
        let reject = null;
        const onerr = (er) => {
          this.removeListener("data", ondata);
          this.removeListener("end", onend);
          reject(er);
        };
        const ondata = (value) => {
          this.removeListener("error", onerr);
          this.removeListener("end", onend);
          this.pause();
          resolve({ value, done: !!this[EOF] });
        };
        const onend = () => {
          this.removeListener("error", onerr);
          this.removeListener("data", ondata);
          resolve({ done: true });
        };
        const ondestroy = () => onerr(new Error("stream destroyed"));
        return new Promise((res2, rej) => {
          reject = rej;
          resolve = res2;
          this.once(DESTROYED, ondestroy);
          this.once("error", onerr);
          this.once("end", onend);
          this.once("data", ondata);
        });
      };
      return { next };
    }
    [ITERATOR]() {
      const next = () => {
        const value = this.read();
        const done = value === null;
        return { value, done };
      };
      return { next };
    }
    destroy(er) {
      if (this[DESTROYED]) {
        if (er)
          this.emit("error", er);
        else
          this.emit(DESTROYED);
        return this;
      }
      this[DESTROYED] = true;
      this.buffer.length = 0;
      this[BUFFERLENGTH] = 0;
      if (typeof this.close === "function" && !this[CLOSED])
        this.close();
      if (er)
        this.emit("error", er);
      else
        this.emit(DESTROYED);
      return this;
    }
    static isStream(s) {
      return !!s && (s instanceof Minipass || s instanceof Stream || s instanceof EE && (typeof s.pipe === "function" || typeof s.write === "function" && typeof s.end === "function"));
    }
  };
});

// node_modules/minizlib/index.js
var require_minizlib = __commonJS((exports) => {
  var assert2 = __require("assert");
  var Buffer2 = __require("buffer").Buffer;
  var realZlib = __require("zlib");
  var constants = exports.constants = require_constants();
  var Minipass = require_minipass2();
  var OriginalBufferConcat = Buffer2.concat;
  var _superWrite = Symbol("_superWrite");

  class ZlibError extends Error {
    constructor(err) {
      super("zlib: " + err.message);
      this.code = err.code;
      this.errno = err.errno;
      if (!this.code)
        this.code = "ZLIB_ERROR";
      this.message = "zlib: " + err.message;
      Error.captureStackTrace(this, this.constructor);
    }
    get name() {
      return "ZlibError";
    }
  }
  var _opts = Symbol("opts");
  var _flushFlag = Symbol("flushFlag");
  var _finishFlushFlag = Symbol("finishFlushFlag");
  var _fullFlushFlag = Symbol("fullFlushFlag");
  var _handle = Symbol("handle");
  var _onError = Symbol("onError");
  var _sawError = Symbol("sawError");
  var _level = Symbol("level");
  var _strategy = Symbol("strategy");
  var _ended = Symbol("ended");
  var _defaultFullFlush = Symbol("_defaultFullFlush");

  class ZlibBase extends Minipass {
    constructor(opts, mode) {
      if (!opts || typeof opts !== "object")
        throw new TypeError("invalid options for ZlibBase constructor");
      super(opts);
      this[_sawError] = false;
      this[_ended] = false;
      this[_opts] = opts;
      this[_flushFlag] = opts.flush;
      this[_finishFlushFlag] = opts.finishFlush;
      try {
        this[_handle] = new realZlib[mode](opts);
      } catch (er) {
        throw new ZlibError(er);
      }
      this[_onError] = (err) => {
        if (this[_sawError])
          return;
        this[_sawError] = true;
        this.close();
        this.emit("error", err);
      };
      this[_handle].on("error", (er) => this[_onError](new ZlibError(er)));
      this.once("end", () => this.close);
    }
    close() {
      if (this[_handle]) {
        this[_handle].close();
        this[_handle] = null;
        this.emit("close");
      }
    }
    reset() {
      if (!this[_sawError]) {
        assert2(this[_handle], "zlib binding closed");
        return this[_handle].reset();
      }
    }
    flush(flushFlag) {
      if (this.ended)
        return;
      if (typeof flushFlag !== "number")
        flushFlag = this[_fullFlushFlag];
      this.write(Object.assign(Buffer2.alloc(0), { [_flushFlag]: flushFlag }));
    }
    end(chunk, encoding, cb) {
      if (chunk)
        this.write(chunk, encoding);
      this.flush(this[_finishFlushFlag]);
      this[_ended] = true;
      return super.end(null, null, cb);
    }
    get ended() {
      return this[_ended];
    }
    write(chunk, encoding, cb) {
      if (typeof encoding === "function")
        cb = encoding, encoding = "utf8";
      if (typeof chunk === "string")
        chunk = Buffer2.from(chunk, encoding);
      if (this[_sawError])
        return;
      assert2(this[_handle], "zlib binding closed");
      const nativeHandle = this[_handle]._handle;
      const originalNativeClose = nativeHandle.close;
      nativeHandle.close = () => {};
      const originalClose = this[_handle].close;
      this[_handle].close = () => {};
      Buffer2.concat = (args) => args;
      let result;
      try {
        const flushFlag = typeof chunk[_flushFlag] === "number" ? chunk[_flushFlag] : this[_flushFlag];
        result = this[_handle]._processChunk(chunk, flushFlag);
        Buffer2.concat = OriginalBufferConcat;
      } catch (err) {
        Buffer2.concat = OriginalBufferConcat;
        this[_onError](new ZlibError(err));
      } finally {
        if (this[_handle]) {
          this[_handle]._handle = nativeHandle;
          nativeHandle.close = originalNativeClose;
          this[_handle].close = originalClose;
          this[_handle].removeAllListeners("error");
        }
      }
      if (this[_handle])
        this[_handle].on("error", (er) => this[_onError](new ZlibError(er)));
      let writeReturn;
      if (result) {
        if (Array.isArray(result) && result.length > 0) {
          writeReturn = this[_superWrite](Buffer2.from(result[0]));
          for (let i = 1;i < result.length; i++) {
            writeReturn = this[_superWrite](result[i]);
          }
        } else {
          writeReturn = this[_superWrite](Buffer2.from(result));
        }
      }
      if (cb)
        cb();
      return writeReturn;
    }
    [_superWrite](data) {
      return super.write(data);
    }
  }

  class Zlib extends ZlibBase {
    constructor(opts, mode) {
      opts = opts || {};
      opts.flush = opts.flush || constants.Z_NO_FLUSH;
      opts.finishFlush = opts.finishFlush || constants.Z_FINISH;
      super(opts, mode);
      this[_fullFlushFlag] = constants.Z_FULL_FLUSH;
      this[_level] = opts.level;
      this[_strategy] = opts.strategy;
    }
    params(level, strategy) {
      if (this[_sawError])
        return;
      if (!this[_handle])
        throw new Error("cannot switch params when binding is closed");
      if (!this[_handle].params)
        throw new Error("not supported in this implementation");
      if (this[_level] !== level || this[_strategy] !== strategy) {
        this.flush(constants.Z_SYNC_FLUSH);
        assert2(this[_handle], "zlib binding closed");
        const origFlush = this[_handle].flush;
        this[_handle].flush = (flushFlag, cb) => {
          this.flush(flushFlag);
          cb();
        };
        try {
          this[_handle].params(level, strategy);
        } finally {
          this[_handle].flush = origFlush;
        }
        if (this[_handle]) {
          this[_level] = level;
          this[_strategy] = strategy;
        }
      }
    }
  }

  class Deflate extends Zlib {
    constructor(opts) {
      super(opts, "Deflate");
    }
  }

  class Inflate extends Zlib {
    constructor(opts) {
      super(opts, "Inflate");
    }
  }
  var _portable = Symbol("_portable");

  class Gzip extends Zlib {
    constructor(opts) {
      super(opts, "Gzip");
      this[_portable] = opts && !!opts.portable;
    }
    [_superWrite](data) {
      if (!this[_portable])
        return super[_superWrite](data);
      this[_portable] = false;
      data[9] = 255;
      return super[_superWrite](data);
    }
  }

  class Gunzip extends Zlib {
    constructor(opts) {
      super(opts, "Gunzip");
    }
  }

  class DeflateRaw extends Zlib {
    constructor(opts) {
      super(opts, "DeflateRaw");
    }
  }

  class InflateRaw extends Zlib {
    constructor(opts) {
      super(opts, "InflateRaw");
    }
  }

  class Unzip extends Zlib {
    constructor(opts) {
      super(opts, "Unzip");
    }
  }

  class Brotli extends ZlibBase {
    constructor(opts, mode) {
      opts = opts || {};
      opts.flush = opts.flush || constants.BROTLI_OPERATION_PROCESS;
      opts.finishFlush = opts.finishFlush || constants.BROTLI_OPERATION_FINISH;
      super(opts, mode);
      this[_fullFlushFlag] = constants.BROTLI_OPERATION_FLUSH;
    }
  }

  class BrotliCompress extends Brotli {
    constructor(opts) {
      super(opts, "BrotliCompress");
    }
  }

  class BrotliDecompress extends Brotli {
    constructor(opts) {
      super(opts, "BrotliDecompress");
    }
  }
  exports.Deflate = Deflate;
  exports.Inflate = Inflate;
  exports.Gzip = Gzip;
  exports.Gunzip = Gunzip;
  exports.DeflateRaw = DeflateRaw;
  exports.InflateRaw = InflateRaw;
  exports.Unzip = Unzip;
  if (typeof realZlib.BrotliCompress === "function") {
    exports.BrotliCompress = BrotliCompress;
    exports.BrotliDecompress = BrotliDecompress;
  } else {
    exports.BrotliCompress = exports.BrotliDecompress = class {
      constructor() {
        throw new Error("Brotli is not supported in this version of Node.js");
      }
    };
  }
});

// node_modules/tar/lib/normalize-windows-path.js
var require_normalize_windows_path = __commonJS((exports, module) => {
  var platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;
  module.exports = platform !== "win32" ? (p) => p : (p) => p && p.replace(/\\/g, "/");
});

// node_modules/tar/lib/read-entry.js
var require_read_entry = __commonJS((exports, module) => {
  var { Minipass } = require_minipass();
  var normPath = require_normalize_windows_path();
  var SLURP = Symbol("slurp");
  module.exports = class ReadEntry extends Minipass {
    constructor(header, ex, gex) {
      super();
      this.pause();
      this.extended = ex;
      this.globalExtended = gex;
      this.header = header;
      this.startBlockSize = 512 * Math.ceil(header.size / 512);
      this.blockRemain = this.startBlockSize;
      this.remain = header.size;
      this.type = header.type;
      this.meta = false;
      this.ignore = false;
      switch (this.type) {
        case "File":
        case "OldFile":
        case "Link":
        case "SymbolicLink":
        case "CharacterDevice":
        case "BlockDevice":
        case "Directory":
        case "FIFO":
        case "ContiguousFile":
        case "GNUDumpDir":
          break;
        case "NextFileHasLongLinkpath":
        case "NextFileHasLongPath":
        case "OldGnuLongPath":
        case "GlobalExtendedHeader":
        case "ExtendedHeader":
        case "OldExtendedHeader":
          this.meta = true;
          break;
        default:
          this.ignore = true;
      }
      this.path = normPath(header.path);
      this.mode = header.mode;
      if (this.mode) {
        this.mode = this.mode & 4095;
      }
      this.uid = header.uid;
      this.gid = header.gid;
      this.uname = header.uname;
      this.gname = header.gname;
      this.size = header.size;
      this.mtime = header.mtime;
      this.atime = header.atime;
      this.ctime = header.ctime;
      this.linkpath = normPath(header.linkpath);
      this.uname = header.uname;
      this.gname = header.gname;
      if (ex) {
        this[SLURP](ex);
      }
      if (gex) {
        this[SLURP](gex, true);
      }
    }
    write(data) {
      const writeLen = data.length;
      if (writeLen > this.blockRemain) {
        throw new Error("writing more to entry than is appropriate");
      }
      const r = this.remain;
      const br = this.blockRemain;
      this.remain = Math.max(0, r - writeLen);
      this.blockRemain = Math.max(0, br - writeLen);
      if (this.ignore) {
        return true;
      }
      if (r >= writeLen) {
        return super.write(data);
      }
      return super.write(data.slice(0, r));
    }
    [SLURP](ex, global2) {
      for (const k in ex) {
        if (ex[k] !== null && ex[k] !== undefined && !(global2 && k === "path")) {
          this[k] = k === "path" || k === "linkpath" ? normPath(ex[k]) : ex[k];
        }
      }
    }
  };
});

// node_modules/tar/lib/types.js
var require_types = __commonJS((exports) => {
  exports.name = new Map([
    ["0", "File"],
    ["", "OldFile"],
    ["1", "Link"],
    ["2", "SymbolicLink"],
    ["3", "CharacterDevice"],
    ["4", "BlockDevice"],
    ["5", "Directory"],
    ["6", "FIFO"],
    ["7", "ContiguousFile"],
    ["g", "GlobalExtendedHeader"],
    ["x", "ExtendedHeader"],
    ["A", "SolarisACL"],
    ["D", "GNUDumpDir"],
    ["I", "Inode"],
    ["K", "NextFileHasLongLinkpath"],
    ["L", "NextFileHasLongPath"],
    ["M", "ContinuationFile"],
    ["N", "OldGnuLongPath"],
    ["S", "SparseFile"],
    ["V", "TapeVolumeHeader"],
    ["X", "OldExtendedHeader"]
  ]);
  exports.code = new Map(Array.from(exports.name).map((kv) => [kv[1], kv[0]]));
});

// node_modules/tar/lib/large-numbers.js
var require_large_numbers = __commonJS((exports, module) => {
  var encode3 = (num, buf) => {
    if (!Number.isSafeInteger(num)) {
      throw Error("cannot encode number outside of javascript safe integer range");
    } else if (num < 0) {
      encodeNegative(num, buf);
    } else {
      encodePositive(num, buf);
    }
    return buf;
  };
  var encodePositive = (num, buf) => {
    buf[0] = 128;
    for (var i = buf.length;i > 1; i--) {
      buf[i - 1] = num & 255;
      num = Math.floor(num / 256);
    }
  };
  var encodeNegative = (num, buf) => {
    buf[0] = 255;
    var flipped = false;
    num = num * -1;
    for (var i = buf.length;i > 1; i--) {
      var byte = num & 255;
      num = Math.floor(num / 256);
      if (flipped) {
        buf[i - 1] = onesComp(byte);
      } else if (byte === 0) {
        buf[i - 1] = 0;
      } else {
        flipped = true;
        buf[i - 1] = twosComp(byte);
      }
    }
  };
  var parse6 = (buf) => {
    const pre = buf[0];
    const value = pre === 128 ? pos(buf.slice(1, buf.length)) : pre === 255 ? twos(buf) : null;
    if (value === null) {
      throw Error("invalid base256 encoding");
    }
    if (!Number.isSafeInteger(value)) {
      throw Error("parsed number outside of javascript safe integer range");
    }
    return value;
  };
  var twos = (buf) => {
    var len = buf.length;
    var sum = 0;
    var flipped = false;
    for (var i = len - 1;i > -1; i--) {
      var byte = buf[i];
      var f;
      if (flipped) {
        f = onesComp(byte);
      } else if (byte === 0) {
        f = byte;
      } else {
        flipped = true;
        f = twosComp(byte);
      }
      if (f !== 0) {
        sum -= f * Math.pow(256, len - i - 1);
      }
    }
    return sum;
  };
  var pos = (buf) => {
    var len = buf.length;
    var sum = 0;
    for (var i = len - 1;i > -1; i--) {
      var byte = buf[i];
      if (byte !== 0) {
        sum += byte * Math.pow(256, len - i - 1);
      }
    }
    return sum;
  };
  var onesComp = (byte) => (255 ^ byte) & 255;
  var twosComp = (byte) => (255 ^ byte) + 1 & 255;
  module.exports = {
    encode: encode3,
    parse: parse6
  };
});

// node_modules/tar/lib/header.js
var require_header = __commonJS((exports, module) => {
  var types = require_types();
  var pathModule = __require("path").posix;
  var large = require_large_numbers();
  var SLURP = Symbol("slurp");
  var TYPE = Symbol("type");

  class Header {
    constructor(data, off, ex, gex) {
      this.cksumValid = false;
      this.needPax = false;
      this.nullBlock = false;
      this.block = null;
      this.path = null;
      this.mode = null;
      this.uid = null;
      this.gid = null;
      this.size = null;
      this.mtime = null;
      this.cksum = null;
      this[TYPE] = "0";
      this.linkpath = null;
      this.uname = null;
      this.gname = null;
      this.devmaj = 0;
      this.devmin = 0;
      this.atime = null;
      this.ctime = null;
      if (Buffer.isBuffer(data)) {
        this.decode(data, off || 0, ex, gex);
      } else if (data) {
        this.set(data);
      }
    }
    decode(buf, off, ex, gex) {
      if (!off) {
        off = 0;
      }
      if (!buf || !(buf.length >= off + 512)) {
        throw new Error("need 512 bytes for header");
      }
      this.path = decString(buf, off, 100);
      this.mode = decNumber(buf, off + 100, 8);
      this.uid = decNumber(buf, off + 108, 8);
      this.gid = decNumber(buf, off + 116, 8);
      this.size = decNumber(buf, off + 124, 12);
      this.mtime = decDate(buf, off + 136, 12);
      this.cksum = decNumber(buf, off + 148, 12);
      this[SLURP](ex);
      this[SLURP](gex, true);
      this[TYPE] = decString(buf, off + 156, 1);
      if (this[TYPE] === "") {
        this[TYPE] = "0";
      }
      if (this[TYPE] === "0" && this.path.slice(-1) === "/") {
        this[TYPE] = "5";
      }
      if (this[TYPE] === "5") {
        this.size = 0;
      }
      this.linkpath = decString(buf, off + 157, 100);
      if (buf.slice(off + 257, off + 265).toString() === "ustar\x0000") {
        this.uname = decString(buf, off + 265, 32);
        this.gname = decString(buf, off + 297, 32);
        this.devmaj = decNumber(buf, off + 329, 8);
        this.devmin = decNumber(buf, off + 337, 8);
        if (buf[off + 475] !== 0) {
          const prefix = decString(buf, off + 345, 155);
          this.path = prefix + "/" + this.path;
        } else {
          const prefix = decString(buf, off + 345, 130);
          if (prefix) {
            this.path = prefix + "/" + this.path;
          }
          this.atime = decDate(buf, off + 476, 12);
          this.ctime = decDate(buf, off + 488, 12);
        }
      }
      let sum = 8 * 32;
      for (let i = off;i < off + 148; i++) {
        sum += buf[i];
      }
      for (let i = off + 156;i < off + 512; i++) {
        sum += buf[i];
      }
      this.cksumValid = sum === this.cksum;
      if (this.cksum === null && sum === 8 * 32) {
        this.nullBlock = true;
      }
    }
    [SLURP](ex, global2) {
      for (const k in ex) {
        if (ex[k] !== null && ex[k] !== undefined && !(global2 && k === "path")) {
          this[k] = ex[k];
        }
      }
    }
    encode(buf, off) {
      if (!buf) {
        buf = this.block = Buffer.alloc(512);
        off = 0;
      }
      if (!off) {
        off = 0;
      }
      if (!(buf.length >= off + 512)) {
        throw new Error("need 512 bytes for header");
      }
      const prefixSize = this.ctime || this.atime ? 130 : 155;
      const split = splitPrefix(this.path || "", prefixSize);
      const path = split[0];
      const prefix = split[1];
      this.needPax = split[2];
      this.needPax = encString(buf, off, 100, path) || this.needPax;
      this.needPax = encNumber(buf, off + 100, 8, this.mode) || this.needPax;
      this.needPax = encNumber(buf, off + 108, 8, this.uid) || this.needPax;
      this.needPax = encNumber(buf, off + 116, 8, this.gid) || this.needPax;
      this.needPax = encNumber(buf, off + 124, 12, this.size) || this.needPax;
      this.needPax = encDate(buf, off + 136, 12, this.mtime) || this.needPax;
      buf[off + 156] = this[TYPE].charCodeAt(0);
      this.needPax = encString(buf, off + 157, 100, this.linkpath) || this.needPax;
      buf.write("ustar\x0000", off + 257, 8);
      this.needPax = encString(buf, off + 265, 32, this.uname) || this.needPax;
      this.needPax = encString(buf, off + 297, 32, this.gname) || this.needPax;
      this.needPax = encNumber(buf, off + 329, 8, this.devmaj) || this.needPax;
      this.needPax = encNumber(buf, off + 337, 8, this.devmin) || this.needPax;
      this.needPax = encString(buf, off + 345, prefixSize, prefix) || this.needPax;
      if (buf[off + 475] !== 0) {
        this.needPax = encString(buf, off + 345, 155, prefix) || this.needPax;
      } else {
        this.needPax = encString(buf, off + 345, 130, prefix) || this.needPax;
        this.needPax = encDate(buf, off + 476, 12, this.atime) || this.needPax;
        this.needPax = encDate(buf, off + 488, 12, this.ctime) || this.needPax;
      }
      let sum = 8 * 32;
      for (let i = off;i < off + 148; i++) {
        sum += buf[i];
      }
      for (let i = off + 156;i < off + 512; i++) {
        sum += buf[i];
      }
      this.cksum = sum;
      encNumber(buf, off + 148, 8, this.cksum);
      this.cksumValid = true;
      return this.needPax;
    }
    set(data) {
      for (const i in data) {
        if (data[i] !== null && data[i] !== undefined) {
          this[i] = data[i];
        }
      }
    }
    get type() {
      return types.name.get(this[TYPE]) || this[TYPE];
    }
    get typeKey() {
      return this[TYPE];
    }
    set type(type) {
      if (types.code.has(type)) {
        this[TYPE] = types.code.get(type);
      } else {
        this[TYPE] = type;
      }
    }
  }
  var splitPrefix = (p, prefixSize) => {
    const pathSize = 100;
    let pp = p;
    let prefix = "";
    let ret;
    const root = pathModule.parse(p).root || ".";
    if (Buffer.byteLength(pp) < pathSize) {
      ret = [pp, prefix, false];
    } else {
      prefix = pathModule.dirname(pp);
      pp = pathModule.basename(pp);
      do {
        if (Buffer.byteLength(pp) <= pathSize && Buffer.byteLength(prefix) <= prefixSize) {
          ret = [pp, prefix, false];
        } else if (Buffer.byteLength(pp) > pathSize && Buffer.byteLength(prefix) <= prefixSize) {
          ret = [pp.slice(0, pathSize - 1), prefix, true];
        } else {
          pp = pathModule.join(pathModule.basename(prefix), pp);
          prefix = pathModule.dirname(prefix);
        }
      } while (prefix !== root && !ret);
      if (!ret) {
        ret = [p.slice(0, pathSize - 1), "", true];
      }
    }
    return ret;
  };
  var decString = (buf, off, size) => buf.slice(off, off + size).toString("utf8").replace(/\0.*/, "");
  var decDate = (buf, off, size) => numToDate(decNumber(buf, off, size));
  var numToDate = (num) => num === null ? null : new Date(num * 1000);
  var decNumber = (buf, off, size) => buf[off] & 128 ? large.parse(buf.slice(off, off + size)) : decSmallNumber(buf, off, size);
  var nanNull = (value) => isNaN(value) ? null : value;
  var decSmallNumber = (buf, off, size) => nanNull(parseInt(buf.slice(off, off + size).toString("utf8").replace(/\0.*$/, "").trim(), 8));
  var MAXNUM = {
    12: 8589934591,
    8: 2097151
  };
  var encNumber = (buf, off, size, number4) => number4 === null ? false : number4 > MAXNUM[size] || number4 < 0 ? (large.encode(number4, buf.slice(off, off + size)), true) : (encSmallNumber(buf, off, size, number4), false);
  var encSmallNumber = (buf, off, size, number4) => buf.write(octalString(number4, size), off, size, "ascii");
  var octalString = (number4, size) => padOctal(Math.floor(number4).toString(8), size);
  var padOctal = (string4, size) => (string4.length === size - 1 ? string4 : new Array(size - string4.length - 1).join("0") + string4 + " ") + "\x00";
  var encDate = (buf, off, size, date5) => date5 === null ? false : encNumber(buf, off, size, date5.getTime() / 1000);
  var NULLS = new Array(156).join("\x00");
  var encString = (buf, off, size, string4) => string4 === null ? false : (buf.write(string4 + NULLS, off, size, "utf8"), string4.length !== Buffer.byteLength(string4) || string4.length > size);
  module.exports = Header;
});

// node_modules/tar/lib/pax.js
var require_pax = __commonJS((exports, module) => {
  var Header = require_header();
  var path = __require("path");

  class Pax {
    constructor(obj, global2) {
      this.atime = obj.atime || null;
      this.charset = obj.charset || null;
      this.comment = obj.comment || null;
      this.ctime = obj.ctime || null;
      this.gid = obj.gid || null;
      this.gname = obj.gname || null;
      this.linkpath = obj.linkpath || null;
      this.mtime = obj.mtime || null;
      this.path = obj.path || null;
      this.size = obj.size || null;
      this.uid = obj.uid || null;
      this.uname = obj.uname || null;
      this.dev = obj.dev || null;
      this.ino = obj.ino || null;
      this.nlink = obj.nlink || null;
      this.global = global2 || false;
    }
    encode() {
      const body = this.encodeBody();
      if (body === "") {
        return null;
      }
      const bodyLen = Buffer.byteLength(body);
      const bufLen = 512 * Math.ceil(1 + bodyLen / 512);
      const buf = Buffer.allocUnsafe(bufLen);
      for (let i = 0;i < 512; i++) {
        buf[i] = 0;
      }
      new Header({
        path: ("PaxHeader/" + path.basename(this.path)).slice(0, 99),
        mode: this.mode || 420,
        uid: this.uid || null,
        gid: this.gid || null,
        size: bodyLen,
        mtime: this.mtime || null,
        type: this.global ? "GlobalExtendedHeader" : "ExtendedHeader",
        linkpath: "",
        uname: this.uname || "",
        gname: this.gname || "",
        devmaj: 0,
        devmin: 0,
        atime: this.atime || null,
        ctime: this.ctime || null
      }).encode(buf);
      buf.write(body, 512, bodyLen, "utf8");
      for (let i = bodyLen + 512;i < buf.length; i++) {
        buf[i] = 0;
      }
      return buf;
    }
    encodeBody() {
      return this.encodeField("path") + this.encodeField("ctime") + this.encodeField("atime") + this.encodeField("dev") + this.encodeField("ino") + this.encodeField("nlink") + this.encodeField("charset") + this.encodeField("comment") + this.encodeField("gid") + this.encodeField("gname") + this.encodeField("linkpath") + this.encodeField("mtime") + this.encodeField("size") + this.encodeField("uid") + this.encodeField("uname");
    }
    encodeField(field) {
      if (this[field] === null || this[field] === undefined) {
        return "";
      }
      const v = this[field] instanceof Date ? this[field].getTime() / 1000 : this[field];
      const s = " " + (field === "dev" || field === "ino" || field === "nlink" ? "SCHILY." : "") + field + "=" + v + `
`;
      const byteLen = Buffer.byteLength(s);
      let digits = Math.floor(Math.log(byteLen) / Math.log(10)) + 1;
      if (byteLen + digits >= Math.pow(10, digits)) {
        digits += 1;
      }
      const len = digits + byteLen;
      return len + s;
    }
  }
  Pax.parse = (string4, ex, g) => new Pax(merge2(parseKV(string4), ex), g);
  var merge2 = (a, b) => b ? Object.keys(a).reduce((s, k) => (s[k] = a[k], s), b) : a;
  var parseKV = (string4) => string4.replace(/\n$/, "").split(`
`).reduce(parseKVLine, Object.create(null));
  var parseKVLine = (set2, line) => {
    const n = parseInt(line, 10);
    if (n !== Buffer.byteLength(line) + 1) {
      return set2;
    }
    line = line.slice((n + " ").length);
    const kv = line.split("=");
    const k = kv.shift().replace(/^SCHILY\.(dev|ino|nlink)/, "$1");
    if (!k) {
      return set2;
    }
    const v = kv.join("=");
    set2[k] = /^([A-Z]+\.)?([mac]|birth|creation)time$/.test(k) ? new Date(v * 1000) : /^[0-9]+$/.test(v) ? +v : v;
    return set2;
  };
  module.exports = Pax;
});

// node_modules/tar/lib/strip-trailing-slashes.js
var require_strip_trailing_slashes = __commonJS((exports, module) => {
  module.exports = (str2) => {
    let i = str2.length - 1;
    let slashesStart = -1;
    while (i > -1 && str2.charAt(i) === "/") {
      slashesStart = i;
      i--;
    }
    return slashesStart === -1 ? str2 : str2.slice(0, slashesStart);
  };
});

// node_modules/tar/lib/warn-mixin.js
var require_warn_mixin = __commonJS((exports, module) => {
  module.exports = (Base) => class extends Base {
    warn(code, message, data = {}) {
      if (this.file) {
        data.file = this.file;
      }
      if (this.cwd) {
        data.cwd = this.cwd;
      }
      data.code = message instanceof Error && message.code || code;
      data.tarCode = code;
      if (!this.strict && data.recoverable !== false) {
        if (message instanceof Error) {
          data = Object.assign(message, data);
          message = message.message;
        }
        this.emit("warn", data.tarCode, message, data);
      } else if (message instanceof Error) {
        this.emit("error", Object.assign(message, data));
      } else {
        this.emit("error", Object.assign(new Error(`${code}: ${message}`), data));
      }
    }
  };
});

// node_modules/tar/lib/winchars.js
var require_winchars = __commonJS((exports, module) => {
  var raw = [
    "|",
    "<",
    ">",
    "?",
    ":"
  ];
  var win = raw.map((char) => String.fromCharCode(61440 + char.charCodeAt(0)));
  var toWin = new Map(raw.map((char, i) => [char, win[i]]));
  var toRaw = new Map(win.map((char, i) => [char, raw[i]]));
  module.exports = {
    encode: (s) => raw.reduce((s2, c) => s2.split(c).join(toWin.get(c)), s),
    decode: (s) => win.reduce((s2, c) => s2.split(c).join(toRaw.get(c)), s)
  };
});

// node_modules/tar/lib/strip-absolute-path.js
var require_strip_absolute_path = __commonJS((exports, module) => {
  var { isAbsolute, parse: parse6 } = __require("path").win32;
  module.exports = (path) => {
    let r = "";
    let parsed = parse6(path);
    while (isAbsolute(path) || parsed.root) {
      const root = path.charAt(0) === "/" && path.slice(0, 4) !== "//?/" ? "/" : parsed.root;
      path = path.slice(root.length);
      r += root;
      parsed = parse6(path);
    }
    return [r, path];
  };
});

// node_modules/tar/lib/mode-fix.js
var require_mode_fix = __commonJS((exports, module) => {
  module.exports = (mode, isDir, portable) => {
    mode &= 4095;
    if (portable) {
      mode = (mode | 384) & ~18;
    }
    if (isDir) {
      if (mode & 256) {
        mode |= 64;
      }
      if (mode & 32) {
        mode |= 8;
      }
      if (mode & 4) {
        mode |= 1;
      }
    }
    return mode;
  };
});

// node_modules/tar/lib/write-entry.js
var require_write_entry = __commonJS((exports, module) => {
  var { Minipass } = require_minipass();
  var Pax = require_pax();
  var Header = require_header();
  var fs = __require("fs");
  var path = __require("path");
  var normPath = require_normalize_windows_path();
  var stripSlash = require_strip_trailing_slashes();
  var prefixPath = (path2, prefix) => {
    if (!prefix) {
      return normPath(path2);
    }
    path2 = normPath(path2).replace(/^\.(\/|$)/, "");
    return stripSlash(prefix) + "/" + path2;
  };
  var maxReadSize = 16 * 1024 * 1024;
  var PROCESS = Symbol("process");
  var FILE = Symbol("file");
  var DIRECTORY = Symbol("directory");
  var SYMLINK = Symbol("symlink");
  var HARDLINK = Symbol("hardlink");
  var HEADER = Symbol("header");
  var READ = Symbol("read");
  var LSTAT = Symbol("lstat");
  var ONLSTAT = Symbol("onlstat");
  var ONREAD = Symbol("onread");
  var ONREADLINK = Symbol("onreadlink");
  var OPENFILE = Symbol("openfile");
  var ONOPENFILE = Symbol("onopenfile");
  var CLOSE = Symbol("close");
  var MODE = Symbol("mode");
  var AWAITDRAIN = Symbol("awaitDrain");
  var ONDRAIN = Symbol("ondrain");
  var PREFIX = Symbol("prefix");
  var HAD_ERROR = Symbol("hadError");
  var warner = require_warn_mixin();
  var winchars = require_winchars();
  var stripAbsolutePath = require_strip_absolute_path();
  var modeFix = require_mode_fix();
  var WriteEntry = warner(class WriteEntry2 extends Minipass {
    constructor(p, opt) {
      opt = opt || {};
      super(opt);
      if (typeof p !== "string") {
        throw new TypeError("path is required");
      }
      this.path = normPath(p);
      this.portable = !!opt.portable;
      this.myuid = process.getuid && process.getuid() || 0;
      this.myuser = process.env.USER || "";
      this.maxReadSize = opt.maxReadSize || maxReadSize;
      this.linkCache = opt.linkCache || new Map;
      this.statCache = opt.statCache || new Map;
      this.preservePaths = !!opt.preservePaths;
      this.cwd = normPath(opt.cwd || process.cwd());
      this.strict = !!opt.strict;
      this.noPax = !!opt.noPax;
      this.noMtime = !!opt.noMtime;
      this.mtime = opt.mtime || null;
      this.prefix = opt.prefix ? normPath(opt.prefix) : null;
      this.fd = null;
      this.blockLen = null;
      this.blockRemain = null;
      this.buf = null;
      this.offset = null;
      this.length = null;
      this.pos = null;
      this.remain = null;
      if (typeof opt.onwarn === "function") {
        this.on("warn", opt.onwarn);
      }
      let pathWarn = false;
      if (!this.preservePaths) {
        const [root, stripped] = stripAbsolutePath(this.path);
        if (root) {
          this.path = stripped;
          pathWarn = root;
        }
      }
      this.win32 = !!opt.win32 || process.platform === "win32";
      if (this.win32) {
        this.path = winchars.decode(this.path.replace(/\\/g, "/"));
        p = p.replace(/\\/g, "/");
      }
      this.absolute = normPath(opt.absolute || path.resolve(this.cwd, p));
      if (this.path === "") {
        this.path = "./";
      }
      if (pathWarn) {
        this.warn("TAR_ENTRY_INFO", `stripping ${pathWarn} from absolute path`, {
          entry: this,
          path: pathWarn + this.path
        });
      }
      if (this.statCache.has(this.absolute)) {
        this[ONLSTAT](this.statCache.get(this.absolute));
      } else {
        this[LSTAT]();
      }
    }
    emit(ev, ...data) {
      if (ev === "error") {
        this[HAD_ERROR] = true;
      }
      return super.emit(ev, ...data);
    }
    [LSTAT]() {
      fs.lstat(this.absolute, (er, stat) => {
        if (er) {
          return this.emit("error", er);
        }
        this[ONLSTAT](stat);
      });
    }
    [ONLSTAT](stat) {
      this.statCache.set(this.absolute, stat);
      this.stat = stat;
      if (!stat.isFile()) {
        stat.size = 0;
      }
      this.type = getType(stat);
      this.emit("stat", stat);
      this[PROCESS]();
    }
    [PROCESS]() {
      switch (this.type) {
        case "File":
          return this[FILE]();
        case "Directory":
          return this[DIRECTORY]();
        case "SymbolicLink":
          return this[SYMLINK]();
        default:
          return this.end();
      }
    }
    [MODE](mode) {
      return modeFix(mode, this.type === "Directory", this.portable);
    }
    [PREFIX](path2) {
      return prefixPath(path2, this.prefix);
    }
    [HEADER]() {
      if (this.type === "Directory" && this.portable) {
        this.noMtime = true;
      }
      this.header = new Header({
        path: this[PREFIX](this.path),
        linkpath: this.type === "Link" ? this[PREFIX](this.linkpath) : this.linkpath,
        mode: this[MODE](this.stat.mode),
        uid: this.portable ? null : this.stat.uid,
        gid: this.portable ? null : this.stat.gid,
        size: this.stat.size,
        mtime: this.noMtime ? null : this.mtime || this.stat.mtime,
        type: this.type,
        uname: this.portable ? null : this.stat.uid === this.myuid ? this.myuser : "",
        atime: this.portable ? null : this.stat.atime,
        ctime: this.portable ? null : this.stat.ctime
      });
      if (this.header.encode() && !this.noPax) {
        super.write(new Pax({
          atime: this.portable ? null : this.header.atime,
          ctime: this.portable ? null : this.header.ctime,
          gid: this.portable ? null : this.header.gid,
          mtime: this.noMtime ? null : this.mtime || this.header.mtime,
          path: this[PREFIX](this.path),
          linkpath: this.type === "Link" ? this[PREFIX](this.linkpath) : this.linkpath,
          size: this.header.size,
          uid: this.portable ? null : this.header.uid,
          uname: this.portable ? null : this.header.uname,
          dev: this.portable ? null : this.stat.dev,
          ino: this.portable ? null : this.stat.ino,
          nlink: this.portable ? null : this.stat.nlink
        }).encode());
      }
      super.write(this.header.block);
    }
    [DIRECTORY]() {
      if (this.path.slice(-1) !== "/") {
        this.path += "/";
      }
      this.stat.size = 0;
      this[HEADER]();
      this.end();
    }
    [SYMLINK]() {
      fs.readlink(this.absolute, (er, linkpath) => {
        if (er) {
          return this.emit("error", er);
        }
        this[ONREADLINK](linkpath);
      });
    }
    [ONREADLINK](linkpath) {
      this.linkpath = normPath(linkpath);
      this[HEADER]();
      this.end();
    }
    [HARDLINK](linkpath) {
      this.type = "Link";
      this.linkpath = normPath(path.relative(this.cwd, linkpath));
      this.stat.size = 0;
      this[HEADER]();
      this.end();
    }
    [FILE]() {
      if (this.stat.nlink > 1) {
        const linkKey = this.stat.dev + ":" + this.stat.ino;
        if (this.linkCache.has(linkKey)) {
          const linkpath = this.linkCache.get(linkKey);
          if (linkpath.indexOf(this.cwd) === 0) {
            return this[HARDLINK](linkpath);
          }
        }
        this.linkCache.set(linkKey, this.absolute);
      }
      this[HEADER]();
      if (this.stat.size === 0) {
        return this.end();
      }
      this[OPENFILE]();
    }
    [OPENFILE]() {
      fs.open(this.absolute, "r", (er, fd) => {
        if (er) {
          return this.emit("error", er);
        }
        this[ONOPENFILE](fd);
      });
    }
    [ONOPENFILE](fd) {
      this.fd = fd;
      if (this[HAD_ERROR]) {
        return this[CLOSE]();
      }
      this.blockLen = 512 * Math.ceil(this.stat.size / 512);
      this.blockRemain = this.blockLen;
      const bufLen = Math.min(this.blockLen, this.maxReadSize);
      this.buf = Buffer.allocUnsafe(bufLen);
      this.offset = 0;
      this.pos = 0;
      this.remain = this.stat.size;
      this.length = this.buf.length;
      this[READ]();
    }
    [READ]() {
      const { fd, buf, offset, length, pos } = this;
      fs.read(fd, buf, offset, length, pos, (er, bytesRead) => {
        if (er) {
          return this[CLOSE](() => this.emit("error", er));
        }
        this[ONREAD](bytesRead);
      });
    }
    [CLOSE](cb) {
      fs.close(this.fd, cb);
    }
    [ONREAD](bytesRead) {
      if (bytesRead <= 0 && this.remain > 0) {
        const er = new Error("encountered unexpected EOF");
        er.path = this.absolute;
        er.syscall = "read";
        er.code = "EOF";
        return this[CLOSE](() => this.emit("error", er));
      }
      if (bytesRead > this.remain) {
        const er = new Error("did not encounter expected EOF");
        er.path = this.absolute;
        er.syscall = "read";
        er.code = "EOF";
        return this[CLOSE](() => this.emit("error", er));
      }
      if (bytesRead === this.remain) {
        for (let i = bytesRead;i < this.length && bytesRead < this.blockRemain; i++) {
          this.buf[i + this.offset] = 0;
          bytesRead++;
          this.remain++;
        }
      }
      const writeBuf = this.offset === 0 && bytesRead === this.buf.length ? this.buf : this.buf.slice(this.offset, this.offset + bytesRead);
      const flushed = this.write(writeBuf);
      if (!flushed) {
        this[AWAITDRAIN](() => this[ONDRAIN]());
      } else {
        this[ONDRAIN]();
      }
    }
    [AWAITDRAIN](cb) {
      this.once("drain", cb);
    }
    write(writeBuf) {
      if (this.blockRemain < writeBuf.length) {
        const er = new Error("writing more data than expected");
        er.path = this.absolute;
        return this.emit("error", er);
      }
      this.remain -= writeBuf.length;
      this.blockRemain -= writeBuf.length;
      this.pos += writeBuf.length;
      this.offset += writeBuf.length;
      return super.write(writeBuf);
    }
    [ONDRAIN]() {
      if (!this.remain) {
        if (this.blockRemain) {
          super.write(Buffer.alloc(this.blockRemain));
        }
        return this[CLOSE]((er) => er ? this.emit("error", er) : this.end());
      }
      if (this.offset >= this.length) {
        this.buf = Buffer.allocUnsafe(Math.min(this.blockRemain, this.buf.length));
        this.offset = 0;
      }
      this.length = this.buf.length - this.offset;
      this[READ]();
    }
  });

  class WriteEntrySync extends WriteEntry {
    [LSTAT]() {
      this[ONLSTAT](fs.lstatSync(this.absolute));
    }
    [SYMLINK]() {
      this[ONREADLINK](fs.readlinkSync(this.absolute));
    }
    [OPENFILE]() {
      this[ONOPENFILE](fs.openSync(this.absolute, "r"));
    }
    [READ]() {
      let threw = true;
      try {
        const { fd, buf, offset, length, pos } = this;
        const bytesRead = fs.readSync(fd, buf, offset, length, pos);
        this[ONREAD](bytesRead);
        threw = false;
      } finally {
        if (threw) {
          try {
            this[CLOSE](() => {});
          } catch (er) {}
        }
      }
    }
    [AWAITDRAIN](cb) {
      cb();
    }
    [CLOSE](cb) {
      fs.closeSync(this.fd);
      cb();
    }
  }
  var WriteEntryTar = warner(class WriteEntryTar2 extends Minipass {
    constructor(readEntry, opt) {
      opt = opt || {};
      super(opt);
      this.preservePaths = !!opt.preservePaths;
      this.portable = !!opt.portable;
      this.strict = !!opt.strict;
      this.noPax = !!opt.noPax;
      this.noMtime = !!opt.noMtime;
      this.readEntry = readEntry;
      this.type = readEntry.type;
      if (this.type === "Directory" && this.portable) {
        this.noMtime = true;
      }
      this.prefix = opt.prefix || null;
      this.path = normPath(readEntry.path);
      this.mode = this[MODE](readEntry.mode);
      this.uid = this.portable ? null : readEntry.uid;
      this.gid = this.portable ? null : readEntry.gid;
      this.uname = this.portable ? null : readEntry.uname;
      this.gname = this.portable ? null : readEntry.gname;
      this.size = readEntry.size;
      this.mtime = this.noMtime ? null : opt.mtime || readEntry.mtime;
      this.atime = this.portable ? null : readEntry.atime;
      this.ctime = this.portable ? null : readEntry.ctime;
      this.linkpath = normPath(readEntry.linkpath);
      if (typeof opt.onwarn === "function") {
        this.on("warn", opt.onwarn);
      }
      let pathWarn = false;
      if (!this.preservePaths) {
        const [root, stripped] = stripAbsolutePath(this.path);
        if (root) {
          this.path = stripped;
          pathWarn = root;
        }
      }
      this.remain = readEntry.size;
      this.blockRemain = readEntry.startBlockSize;
      this.header = new Header({
        path: this[PREFIX](this.path),
        linkpath: this.type === "Link" ? this[PREFIX](this.linkpath) : this.linkpath,
        mode: this.mode,
        uid: this.portable ? null : this.uid,
        gid: this.portable ? null : this.gid,
        size: this.size,
        mtime: this.noMtime ? null : this.mtime,
        type: this.type,
        uname: this.portable ? null : this.uname,
        atime: this.portable ? null : this.atime,
        ctime: this.portable ? null : this.ctime
      });
      if (pathWarn) {
        this.warn("TAR_ENTRY_INFO", `stripping ${pathWarn} from absolute path`, {
          entry: this,
          path: pathWarn + this.path
        });
      }
      if (this.header.encode() && !this.noPax) {
        super.write(new Pax({
          atime: this.portable ? null : this.atime,
          ctime: this.portable ? null : this.ctime,
          gid: this.portable ? null : this.gid,
          mtime: this.noMtime ? null : this.mtime,
          path: this[PREFIX](this.path),
          linkpath: this.type === "Link" ? this[PREFIX](this.linkpath) : this.linkpath,
          size: this.size,
          uid: this.portable ? null : this.uid,
          uname: this.portable ? null : this.uname,
          dev: this.portable ? null : this.readEntry.dev,
          ino: this.portable ? null : this.readEntry.ino,
          nlink: this.portable ? null : this.readEntry.nlink
        }).encode());
      }
      super.write(this.header.block);
      readEntry.pipe(this);
    }
    [PREFIX](path2) {
      return prefixPath(path2, this.prefix);
    }
    [MODE](mode) {
      return modeFix(mode, this.type === "Directory", this.portable);
    }
    write(data) {
      const writeLen = data.length;
      if (writeLen > this.blockRemain) {
        throw new Error("writing more to entry than is appropriate");
      }
      this.blockRemain -= writeLen;
      return super.write(data);
    }
    end() {
      if (this.blockRemain) {
        super.write(Buffer.alloc(this.blockRemain));
      }
      return super.end();
    }
  });
  WriteEntry.Sync = WriteEntrySync;
  WriteEntry.Tar = WriteEntryTar;
  var getType = (stat) => stat.isFile() ? "File" : stat.isDirectory() ? "Directory" : stat.isSymbolicLink() ? "SymbolicLink" : "Unsupported";
  module.exports = WriteEntry;
});

// node_modules/yallist/iterator.js
var require_iterator = __commonJS((exports, module) => {
  module.exports = function(Yallist) {
    Yallist.prototype[Symbol.iterator] = function* () {
      for (let walker = this.head;walker; walker = walker.next) {
        yield walker.value;
      }
    };
  };
});

// node_modules/yallist/yallist.js
var require_yallist = __commonJS((exports, module) => {
  module.exports = Yallist;
  Yallist.Node = Node;
  Yallist.create = Yallist;
  function Yallist(list) {
    var self2 = this;
    if (!(self2 instanceof Yallist)) {
      self2 = new Yallist;
    }
    self2.tail = null;
    self2.head = null;
    self2.length = 0;
    if (list && typeof list.forEach === "function") {
      list.forEach(function(item) {
        self2.push(item);
      });
    } else if (arguments.length > 0) {
      for (var i = 0, l = arguments.length;i < l; i++) {
        self2.push(arguments[i]);
      }
    }
    return self2;
  }
  Yallist.prototype.removeNode = function(node) {
    if (node.list !== this) {
      throw new Error("removing node which does not belong to this list");
    }
    var next = node.next;
    var prev = node.prev;
    if (next) {
      next.prev = prev;
    }
    if (prev) {
      prev.next = next;
    }
    if (node === this.head) {
      this.head = next;
    }
    if (node === this.tail) {
      this.tail = prev;
    }
    node.list.length--;
    node.next = null;
    node.prev = null;
    node.list = null;
    return next;
  };
  Yallist.prototype.unshiftNode = function(node) {
    if (node === this.head) {
      return;
    }
    if (node.list) {
      node.list.removeNode(node);
    }
    var head = this.head;
    node.list = this;
    node.next = head;
    if (head) {
      head.prev = node;
    }
    this.head = node;
    if (!this.tail) {
      this.tail = node;
    }
    this.length++;
  };
  Yallist.prototype.pushNode = function(node) {
    if (node === this.tail) {
      return;
    }
    if (node.list) {
      node.list.removeNode(node);
    }
    var tail = this.tail;
    node.list = this;
    node.prev = tail;
    if (tail) {
      tail.next = node;
    }
    this.tail = node;
    if (!this.head) {
      this.head = node;
    }
    this.length++;
  };
  Yallist.prototype.push = function() {
    for (var i = 0, l = arguments.length;i < l; i++) {
      push(this, arguments[i]);
    }
    return this.length;
  };
  Yallist.prototype.unshift = function() {
    for (var i = 0, l = arguments.length;i < l; i++) {
      unshift(this, arguments[i]);
    }
    return this.length;
  };
  Yallist.prototype.pop = function() {
    if (!this.tail) {
      return;
    }
    var res = this.tail.value;
    this.tail = this.tail.prev;
    if (this.tail) {
      this.tail.next = null;
    } else {
      this.head = null;
    }
    this.length--;
    return res;
  };
  Yallist.prototype.shift = function() {
    if (!this.head) {
      return;
    }
    var res = this.head.value;
    this.head = this.head.next;
    if (this.head) {
      this.head.prev = null;
    } else {
      this.tail = null;
    }
    this.length--;
    return res;
  };
  Yallist.prototype.forEach = function(fn, thisp) {
    thisp = thisp || this;
    for (var walker = this.head, i = 0;walker !== null; i++) {
      fn.call(thisp, walker.value, i, this);
      walker = walker.next;
    }
  };
  Yallist.prototype.forEachReverse = function(fn, thisp) {
    thisp = thisp || this;
    for (var walker = this.tail, i = this.length - 1;walker !== null; i--) {
      fn.call(thisp, walker.value, i, this);
      walker = walker.prev;
    }
  };
  Yallist.prototype.get = function(n) {
    for (var i = 0, walker = this.head;walker !== null && i < n; i++) {
      walker = walker.next;
    }
    if (i === n && walker !== null) {
      return walker.value;
    }
  };
  Yallist.prototype.getReverse = function(n) {
    for (var i = 0, walker = this.tail;walker !== null && i < n; i++) {
      walker = walker.prev;
    }
    if (i === n && walker !== null) {
      return walker.value;
    }
  };
  Yallist.prototype.map = function(fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist;
    for (var walker = this.head;walker !== null; ) {
      res.push(fn.call(thisp, walker.value, this));
      walker = walker.next;
    }
    return res;
  };
  Yallist.prototype.mapReverse = function(fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist;
    for (var walker = this.tail;walker !== null; ) {
      res.push(fn.call(thisp, walker.value, this));
      walker = walker.prev;
    }
    return res;
  };
  Yallist.prototype.reduce = function(fn, initial) {
    var acc;
    var walker = this.head;
    if (arguments.length > 1) {
      acc = initial;
    } else if (this.head) {
      walker = this.head.next;
      acc = this.head.value;
    } else {
      throw new TypeError("Reduce of empty list with no initial value");
    }
    for (var i = 0;walker !== null; i++) {
      acc = fn(acc, walker.value, i);
      walker = walker.next;
    }
    return acc;
  };
  Yallist.prototype.reduceReverse = function(fn, initial) {
    var acc;
    var walker = this.tail;
    if (arguments.length > 1) {
      acc = initial;
    } else if (this.tail) {
      walker = this.tail.prev;
      acc = this.tail.value;
    } else {
      throw new TypeError("Reduce of empty list with no initial value");
    }
    for (var i = this.length - 1;walker !== null; i--) {
      acc = fn(acc, walker.value, i);
      walker = walker.prev;
    }
    return acc;
  };
  Yallist.prototype.toArray = function() {
    var arr = new Array(this.length);
    for (var i = 0, walker = this.head;walker !== null; i++) {
      arr[i] = walker.value;
      walker = walker.next;
    }
    return arr;
  };
  Yallist.prototype.toArrayReverse = function() {
    var arr = new Array(this.length);
    for (var i = 0, walker = this.tail;walker !== null; i++) {
      arr[i] = walker.value;
      walker = walker.prev;
    }
    return arr;
  };
  Yallist.prototype.slice = function(from, to) {
    to = to || this.length;
    if (to < 0) {
      to += this.length;
    }
    from = from || 0;
    if (from < 0) {
      from += this.length;
    }
    var ret = new Yallist;
    if (to < from || to < 0) {
      return ret;
    }
    if (from < 0) {
      from = 0;
    }
    if (to > this.length) {
      to = this.length;
    }
    for (var i = 0, walker = this.head;walker !== null && i < from; i++) {
      walker = walker.next;
    }
    for (;walker !== null && i < to; i++, walker = walker.next) {
      ret.push(walker.value);
    }
    return ret;
  };
  Yallist.prototype.sliceReverse = function(from, to) {
    to = to || this.length;
    if (to < 0) {
      to += this.length;
    }
    from = from || 0;
    if (from < 0) {
      from += this.length;
    }
    var ret = new Yallist;
    if (to < from || to < 0) {
      return ret;
    }
    if (from < 0) {
      from = 0;
    }
    if (to > this.length) {
      to = this.length;
    }
    for (var i = this.length, walker = this.tail;walker !== null && i > to; i--) {
      walker = walker.prev;
    }
    for (;walker !== null && i > from; i--, walker = walker.prev) {
      ret.push(walker.value);
    }
    return ret;
  };
  Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
    if (start > this.length) {
      start = this.length - 1;
    }
    if (start < 0) {
      start = this.length + start;
    }
    for (var i = 0, walker = this.head;walker !== null && i < start; i++) {
      walker = walker.next;
    }
    var ret = [];
    for (var i = 0;walker && i < deleteCount; i++) {
      ret.push(walker.value);
      walker = this.removeNode(walker);
    }
    if (walker === null) {
      walker = this.tail;
    }
    if (walker !== this.head && walker !== this.tail) {
      walker = walker.prev;
    }
    for (var i = 0;i < nodes.length; i++) {
      walker = insert(this, walker, nodes[i]);
    }
    return ret;
  };
  Yallist.prototype.reverse = function() {
    var head = this.head;
    var tail = this.tail;
    for (var walker = head;walker !== null; walker = walker.prev) {
      var p = walker.prev;
      walker.prev = walker.next;
      walker.next = p;
    }
    this.head = tail;
    this.tail = head;
    return this;
  };
  function insert(self2, node, value) {
    var inserted = node === self2.head ? new Node(value, null, node, self2) : new Node(value, node, node.next, self2);
    if (inserted.next === null) {
      self2.tail = inserted;
    }
    if (inserted.prev === null) {
      self2.head = inserted;
    }
    self2.length++;
    return inserted;
  }
  function push(self2, item) {
    self2.tail = new Node(item, self2.tail, null, self2);
    if (!self2.head) {
      self2.head = self2.tail;
    }
    self2.length++;
  }
  function unshift(self2, item) {
    self2.head = new Node(item, null, self2.head, self2);
    if (!self2.tail) {
      self2.tail = self2.head;
    }
    self2.length++;
  }
  function Node(value, prev, next, list) {
    if (!(this instanceof Node)) {
      return new Node(value, prev, next, list);
    }
    this.list = list;
    this.value = value;
    if (prev) {
      prev.next = this;
      this.prev = prev;
    } else {
      this.prev = null;
    }
    if (next) {
      next.prev = this;
      this.next = next;
    } else {
      this.next = null;
    }
  }
  try {
    require_iterator()(Yallist);
  } catch (er) {}
});

// node_modules/tar/lib/pack.js
var require_pack = __commonJS((exports, module) => {
  class PackJob {
    constructor(path2, absolute) {
      this.path = path2 || "./";
      this.absolute = absolute;
      this.entry = null;
      this.stat = null;
      this.readdir = null;
      this.pending = false;
      this.ignore = false;
      this.piped = false;
    }
  }
  var { Minipass } = require_minipass();
  var zlib = require_minizlib();
  var ReadEntry = require_read_entry();
  var WriteEntry = require_write_entry();
  var WriteEntrySync = WriteEntry.Sync;
  var WriteEntryTar = WriteEntry.Tar;
  var Yallist = require_yallist();
  var EOF = Buffer.alloc(1024);
  var ONSTAT = Symbol("onStat");
  var ENDED = Symbol("ended");
  var QUEUE = Symbol("queue");
  var CURRENT = Symbol("current");
  var PROCESS = Symbol("process");
  var PROCESSING = Symbol("processing");
  var PROCESSJOB = Symbol("processJob");
  var JOBS = Symbol("jobs");
  var JOBDONE = Symbol("jobDone");
  var ADDFSENTRY = Symbol("addFSEntry");
  var ADDTARENTRY = Symbol("addTarEntry");
  var STAT = Symbol("stat");
  var READDIR = Symbol("readdir");
  var ONREADDIR = Symbol("onreaddir");
  var PIPE = Symbol("pipe");
  var ENTRY = Symbol("entry");
  var ENTRYOPT = Symbol("entryOpt");
  var WRITEENTRYCLASS = Symbol("writeEntryClass");
  var WRITE = Symbol("write");
  var ONDRAIN = Symbol("ondrain");
  var fs = __require("fs");
  var path = __require("path");
  var warner = require_warn_mixin();
  var normPath = require_normalize_windows_path();
  var Pack = warner(class Pack2 extends Minipass {
    constructor(opt) {
      super(opt);
      opt = opt || Object.create(null);
      this.opt = opt;
      this.file = opt.file || "";
      this.cwd = opt.cwd || process.cwd();
      this.maxReadSize = opt.maxReadSize;
      this.preservePaths = !!opt.preservePaths;
      this.strict = !!opt.strict;
      this.noPax = !!opt.noPax;
      this.prefix = normPath(opt.prefix || "");
      this.linkCache = opt.linkCache || new Map;
      this.statCache = opt.statCache || new Map;
      this.readdirCache = opt.readdirCache || new Map;
      this[WRITEENTRYCLASS] = WriteEntry;
      if (typeof opt.onwarn === "function") {
        this.on("warn", opt.onwarn);
      }
      this.portable = !!opt.portable;
      this.zip = null;
      if (opt.gzip || opt.brotli) {
        if (opt.gzip && opt.brotli) {
          throw new TypeError("gzip and brotli are mutually exclusive");
        }
        if (opt.gzip) {
          if (typeof opt.gzip !== "object") {
            opt.gzip = {};
          }
          if (this.portable) {
            opt.gzip.portable = true;
          }
          this.zip = new zlib.Gzip(opt.gzip);
        }
        if (opt.brotli) {
          if (typeof opt.brotli !== "object") {
            opt.brotli = {};
          }
          this.zip = new zlib.BrotliCompress(opt.brotli);
        }
        this.zip.on("data", (chunk) => super.write(chunk));
        this.zip.on("end", (_) => super.end());
        this.zip.on("drain", (_) => this[ONDRAIN]());
        this.on("resume", (_) => this.zip.resume());
      } else {
        this.on("drain", this[ONDRAIN]);
      }
      this.noDirRecurse = !!opt.noDirRecurse;
      this.follow = !!opt.follow;
      this.noMtime = !!opt.noMtime;
      this.mtime = opt.mtime || null;
      this.filter = typeof opt.filter === "function" ? opt.filter : (_) => true;
      this[QUEUE] = new Yallist;
      this[JOBS] = 0;
      this.jobs = +opt.jobs || 4;
      this[PROCESSING] = false;
      this[ENDED] = false;
    }
    [WRITE](chunk) {
      return super.write(chunk);
    }
    add(path2) {
      this.write(path2);
      return this;
    }
    end(path2) {
      if (path2) {
        this.write(path2);
      }
      this[ENDED] = true;
      this[PROCESS]();
      return this;
    }
    write(path2) {
      if (this[ENDED]) {
        throw new Error("write after end");
      }
      if (path2 instanceof ReadEntry) {
        this[ADDTARENTRY](path2);
      } else {
        this[ADDFSENTRY](path2);
      }
      return this.flowing;
    }
    [ADDTARENTRY](p) {
      const absolute = normPath(path.resolve(this.cwd, p.path));
      if (!this.filter(p.path, p)) {
        p.resume();
      } else {
        const job = new PackJob(p.path, absolute, false);
        job.entry = new WriteEntryTar(p, this[ENTRYOPT](job));
        job.entry.on("end", (_) => this[JOBDONE](job));
        this[JOBS] += 1;
        this[QUEUE].push(job);
      }
      this[PROCESS]();
    }
    [ADDFSENTRY](p) {
      const absolute = normPath(path.resolve(this.cwd, p));
      this[QUEUE].push(new PackJob(p, absolute));
      this[PROCESS]();
    }
    [STAT](job) {
      job.pending = true;
      this[JOBS] += 1;
      const stat = this.follow ? "stat" : "lstat";
      fs[stat](job.absolute, (er, stat2) => {
        job.pending = false;
        this[JOBS] -= 1;
        if (er) {
          this.emit("error", er);
        } else {
          this[ONSTAT](job, stat2);
        }
      });
    }
    [ONSTAT](job, stat) {
      this.statCache.set(job.absolute, stat);
      job.stat = stat;
      if (!this.filter(job.path, stat)) {
        job.ignore = true;
      }
      this[PROCESS]();
    }
    [READDIR](job) {
      job.pending = true;
      this[JOBS] += 1;
      fs.readdir(job.absolute, (er, entries) => {
        job.pending = false;
        this[JOBS] -= 1;
        if (er) {
          return this.emit("error", er);
        }
        this[ONREADDIR](job, entries);
      });
    }
    [ONREADDIR](job, entries) {
      this.readdirCache.set(job.absolute, entries);
      job.readdir = entries;
      this[PROCESS]();
    }
    [PROCESS]() {
      if (this[PROCESSING]) {
        return;
      }
      this[PROCESSING] = true;
      for (let w = this[QUEUE].head;w !== null && this[JOBS] < this.jobs; w = w.next) {
        this[PROCESSJOB](w.value);
        if (w.value.ignore) {
          const p = w.next;
          this[QUEUE].removeNode(w);
          w.next = p;
        }
      }
      this[PROCESSING] = false;
      if (this[ENDED] && !this[QUEUE].length && this[JOBS] === 0) {
        if (this.zip) {
          this.zip.end(EOF);
        } else {
          super.write(EOF);
          super.end();
        }
      }
    }
    get [CURRENT]() {
      return this[QUEUE] && this[QUEUE].head && this[QUEUE].head.value;
    }
    [JOBDONE](job) {
      this[QUEUE].shift();
      this[JOBS] -= 1;
      this[PROCESS]();
    }
    [PROCESSJOB](job) {
      if (job.pending) {
        return;
      }
      if (job.entry) {
        if (job === this[CURRENT] && !job.piped) {
          this[PIPE](job);
        }
        return;
      }
      if (!job.stat) {
        if (this.statCache.has(job.absolute)) {
          this[ONSTAT](job, this.statCache.get(job.absolute));
        } else {
          this[STAT](job);
        }
      }
      if (!job.stat) {
        return;
      }
      if (job.ignore) {
        return;
      }
      if (!this.noDirRecurse && job.stat.isDirectory() && !job.readdir) {
        if (this.readdirCache.has(job.absolute)) {
          this[ONREADDIR](job, this.readdirCache.get(job.absolute));
        } else {
          this[READDIR](job);
        }
        if (!job.readdir) {
          return;
        }
      }
      job.entry = this[ENTRY](job);
      if (!job.entry) {
        job.ignore = true;
        return;
      }
      if (job === this[CURRENT] && !job.piped) {
        this[PIPE](job);
      }
    }
    [ENTRYOPT](job) {
      return {
        onwarn: (code, msg, data) => this.warn(code, msg, data),
        noPax: this.noPax,
        cwd: this.cwd,
        absolute: job.absolute,
        preservePaths: this.preservePaths,
        maxReadSize: this.maxReadSize,
        strict: this.strict,
        portable: this.portable,
        linkCache: this.linkCache,
        statCache: this.statCache,
        noMtime: this.noMtime,
        mtime: this.mtime,
        prefix: this.prefix
      };
    }
    [ENTRY](job) {
      this[JOBS] += 1;
      try {
        return new this[WRITEENTRYCLASS](job.path, this[ENTRYOPT](job)).on("end", () => this[JOBDONE](job)).on("error", (er) => this.emit("error", er));
      } catch (er) {
        this.emit("error", er);
      }
    }
    [ONDRAIN]() {
      if (this[CURRENT] && this[CURRENT].entry) {
        this[CURRENT].entry.resume();
      }
    }
    [PIPE](job) {
      job.piped = true;
      if (job.readdir) {
        job.readdir.forEach((entry) => {
          const p = job.path;
          const base = p === "./" ? "" : p.replace(/\/*$/, "/");
          this[ADDFSENTRY](base + entry);
        });
      }
      const source = job.entry;
      const zip = this.zip;
      if (zip) {
        source.on("data", (chunk) => {
          if (!zip.write(chunk)) {
            source.pause();
          }
        });
      } else {
        source.on("data", (chunk) => {
          if (!super.write(chunk)) {
            source.pause();
          }
        });
      }
    }
    pause() {
      if (this.zip) {
        this.zip.pause();
      }
      return super.pause();
    }
  });

  class PackSync extends Pack {
    constructor(opt) {
      super(opt);
      this[WRITEENTRYCLASS] = WriteEntrySync;
    }
    pause() {}
    resume() {}
    [STAT](job) {
      const stat = this.follow ? "statSync" : "lstatSync";
      this[ONSTAT](job, fs[stat](job.absolute));
    }
    [READDIR](job, stat) {
      this[ONREADDIR](job, fs.readdirSync(job.absolute));
    }
    [PIPE](job) {
      const source = job.entry;
      const zip = this.zip;
      if (job.readdir) {
        job.readdir.forEach((entry) => {
          const p = job.path;
          const base = p === "./" ? "" : p.replace(/\/*$/, "/");
          this[ADDFSENTRY](base + entry);
        });
      }
      if (zip) {
        source.on("data", (chunk) => {
          zip.write(chunk);
        });
      } else {
        source.on("data", (chunk) => {
          super[WRITE](chunk);
        });
      }
    }
  }
  Pack.Sync = PackSync;
  module.exports = Pack;
});

// node_modules/fs-minipass/node_modules/minipass/index.js
var require_minipass3 = __commonJS((exports, module) => {
  var proc = typeof process === "object" && process ? process : {
    stdout: null,
    stderr: null
  };
  var EE = __require("events");
  var Stream = __require("stream");
  var SD = __require("string_decoder").StringDecoder;
  var EOF = Symbol("EOF");
  var MAYBE_EMIT_END = Symbol("maybeEmitEnd");
  var EMITTED_END = Symbol("emittedEnd");
  var EMITTING_END = Symbol("emittingEnd");
  var EMITTED_ERROR = Symbol("emittedError");
  var CLOSED = Symbol("closed");
  var READ = Symbol("read");
  var FLUSH = Symbol("flush");
  var FLUSHCHUNK = Symbol("flushChunk");
  var ENCODING = Symbol("encoding");
  var DECODER = Symbol("decoder");
  var FLOWING = Symbol("flowing");
  var PAUSED = Symbol("paused");
  var RESUME = Symbol("resume");
  var BUFFERLENGTH = Symbol("bufferLength");
  var BUFFERPUSH = Symbol("bufferPush");
  var BUFFERSHIFT = Symbol("bufferShift");
  var OBJECTMODE = Symbol("objectMode");
  var DESTROYED = Symbol("destroyed");
  var EMITDATA = Symbol("emitData");
  var EMITEND = Symbol("emitEnd");
  var EMITEND2 = Symbol("emitEnd2");
  var ASYNC = Symbol("async");
  var defer = (fn) => Promise.resolve().then(fn);
  var doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== "1";
  var ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol("asyncIterator not implemented");
  var ITERATOR = doIter && Symbol.iterator || Symbol("iterator not implemented");
  var isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
  var isArrayBuffer = (b) => b instanceof ArrayBuffer || typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0;
  var isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);

  class Pipe {
    constructor(src, dest, opts) {
      this.src = src;
      this.dest = dest;
      this.opts = opts;
      this.ondrain = () => src[RESUME]();
      dest.on("drain", this.ondrain);
    }
    unpipe() {
      this.dest.removeListener("drain", this.ondrain);
    }
    proxyErrors() {}
    end() {
      this.unpipe();
      if (this.opts.end)
        this.dest.end();
    }
  }

  class PipeProxyErrors extends Pipe {
    unpipe() {
      this.src.removeListener("error", this.proxyErrors);
      super.unpipe();
    }
    constructor(src, dest, opts) {
      super(src, dest, opts);
      this.proxyErrors = (er) => dest.emit("error", er);
      src.on("error", this.proxyErrors);
    }
  }
  module.exports = class Minipass extends Stream {
    constructor(options2) {
      super();
      this[FLOWING] = false;
      this[PAUSED] = false;
      this.pipes = [];
      this.buffer = [];
      this[OBJECTMODE] = options2 && options2.objectMode || false;
      if (this[OBJECTMODE])
        this[ENCODING] = null;
      else
        this[ENCODING] = options2 && options2.encoding || null;
      if (this[ENCODING] === "buffer")
        this[ENCODING] = null;
      this[ASYNC] = options2 && !!options2.async || false;
      this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null;
      this[EOF] = false;
      this[EMITTED_END] = false;
      this[EMITTING_END] = false;
      this[CLOSED] = false;
      this[EMITTED_ERROR] = null;
      this.writable = true;
      this.readable = true;
      this[BUFFERLENGTH] = 0;
      this[DESTROYED] = false;
    }
    get bufferLength() {
      return this[BUFFERLENGTH];
    }
    get encoding() {
      return this[ENCODING];
    }
    set encoding(enc) {
      if (this[OBJECTMODE])
        throw new Error("cannot set encoding in objectMode");
      if (this[ENCODING] && enc !== this[ENCODING] && (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))
        throw new Error("cannot change encoding");
      if (this[ENCODING] !== enc) {
        this[DECODER] = enc ? new SD(enc) : null;
        if (this.buffer.length)
          this.buffer = this.buffer.map((chunk) => this[DECODER].write(chunk));
      }
      this[ENCODING] = enc;
    }
    setEncoding(enc) {
      this.encoding = enc;
    }
    get objectMode() {
      return this[OBJECTMODE];
    }
    set objectMode(om) {
      this[OBJECTMODE] = this[OBJECTMODE] || !!om;
    }
    get ["async"]() {
      return this[ASYNC];
    }
    set ["async"](a) {
      this[ASYNC] = this[ASYNC] || !!a;
    }
    write(chunk, encoding, cb) {
      if (this[EOF])
        throw new Error("write after end");
      if (this[DESTROYED]) {
        this.emit("error", Object.assign(new Error("Cannot call write after a stream was destroyed"), { code: "ERR_STREAM_DESTROYED" }));
        return true;
      }
      if (typeof encoding === "function")
        cb = encoding, encoding = "utf8";
      if (!encoding)
        encoding = "utf8";
      const fn = this[ASYNC] ? defer : (f) => f();
      if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
        if (isArrayBufferView(chunk))
          chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
        else if (isArrayBuffer(chunk))
          chunk = Buffer.from(chunk);
        else if (typeof chunk !== "string")
          this.objectMode = true;
      }
      if (this[OBJECTMODE]) {
        if (this.flowing && this[BUFFERLENGTH] !== 0)
          this[FLUSH](true);
        if (this.flowing)
          this.emit("data", chunk);
        else
          this[BUFFERPUSH](chunk);
        if (this[BUFFERLENGTH] !== 0)
          this.emit("readable");
        if (cb)
          fn(cb);
        return this.flowing;
      }
      if (!chunk.length) {
        if (this[BUFFERLENGTH] !== 0)
          this.emit("readable");
        if (cb)
          fn(cb);
        return this.flowing;
      }
      if (typeof chunk === "string" && !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {
        chunk = Buffer.from(chunk, encoding);
      }
      if (Buffer.isBuffer(chunk) && this[ENCODING])
        chunk = this[DECODER].write(chunk);
      if (this.flowing && this[BUFFERLENGTH] !== 0)
        this[FLUSH](true);
      if (this.flowing)
        this.emit("data", chunk);
      else
        this[BUFFERPUSH](chunk);
      if (this[BUFFERLENGTH] !== 0)
        this.emit("readable");
      if (cb)
        fn(cb);
      return this.flowing;
    }
    read(n) {
      if (this[DESTROYED])
        return null;
      if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {
        this[MAYBE_EMIT_END]();
        return null;
      }
      if (this[OBJECTMODE])
        n = null;
      if (this.buffer.length > 1 && !this[OBJECTMODE]) {
        if (this.encoding)
          this.buffer = [this.buffer.join("")];
        else
          this.buffer = [Buffer.concat(this.buffer, this[BUFFERLENGTH])];
      }
      const ret = this[READ](n || null, this.buffer[0]);
      this[MAYBE_EMIT_END]();
      return ret;
    }
    [READ](n, chunk) {
      if (n === chunk.length || n === null)
        this[BUFFERSHIFT]();
      else {
        this.buffer[0] = chunk.slice(n);
        chunk = chunk.slice(0, n);
        this[BUFFERLENGTH] -= n;
      }
      this.emit("data", chunk);
      if (!this.buffer.length && !this[EOF])
        this.emit("drain");
      return chunk;
    }
    end(chunk, encoding, cb) {
      if (typeof chunk === "function")
        cb = chunk, chunk = null;
      if (typeof encoding === "function")
        cb = encoding, encoding = "utf8";
      if (chunk)
        this.write(chunk, encoding);
      if (cb)
        this.once("end", cb);
      this[EOF] = true;
      this.writable = false;
      if (this.flowing || !this[PAUSED])
        this[MAYBE_EMIT_END]();
      return this;
    }
    [RESUME]() {
      if (this[DESTROYED])
        return;
      this[PAUSED] = false;
      this[FLOWING] = true;
      this.emit("resume");
      if (this.buffer.length)
        this[FLUSH]();
      else if (this[EOF])
        this[MAYBE_EMIT_END]();
      else
        this.emit("drain");
    }
    resume() {
      return this[RESUME]();
    }
    pause() {
      this[FLOWING] = false;
      this[PAUSED] = true;
    }
    get destroyed() {
      return this[DESTROYED];
    }
    get flowing() {
      return this[FLOWING];
    }
    get paused() {
      return this[PAUSED];
    }
    [BUFFERPUSH](chunk) {
      if (this[OBJECTMODE])
        this[BUFFERLENGTH] += 1;
      else
        this[BUFFERLENGTH] += chunk.length;
      this.buffer.push(chunk);
    }
    [BUFFERSHIFT]() {
      if (this.buffer.length) {
        if (this[OBJECTMODE])
          this[BUFFERLENGTH] -= 1;
        else
          this[BUFFERLENGTH] -= this.buffer[0].length;
      }
      return this.buffer.shift();
    }
    [FLUSH](noDrain) {
      do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()));
      if (!noDrain && !this.buffer.length && !this[EOF])
        this.emit("drain");
    }
    [FLUSHCHUNK](chunk) {
      return chunk ? (this.emit("data", chunk), this.flowing) : false;
    }
    pipe(dest, opts) {
      if (this[DESTROYED])
        return;
      const ended = this[EMITTED_END];
      opts = opts || {};
      if (dest === proc.stdout || dest === proc.stderr)
        opts.end = false;
      else
        opts.end = opts.end !== false;
      opts.proxyErrors = !!opts.proxyErrors;
      if (ended) {
        if (opts.end)
          dest.end();
      } else {
        this.pipes.push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts));
        if (this[ASYNC])
          defer(() => this[RESUME]());
        else
          this[RESUME]();
      }
      return dest;
    }
    unpipe(dest) {
      const p = this.pipes.find((p2) => p2.dest === dest);
      if (p) {
        this.pipes.splice(this.pipes.indexOf(p), 1);
        p.unpipe();
      }
    }
    addListener(ev, fn) {
      return this.on(ev, fn);
    }
    on(ev, fn) {
      const ret = super.on(ev, fn);
      if (ev === "data" && !this.pipes.length && !this.flowing)
        this[RESUME]();
      else if (ev === "readable" && this[BUFFERLENGTH] !== 0)
        super.emit("readable");
      else if (isEndish(ev) && this[EMITTED_END]) {
        super.emit(ev);
        this.removeAllListeners(ev);
      } else if (ev === "error" && this[EMITTED_ERROR]) {
        if (this[ASYNC])
          defer(() => fn.call(this, this[EMITTED_ERROR]));
        else
          fn.call(this, this[EMITTED_ERROR]);
      }
      return ret;
    }
    get emittedEnd() {
      return this[EMITTED_END];
    }
    [MAYBE_EMIT_END]() {
      if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this.buffer.length === 0 && this[EOF]) {
        this[EMITTING_END] = true;
        this.emit("end");
        this.emit("prefinish");
        this.emit("finish");
        if (this[CLOSED])
          this.emit("close");
        this[EMITTING_END] = false;
      }
    }
    emit(ev, data, ...extra) {
      if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED])
        return;
      else if (ev === "data") {
        return !data ? false : this[ASYNC] ? defer(() => this[EMITDATA](data)) : this[EMITDATA](data);
      } else if (ev === "end") {
        return this[EMITEND]();
      } else if (ev === "close") {
        this[CLOSED] = true;
        if (!this[EMITTED_END] && !this[DESTROYED])
          return;
        const ret2 = super.emit("close");
        this.removeAllListeners("close");
        return ret2;
      } else if (ev === "error") {
        this[EMITTED_ERROR] = data;
        const ret2 = super.emit("error", data);
        this[MAYBE_EMIT_END]();
        return ret2;
      } else if (ev === "resume") {
        const ret2 = super.emit("resume");
        this[MAYBE_EMIT_END]();
        return ret2;
      } else if (ev === "finish" || ev === "prefinish") {
        const ret2 = super.emit(ev);
        this.removeAllListeners(ev);
        return ret2;
      }
      const ret = super.emit(ev, data, ...extra);
      this[MAYBE_EMIT_END]();
      return ret;
    }
    [EMITDATA](data) {
      for (const p of this.pipes) {
        if (p.dest.write(data) === false)
          this.pause();
      }
      const ret = super.emit("data", data);
      this[MAYBE_EMIT_END]();
      return ret;
    }
    [EMITEND]() {
      if (this[EMITTED_END])
        return;
      this[EMITTED_END] = true;
      this.readable = false;
      if (this[ASYNC])
        defer(() => this[EMITEND2]());
      else
        this[EMITEND2]();
    }
    [EMITEND2]() {
      if (this[DECODER]) {
        const data = this[DECODER].end();
        if (data) {
          for (const p of this.pipes) {
            p.dest.write(data);
          }
          super.emit("data", data);
        }
      }
      for (const p of this.pipes) {
        p.end();
      }
      const ret = super.emit("end");
      this.removeAllListeners("end");
      return ret;
    }
    collect() {
      const buf = [];
      if (!this[OBJECTMODE])
        buf.dataLength = 0;
      const p = this.promise();
      this.on("data", (c) => {
        buf.push(c);
        if (!this[OBJECTMODE])
          buf.dataLength += c.length;
      });
      return p.then(() => buf);
    }
    concat() {
      return this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this.collect().then((buf) => this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength));
    }
    promise() {
      return new Promise((resolve, reject) => {
        this.on(DESTROYED, () => reject(new Error("stream destroyed")));
        this.on("error", (er) => reject(er));
        this.on("end", () => resolve());
      });
    }
    [ASYNCITERATOR]() {
      const next = () => {
        const res = this.read();
        if (res !== null)
          return Promise.resolve({ done: false, value: res });
        if (this[EOF])
          return Promise.resolve({ done: true });
        let resolve = null;
        let reject = null;
        const onerr = (er) => {
          this.removeListener("data", ondata);
          this.removeListener("end", onend);
          reject(er);
        };
        const ondata = (value) => {
          this.removeListener("error", onerr);
          this.removeListener("end", onend);
          this.pause();
          resolve({ value, done: !!this[EOF] });
        };
        const onend = () => {
          this.removeListener("error", onerr);
          this.removeListener("data", ondata);
          resolve({ done: true });
        };
        const ondestroy = () => onerr(new Error("stream destroyed"));
        return new Promise((res2, rej) => {
          reject = rej;
          resolve = res2;
          this.once(DESTROYED, ondestroy);
          this.once("error", onerr);
          this.once("end", onend);
          this.once("data", ondata);
        });
      };
      return { next };
    }
    [ITERATOR]() {
      const next = () => {
        const value = this.read();
        const done = value === null;
        return { value, done };
      };
      return { next };
    }
    destroy(er) {
      if (this[DESTROYED]) {
        if (er)
          this.emit("error", er);
        else
          this.emit(DESTROYED);
        return this;
      }
      this[DESTROYED] = true;
      this.buffer.length = 0;
      this[BUFFERLENGTH] = 0;
      if (typeof this.close === "function" && !this[CLOSED])
        this.close();
      if (er)
        this.emit("error", er);
      else
        this.emit(DESTROYED);
      return this;
    }
    static isStream(s) {
      return !!s && (s instanceof Minipass || s instanceof Stream || s instanceof EE && (typeof s.pipe === "function" || typeof s.write === "function" && typeof s.end === "function"));
    }
  };
});

// node_modules/fs-minipass/index.js
var require_fs_minipass = __commonJS((exports) => {
  var MiniPass = require_minipass3();
  var EE = __require("events").EventEmitter;
  var fs = __require("fs");
  var writev = fs.writev;
  if (!writev) {
    const binding = process.binding("fs");
    const FSReqWrap = binding.FSReqWrap || binding.FSReqCallback;
    writev = (fd, iovec, pos, cb) => {
      const done = (er, bw) => cb(er, bw, iovec);
      const req = new FSReqWrap;
      req.oncomplete = done;
      binding.writeBuffers(fd, iovec, pos, req);
    };
  }
  var _autoClose = Symbol("_autoClose");
  var _close = Symbol("_close");
  var _ended = Symbol("_ended");
  var _fd = Symbol("_fd");
  var _finished = Symbol("_finished");
  var _flags = Symbol("_flags");
  var _flush = Symbol("_flush");
  var _handleChunk = Symbol("_handleChunk");
  var _makeBuf = Symbol("_makeBuf");
  var _mode = Symbol("_mode");
  var _needDrain = Symbol("_needDrain");
  var _onerror = Symbol("_onerror");
  var _onopen = Symbol("_onopen");
  var _onread = Symbol("_onread");
  var _onwrite = Symbol("_onwrite");
  var _open = Symbol("_open");
  var _path = Symbol("_path");
  var _pos = Symbol("_pos");
  var _queue = Symbol("_queue");
  var _read = Symbol("_read");
  var _readSize = Symbol("_readSize");
  var _reading = Symbol("_reading");
  var _remain = Symbol("_remain");
  var _size2 = Symbol("_size");
  var _write = Symbol("_write");
  var _writing = Symbol("_writing");
  var _defaultFlag = Symbol("_defaultFlag");
  var _errored = Symbol("_errored");

  class ReadStream extends MiniPass {
    constructor(path, opt) {
      opt = opt || {};
      super(opt);
      this.readable = true;
      this.writable = false;
      if (typeof path !== "string")
        throw new TypeError("path must be a string");
      this[_errored] = false;
      this[_fd] = typeof opt.fd === "number" ? opt.fd : null;
      this[_path] = path;
      this[_readSize] = opt.readSize || 16 * 1024 * 1024;
      this[_reading] = false;
      this[_size2] = typeof opt.size === "number" ? opt.size : Infinity;
      this[_remain] = this[_size2];
      this[_autoClose] = typeof opt.autoClose === "boolean" ? opt.autoClose : true;
      if (typeof this[_fd] === "number")
        this[_read]();
      else
        this[_open]();
    }
    get fd() {
      return this[_fd];
    }
    get path() {
      return this[_path];
    }
    write() {
      throw new TypeError("this is a readable stream");
    }
    end() {
      throw new TypeError("this is a readable stream");
    }
    [_open]() {
      fs.open(this[_path], "r", (er, fd) => this[_onopen](er, fd));
    }
    [_onopen](er, fd) {
      if (er)
        this[_onerror](er);
      else {
        this[_fd] = fd;
        this.emit("open", fd);
        this[_read]();
      }
    }
    [_makeBuf]() {
      return Buffer.allocUnsafe(Math.min(this[_readSize], this[_remain]));
    }
    [_read]() {
      if (!this[_reading]) {
        this[_reading] = true;
        const buf = this[_makeBuf]();
        if (buf.length === 0)
          return process.nextTick(() => this[_onread](null, 0, buf));
        fs.read(this[_fd], buf, 0, buf.length, null, (er, br, buf2) => this[_onread](er, br, buf2));
      }
    }
    [_onread](er, br, buf) {
      this[_reading] = false;
      if (er)
        this[_onerror](er);
      else if (this[_handleChunk](br, buf))
        this[_read]();
    }
    [_close]() {
      if (this[_autoClose] && typeof this[_fd] === "number") {
        const fd = this[_fd];
        this[_fd] = null;
        fs.close(fd, (er) => er ? this.emit("error", er) : this.emit("close"));
      }
    }
    [_onerror](er) {
      this[_reading] = true;
      this[_close]();
      this.emit("error", er);
    }
    [_handleChunk](br, buf) {
      let ret = false;
      this[_remain] -= br;
      if (br > 0)
        ret = super.write(br < buf.length ? buf.slice(0, br) : buf);
      if (br === 0 || this[_remain] <= 0) {
        ret = false;
        this[_close]();
        super.end();
      }
      return ret;
    }
    emit(ev, data) {
      switch (ev) {
        case "prefinish":
        case "finish":
          break;
        case "drain":
          if (typeof this[_fd] === "number")
            this[_read]();
          break;
        case "error":
          if (this[_errored])
            return;
          this[_errored] = true;
          return super.emit(ev, data);
        default:
          return super.emit(ev, data);
      }
    }
  }

  class ReadStreamSync extends ReadStream {
    [_open]() {
      let threw = true;
      try {
        this[_onopen](null, fs.openSync(this[_path], "r"));
        threw = false;
      } finally {
        if (threw)
          this[_close]();
      }
    }
    [_read]() {
      let threw = true;
      try {
        if (!this[_reading]) {
          this[_reading] = true;
          do {
            const buf = this[_makeBuf]();
            const br = buf.length === 0 ? 0 : fs.readSync(this[_fd], buf, 0, buf.length, null);
            if (!this[_handleChunk](br, buf))
              break;
          } while (true);
          this[_reading] = false;
        }
        threw = false;
      } finally {
        if (threw)
          this[_close]();
      }
    }
    [_close]() {
      if (this[_autoClose] && typeof this[_fd] === "number") {
        const fd = this[_fd];
        this[_fd] = null;
        fs.closeSync(fd);
        this.emit("close");
      }
    }
  }

  class WriteStream extends EE {
    constructor(path, opt) {
      opt = opt || {};
      super(opt);
      this.readable = false;
      this.writable = true;
      this[_errored] = false;
      this[_writing] = false;
      this[_ended] = false;
      this[_needDrain] = false;
      this[_queue] = [];
      this[_path] = path;
      this[_fd] = typeof opt.fd === "number" ? opt.fd : null;
      this[_mode] = opt.mode === undefined ? 438 : opt.mode;
      this[_pos] = typeof opt.start === "number" ? opt.start : null;
      this[_autoClose] = typeof opt.autoClose === "boolean" ? opt.autoClose : true;
      const defaultFlag = this[_pos] !== null ? "r+" : "w";
      this[_defaultFlag] = opt.flags === undefined;
      this[_flags] = this[_defaultFlag] ? defaultFlag : opt.flags;
      if (this[_fd] === null)
        this[_open]();
    }
    emit(ev, data) {
      if (ev === "error") {
        if (this[_errored])
          return;
        this[_errored] = true;
      }
      return super.emit(ev, data);
    }
    get fd() {
      return this[_fd];
    }
    get path() {
      return this[_path];
    }
    [_onerror](er) {
      this[_close]();
      this[_writing] = true;
      this.emit("error", er);
    }
    [_open]() {
      fs.open(this[_path], this[_flags], this[_mode], (er, fd) => this[_onopen](er, fd));
    }
    [_onopen](er, fd) {
      if (this[_defaultFlag] && this[_flags] === "r+" && er && er.code === "ENOENT") {
        this[_flags] = "w";
        this[_open]();
      } else if (er)
        this[_onerror](er);
      else {
        this[_fd] = fd;
        this.emit("open", fd);
        this[_flush]();
      }
    }
    end(buf, enc) {
      if (buf)
        this.write(buf, enc);
      this[_ended] = true;
      if (!this[_writing] && !this[_queue].length && typeof this[_fd] === "number")
        this[_onwrite](null, 0);
      return this;
    }
    write(buf, enc) {
      if (typeof buf === "string")
        buf = Buffer.from(buf, enc);
      if (this[_ended]) {
        this.emit("error", new Error("write() after end()"));
        return false;
      }
      if (this[_fd] === null || this[_writing] || this[_queue].length) {
        this[_queue].push(buf);
        this[_needDrain] = true;
        return false;
      }
      this[_writing] = true;
      this[_write](buf);
      return true;
    }
    [_write](buf) {
      fs.write(this[_fd], buf, 0, buf.length, this[_pos], (er, bw) => this[_onwrite](er, bw));
    }
    [_onwrite](er, bw) {
      if (er)
        this[_onerror](er);
      else {
        if (this[_pos] !== null)
          this[_pos] += bw;
        if (this[_queue].length)
          this[_flush]();
        else {
          this[_writing] = false;
          if (this[_ended] && !this[_finished]) {
            this[_finished] = true;
            this[_close]();
            this.emit("finish");
          } else if (this[_needDrain]) {
            this[_needDrain] = false;
            this.emit("drain");
          }
        }
      }
    }
    [_flush]() {
      if (this[_queue].length === 0) {
        if (this[_ended])
          this[_onwrite](null, 0);
      } else if (this[_queue].length === 1)
        this[_write](this[_queue].pop());
      else {
        const iovec = this[_queue];
        this[_queue] = [];
        writev(this[_fd], iovec, this[_pos], (er, bw) => this[_onwrite](er, bw));
      }
    }
    [_close]() {
      if (this[_autoClose] && typeof this[_fd] === "number") {
        const fd = this[_fd];
        this[_fd] = null;
        fs.close(fd, (er) => er ? this.emit("error", er) : this.emit("close"));
      }
    }
  }

  class WriteStreamSync extends WriteStream {
    [_open]() {
      let fd;
      if (this[_defaultFlag] && this[_flags] === "r+") {
        try {
          fd = fs.openSync(this[_path], this[_flags], this[_mode]);
        } catch (er) {
          if (er.code === "ENOENT") {
            this[_flags] = "w";
            return this[_open]();
          } else
            throw er;
        }
      } else
        fd = fs.openSync(this[_path], this[_flags], this[_mode]);
      this[_onopen](null, fd);
    }
    [_close]() {
      if (this[_autoClose] && typeof this[_fd] === "number") {
        const fd = this[_fd];
        this[_fd] = null;
        fs.closeSync(fd);
        this.emit("close");
      }
    }
    [_write](buf) {
      let threw = true;
      try {
        this[_onwrite](null, fs.writeSync(this[_fd], buf, 0, buf.length, this[_pos]));
        threw = false;
      } finally {
        if (threw)
          try {
            this[_close]();
          } catch (_) {}
      }
    }
  }
  exports.ReadStream = ReadStream;
  exports.ReadStreamSync = ReadStreamSync;
  exports.WriteStream = WriteStream;
  exports.WriteStreamSync = WriteStreamSync;
});

// node_modules/tar/lib/parse.js
var require_parse = __commonJS((exports, module) => {
  var warner = require_warn_mixin();
  var Header = require_header();
  var EE = __require("events");
  var Yallist = require_yallist();
  var maxMetaEntrySize = 1024 * 1024;
  var Entry = require_read_entry();
  var Pax = require_pax();
  var zlib = require_minizlib();
  var { nextTick } = __require("process");
  var gzipHeader = Buffer.from([31, 139]);
  var STATE = Symbol("state");
  var WRITEENTRY = Symbol("writeEntry");
  var READENTRY = Symbol("readEntry");
  var NEXTENTRY = Symbol("nextEntry");
  var PROCESSENTRY = Symbol("processEntry");
  var EX = Symbol("extendedHeader");
  var GEX = Symbol("globalExtendedHeader");
  var META = Symbol("meta");
  var EMITMETA = Symbol("emitMeta");
  var BUFFER = Symbol("buffer");
  var QUEUE = Symbol("queue");
  var ENDED = Symbol("ended");
  var EMITTEDEND = Symbol("emittedEnd");
  var EMIT = Symbol("emit");
  var UNZIP = Symbol("unzip");
  var CONSUMECHUNK = Symbol("consumeChunk");
  var CONSUMECHUNKSUB = Symbol("consumeChunkSub");
  var CONSUMEBODY = Symbol("consumeBody");
  var CONSUMEMETA = Symbol("consumeMeta");
  var CONSUMEHEADER = Symbol("consumeHeader");
  var CONSUMING = Symbol("consuming");
  var BUFFERCONCAT = Symbol("bufferConcat");
  var MAYBEEND = Symbol("maybeEnd");
  var WRITING = Symbol("writing");
  var ABORTED = Symbol("aborted");
  var DONE = Symbol("onDone");
  var SAW_VALID_ENTRY = Symbol("sawValidEntry");
  var SAW_NULL_BLOCK = Symbol("sawNullBlock");
  var SAW_EOF = Symbol("sawEOF");
  var CLOSESTREAM = Symbol("closeStream");
  var noop = (_) => true;
  module.exports = warner(class Parser extends EE {
    constructor(opt) {
      opt = opt || {};
      super(opt);
      this.file = opt.file || "";
      this[SAW_VALID_ENTRY] = null;
      this.on(DONE, (_) => {
        if (this[STATE] === "begin" || this[SAW_VALID_ENTRY] === false) {
          this.warn("TAR_BAD_ARCHIVE", "Unrecognized archive format");
        }
      });
      if (opt.ondone) {
        this.on(DONE, opt.ondone);
      } else {
        this.on(DONE, (_) => {
          this.emit("prefinish");
          this.emit("finish");
          this.emit("end");
        });
      }
      this.strict = !!opt.strict;
      this.maxMetaEntrySize = opt.maxMetaEntrySize || maxMetaEntrySize;
      this.filter = typeof opt.filter === "function" ? opt.filter : noop;
      const isTBR = opt.file && (opt.file.endsWith(".tar.br") || opt.file.endsWith(".tbr"));
      this.brotli = !opt.gzip && opt.brotli !== undefined ? opt.brotli : isTBR ? undefined : false;
      this.writable = true;
      this.readable = false;
      this[QUEUE] = new Yallist;
      this[BUFFER] = null;
      this[READENTRY] = null;
      this[WRITEENTRY] = null;
      this[STATE] = "begin";
      this[META] = "";
      this[EX] = null;
      this[GEX] = null;
      this[ENDED] = false;
      this[UNZIP] = null;
      this[ABORTED] = false;
      this[SAW_NULL_BLOCK] = false;
      this[SAW_EOF] = false;
      this.on("end", () => this[CLOSESTREAM]());
      if (typeof opt.onwarn === "function") {
        this.on("warn", opt.onwarn);
      }
      if (typeof opt.onentry === "function") {
        this.on("entry", opt.onentry);
      }
    }
    [CONSUMEHEADER](chunk, position) {
      if (this[SAW_VALID_ENTRY] === null) {
        this[SAW_VALID_ENTRY] = false;
      }
      let header;
      try {
        header = new Header(chunk, position, this[EX], this[GEX]);
      } catch (er) {
        return this.warn("TAR_ENTRY_INVALID", er);
      }
      if (header.nullBlock) {
        if (this[SAW_NULL_BLOCK]) {
          this[SAW_EOF] = true;
          if (this[STATE] === "begin") {
            this[STATE] = "header";
          }
          this[EMIT]("eof");
        } else {
          this[SAW_NULL_BLOCK] = true;
          this[EMIT]("nullBlock");
        }
      } else {
        this[SAW_NULL_BLOCK] = false;
        if (!header.cksumValid) {
          this.warn("TAR_ENTRY_INVALID", "checksum failure", { header });
        } else if (!header.path) {
          this.warn("TAR_ENTRY_INVALID", "path is required", { header });
        } else {
          const type = header.type;
          if (/^(Symbolic)?Link$/.test(type) && !header.linkpath) {
            this.warn("TAR_ENTRY_INVALID", "linkpath required", { header });
          } else if (!/^(Symbolic)?Link$/.test(type) && header.linkpath) {
            this.warn("TAR_ENTRY_INVALID", "linkpath forbidden", { header });
          } else {
            const entry = this[WRITEENTRY] = new Entry(header, this[EX], this[GEX]);
            if (!this[SAW_VALID_ENTRY]) {
              if (entry.remain) {
                const onend = () => {
                  if (!entry.invalid) {
                    this[SAW_VALID_ENTRY] = true;
                  }
                };
                entry.on("end", onend);
              } else {
                this[SAW_VALID_ENTRY] = true;
              }
            }
            if (entry.meta) {
              if (entry.size > this.maxMetaEntrySize) {
                entry.ignore = true;
                this[EMIT]("ignoredEntry", entry);
                this[STATE] = "ignore";
                entry.resume();
              } else if (entry.size > 0) {
                this[META] = "";
                entry.on("data", (c) => this[META] += c);
                this[STATE] = "meta";
              }
            } else {
              this[EX] = null;
              entry.ignore = entry.ignore || !this.filter(entry.path, entry);
              if (entry.ignore) {
                this[EMIT]("ignoredEntry", entry);
                this[STATE] = entry.remain ? "ignore" : "header";
                entry.resume();
              } else {
                if (entry.remain) {
                  this[STATE] = "body";
                } else {
                  this[STATE] = "header";
                  entry.end();
                }
                if (!this[READENTRY]) {
                  this[QUEUE].push(entry);
                  this[NEXTENTRY]();
                } else {
                  this[QUEUE].push(entry);
                }
              }
            }
          }
        }
      }
    }
    [CLOSESTREAM]() {
      nextTick(() => this.emit("close"));
    }
    [PROCESSENTRY](entry) {
      let go = true;
      if (!entry) {
        this[READENTRY] = null;
        go = false;
      } else if (Array.isArray(entry)) {
        this.emit.apply(this, entry);
      } else {
        this[READENTRY] = entry;
        this.emit("entry", entry);
        if (!entry.emittedEnd) {
          entry.on("end", (_) => this[NEXTENTRY]());
          go = false;
        }
      }
      return go;
    }
    [NEXTENTRY]() {
      do {} while (this[PROCESSENTRY](this[QUEUE].shift()));
      if (!this[QUEUE].length) {
        const re = this[READENTRY];
        const drainNow = !re || re.flowing || re.size === re.remain;
        if (drainNow) {
          if (!this[WRITING]) {
            this.emit("drain");
          }
        } else {
          re.once("drain", (_) => this.emit("drain"));
        }
      }
    }
    [CONSUMEBODY](chunk, position) {
      const entry = this[WRITEENTRY];
      const br = entry.blockRemain;
      const c = br >= chunk.length && position === 0 ? chunk : chunk.slice(position, position + br);
      entry.write(c);
      if (!entry.blockRemain) {
        this[STATE] = "header";
        this[WRITEENTRY] = null;
        entry.end();
      }
      return c.length;
    }
    [CONSUMEMETA](chunk, position) {
      const entry = this[WRITEENTRY];
      const ret = this[CONSUMEBODY](chunk, position);
      if (!this[WRITEENTRY]) {
        this[EMITMETA](entry);
      }
      return ret;
    }
    [EMIT](ev, data, extra) {
      if (!this[QUEUE].length && !this[READENTRY]) {
        this.emit(ev, data, extra);
      } else {
        this[QUEUE].push([ev, data, extra]);
      }
    }
    [EMITMETA](entry) {
      this[EMIT]("meta", this[META]);
      switch (entry.type) {
        case "ExtendedHeader":
        case "OldExtendedHeader":
          this[EX] = Pax.parse(this[META], this[EX], false);
          break;
        case "GlobalExtendedHeader":
          this[GEX] = Pax.parse(this[META], this[GEX], true);
          break;
        case "NextFileHasLongPath":
        case "OldGnuLongPath":
          this[EX] = this[EX] || Object.create(null);
          this[EX].path = this[META].replace(/\0.*/, "");
          break;
        case "NextFileHasLongLinkpath":
          this[EX] = this[EX] || Object.create(null);
          this[EX].linkpath = this[META].replace(/\0.*/, "");
          break;
        default:
          throw new Error("unknown meta: " + entry.type);
      }
    }
    abort(error48) {
      this[ABORTED] = true;
      this.emit("abort", error48);
      this.warn("TAR_ABORT", error48, { recoverable: false });
    }
    write(chunk) {
      if (this[ABORTED]) {
        return;
      }
      const needSniff = this[UNZIP] === null || this.brotli === undefined && this[UNZIP] === false;
      if (needSniff && chunk) {
        if (this[BUFFER]) {
          chunk = Buffer.concat([this[BUFFER], chunk]);
          this[BUFFER] = null;
        }
        if (chunk.length < gzipHeader.length) {
          this[BUFFER] = chunk;
          return true;
        }
        for (let i = 0;this[UNZIP] === null && i < gzipHeader.length; i++) {
          if (chunk[i] !== gzipHeader[i]) {
            this[UNZIP] = false;
          }
        }
        const maybeBrotli = this.brotli === undefined;
        if (this[UNZIP] === false && maybeBrotli) {
          if (chunk.length < 512) {
            if (this[ENDED]) {
              this.brotli = true;
            } else {
              this[BUFFER] = chunk;
              return true;
            }
          } else {
            try {
              new Header(chunk.slice(0, 512));
              this.brotli = false;
            } catch (_) {
              this.brotli = true;
            }
          }
        }
        if (this[UNZIP] === null || this[UNZIP] === false && this.brotli) {
          const ended = this[ENDED];
          this[ENDED] = false;
          this[UNZIP] = this[UNZIP] === null ? new zlib.Unzip : new zlib.BrotliDecompress;
          this[UNZIP].on("data", (chunk2) => this[CONSUMECHUNK](chunk2));
          this[UNZIP].on("error", (er) => this.abort(er));
          this[UNZIP].on("end", (_) => {
            this[ENDED] = true;
            this[CONSUMECHUNK]();
          });
          this[WRITING] = true;
          const ret2 = this[UNZIP][ended ? "end" : "write"](chunk);
          this[WRITING] = false;
          return ret2;
        }
      }
      this[WRITING] = true;
      if (this[UNZIP]) {
        this[UNZIP].write(chunk);
      } else {
        this[CONSUMECHUNK](chunk);
      }
      this[WRITING] = false;
      const ret = this[QUEUE].length ? false : this[READENTRY] ? this[READENTRY].flowing : true;
      if (!ret && !this[QUEUE].length) {
        this[READENTRY].once("drain", (_) => this.emit("drain"));
      }
      return ret;
    }
    [BUFFERCONCAT](c) {
      if (c && !this[ABORTED]) {
        this[BUFFER] = this[BUFFER] ? Buffer.concat([this[BUFFER], c]) : c;
      }
    }
    [MAYBEEND]() {
      if (this[ENDED] && !this[EMITTEDEND] && !this[ABORTED] && !this[CONSUMING]) {
        this[EMITTEDEND] = true;
        const entry = this[WRITEENTRY];
        if (entry && entry.blockRemain) {
          const have = this[BUFFER] ? this[BUFFER].length : 0;
          this.warn("TAR_BAD_ARCHIVE", `Truncated input (needed ${entry.blockRemain} more bytes, only ${have} available)`, { entry });
          if (this[BUFFER]) {
            entry.write(this[BUFFER]);
          }
          entry.end();
        }
        this[EMIT](DONE);
      }
    }
    [CONSUMECHUNK](chunk) {
      if (this[CONSUMING]) {
        this[BUFFERCONCAT](chunk);
      } else if (!chunk && !this[BUFFER]) {
        this[MAYBEEND]();
      } else {
        this[CONSUMING] = true;
        if (this[BUFFER]) {
          this[BUFFERCONCAT](chunk);
          const c = this[BUFFER];
          this[BUFFER] = null;
          this[CONSUMECHUNKSUB](c);
        } else {
          this[CONSUMECHUNKSUB](chunk);
        }
        while (this[BUFFER] && this[BUFFER].length >= 512 && !this[ABORTED] && !this[SAW_EOF]) {
          const c = this[BUFFER];
          this[BUFFER] = null;
          this[CONSUMECHUNKSUB](c);
        }
        this[CONSUMING] = false;
      }
      if (!this[BUFFER] || this[ENDED]) {
        this[MAYBEEND]();
      }
    }
    [CONSUMECHUNKSUB](chunk) {
      let position = 0;
      const length = chunk.length;
      while (position + 512 <= length && !this[ABORTED] && !this[SAW_EOF]) {
        switch (this[STATE]) {
          case "begin":
          case "header":
            this[CONSUMEHEADER](chunk, position);
            position += 512;
            break;
          case "ignore":
          case "body":
            position += this[CONSUMEBODY](chunk, position);
            break;
          case "meta":
            position += this[CONSUMEMETA](chunk, position);
            break;
          default:
            throw new Error("invalid state: " + this[STATE]);
        }
      }
      if (position < length) {
        if (this[BUFFER]) {
          this[BUFFER] = Buffer.concat([chunk.slice(position), this[BUFFER]]);
        } else {
          this[BUFFER] = chunk.slice(position);
        }
      }
    }
    end(chunk) {
      if (!this[ABORTED]) {
        if (this[UNZIP]) {
          this[UNZIP].end(chunk);
        } else {
          this[ENDED] = true;
          if (this.brotli === undefined)
            chunk = chunk || Buffer.alloc(0);
          this.write(chunk);
        }
      }
    }
  });
});

// node_modules/tar/lib/list.js
var require_list = __commonJS((exports, module) => {
  var hlo = require_high_level_opt();
  var Parser = require_parse();
  var fs = __require("fs");
  var fsm = require_fs_minipass();
  var path = __require("path");
  var stripSlash = require_strip_trailing_slashes();
  module.exports = (opt_, files, cb) => {
    if (typeof opt_ === "function") {
      cb = opt_, files = null, opt_ = {};
    } else if (Array.isArray(opt_)) {
      files = opt_, opt_ = {};
    }
    if (typeof files === "function") {
      cb = files, files = null;
    }
    if (!files) {
      files = [];
    } else {
      files = Array.from(files);
    }
    const opt = hlo(opt_);
    if (opt.sync && typeof cb === "function") {
      throw new TypeError("callback not supported for sync tar functions");
    }
    if (!opt.file && typeof cb === "function") {
      throw new TypeError("callback only supported with file option");
    }
    if (files.length) {
      filesFilter(opt, files);
    }
    if (!opt.noResume) {
      onentryFunction(opt);
    }
    return opt.file && opt.sync ? listFileSync(opt) : opt.file ? listFile(opt, cb) : list(opt);
  };
  var onentryFunction = (opt) => {
    const onentry = opt.onentry;
    opt.onentry = onentry ? (e) => {
      onentry(e);
      e.resume();
    } : (e) => e.resume();
  };
  var filesFilter = (opt, files) => {
    const map2 = new Map(files.map((f) => [stripSlash(f), true]));
    const filter = opt.filter;
    const mapHas = (file2, r) => {
      const root = r || path.parse(file2).root || ".";
      const ret = file2 === root ? false : map2.has(file2) ? map2.get(file2) : mapHas(path.dirname(file2), root);
      map2.set(file2, ret);
      return ret;
    };
    opt.filter = filter ? (file2, entry) => filter(file2, entry) && mapHas(stripSlash(file2)) : (file2) => mapHas(stripSlash(file2));
  };
  var listFileSync = (opt) => {
    const p = list(opt);
    const file2 = opt.file;
    let threw = true;
    let fd;
    try {
      const stat = fs.statSync(file2);
      const readSize = opt.maxReadSize || 16 * 1024 * 1024;
      if (stat.size < readSize) {
        p.end(fs.readFileSync(file2));
      } else {
        let pos = 0;
        const buf = Buffer.allocUnsafe(readSize);
        fd = fs.openSync(file2, "r");
        while (pos < stat.size) {
          const bytesRead = fs.readSync(fd, buf, 0, readSize, pos);
          pos += bytesRead;
          p.write(buf.slice(0, bytesRead));
        }
        p.end();
      }
      threw = false;
    } finally {
      if (threw && fd) {
        try {
          fs.closeSync(fd);
        } catch (er) {}
      }
    }
  };
  var listFile = (opt, cb) => {
    const parse6 = new Parser(opt);
    const readSize = opt.maxReadSize || 16 * 1024 * 1024;
    const file2 = opt.file;
    const p = new Promise((resolve, reject) => {
      parse6.on("error", reject);
      parse6.on("end", resolve);
      fs.stat(file2, (er, stat) => {
        if (er) {
          reject(er);
        } else {
          const stream = new fsm.ReadStream(file2, {
            readSize,
            size: stat.size
          });
          stream.on("error", reject);
          stream.pipe(parse6);
        }
      });
    });
    return cb ? p.then(cb, cb) : p;
  };
  var list = (opt) => new Parser(opt);
});

// node_modules/tar/lib/create.js
var require_create = __commonJS((exports, module) => {
  var hlo = require_high_level_opt();
  var Pack = require_pack();
  var fsm = require_fs_minipass();
  var t = require_list();
  var path = __require("path");
  module.exports = (opt_, files, cb) => {
    if (typeof files === "function") {
      cb = files;
    }
    if (Array.isArray(opt_)) {
      files = opt_, opt_ = {};
    }
    if (!files || !Array.isArray(files) || !files.length) {
      throw new TypeError("no files or directories specified");
    }
    files = Array.from(files);
    const opt = hlo(opt_);
    if (opt.sync && typeof cb === "function") {
      throw new TypeError("callback not supported for sync tar functions");
    }
    if (!opt.file && typeof cb === "function") {
      throw new TypeError("callback only supported with file option");
    }
    return opt.file && opt.sync ? createFileSync(opt, files) : opt.file ? createFile(opt, files, cb) : opt.sync ? createSync(opt, files) : create(opt, files);
  };
  var createFileSync = (opt, files) => {
    const p = new Pack.Sync(opt);
    const stream = new fsm.WriteStreamSync(opt.file, {
      mode: opt.mode || 438
    });
    p.pipe(stream);
    addFilesSync(p, files);
  };
  var createFile = (opt, files, cb) => {
    const p = new Pack(opt);
    const stream = new fsm.WriteStream(opt.file, {
      mode: opt.mode || 438
    });
    p.pipe(stream);
    const promise2 = new Promise((res, rej) => {
      stream.on("error", rej);
      stream.on("close", res);
      p.on("error", rej);
    });
    addFilesAsync(p, files);
    return cb ? promise2.then(cb, cb) : promise2;
  };
  var addFilesSync = (p, files) => {
    files.forEach((file2) => {
      if (file2.charAt(0) === "@") {
        t({
          file: path.resolve(p.cwd, file2.slice(1)),
          sync: true,
          noResume: true,
          onentry: (entry) => p.add(entry)
        });
      } else {
        p.add(file2);
      }
    });
    p.end();
  };
  var addFilesAsync = (p, files) => {
    while (files.length) {
      const file2 = files.shift();
      if (file2.charAt(0) === "@") {
        return t({
          file: path.resolve(p.cwd, file2.slice(1)),
          noResume: true,
          onentry: (entry) => p.add(entry)
        }).then((_) => addFilesAsync(p, files));
      } else {
        p.add(file2);
      }
    }
    p.end();
  };
  var createSync = (opt, files) => {
    const p = new Pack.Sync(opt);
    addFilesSync(p, files);
    return p;
  };
  var create = (opt, files) => {
    const p = new Pack(opt);
    addFilesAsync(p, files);
    return p;
  };
});

// node_modules/tar/lib/replace.js
var require_replace = __commonJS((exports, module) => {
  var hlo = require_high_level_opt();
  var Pack = require_pack();
  var fs = __require("fs");
  var fsm = require_fs_minipass();
  var t = require_list();
  var path = __require("path");
  var Header = require_header();
  module.exports = (opt_, files, cb) => {
    const opt = hlo(opt_);
    if (!opt.file) {
      throw new TypeError("file is required");
    }
    if (opt.gzip || opt.brotli || opt.file.endsWith(".br") || opt.file.endsWith(".tbr")) {
      throw new TypeError("cannot append to compressed archives");
    }
    if (!files || !Array.isArray(files) || !files.length) {
      throw new TypeError("no files or directories specified");
    }
    files = Array.from(files);
    return opt.sync ? replaceSync(opt, files) : replace(opt, files, cb);
  };
  var replaceSync = (opt, files) => {
    const p = new Pack.Sync(opt);
    let threw = true;
    let fd;
    let position;
    try {
      try {
        fd = fs.openSync(opt.file, "r+");
      } catch (er) {
        if (er.code === "ENOENT") {
          fd = fs.openSync(opt.file, "w+");
        } else {
          throw er;
        }
      }
      const st = fs.fstatSync(fd);
      const headBuf = Buffer.alloc(512);
      POSITION:
        for (position = 0;position < st.size; position += 512) {
          for (let bufPos = 0, bytes = 0;bufPos < 512; bufPos += bytes) {
            bytes = fs.readSync(fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos);
            if (position === 0 && headBuf[0] === 31 && headBuf[1] === 139) {
              throw new Error("cannot append to compressed archives");
            }
            if (!bytes) {
              break POSITION;
            }
          }
          const h = new Header(headBuf);
          if (!h.cksumValid) {
            break;
          }
          const entryBlockSize = 512 * Math.ceil(h.size / 512);
          if (position + entryBlockSize + 512 > st.size) {
            break;
          }
          position += entryBlockSize;
          if (opt.mtimeCache) {
            opt.mtimeCache.set(h.path, h.mtime);
          }
        }
      threw = false;
      streamSync(opt, p, position, fd, files);
    } finally {
      if (threw) {
        try {
          fs.closeSync(fd);
        } catch (er) {}
      }
    }
  };
  var streamSync = (opt, p, position, fd, files) => {
    const stream = new fsm.WriteStreamSync(opt.file, {
      fd,
      start: position
    });
    p.pipe(stream);
    addFilesSync(p, files);
  };
  var replace = (opt, files, cb) => {
    files = Array.from(files);
    const p = new Pack(opt);
    const getPos = (fd, size, cb_) => {
      const cb2 = (er, pos) => {
        if (er) {
          fs.close(fd, (_) => cb_(er));
        } else {
          cb_(null, pos);
        }
      };
      let position = 0;
      if (size === 0) {
        return cb2(null, 0);
      }
      let bufPos = 0;
      const headBuf = Buffer.alloc(512);
      const onread = (er, bytes) => {
        if (er) {
          return cb2(er);
        }
        bufPos += bytes;
        if (bufPos < 512 && bytes) {
          return fs.read(fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos, onread);
        }
        if (position === 0 && headBuf[0] === 31 && headBuf[1] === 139) {
          return cb2(new Error("cannot append to compressed archives"));
        }
        if (bufPos < 512) {
          return cb2(null, position);
        }
        const h = new Header(headBuf);
        if (!h.cksumValid) {
          return cb2(null, position);
        }
        const entryBlockSize = 512 * Math.ceil(h.size / 512);
        if (position + entryBlockSize + 512 > size) {
          return cb2(null, position);
        }
        position += entryBlockSize + 512;
        if (position >= size) {
          return cb2(null, position);
        }
        if (opt.mtimeCache) {
          opt.mtimeCache.set(h.path, h.mtime);
        }
        bufPos = 0;
        fs.read(fd, headBuf, 0, 512, position, onread);
      };
      fs.read(fd, headBuf, 0, 512, position, onread);
    };
    const promise2 = new Promise((resolve, reject) => {
      p.on("error", reject);
      let flag = "r+";
      const onopen = (er, fd) => {
        if (er && er.code === "ENOENT" && flag === "r+") {
          flag = "w+";
          return fs.open(opt.file, flag, onopen);
        }
        if (er) {
          return reject(er);
        }
        fs.fstat(fd, (er2, st) => {
          if (er2) {
            return fs.close(fd, () => reject(er2));
          }
          getPos(fd, st.size, (er3, position) => {
            if (er3) {
              return reject(er3);
            }
            const stream = new fsm.WriteStream(opt.file, {
              fd,
              start: position
            });
            p.pipe(stream);
            stream.on("error", reject);
            stream.on("close", resolve);
            addFilesAsync(p, files);
          });
        });
      };
      fs.open(opt.file, flag, onopen);
    });
    return cb ? promise2.then(cb, cb) : promise2;
  };
  var addFilesSync = (p, files) => {
    files.forEach((file2) => {
      if (file2.charAt(0) === "@") {
        t({
          file: path.resolve(p.cwd, file2.slice(1)),
          sync: true,
          noResume: true,
          onentry: (entry) => p.add(entry)
        });
      } else {
        p.add(file2);
      }
    });
    p.end();
  };
  var addFilesAsync = (p, files) => {
    while (files.length) {
      const file2 = files.shift();
      if (file2.charAt(0) === "@") {
        return t({
          file: path.resolve(p.cwd, file2.slice(1)),
          noResume: true,
          onentry: (entry) => p.add(entry)
        }).then((_) => addFilesAsync(p, files));
      } else {
        p.add(file2);
      }
    }
    p.end();
  };
});

// node_modules/tar/lib/update.js
var require_update = __commonJS((exports, module) => {
  var hlo = require_high_level_opt();
  var r = require_replace();
  module.exports = (opt_, files, cb) => {
    const opt = hlo(opt_);
    if (!opt.file) {
      throw new TypeError("file is required");
    }
    if (opt.gzip || opt.brotli || opt.file.endsWith(".br") || opt.file.endsWith(".tbr")) {
      throw new TypeError("cannot append to compressed archives");
    }
    if (!files || !Array.isArray(files) || !files.length) {
      throw new TypeError("no files or directories specified");
    }
    files = Array.from(files);
    mtimeFilter(opt);
    return r(opt, files, cb);
  };
  var mtimeFilter = (opt) => {
    const filter = opt.filter;
    if (!opt.mtimeCache) {
      opt.mtimeCache = new Map;
    }
    opt.filter = filter ? (path, stat) => filter(path, stat) && !(opt.mtimeCache.get(path) > stat.mtime) : (path, stat) => !(opt.mtimeCache.get(path) > stat.mtime);
  };
});

// node_modules/mkdirp/lib/opts-arg.js
var require_opts_arg = __commonJS((exports, module) => {
  var { promisify } = __require("util");
  var fs = __require("fs");
  var optsArg = (opts) => {
    if (!opts)
      opts = { mode: 511, fs };
    else if (typeof opts === "object")
      opts = { mode: 511, fs, ...opts };
    else if (typeof opts === "number")
      opts = { mode: opts, fs };
    else if (typeof opts === "string")
      opts = { mode: parseInt(opts, 8), fs };
    else
      throw new TypeError("invalid options argument");
    opts.mkdir = opts.mkdir || opts.fs.mkdir || fs.mkdir;
    opts.mkdirAsync = promisify(opts.mkdir);
    opts.stat = opts.stat || opts.fs.stat || fs.stat;
    opts.statAsync = promisify(opts.stat);
    opts.statSync = opts.statSync || opts.fs.statSync || fs.statSync;
    opts.mkdirSync = opts.mkdirSync || opts.fs.mkdirSync || fs.mkdirSync;
    return opts;
  };
  module.exports = optsArg;
});

// node_modules/mkdirp/lib/path-arg.js
var require_path_arg = __commonJS((exports, module) => {
  var platform = process.env.__TESTING_MKDIRP_PLATFORM__ || process.platform;
  var { resolve, parse: parse6 } = __require("path");
  var pathArg = (path) => {
    if (/\0/.test(path)) {
      throw Object.assign(new TypeError("path must be a string without null bytes"), {
        path,
        code: "ERR_INVALID_ARG_VALUE"
      });
    }
    path = resolve(path);
    if (platform === "win32") {
      const badWinChars = /[*|"<>?:]/;
      const { root } = parse6(path);
      if (badWinChars.test(path.substr(root.length))) {
        throw Object.assign(new Error("Illegal characters in path."), {
          path,
          code: "EINVAL"
        });
      }
    }
    return path;
  };
  module.exports = pathArg;
});

// node_modules/mkdirp/lib/find-made.js
var require_find_made = __commonJS((exports, module) => {
  var { dirname } = __require("path");
  var findMade = (opts, parent, path = undefined) => {
    if (path === parent)
      return Promise.resolve();
    return opts.statAsync(parent).then((st) => st.isDirectory() ? path : undefined, (er) => er.code === "ENOENT" ? findMade(opts, dirname(parent), parent) : undefined);
  };
  var findMadeSync = (opts, parent, path = undefined) => {
    if (path === parent)
      return;
    try {
      return opts.statSync(parent).isDirectory() ? path : undefined;
    } catch (er) {
      return er.code === "ENOENT" ? findMadeSync(opts, dirname(parent), parent) : undefined;
    }
  };
  module.exports = { findMade, findMadeSync };
});

// node_modules/mkdirp/lib/mkdirp-manual.js
var require_mkdirp_manual = __commonJS((exports, module) => {
  var { dirname } = __require("path");
  var mkdirpManual = (path, opts, made) => {
    opts.recursive = false;
    const parent = dirname(path);
    if (parent === path) {
      return opts.mkdirAsync(path, opts).catch((er) => {
        if (er.code !== "EISDIR")
          throw er;
      });
    }
    return opts.mkdirAsync(path, opts).then(() => made || path, (er) => {
      if (er.code === "ENOENT")
        return mkdirpManual(parent, opts).then((made2) => mkdirpManual(path, opts, made2));
      if (er.code !== "EEXIST" && er.code !== "EROFS")
        throw er;
      return opts.statAsync(path).then((st) => {
        if (st.isDirectory())
          return made;
        else
          throw er;
      }, () => {
        throw er;
      });
    });
  };
  var mkdirpManualSync = (path, opts, made) => {
    const parent = dirname(path);
    opts.recursive = false;
    if (parent === path) {
      try {
        return opts.mkdirSync(path, opts);
      } catch (er) {
        if (er.code !== "EISDIR")
          throw er;
        else
          return;
      }
    }
    try {
      opts.mkdirSync(path, opts);
      return made || path;
    } catch (er) {
      if (er.code === "ENOENT")
        return mkdirpManualSync(path, opts, mkdirpManualSync(parent, opts, made));
      if (er.code !== "EEXIST" && er.code !== "EROFS")
        throw er;
      try {
        if (!opts.statSync(path).isDirectory())
          throw er;
      } catch (_) {
        throw er;
      }
    }
  };
  module.exports = { mkdirpManual, mkdirpManualSync };
});

// node_modules/mkdirp/lib/mkdirp-native.js
var require_mkdirp_native = __commonJS((exports, module) => {
  var { dirname } = __require("path");
  var { findMade, findMadeSync } = require_find_made();
  var { mkdirpManual, mkdirpManualSync } = require_mkdirp_manual();
  var mkdirpNative = (path, opts) => {
    opts.recursive = true;
    const parent = dirname(path);
    if (parent === path)
      return opts.mkdirAsync(path, opts);
    return findMade(opts, path).then((made) => opts.mkdirAsync(path, opts).then(() => made).catch((er) => {
      if (er.code === "ENOENT")
        return mkdirpManual(path, opts);
      else
        throw er;
    }));
  };
  var mkdirpNativeSync = (path, opts) => {
    opts.recursive = true;
    const parent = dirname(path);
    if (parent === path)
      return opts.mkdirSync(path, opts);
    const made = findMadeSync(opts, path);
    try {
      opts.mkdirSync(path, opts);
      return made;
    } catch (er) {
      if (er.code === "ENOENT")
        return mkdirpManualSync(path, opts);
      else
        throw er;
    }
  };
  module.exports = { mkdirpNative, mkdirpNativeSync };
});

// node_modules/mkdirp/lib/use-native.js
var require_use_native = __commonJS((exports, module) => {
  var fs = __require("fs");
  var version2 = process.env.__TESTING_MKDIRP_NODE_VERSION__ || process.version;
  var versArr = version2.replace(/^v/, "").split(".");
  var hasNative = +versArr[0] > 10 || +versArr[0] === 10 && +versArr[1] >= 12;
  var useNative = !hasNative ? () => false : (opts) => opts.mkdir === fs.mkdir;
  var useNativeSync = !hasNative ? () => false : (opts) => opts.mkdirSync === fs.mkdirSync;
  module.exports = { useNative, useNativeSync };
});

// node_modules/mkdirp/index.js
var require_mkdirp = __commonJS((exports, module) => {
  var optsArg = require_opts_arg();
  var pathArg = require_path_arg();
  var { mkdirpNative, mkdirpNativeSync } = require_mkdirp_native();
  var { mkdirpManual, mkdirpManualSync } = require_mkdirp_manual();
  var { useNative, useNativeSync } = require_use_native();
  var mkdirp = (path, opts) => {
    path = pathArg(path);
    opts = optsArg(opts);
    return useNative(opts) ? mkdirpNative(path, opts) : mkdirpManual(path, opts);
  };
  var mkdirpSync = (path, opts) => {
    path = pathArg(path);
    opts = optsArg(opts);
    return useNativeSync(opts) ? mkdirpNativeSync(path, opts) : mkdirpManualSync(path, opts);
  };
  mkdirp.sync = mkdirpSync;
  mkdirp.native = (path, opts) => mkdirpNative(pathArg(path), optsArg(opts));
  mkdirp.manual = (path, opts) => mkdirpManual(pathArg(path), optsArg(opts));
  mkdirp.nativeSync = (path, opts) => mkdirpNativeSync(pathArg(path), optsArg(opts));
  mkdirp.manualSync = (path, opts) => mkdirpManualSync(pathArg(path), optsArg(opts));
  module.exports = mkdirp;
});

// node_modules/chownr/chownr.js
var require_chownr = __commonJS((exports, module) => {
  var fs = __require("fs");
  var path = __require("path");
  var LCHOWN = fs.lchown ? "lchown" : "chown";
  var LCHOWNSYNC = fs.lchownSync ? "lchownSync" : "chownSync";
  var needEISDIRHandled = fs.lchown && !process.version.match(/v1[1-9]+\./) && !process.version.match(/v10\.[6-9]/);
  var lchownSync = (path2, uid, gid) => {
    try {
      return fs[LCHOWNSYNC](path2, uid, gid);
    } catch (er) {
      if (er.code !== "ENOENT")
        throw er;
    }
  };
  var chownSync = (path2, uid, gid) => {
    try {
      return fs.chownSync(path2, uid, gid);
    } catch (er) {
      if (er.code !== "ENOENT")
        throw er;
    }
  };
  var handleEISDIR = needEISDIRHandled ? (path2, uid, gid, cb) => (er) => {
    if (!er || er.code !== "EISDIR")
      cb(er);
    else
      fs.chown(path2, uid, gid, cb);
  } : (_, __, ___, cb) => cb;
  var handleEISDirSync = needEISDIRHandled ? (path2, uid, gid) => {
    try {
      return lchownSync(path2, uid, gid);
    } catch (er) {
      if (er.code !== "EISDIR")
        throw er;
      chownSync(path2, uid, gid);
    }
  } : (path2, uid, gid) => lchownSync(path2, uid, gid);
  var nodeVersion = process.version;
  var readdir = (path2, options2, cb) => fs.readdir(path2, options2, cb);
  var readdirSync = (path2, options2) => fs.readdirSync(path2, options2);
  if (/^v4\./.test(nodeVersion))
    readdir = (path2, options2, cb) => fs.readdir(path2, cb);
  var chown = (cpath, uid, gid, cb) => {
    fs[LCHOWN](cpath, uid, gid, handleEISDIR(cpath, uid, gid, (er) => {
      cb(er && er.code !== "ENOENT" ? er : null);
    }));
  };
  var chownrKid = (p, child, uid, gid, cb) => {
    if (typeof child === "string")
      return fs.lstat(path.resolve(p, child), (er, stats) => {
        if (er)
          return cb(er.code !== "ENOENT" ? er : null);
        stats.name = child;
        chownrKid(p, stats, uid, gid, cb);
      });
    if (child.isDirectory()) {
      chownr(path.resolve(p, child.name), uid, gid, (er) => {
        if (er)
          return cb(er);
        const cpath = path.resolve(p, child.name);
        chown(cpath, uid, gid, cb);
      });
    } else {
      const cpath = path.resolve(p, child.name);
      chown(cpath, uid, gid, cb);
    }
  };
  var chownr = (p, uid, gid, cb) => {
    readdir(p, { withFileTypes: true }, (er, children) => {
      if (er) {
        if (er.code === "ENOENT")
          return cb();
        else if (er.code !== "ENOTDIR" && er.code !== "ENOTSUP")
          return cb(er);
      }
      if (er || !children.length)
        return chown(p, uid, gid, cb);
      let len = children.length;
      let errState = null;
      const then = (er2) => {
        if (errState)
          return;
        if (er2)
          return cb(errState = er2);
        if (--len === 0)
          return chown(p, uid, gid, cb);
      };
      children.forEach((child) => chownrKid(p, child, uid, gid, then));
    });
  };
  var chownrKidSync = (p, child, uid, gid) => {
    if (typeof child === "string") {
      try {
        const stats = fs.lstatSync(path.resolve(p, child));
        stats.name = child;
        child = stats;
      } catch (er) {
        if (er.code === "ENOENT")
          return;
        else
          throw er;
      }
    }
    if (child.isDirectory())
      chownrSync(path.resolve(p, child.name), uid, gid);
    handleEISDirSync(path.resolve(p, child.name), uid, gid);
  };
  var chownrSync = (p, uid, gid) => {
    let children;
    try {
      children = readdirSync(p, { withFileTypes: true });
    } catch (er) {
      if (er.code === "ENOENT")
        return;
      else if (er.code === "ENOTDIR" || er.code === "ENOTSUP")
        return handleEISDirSync(p, uid, gid);
      else
        throw er;
    }
    if (children && children.length)
      children.forEach((child) => chownrKidSync(p, child, uid, gid));
    return handleEISDirSync(p, uid, gid);
  };
  module.exports = chownr;
  chownr.sync = chownrSync;
});

// node_modules/tar/lib/mkdir.js
var require_mkdir = __commonJS((exports, module) => {
  var mkdirp = require_mkdirp();
  var fs = __require("fs");
  var path = __require("path");
  var chownr = require_chownr();
  var normPath = require_normalize_windows_path();

  class SymlinkError extends Error {
    constructor(symlink, path2) {
      super("Cannot extract through symbolic link");
      this.path = path2;
      this.symlink = symlink;
    }
    get name() {
      return "SylinkError";
    }
  }

  class CwdError extends Error {
    constructor(path2, code) {
      super(code + ": Cannot cd into '" + path2 + "'");
      this.path = path2;
      this.code = code;
    }
    get name() {
      return "CwdError";
    }
  }
  var cGet = (cache, key) => cache.get(normPath(key));
  var cSet = (cache, key, val) => cache.set(normPath(key), val);
  var checkCwd = (dir, cb) => {
    fs.stat(dir, (er, st) => {
      if (er || !st.isDirectory()) {
        er = new CwdError(dir, er && er.code || "ENOTDIR");
      }
      cb(er);
    });
  };
  module.exports = (dir, opt, cb) => {
    dir = normPath(dir);
    const umask = opt.umask;
    const mode = opt.mode | 448;
    const needChmod = (mode & umask) !== 0;
    const uid = opt.uid;
    const gid = opt.gid;
    const doChown = typeof uid === "number" && typeof gid === "number" && (uid !== opt.processUid || gid !== opt.processGid);
    const preserve = opt.preserve;
    const unlink = opt.unlink;
    const cache = opt.cache;
    const cwd = normPath(opt.cwd);
    const done = (er, created) => {
      if (er) {
        cb(er);
      } else {
        cSet(cache, dir, true);
        if (created && doChown) {
          chownr(created, uid, gid, (er2) => done(er2));
        } else if (needChmod) {
          fs.chmod(dir, mode, cb);
        } else {
          cb();
        }
      }
    };
    if (cache && cGet(cache, dir) === true) {
      return done();
    }
    if (dir === cwd) {
      return checkCwd(dir, done);
    }
    if (preserve) {
      return mkdirp(dir, { mode }).then((made) => done(null, made), done);
    }
    const sub = normPath(path.relative(cwd, dir));
    const parts = sub.split("/");
    mkdir_(cwd, parts, mode, cache, unlink, cwd, null, done);
  };
  var mkdir_ = (base, parts, mode, cache, unlink, cwd, created, cb) => {
    if (!parts.length) {
      return cb(null, created);
    }
    const p = parts.shift();
    const part = normPath(path.resolve(base + "/" + p));
    if (cGet(cache, part)) {
      return mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);
    }
    fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb));
  };
  var onmkdir = (part, parts, mode, cache, unlink, cwd, created, cb) => (er) => {
    if (er) {
      fs.lstat(part, (statEr, st) => {
        if (statEr) {
          statEr.path = statEr.path && normPath(statEr.path);
          cb(statEr);
        } else if (st.isDirectory()) {
          mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);
        } else if (unlink) {
          fs.unlink(part, (er2) => {
            if (er2) {
              return cb(er2);
            }
            fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb));
          });
        } else if (st.isSymbolicLink()) {
          return cb(new SymlinkError(part, part + "/" + parts.join("/")));
        } else {
          cb(er);
        }
      });
    } else {
      created = created || part;
      mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);
    }
  };
  var checkCwdSync = (dir) => {
    let ok = false;
    let code = "ENOTDIR";
    try {
      ok = fs.statSync(dir).isDirectory();
    } catch (er) {
      code = er.code;
    } finally {
      if (!ok) {
        throw new CwdError(dir, code);
      }
    }
  };
  module.exports.sync = (dir, opt) => {
    dir = normPath(dir);
    const umask = opt.umask;
    const mode = opt.mode | 448;
    const needChmod = (mode & umask) !== 0;
    const uid = opt.uid;
    const gid = opt.gid;
    const doChown = typeof uid === "number" && typeof gid === "number" && (uid !== opt.processUid || gid !== opt.processGid);
    const preserve = opt.preserve;
    const unlink = opt.unlink;
    const cache = opt.cache;
    const cwd = normPath(opt.cwd);
    const done = (created2) => {
      cSet(cache, dir, true);
      if (created2 && doChown) {
        chownr.sync(created2, uid, gid);
      }
      if (needChmod) {
        fs.chmodSync(dir, mode);
      }
    };
    if (cache && cGet(cache, dir) === true) {
      return done();
    }
    if (dir === cwd) {
      checkCwdSync(cwd);
      return done();
    }
    if (preserve) {
      return done(mkdirp.sync(dir, mode));
    }
    const sub = normPath(path.relative(cwd, dir));
    const parts = sub.split("/");
    let created = null;
    for (let p = parts.shift(), part = cwd;p && (part += "/" + p); p = parts.shift()) {
      part = normPath(path.resolve(part));
      if (cGet(cache, part)) {
        continue;
      }
      try {
        fs.mkdirSync(part, mode);
        created = created || part;
        cSet(cache, part, true);
      } catch (er) {
        const st = fs.lstatSync(part);
        if (st.isDirectory()) {
          cSet(cache, part, true);
          continue;
        } else if (unlink) {
          fs.unlinkSync(part);
          fs.mkdirSync(part, mode);
          created = created || part;
          cSet(cache, part, true);
          continue;
        } else if (st.isSymbolicLink()) {
          return new SymlinkError(part, part + "/" + parts.join("/"));
        }
      }
    }
    return done(created);
  };
});

// node_modules/tar/lib/normalize-unicode.js
var require_normalize_unicode = __commonJS((exports, module) => {
  var normalizeCache = Object.create(null);
  var { hasOwnProperty } = Object.prototype;
  module.exports = (s) => {
    if (!hasOwnProperty.call(normalizeCache, s)) {
      normalizeCache[s] = s.normalize("NFD");
    }
    return normalizeCache[s];
  };
});

// node_modules/tar/lib/path-reservations.js
var require_path_reservations = __commonJS((exports, module) => {
  var assert2 = __require("assert");
  var normalize = require_normalize_unicode();
  var stripSlashes = require_strip_trailing_slashes();
  var { join: join4 } = __require("path");
  var platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;
  var isWindows = platform === "win32";
  module.exports = () => {
    const queues = new Map;
    const reservations = new Map;
    const getDirs = (path) => {
      const dirs = path.split("/").slice(0, -1).reduce((set2, path2) => {
        if (set2.length) {
          path2 = join4(set2[set2.length - 1], path2);
        }
        set2.push(path2 || "/");
        return set2;
      }, []);
      return dirs;
    };
    const running = new Set;
    const getQueues = (fn) => {
      const res = reservations.get(fn);
      if (!res) {
        throw new Error("function does not have any path reservations");
      }
      return {
        paths: res.paths.map((path) => queues.get(path)),
        dirs: [...res.dirs].map((path) => queues.get(path))
      };
    };
    const check2 = (fn) => {
      const { paths, dirs } = getQueues(fn);
      return paths.every((q) => q[0] === fn) && dirs.every((q) => q[0] instanceof Set && q[0].has(fn));
    };
    const run = (fn) => {
      if (running.has(fn) || !check2(fn)) {
        return false;
      }
      running.add(fn);
      fn(() => clear(fn));
      return true;
    };
    const clear = (fn) => {
      if (!running.has(fn)) {
        return false;
      }
      const { paths, dirs } = reservations.get(fn);
      const next = new Set;
      paths.forEach((path) => {
        const q = queues.get(path);
        assert2.equal(q[0], fn);
        if (q.length === 1) {
          queues.delete(path);
        } else {
          q.shift();
          if (typeof q[0] === "function") {
            next.add(q[0]);
          } else {
            q[0].forEach((fn2) => next.add(fn2));
          }
        }
      });
      dirs.forEach((dir) => {
        const q = queues.get(dir);
        assert2(q[0] instanceof Set);
        if (q[0].size === 1 && q.length === 1) {
          queues.delete(dir);
        } else if (q[0].size === 1) {
          q.shift();
          next.add(q[0]);
        } else {
          q[0].delete(fn);
        }
      });
      running.delete(fn);
      next.forEach((fn2) => run(fn2));
      return true;
    };
    const reserve = (paths, fn) => {
      paths = isWindows ? ["win32 parallelization disabled"] : paths.map((p) => {
        return stripSlashes(join4(normalize(p))).toLowerCase();
      });
      const dirs = new Set(paths.map((path) => getDirs(path)).reduce((a, b) => a.concat(b)));
      reservations.set(fn, { dirs, paths });
      paths.forEach((path) => {
        const q = queues.get(path);
        if (!q) {
          queues.set(path, [fn]);
        } else {
          q.push(fn);
        }
      });
      dirs.forEach((dir) => {
        const q = queues.get(dir);
        if (!q) {
          queues.set(dir, [new Set([fn])]);
        } else if (q[q.length - 1] instanceof Set) {
          q[q.length - 1].add(fn);
        } else {
          q.push(new Set([fn]));
        }
      });
      return run(fn);
    };
    return { check: check2, reserve };
  };
});

// node_modules/tar/lib/get-write-flag.js
var require_get_write_flag = __commonJS((exports, module) => {
  var platform = process.env.__FAKE_PLATFORM__ || process.platform;
  var isWindows = platform === "win32";
  var fs = global.__FAKE_TESTING_FS__ || __require("fs");
  var { O_CREAT, O_TRUNC, O_WRONLY, UV_FS_O_FILEMAP = 0 } = fs.constants;
  var fMapEnabled = isWindows && !!UV_FS_O_FILEMAP;
  var fMapLimit = 512 * 1024;
  var fMapFlag = UV_FS_O_FILEMAP | O_TRUNC | O_CREAT | O_WRONLY;
  module.exports = !fMapEnabled ? () => "w" : (size) => size < fMapLimit ? fMapFlag : "w";
});

// node_modules/tar/lib/unpack.js
var require_unpack = __commonJS((exports, module) => {
  var assert2 = __require("assert");
  var Parser = require_parse();
  var fs = __require("fs");
  var fsm = require_fs_minipass();
  var path = __require("path");
  var mkdir = require_mkdir();
  var wc = require_winchars();
  var pathReservations = require_path_reservations();
  var stripAbsolutePath = require_strip_absolute_path();
  var normPath = require_normalize_windows_path();
  var stripSlash = require_strip_trailing_slashes();
  var normalize = require_normalize_unicode();
  var ONENTRY = Symbol("onEntry");
  var CHECKFS = Symbol("checkFs");
  var CHECKFS2 = Symbol("checkFs2");
  var PRUNECACHE = Symbol("pruneCache");
  var ISREUSABLE = Symbol("isReusable");
  var MAKEFS = Symbol("makeFs");
  var FILE = Symbol("file");
  var DIRECTORY = Symbol("directory");
  var LINK = Symbol("link");
  var SYMLINK = Symbol("symlink");
  var HARDLINK = Symbol("hardlink");
  var UNSUPPORTED = Symbol("unsupported");
  var CHECKPATH = Symbol("checkPath");
  var MKDIR = Symbol("mkdir");
  var ONERROR = Symbol("onError");
  var PENDING = Symbol("pending");
  var PEND = Symbol("pend");
  var UNPEND = Symbol("unpend");
  var ENDED = Symbol("ended");
  var MAYBECLOSE = Symbol("maybeClose");
  var SKIP = Symbol("skip");
  var DOCHOWN = Symbol("doChown");
  var UID = Symbol("uid");
  var GID = Symbol("gid");
  var CHECKED_CWD = Symbol("checkedCwd");
  var crypto2 = __require("crypto");
  var getFlag = require_get_write_flag();
  var platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;
  var isWindows = platform === "win32";
  var DEFAULT_MAX_DEPTH = 1024;
  var unlinkFile = (path2, cb) => {
    if (!isWindows) {
      return fs.unlink(path2, cb);
    }
    const name = path2 + ".DELETE." + crypto2.randomBytes(16).toString("hex");
    fs.rename(path2, name, (er) => {
      if (er) {
        return cb(er);
      }
      fs.unlink(name, cb);
    });
  };
  var unlinkFileSync = (path2) => {
    if (!isWindows) {
      return fs.unlinkSync(path2);
    }
    const name = path2 + ".DELETE." + crypto2.randomBytes(16).toString("hex");
    fs.renameSync(path2, name);
    fs.unlinkSync(name);
  };
  var uint322 = (a, b, c) => a === a >>> 0 ? a : b === b >>> 0 ? b : c;
  var cacheKeyNormalize = (path2) => stripSlash(normPath(normalize(path2))).toLowerCase();
  var pruneCache = (cache, abs) => {
    abs = cacheKeyNormalize(abs);
    for (const path2 of cache.keys()) {
      const pnorm = cacheKeyNormalize(path2);
      if (pnorm === abs || pnorm.indexOf(abs + "/") === 0) {
        cache.delete(path2);
      }
    }
  };
  var dropCache = (cache) => {
    for (const key of cache.keys()) {
      cache.delete(key);
    }
  };

  class Unpack extends Parser {
    constructor(opt) {
      if (!opt) {
        opt = {};
      }
      opt.ondone = (_) => {
        this[ENDED] = true;
        this[MAYBECLOSE]();
      };
      super(opt);
      this[CHECKED_CWD] = false;
      this.reservations = pathReservations();
      this.transform = typeof opt.transform === "function" ? opt.transform : null;
      this.writable = true;
      this.readable = false;
      this[PENDING] = 0;
      this[ENDED] = false;
      this.dirCache = opt.dirCache || new Map;
      if (typeof opt.uid === "number" || typeof opt.gid === "number") {
        if (typeof opt.uid !== "number" || typeof opt.gid !== "number") {
          throw new TypeError("cannot set owner without number uid and gid");
        }
        if (opt.preserveOwner) {
          throw new TypeError("cannot preserve owner in archive and also set owner explicitly");
        }
        this.uid = opt.uid;
        this.gid = opt.gid;
        this.setOwner = true;
      } else {
        this.uid = null;
        this.gid = null;
        this.setOwner = false;
      }
      if (opt.preserveOwner === undefined && typeof opt.uid !== "number") {
        this.preserveOwner = process.getuid && process.getuid() === 0;
      } else {
        this.preserveOwner = !!opt.preserveOwner;
      }
      this.processUid = (this.preserveOwner || this.setOwner) && process.getuid ? process.getuid() : null;
      this.processGid = (this.preserveOwner || this.setOwner) && process.getgid ? process.getgid() : null;
      this.maxDepth = typeof opt.maxDepth === "number" ? opt.maxDepth : DEFAULT_MAX_DEPTH;
      this.forceChown = opt.forceChown === true;
      this.win32 = !!opt.win32 || isWindows;
      this.newer = !!opt.newer;
      this.keep = !!opt.keep;
      this.noMtime = !!opt.noMtime;
      this.preservePaths = !!opt.preservePaths;
      this.unlink = !!opt.unlink;
      this.cwd = normPath(path.resolve(opt.cwd || process.cwd()));
      this.strip = +opt.strip || 0;
      this.processUmask = opt.noChmod ? 0 : process.umask();
      this.umask = typeof opt.umask === "number" ? opt.umask : this.processUmask;
      this.dmode = opt.dmode || 511 & ~this.umask;
      this.fmode = opt.fmode || 438 & ~this.umask;
      this.on("entry", (entry) => this[ONENTRY](entry));
    }
    warn(code, msg, data = {}) {
      if (code === "TAR_BAD_ARCHIVE" || code === "TAR_ABORT") {
        data.recoverable = false;
      }
      return super.warn(code, msg, data);
    }
    [MAYBECLOSE]() {
      if (this[ENDED] && this[PENDING] === 0) {
        this.emit("prefinish");
        this.emit("finish");
        this.emit("end");
      }
    }
    [CHECKPATH](entry) {
      const p = normPath(entry.path);
      const parts = p.split("/");
      if (this.strip) {
        if (parts.length < this.strip) {
          return false;
        }
        if (entry.type === "Link") {
          const linkparts = normPath(entry.linkpath).split("/");
          if (linkparts.length >= this.strip) {
            entry.linkpath = linkparts.slice(this.strip).join("/");
          } else {
            return false;
          }
        }
        parts.splice(0, this.strip);
        entry.path = parts.join("/");
      }
      if (isFinite(this.maxDepth) && parts.length > this.maxDepth) {
        this.warn("TAR_ENTRY_ERROR", "path excessively deep", {
          entry,
          path: p,
          depth: parts.length,
          maxDepth: this.maxDepth
        });
        return false;
      }
      if (!this.preservePaths) {
        if (parts.includes("..") || isWindows && /^[a-z]:\.\.$/i.test(parts[0])) {
          this.warn("TAR_ENTRY_ERROR", `path contains '..'`, {
            entry,
            path: p
          });
          return false;
        }
        const [root, stripped] = stripAbsolutePath(p);
        if (root) {
          entry.path = stripped;
          this.warn("TAR_ENTRY_INFO", `stripping ${root} from absolute path`, {
            entry,
            path: p
          });
        }
      }
      if (path.isAbsolute(entry.path)) {
        entry.absolute = normPath(path.resolve(entry.path));
      } else {
        entry.absolute = normPath(path.resolve(this.cwd, entry.path));
      }
      if (!this.preservePaths && entry.absolute.indexOf(this.cwd + "/") !== 0 && entry.absolute !== this.cwd) {
        this.warn("TAR_ENTRY_ERROR", "path escaped extraction target", {
          entry,
          path: normPath(entry.path),
          resolvedPath: entry.absolute,
          cwd: this.cwd
        });
        return false;
      }
      if (entry.absolute === this.cwd && entry.type !== "Directory" && entry.type !== "GNUDumpDir") {
        return false;
      }
      if (this.win32) {
        const { root: aRoot } = path.win32.parse(entry.absolute);
        entry.absolute = aRoot + wc.encode(entry.absolute.slice(aRoot.length));
        const { root: pRoot } = path.win32.parse(entry.path);
        entry.path = pRoot + wc.encode(entry.path.slice(pRoot.length));
      }
      return true;
    }
    [ONENTRY](entry) {
      if (!this[CHECKPATH](entry)) {
        return entry.resume();
      }
      assert2.equal(typeof entry.absolute, "string");
      switch (entry.type) {
        case "Directory":
        case "GNUDumpDir":
          if (entry.mode) {
            entry.mode = entry.mode | 448;
          }
        case "File":
        case "OldFile":
        case "ContiguousFile":
        case "Link":
        case "SymbolicLink":
          return this[CHECKFS](entry);
        case "CharacterDevice":
        case "BlockDevice":
        case "FIFO":
        default:
          return this[UNSUPPORTED](entry);
      }
    }
    [ONERROR](er, entry) {
      if (er.name === "CwdError") {
        this.emit("error", er);
      } else {
        this.warn("TAR_ENTRY_ERROR", er, { entry });
        this[UNPEND]();
        entry.resume();
      }
    }
    [MKDIR](dir, mode, cb) {
      mkdir(normPath(dir), {
        uid: this.uid,
        gid: this.gid,
        processUid: this.processUid,
        processGid: this.processGid,
        umask: this.processUmask,
        preserve: this.preservePaths,
        unlink: this.unlink,
        cache: this.dirCache,
        cwd: this.cwd,
        mode,
        noChmod: this.noChmod
      }, cb);
    }
    [DOCHOWN](entry) {
      return this.forceChown || this.preserveOwner && (typeof entry.uid === "number" && entry.uid !== this.processUid || typeof entry.gid === "number" && entry.gid !== this.processGid) || (typeof this.uid === "number" && this.uid !== this.processUid || typeof this.gid === "number" && this.gid !== this.processGid);
    }
    [UID](entry) {
      return uint322(this.uid, entry.uid, this.processUid);
    }
    [GID](entry) {
      return uint322(this.gid, entry.gid, this.processGid);
    }
    [FILE](entry, fullyDone) {
      const mode = entry.mode & 4095 || this.fmode;
      const stream = new fsm.WriteStream(entry.absolute, {
        flags: getFlag(entry.size),
        mode,
        autoClose: false
      });
      stream.on("error", (er) => {
        if (stream.fd) {
          fs.close(stream.fd, () => {});
        }
        stream.write = () => true;
        this[ONERROR](er, entry);
        fullyDone();
      });
      let actions = 1;
      const done = (er) => {
        if (er) {
          if (stream.fd) {
            fs.close(stream.fd, () => {});
          }
          this[ONERROR](er, entry);
          fullyDone();
          return;
        }
        if (--actions === 0) {
          fs.close(stream.fd, (er2) => {
            if (er2) {
              this[ONERROR](er2, entry);
            } else {
              this[UNPEND]();
            }
            fullyDone();
          });
        }
      };
      stream.on("finish", (_) => {
        const abs = entry.absolute;
        const fd = stream.fd;
        if (entry.mtime && !this.noMtime) {
          actions++;
          const atime = entry.atime || new Date;
          const mtime = entry.mtime;
          fs.futimes(fd, atime, mtime, (er) => er ? fs.utimes(abs, atime, mtime, (er2) => done(er2 && er)) : done());
        }
        if (this[DOCHOWN](entry)) {
          actions++;
          const uid = this[UID](entry);
          const gid = this[GID](entry);
          fs.fchown(fd, uid, gid, (er) => er ? fs.chown(abs, uid, gid, (er2) => done(er2 && er)) : done());
        }
        done();
      });
      const tx = this.transform ? this.transform(entry) || entry : entry;
      if (tx !== entry) {
        tx.on("error", (er) => {
          this[ONERROR](er, entry);
          fullyDone();
        });
        entry.pipe(tx);
      }
      tx.pipe(stream);
    }
    [DIRECTORY](entry, fullyDone) {
      const mode = entry.mode & 4095 || this.dmode;
      this[MKDIR](entry.absolute, mode, (er) => {
        if (er) {
          this[ONERROR](er, entry);
          fullyDone();
          return;
        }
        let actions = 1;
        const done = (_) => {
          if (--actions === 0) {
            fullyDone();
            this[UNPEND]();
            entry.resume();
          }
        };
        if (entry.mtime && !this.noMtime) {
          actions++;
          fs.utimes(entry.absolute, entry.atime || new Date, entry.mtime, done);
        }
        if (this[DOCHOWN](entry)) {
          actions++;
          fs.chown(entry.absolute, this[UID](entry), this[GID](entry), done);
        }
        done();
      });
    }
    [UNSUPPORTED](entry) {
      entry.unsupported = true;
      this.warn("TAR_ENTRY_UNSUPPORTED", `unsupported entry type: ${entry.type}`, { entry });
      entry.resume();
    }
    [SYMLINK](entry, done) {
      this[LINK](entry, entry.linkpath, "symlink", done);
    }
    [HARDLINK](entry, done) {
      const linkpath = normPath(path.resolve(this.cwd, entry.linkpath));
      this[LINK](entry, linkpath, "link", done);
    }
    [PEND]() {
      this[PENDING]++;
    }
    [UNPEND]() {
      this[PENDING]--;
      this[MAYBECLOSE]();
    }
    [SKIP](entry) {
      this[UNPEND]();
      entry.resume();
    }
    [ISREUSABLE](entry, st) {
      return entry.type === "File" && !this.unlink && st.isFile() && st.nlink <= 1 && !isWindows;
    }
    [CHECKFS](entry) {
      this[PEND]();
      const paths = [entry.path];
      if (entry.linkpath) {
        paths.push(entry.linkpath);
      }
      this.reservations.reserve(paths, (done) => this[CHECKFS2](entry, done));
    }
    [PRUNECACHE](entry) {
      if (entry.type === "SymbolicLink") {
        dropCache(this.dirCache);
      } else if (entry.type !== "Directory") {
        pruneCache(this.dirCache, entry.absolute);
      }
    }
    [CHECKFS2](entry, fullyDone) {
      this[PRUNECACHE](entry);
      const done = (er) => {
        this[PRUNECACHE](entry);
        fullyDone(er);
      };
      const checkCwd = () => {
        this[MKDIR](this.cwd, this.dmode, (er) => {
          if (er) {
            this[ONERROR](er, entry);
            done();
            return;
          }
          this[CHECKED_CWD] = true;
          start();
        });
      };
      const start = () => {
        if (entry.absolute !== this.cwd) {
          const parent = normPath(path.dirname(entry.absolute));
          if (parent !== this.cwd) {
            return this[MKDIR](parent, this.dmode, (er) => {
              if (er) {
                this[ONERROR](er, entry);
                done();
                return;
              }
              afterMakeParent();
            });
          }
        }
        afterMakeParent();
      };
      const afterMakeParent = () => {
        fs.lstat(entry.absolute, (lstatEr, st) => {
          if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {
            this[SKIP](entry);
            done();
            return;
          }
          if (lstatEr || this[ISREUSABLE](entry, st)) {
            return this[MAKEFS](null, entry, done);
          }
          if (st.isDirectory()) {
            if (entry.type === "Directory") {
              const needChmod = !this.noChmod && entry.mode && (st.mode & 4095) !== entry.mode;
              const afterChmod = (er) => this[MAKEFS](er, entry, done);
              if (!needChmod) {
                return afterChmod();
              }
              return fs.chmod(entry.absolute, entry.mode, afterChmod);
            }
            if (entry.absolute !== this.cwd) {
              return fs.rmdir(entry.absolute, (er) => this[MAKEFS](er, entry, done));
            }
          }
          if (entry.absolute === this.cwd) {
            return this[MAKEFS](null, entry, done);
          }
          unlinkFile(entry.absolute, (er) => this[MAKEFS](er, entry, done));
        });
      };
      if (this[CHECKED_CWD]) {
        start();
      } else {
        checkCwd();
      }
    }
    [MAKEFS](er, entry, done) {
      if (er) {
        this[ONERROR](er, entry);
        done();
        return;
      }
      switch (entry.type) {
        case "File":
        case "OldFile":
        case "ContiguousFile":
          return this[FILE](entry, done);
        case "Link":
          return this[HARDLINK](entry, done);
        case "SymbolicLink":
          return this[SYMLINK](entry, done);
        case "Directory":
        case "GNUDumpDir":
          return this[DIRECTORY](entry, done);
      }
    }
    [LINK](entry, linkpath, link, done) {
      fs[link](linkpath, entry.absolute, (er) => {
        if (er) {
          this[ONERROR](er, entry);
        } else {
          this[UNPEND]();
          entry.resume();
        }
        done();
      });
    }
  }
  var callSync = (fn) => {
    try {
      return [null, fn()];
    } catch (er) {
      return [er, null];
    }
  };

  class UnpackSync extends Unpack {
    [MAKEFS](er, entry) {
      return super[MAKEFS](er, entry, () => {});
    }
    [CHECKFS](entry) {
      this[PRUNECACHE](entry);
      if (!this[CHECKED_CWD]) {
        const er2 = this[MKDIR](this.cwd, this.dmode);
        if (er2) {
          return this[ONERROR](er2, entry);
        }
        this[CHECKED_CWD] = true;
      }
      if (entry.absolute !== this.cwd) {
        const parent = normPath(path.dirname(entry.absolute));
        if (parent !== this.cwd) {
          const mkParent = this[MKDIR](parent, this.dmode);
          if (mkParent) {
            return this[ONERROR](mkParent, entry);
          }
        }
      }
      const [lstatEr, st] = callSync(() => fs.lstatSync(entry.absolute));
      if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {
        return this[SKIP](entry);
      }
      if (lstatEr || this[ISREUSABLE](entry, st)) {
        return this[MAKEFS](null, entry);
      }
      if (st.isDirectory()) {
        if (entry.type === "Directory") {
          const needChmod = !this.noChmod && entry.mode && (st.mode & 4095) !== entry.mode;
          const [er3] = needChmod ? callSync(() => {
            fs.chmodSync(entry.absolute, entry.mode);
          }) : [];
          return this[MAKEFS](er3, entry);
        }
        const [er2] = callSync(() => fs.rmdirSync(entry.absolute));
        this[MAKEFS](er2, entry);
      }
      const [er] = entry.absolute === this.cwd ? [] : callSync(() => unlinkFileSync(entry.absolute));
      this[MAKEFS](er, entry);
    }
    [FILE](entry, done) {
      const mode = entry.mode & 4095 || this.fmode;
      const oner = (er) => {
        let closeError;
        try {
          fs.closeSync(fd);
        } catch (e) {
          closeError = e;
        }
        if (er || closeError) {
          this[ONERROR](er || closeError, entry);
        }
        done();
      };
      let fd;
      try {
        fd = fs.openSync(entry.absolute, getFlag(entry.size), mode);
      } catch (er) {
        return oner(er);
      }
      const tx = this.transform ? this.transform(entry) || entry : entry;
      if (tx !== entry) {
        tx.on("error", (er) => this[ONERROR](er, entry));
        entry.pipe(tx);
      }
      tx.on("data", (chunk) => {
        try {
          fs.writeSync(fd, chunk, 0, chunk.length);
        } catch (er) {
          oner(er);
        }
      });
      tx.on("end", (_) => {
        let er = null;
        if (entry.mtime && !this.noMtime) {
          const atime = entry.atime || new Date;
          const mtime = entry.mtime;
          try {
            fs.futimesSync(fd, atime, mtime);
          } catch (futimeser) {
            try {
              fs.utimesSync(entry.absolute, atime, mtime);
            } catch (utimeser) {
              er = futimeser;
            }
          }
        }
        if (this[DOCHOWN](entry)) {
          const uid = this[UID](entry);
          const gid = this[GID](entry);
          try {
            fs.fchownSync(fd, uid, gid);
          } catch (fchowner) {
            try {
              fs.chownSync(entry.absolute, uid, gid);
            } catch (chowner) {
              er = er || fchowner;
            }
          }
        }
        oner(er);
      });
    }
    [DIRECTORY](entry, done) {
      const mode = entry.mode & 4095 || this.dmode;
      const er = this[MKDIR](entry.absolute, mode);
      if (er) {
        this[ONERROR](er, entry);
        done();
        return;
      }
      if (entry.mtime && !this.noMtime) {
        try {
          fs.utimesSync(entry.absolute, entry.atime || new Date, entry.mtime);
        } catch (er2) {}
      }
      if (this[DOCHOWN](entry)) {
        try {
          fs.chownSync(entry.absolute, this[UID](entry), this[GID](entry));
        } catch (er2) {}
      }
      done();
      entry.resume();
    }
    [MKDIR](dir, mode) {
      try {
        return mkdir.sync(normPath(dir), {
          uid: this.uid,
          gid: this.gid,
          processUid: this.processUid,
          processGid: this.processGid,
          umask: this.processUmask,
          preserve: this.preservePaths,
          unlink: this.unlink,
          cache: this.dirCache,
          cwd: this.cwd,
          mode
        });
      } catch (er) {
        return er;
      }
    }
    [LINK](entry, linkpath, link, done) {
      try {
        fs[link + "Sync"](linkpath, entry.absolute);
        done();
        entry.resume();
      } catch (er) {
        return this[ONERROR](er, entry);
      }
    }
  }
  Unpack.Sync = UnpackSync;
  module.exports = Unpack;
});

// node_modules/tar/lib/extract.js
var require_extract = __commonJS((exports, module) => {
  var hlo = require_high_level_opt();
  var Unpack = require_unpack();
  var fs = __require("fs");
  var fsm = require_fs_minipass();
  var path = __require("path");
  var stripSlash = require_strip_trailing_slashes();
  module.exports = (opt_, files, cb) => {
    if (typeof opt_ === "function") {
      cb = opt_, files = null, opt_ = {};
    } else if (Array.isArray(opt_)) {
      files = opt_, opt_ = {};
    }
    if (typeof files === "function") {
      cb = files, files = null;
    }
    if (!files) {
      files = [];
    } else {
      files = Array.from(files);
    }
    const opt = hlo(opt_);
    if (opt.sync && typeof cb === "function") {
      throw new TypeError("callback not supported for sync tar functions");
    }
    if (!opt.file && typeof cb === "function") {
      throw new TypeError("callback only supported with file option");
    }
    if (files.length) {
      filesFilter(opt, files);
    }
    return opt.file && opt.sync ? extractFileSync(opt) : opt.file ? extractFile(opt, cb) : opt.sync ? extractSync(opt) : extract(opt);
  };
  var filesFilter = (opt, files) => {
    const map2 = new Map(files.map((f) => [stripSlash(f), true]));
    const filter = opt.filter;
    const mapHas = (file2, r) => {
      const root = r || path.parse(file2).root || ".";
      const ret = file2 === root ? false : map2.has(file2) ? map2.get(file2) : mapHas(path.dirname(file2), root);
      map2.set(file2, ret);
      return ret;
    };
    opt.filter = filter ? (file2, entry) => filter(file2, entry) && mapHas(stripSlash(file2)) : (file2) => mapHas(stripSlash(file2));
  };
  var extractFileSync = (opt) => {
    const u = new Unpack.Sync(opt);
    const file2 = opt.file;
    const stat = fs.statSync(file2);
    const readSize = opt.maxReadSize || 16 * 1024 * 1024;
    const stream = new fsm.ReadStreamSync(file2, {
      readSize,
      size: stat.size
    });
    stream.pipe(u);
  };
  var extractFile = (opt, cb) => {
    const u = new Unpack(opt);
    const readSize = opt.maxReadSize || 16 * 1024 * 1024;
    const file2 = opt.file;
    const p = new Promise((resolve, reject) => {
      u.on("error", reject);
      u.on("close", resolve);
      fs.stat(file2, (er, stat) => {
        if (er) {
          reject(er);
        } else {
          const stream = new fsm.ReadStream(file2, {
            readSize,
            size: stat.size
          });
          stream.on("error", reject);
          stream.pipe(u);
        }
      });
    });
    return cb ? p.then(cb, cb) : p;
  };
  var extractSync = (opt) => new Unpack.Sync(opt);
  var extract = (opt) => new Unpack(opt);
});

// node_modules/tar/index.js
var require_tar = __commonJS((exports) => {
  exports.c = exports.create = require_create();
  exports.r = exports.replace = require_replace();
  exports.t = exports.list = require_list();
  exports.u = exports.update = require_update();
  exports.x = exports.extract = require_extract();
  exports.Pack = require_pack();
  exports.Unpack = require_unpack();
  exports.Parse = require_parse();
  exports.ReadEntry = require_read_entry();
  exports.WriteEntry = require_write_entry();
  exports.Header = require_header();
  exports.Pax = require_pax();
  exports.types = require_types();
});

// node_modules/@anush008/tokenizers-darwin-universal/tokenizers.darwin-universal.node
var require_tokenizers_darwin_universal = __commonJS((exports, module) => {
  module.exports = __require("../tokenizers.darwin-universal-0nkyb4vc.node");
});

// node_modules/@anush008/tokenizers/index.js
function isMusl() {
  if (!process.report || typeof process.report.getReport !== "function") {
    try {
      const lddPath = __require("child_process").execSync("which ldd").toString().trim();
      return readFileSync2(lddPath, "utf8").includes("musl");
    } catch (e) {
      return true;
    }
  } else {
    const { glibcVersionRuntime } = process.report.getReport().header;
    return !glibcVersionRuntime;
  }
}
var __dirname = "/Users/petersmith/Dev/GitHub/amalfa/node_modules/@anush008/tokenizers", existsSync3, readFileSync2, join4, platform, arch, nativeBinding = null, localFileExisted = false, loadError = null, Decoder, bpeDecoder, byteFallbackDecoder, ctcDecoder, fuseDecoder, metaspaceDecoder, replaceDecoder, sequenceDecoder, stripDecoder, wordPieceDecoder, Encoding, TruncationDirection, TruncationStrategy, Model, BPE, WordPiece, WordLevel, Unigram, Normalizer, prependNormalizer, stripAccentsNormalizer, bertNormalizer, nfdNormalizer, nfkdNormalizer, nfcNormalizer, nfkcNormalizer, stripNormalizer, sequenceNormalizer, lowercase2, replace, nmt, precompiled, JsSplitDelimiterBehavior, PreTokenizer, byteLevelPreTokenizer, byteLevelAlphabet, whitespacePreTokenizer, whitespaceSplitPreTokenizer, bertPreTokenizer, metaspacePreTokenizer, splitPreTokenizer, punctuationPreTokenizer, sequencePreTokenizer, charDelimiterSplit, digitsPreTokenizer, Processor, bertProcessing, robertaProcessing, byteLevelProcessing, templateProcessing, sequenceProcessing, PaddingDirection, AddedToken, Tokenizer, Trainer, slice, mergeEncodings, $AddedToken, $Tokenizer;
var init_tokenizers = __esm(() => {
  ({ existsSync: existsSync3, readFileSync: readFileSync2 } = __require("fs"));
  ({ join: join4 } = __require("path"));
  ({ platform, arch } = process);
  switch (platform) {
    case "android":
      switch (arch) {
        case "arm64":
          localFileExisted = existsSync3(join4(__dirname, "tokenizers.android-arm64.node"));
          try {
            if (localFileExisted) {
              nativeBinding = (()=>{throw new Error("Cannot require module "+"./tokenizers.android-arm64.node");})();
            } else {
              nativeBinding = (()=>{throw new Error("Cannot require module "+"@anush008/tokenizers-android-arm64");})();
            }
          } catch (e) {
            loadError = e;
          }
          break;
        case "arm":
          localFileExisted = existsSync3(join4(__dirname, "tokenizers.android-arm-eabi.node"));
          try {
            if (localFileExisted) {
              nativeBinding = (()=>{throw new Error("Cannot require module "+"./tokenizers.android-arm-eabi.node");})();
            } else {
              nativeBinding = (()=>{throw new Error("Cannot require module "+"@anush008/tokenizers-android-arm-eabi");})();
            }
          } catch (e) {
            loadError = e;
          }
          break;
        default:
          throw new Error(`Unsupported architecture on Android ${arch}`);
      }
      break;
    case "win32":
      switch (arch) {
        case "x64":
          localFileExisted = existsSync3(join4(__dirname, "tokenizers.win32-x64-msvc.node"));
          try {
            if (localFileExisted) {
              nativeBinding = (()=>{throw new Error("Cannot require module "+"./tokenizers.win32-x64-msvc.node");})();
            } else {
              nativeBinding = (()=>{throw new Error("Cannot require module "+"@anush008/tokenizers-win32-x64-msvc");})();
            }
          } catch (e) {
            loadError = e;
          }
          break;
        case "ia32":
          localFileExisted = existsSync3(join4(__dirname, "tokenizers.win32-ia32-msvc.node"));
          try {
            if (localFileExisted) {
              nativeBinding = (()=>{throw new Error("Cannot require module "+"./tokenizers.win32-ia32-msvc.node");})();
            } else {
              nativeBinding = (()=>{throw new Error("Cannot require module "+"@anush008/tokenizers-win32-ia32-msvc");})();
            }
          } catch (e) {
            loadError = e;
          }
          break;
        case "arm64":
          localFileExisted = existsSync3(join4(__dirname, "tokenizers.win32-arm64-msvc.node"));
          try {
            if (localFileExisted) {
              nativeBinding = (()=>{throw new Error("Cannot require module "+"./tokenizers.win32-arm64-msvc.node");})();
            } else {
              nativeBinding = (()=>{throw new Error("Cannot require module "+"@anush008/tokenizers-win32-arm64-msvc");})();
            }
          } catch (e) {
            loadError = e;
          }
          break;
        default:
          throw new Error(`Unsupported architecture on Windows: ${arch}`);
      }
      break;
    case "darwin":
      localFileExisted = existsSync3(join4(__dirname, "tokenizers.darwin-universal.node"));
      try {
        if (localFileExisted) {
          nativeBinding = (()=>{throw new Error("Cannot require module "+"./tokenizers.darwin-universal.node");})();
        } else {
          nativeBinding = require_tokenizers_darwin_universal();
        }
        break;
      } catch {}
      switch (arch) {
        case "x64":
          localFileExisted = existsSync3(join4(__dirname, "tokenizers.darwin-x64.node"));
          try {
            if (localFileExisted) {
              nativeBinding = (()=>{throw new Error("Cannot require module "+"./tokenizers.darwin-x64.node");})();
            } else {
              nativeBinding = (()=>{throw new Error("Cannot require module "+"@anush008/tokenizers-darwin-x64");})();
            }
          } catch (e) {
            loadError = e;
          }
          break;
        case "arm64":
          localFileExisted = existsSync3(join4(__dirname, "tokenizers.darwin-arm64.node"));
          try {
            if (localFileExisted) {
              nativeBinding = (()=>{throw new Error("Cannot require module "+"./tokenizers.darwin-arm64.node");})();
            } else {
              nativeBinding = (()=>{throw new Error("Cannot require module "+"@anush008/tokenizers-darwin-arm64");})();
            }
          } catch (e) {
            loadError = e;
          }
          break;
        default:
          throw new Error(`Unsupported architecture on macOS: ${arch}`);
      }
      break;
    case "freebsd":
      if (arch !== "x64") {
        throw new Error(`Unsupported architecture on FreeBSD: ${arch}`);
      }
      localFileExisted = existsSync3(join4(__dirname, "tokenizers.freebsd-x64.node"));
      try {
        if (localFileExisted) {
          nativeBinding = (()=>{throw new Error("Cannot require module "+"./tokenizers.freebsd-x64.node");})();
        } else {
          nativeBinding = (()=>{throw new Error("Cannot require module "+"@anush008/tokenizers-freebsd-x64");})();
        }
      } catch (e) {
        loadError = e;
      }
      break;
    case "linux":
      switch (arch) {
        case "x64":
          if (isMusl()) {
            localFileExisted = existsSync3(join4(__dirname, "tokenizers.linux-x64-musl.node"));
            try {
              if (localFileExisted) {
                nativeBinding = (()=>{throw new Error("Cannot require module "+"./tokenizers.linux-x64-musl.node");})();
              } else {
                nativeBinding = (()=>{throw new Error("Cannot require module "+"@anush008/tokenizers-linux-x64-musl");})();
              }
            } catch (e) {
              loadError = e;
            }
          } else {
            localFileExisted = existsSync3(join4(__dirname, "tokenizers.linux-x64-gnu.node"));
            try {
              if (localFileExisted) {
                nativeBinding = (()=>{throw new Error("Cannot require module "+"./tokenizers.linux-x64-gnu.node");})();
              } else {
                nativeBinding = (()=>{throw new Error("Cannot require module "+"@anush008/tokenizers-linux-x64-gnu");})();
              }
            } catch (e) {
              loadError = e;
            }
          }
          break;
        case "arm64":
          if (isMusl()) {
            localFileExisted = existsSync3(join4(__dirname, "tokenizers.linux-arm64-musl.node"));
            try {
              if (localFileExisted) {
                nativeBinding = (()=>{throw new Error("Cannot require module "+"./tokenizers.linux-arm64-musl.node");})();
              } else {
                nativeBinding = (()=>{throw new Error("Cannot require module "+"@anush008/tokenizers-linux-arm64-musl");})();
              }
            } catch (e) {
              loadError = e;
            }
          } else {
            localFileExisted = existsSync3(join4(__dirname, "tokenizers.linux-arm64-gnu.node"));
            try {
              if (localFileExisted) {
                nativeBinding = (()=>{throw new Error("Cannot require module "+"./tokenizers.linux-arm64-gnu.node");})();
              } else {
                nativeBinding = (()=>{throw new Error("Cannot require module "+"@anush008/tokenizers-linux-arm64-gnu");})();
              }
            } catch (e) {
              loadError = e;
            }
          }
          break;
        case "arm":
          localFileExisted = existsSync3(join4(__dirname, "tokenizers.linux-arm-gnueabihf.node"));
          try {
            if (localFileExisted) {
              nativeBinding = (()=>{throw new Error("Cannot require module "+"./tokenizers.linux-arm-gnueabihf.node");})();
            } else {
              nativeBinding = (()=>{throw new Error("Cannot require module "+"@anush008/tokenizers-linux-arm-gnueabihf");})();
            }
          } catch (e) {
            loadError = e;
          }
          break;
        default:
          throw new Error(`Unsupported architecture on Linux: ${arch}`);
      }
      break;
    default:
      throw new Error(`Unsupported OS: ${platform}, architecture: ${arch}`);
  }
  if (!nativeBinding) {
    if (loadError) {
      throw loadError;
    }
    throw new Error(`Failed to load native binding`);
  }
  ({ Decoder, bpeDecoder, byteFallbackDecoder, ctcDecoder, fuseDecoder, metaspaceDecoder, replaceDecoder, sequenceDecoder, stripDecoder, wordPieceDecoder, Encoding, TruncationDirection, TruncationStrategy, Model, BPE, WordPiece, WordLevel, Unigram, Normalizer, prependNormalizer, stripAccentsNormalizer, bertNormalizer, nfdNormalizer, nfkdNormalizer, nfcNormalizer, nfkcNormalizer, stripNormalizer, sequenceNormalizer, lowercase: lowercase2, replace, nmt, precompiled, JsSplitDelimiterBehavior, PreTokenizer, byteLevelPreTokenizer, byteLevelAlphabet, whitespacePreTokenizer, whitespaceSplitPreTokenizer, bertPreTokenizer, metaspacePreTokenizer, splitPreTokenizer, punctuationPreTokenizer, sequencePreTokenizer, charDelimiterSplit, digitsPreTokenizer, Processor, bertProcessing, robertaProcessing, byteLevelProcessing, templateProcessing, sequenceProcessing, PaddingDirection, AddedToken, Tokenizer, Trainer, slice, mergeEncodings } = nativeBinding);
  $AddedToken = AddedToken;
  $Tokenizer = Tokenizer;
});

// node_modules/onnxruntime-common/dist/cjs/backend-impl.js
var require_backend_impl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveBackendAndExecutionProviders = exports.registerBackend = undefined;
  var backends = new Map;
  var backendsSortedByPriority = [];
  var registerBackend = (name, backend, priority) => {
    if (backend && typeof backend.init === "function" && typeof backend.createInferenceSessionHandler === "function") {
      const currentBackend = backends.get(name);
      if (currentBackend === undefined) {
        backends.set(name, { backend, priority });
      } else if (currentBackend.priority > priority) {
        return;
      } else if (currentBackend.priority === priority) {
        if (currentBackend.backend !== backend) {
          throw new Error(`cannot register backend "${name}" using priority ${priority}`);
        }
      }
      if (priority >= 0) {
        const i = backendsSortedByPriority.indexOf(name);
        if (i !== -1) {
          backendsSortedByPriority.splice(i, 1);
        }
        for (let i2 = 0;i2 < backendsSortedByPriority.length; i2++) {
          if (backends.get(backendsSortedByPriority[i2]).priority <= priority) {
            backendsSortedByPriority.splice(i2, 0, name);
            return;
          }
        }
        backendsSortedByPriority.push(name);
      }
      return;
    }
    throw new TypeError("not a valid backend");
  };
  exports.registerBackend = registerBackend;
  var tryResolveAndInitializeBackend = async (backendName) => {
    const backendInfo = backends.get(backendName);
    if (!backendInfo) {
      return "backend not found.";
    }
    if (backendInfo.initialized) {
      return backendInfo.backend;
    } else if (backendInfo.aborted) {
      return backendInfo.error;
    } else {
      const isInitializing = !!backendInfo.initPromise;
      try {
        if (!isInitializing) {
          backendInfo.initPromise = backendInfo.backend.init(backendName);
        }
        await backendInfo.initPromise;
        backendInfo.initialized = true;
        return backendInfo.backend;
      } catch (e) {
        if (!isInitializing) {
          backendInfo.error = `${e}`;
          backendInfo.aborted = true;
        }
        return backendInfo.error;
      } finally {
        delete backendInfo.initPromise;
      }
    }
  };
  var resolveBackendAndExecutionProviders = async (options2) => {
    const eps = options2.executionProviders || [];
    const backendHints = eps.map((i) => typeof i === "string" ? i : i.name);
    const backendNames = backendHints.length === 0 ? backendsSortedByPriority : backendHints;
    let backend;
    const errors3 = [];
    const availableBackendNames = new Set;
    for (const backendName of backendNames) {
      const resolveResult = await tryResolveAndInitializeBackend(backendName);
      if (typeof resolveResult === "string") {
        errors3.push({ name: backendName, err: resolveResult });
      } else {
        if (!backend) {
          backend = resolveResult;
        }
        if (backend === resolveResult) {
          availableBackendNames.add(backendName);
        }
      }
    }
    if (!backend) {
      throw new Error(`no available backend found. ERR: ${errors3.map((e) => `[${e.name}] ${e.err}`).join(", ")}`);
    }
    for (const { name, err } of errors3) {
      if (backendHints.includes(name)) {
        console.warn(`removing requested execution provider "${name}" from session options because it is not available: ${err}`);
      }
    }
    const filteredEps = eps.filter((i) => availableBackendNames.has(typeof i === "string" ? i : i.name));
    return [
      backend,
      new Proxy(options2, {
        get: (target, prop) => {
          if (prop === "executionProviders") {
            return filteredEps;
          }
          return Reflect.get(target, prop);
        }
      })
    ];
  };
  exports.resolveBackendAndExecutionProviders = resolveBackendAndExecutionProviders;
});

// node_modules/onnxruntime-common/dist/cjs/backend.js
var require_backend = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.registerBackend = undefined;
  var backend_impl_js_1 = require_backend_impl();
  Object.defineProperty(exports, "registerBackend", { enumerable: true, get: function() {
    return backend_impl_js_1.registerBackend;
  } });
});

// node_modules/onnxruntime-common/dist/cjs/version.js
var require_version = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.version = undefined;
  exports.version = "1.21.0";
});

// node_modules/onnxruntime-common/dist/cjs/env-impl.js
var require_env_impl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.env = undefined;
  var version_js_1 = require_version();
  var logLevelValue = "warning";
  exports.env = {
    wasm: {},
    webgl: {},
    webgpu: {},
    versions: { common: version_js_1.version },
    set logLevel(value) {
      if (value === undefined) {
        return;
      }
      if (typeof value !== "string" || ["verbose", "info", "warning", "error", "fatal"].indexOf(value) === -1) {
        throw new Error(`Unsupported logging level: ${value}`);
      }
      logLevelValue = value;
    },
    get logLevel() {
      return logLevelValue;
    }
  };
  Object.defineProperty(exports.env, "logLevel", { enumerable: true });
});

// node_modules/onnxruntime-common/dist/cjs/env.js
var require_env = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.env = undefined;
  var env_impl_js_1 = require_env_impl();
  exports.env = env_impl_js_1.env;
});

// node_modules/onnxruntime-common/dist/cjs/tensor-conversion-impl.js
var require_tensor_conversion_impl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.tensorToImageData = exports.tensorToDataURL = undefined;
  var tensorToDataURL = (tensor, options2) => {
    const canvas = typeof document !== "undefined" ? document.createElement("canvas") : new OffscreenCanvas(1, 1);
    canvas.width = tensor.dims[3];
    canvas.height = tensor.dims[2];
    const pixels2DContext = canvas.getContext("2d");
    if (pixels2DContext != null) {
      let width;
      let height;
      if (options2?.tensorLayout !== undefined && options2.tensorLayout === "NHWC") {
        width = tensor.dims[2];
        height = tensor.dims[3];
      } else {
        width = tensor.dims[3];
        height = tensor.dims[2];
      }
      const inputformat = options2?.format !== undefined ? options2.format : "RGB";
      const norm = options2?.norm;
      let normMean;
      let normBias;
      if (norm === undefined || norm.mean === undefined) {
        normMean = [255, 255, 255, 255];
      } else {
        if (typeof norm.mean === "number") {
          normMean = [norm.mean, norm.mean, norm.mean, norm.mean];
        } else {
          normMean = [norm.mean[0], norm.mean[1], norm.mean[2], 0];
          if (norm.mean[3] !== undefined) {
            normMean[3] = norm.mean[3];
          }
        }
      }
      if (norm === undefined || norm.bias === undefined) {
        normBias = [0, 0, 0, 0];
      } else {
        if (typeof norm.bias === "number") {
          normBias = [norm.bias, norm.bias, norm.bias, norm.bias];
        } else {
          normBias = [norm.bias[0], norm.bias[1], norm.bias[2], 0];
          if (norm.bias[3] !== undefined) {
            normBias[3] = norm.bias[3];
          }
        }
      }
      const stride = height * width;
      let rTensorPointer = 0, gTensorPointer = stride, bTensorPointer = stride * 2, aTensorPointer = -1;
      if (inputformat === "RGBA") {
        rTensorPointer = 0;
        gTensorPointer = stride;
        bTensorPointer = stride * 2;
        aTensorPointer = stride * 3;
      } else if (inputformat === "RGB") {
        rTensorPointer = 0;
        gTensorPointer = stride;
        bTensorPointer = stride * 2;
      } else if (inputformat === "RBG") {
        rTensorPointer = 0;
        bTensorPointer = stride;
        gTensorPointer = stride * 2;
      }
      for (let i = 0;i < height; i++) {
        for (let j = 0;j < width; j++) {
          const R = (tensor.data[rTensorPointer++] - normBias[0]) * normMean[0];
          const G = (tensor.data[gTensorPointer++] - normBias[1]) * normMean[1];
          const B = (tensor.data[bTensorPointer++] - normBias[2]) * normMean[2];
          const A = aTensorPointer === -1 ? 255 : (tensor.data[aTensorPointer++] - normBias[3]) * normMean[3];
          pixels2DContext.fillStyle = "rgba(" + R + "," + G + "," + B + "," + A + ")";
          pixels2DContext.fillRect(j, i, 1, 1);
        }
      }
      if ("toDataURL" in canvas) {
        return canvas.toDataURL();
      } else {
        throw new Error("toDataURL is not supported");
      }
    } else {
      throw new Error("Can not access image data");
    }
  };
  exports.tensorToDataURL = tensorToDataURL;
  var tensorToImageData = (tensor, options2) => {
    const pixels2DContext = typeof document !== "undefined" ? document.createElement("canvas").getContext("2d") : new OffscreenCanvas(1, 1).getContext("2d");
    let image;
    if (pixels2DContext != null) {
      let width;
      let height;
      let channels;
      if (options2?.tensorLayout !== undefined && options2.tensorLayout === "NHWC") {
        width = tensor.dims[2];
        height = tensor.dims[1];
        channels = tensor.dims[3];
      } else {
        width = tensor.dims[3];
        height = tensor.dims[2];
        channels = tensor.dims[1];
      }
      const inputformat = options2 !== undefined ? options2.format !== undefined ? options2.format : "RGB" : "RGB";
      const norm = options2?.norm;
      let normMean;
      let normBias;
      if (norm === undefined || norm.mean === undefined) {
        normMean = [255, 255, 255, 255];
      } else {
        if (typeof norm.mean === "number") {
          normMean = [norm.mean, norm.mean, norm.mean, norm.mean];
        } else {
          normMean = [norm.mean[0], norm.mean[1], norm.mean[2], 255];
          if (norm.mean[3] !== undefined) {
            normMean[3] = norm.mean[3];
          }
        }
      }
      if (norm === undefined || norm.bias === undefined) {
        normBias = [0, 0, 0, 0];
      } else {
        if (typeof norm.bias === "number") {
          normBias = [norm.bias, norm.bias, norm.bias, norm.bias];
        } else {
          normBias = [norm.bias[0], norm.bias[1], norm.bias[2], 0];
          if (norm.bias[3] !== undefined) {
            normBias[3] = norm.bias[3];
          }
        }
      }
      const stride = height * width;
      if (options2 !== undefined) {
        if (options2.format !== undefined && channels === 4 && options2.format !== "RGBA" || channels === 3 && options2.format !== "RGB" && options2.format !== "BGR") {
          throw new Error("Tensor format doesn't match input tensor dims");
        }
      }
      const step = 4;
      let rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;
      let rTensorPointer = 0, gTensorPointer = stride, bTensorPointer = stride * 2, aTensorPointer = -1;
      if (inputformat === "RGBA") {
        rTensorPointer = 0;
        gTensorPointer = stride;
        bTensorPointer = stride * 2;
        aTensorPointer = stride * 3;
      } else if (inputformat === "RGB") {
        rTensorPointer = 0;
        gTensorPointer = stride;
        bTensorPointer = stride * 2;
      } else if (inputformat === "RBG") {
        rTensorPointer = 0;
        bTensorPointer = stride;
        gTensorPointer = stride * 2;
      }
      image = pixels2DContext.createImageData(width, height);
      for (let i = 0;i < height * width; rImagePointer += step, gImagePointer += step, bImagePointer += step, aImagePointer += step, i++) {
        image.data[rImagePointer] = (tensor.data[rTensorPointer++] - normBias[0]) * normMean[0];
        image.data[gImagePointer] = (tensor.data[gTensorPointer++] - normBias[1]) * normMean[1];
        image.data[bImagePointer] = (tensor.data[bTensorPointer++] - normBias[2]) * normMean[2];
        image.data[aImagePointer] = aTensorPointer === -1 ? 255 : (tensor.data[aTensorPointer++] - normBias[3]) * normMean[3];
      }
    } else {
      throw new Error("Can not access image data");
    }
    return image;
  };
  exports.tensorToImageData = tensorToImageData;
});

// node_modules/onnxruntime-common/dist/cjs/tensor-factory-impl.js
var require_tensor_factory_impl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.tensorFromPinnedBuffer = exports.tensorFromMLTensor = exports.tensorFromGpuBuffer = exports.tensorFromTexture = exports.tensorFromImage = exports.bufferToTensor = undefined;
  var tensor_impl_js_1 = require_tensor_impl();
  var bufferToTensor = (buffer, options2) => {
    if (buffer === undefined) {
      throw new Error("Image buffer must be defined");
    }
    if (options2.height === undefined || options2.width === undefined) {
      throw new Error("Image height and width must be defined");
    }
    if (options2.tensorLayout === "NHWC") {
      throw new Error("NHWC Tensor layout is not supported yet");
    }
    const { height, width } = options2;
    const norm = options2.norm ?? { mean: 255, bias: 0 };
    let normMean;
    let normBias;
    if (typeof norm.mean === "number") {
      normMean = [norm.mean, norm.mean, norm.mean, norm.mean];
    } else {
      normMean = [norm.mean[0], norm.mean[1], norm.mean[2], norm.mean[3] ?? 255];
    }
    if (typeof norm.bias === "number") {
      normBias = [norm.bias, norm.bias, norm.bias, norm.bias];
    } else {
      normBias = [norm.bias[0], norm.bias[1], norm.bias[2], norm.bias[3] ?? 0];
    }
    const inputformat = options2.format !== undefined ? options2.format : "RGBA";
    const outputformat = options2.tensorFormat !== undefined ? options2.tensorFormat !== undefined ? options2.tensorFormat : "RGB" : "RGB";
    const stride = height * width;
    const float32Data = outputformat === "RGBA" ? new Float32Array(stride * 4) : new Float32Array(stride * 3);
    let step = 4, rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;
    let rTensorPointer = 0, gTensorPointer = stride, bTensorPointer = stride * 2, aTensorPointer = -1;
    if (inputformat === "RGB") {
      step = 3;
      rImagePointer = 0;
      gImagePointer = 1;
      bImagePointer = 2;
      aImagePointer = -1;
    }
    if (outputformat === "RGBA") {
      aTensorPointer = stride * 3;
    } else if (outputformat === "RBG") {
      rTensorPointer = 0;
      bTensorPointer = stride;
      gTensorPointer = stride * 2;
    } else if (outputformat === "BGR") {
      bTensorPointer = 0;
      gTensorPointer = stride;
      rTensorPointer = stride * 2;
    }
    for (let i = 0;i < stride; i++, rImagePointer += step, bImagePointer += step, gImagePointer += step, aImagePointer += step) {
      float32Data[rTensorPointer++] = (buffer[rImagePointer] + normBias[0]) / normMean[0];
      float32Data[gTensorPointer++] = (buffer[gImagePointer] + normBias[1]) / normMean[1];
      float32Data[bTensorPointer++] = (buffer[bImagePointer] + normBias[2]) / normMean[2];
      if (aTensorPointer !== -1 && aImagePointer !== -1) {
        float32Data[aTensorPointer++] = (buffer[aImagePointer] + normBias[3]) / normMean[3];
      }
    }
    const outputTensor = outputformat === "RGBA" ? new tensor_impl_js_1.Tensor("float32", float32Data, [1, 4, height, width]) : new tensor_impl_js_1.Tensor("float32", float32Data, [1, 3, height, width]);
    return outputTensor;
  };
  exports.bufferToTensor = bufferToTensor;
  var tensorFromImage = async (image, options2) => {
    const isHTMLImageEle = typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement;
    const isImageDataEle = typeof ImageData !== "undefined" && image instanceof ImageData;
    const isImageBitmap = typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap;
    const isString = typeof image === "string";
    let data;
    let bufferToTensorOptions = options2 ?? {};
    const createCanvas = () => {
      if (typeof document !== "undefined") {
        return document.createElement("canvas");
      } else if (typeof OffscreenCanvas !== "undefined") {
        return new OffscreenCanvas(1, 1);
      } else {
        throw new Error("Canvas is not supported");
      }
    };
    const createCanvasContext = (canvas) => {
      if (typeof HTMLCanvasElement !== "undefined" && canvas instanceof HTMLCanvasElement) {
        return canvas.getContext("2d");
      } else if (canvas instanceof OffscreenCanvas) {
        return canvas.getContext("2d");
      } else {
        return null;
      }
    };
    if (isHTMLImageEle) {
      const canvas = createCanvas();
      canvas.width = image.width;
      canvas.height = image.height;
      const pixels2DContext = createCanvasContext(canvas);
      if (pixels2DContext != null) {
        let height = image.height;
        let width = image.width;
        if (options2 !== undefined && options2.resizedHeight !== undefined && options2.resizedWidth !== undefined) {
          height = options2.resizedHeight;
          width = options2.resizedWidth;
        }
        if (options2 !== undefined) {
          bufferToTensorOptions = options2;
          if (options2.tensorFormat !== undefined) {
            throw new Error("Image input config format must be RGBA for HTMLImageElement");
          } else {
            bufferToTensorOptions.tensorFormat = "RGBA";
          }
          bufferToTensorOptions.height = height;
          bufferToTensorOptions.width = width;
        } else {
          bufferToTensorOptions.tensorFormat = "RGBA";
          bufferToTensorOptions.height = height;
          bufferToTensorOptions.width = width;
        }
        pixels2DContext.drawImage(image, 0, 0);
        data = pixels2DContext.getImageData(0, 0, width, height).data;
      } else {
        throw new Error("Can not access image data");
      }
    } else if (isImageDataEle) {
      let height;
      let width;
      if (options2 !== undefined && options2.resizedWidth !== undefined && options2.resizedHeight !== undefined) {
        height = options2.resizedHeight;
        width = options2.resizedWidth;
      } else {
        height = image.height;
        width = image.width;
      }
      if (options2 !== undefined) {
        bufferToTensorOptions = options2;
      }
      bufferToTensorOptions.format = "RGBA";
      bufferToTensorOptions.height = height;
      bufferToTensorOptions.width = width;
      if (options2 !== undefined) {
        const tempCanvas = createCanvas();
        tempCanvas.width = width;
        tempCanvas.height = height;
        const pixels2DContext = createCanvasContext(tempCanvas);
        if (pixels2DContext != null) {
          pixels2DContext.putImageData(image, 0, 0);
          data = pixels2DContext.getImageData(0, 0, width, height).data;
        } else {
          throw new Error("Can not access image data");
        }
      } else {
        data = image.data;
      }
    } else if (isImageBitmap) {
      if (options2 === undefined) {
        throw new Error("Please provide image config with format for Imagebitmap");
      }
      const canvas = createCanvas();
      canvas.width = image.width;
      canvas.height = image.height;
      const pixels2DContext = createCanvasContext(canvas);
      if (pixels2DContext != null) {
        const height = image.height;
        const width = image.width;
        pixels2DContext.drawImage(image, 0, 0, width, height);
        data = pixels2DContext.getImageData(0, 0, width, height).data;
        bufferToTensorOptions.height = height;
        bufferToTensorOptions.width = width;
        return (0, exports.bufferToTensor)(data, bufferToTensorOptions);
      } else {
        throw new Error("Can not access image data");
      }
    } else if (isString) {
      return new Promise((resolve, reject) => {
        const canvas = createCanvas();
        const context = createCanvasContext(canvas);
        if (!image || !context) {
          return reject();
        }
        const newImage = new Image;
        newImage.crossOrigin = "Anonymous";
        newImage.src = image;
        newImage.onload = () => {
          canvas.width = newImage.width;
          canvas.height = newImage.height;
          context.drawImage(newImage, 0, 0, canvas.width, canvas.height);
          const img = context.getImageData(0, 0, canvas.width, canvas.height);
          bufferToTensorOptions.height = canvas.height;
          bufferToTensorOptions.width = canvas.width;
          resolve((0, exports.bufferToTensor)(img.data, bufferToTensorOptions));
        };
      });
    } else {
      throw new Error("Input data provided is not supported - aborted tensor creation");
    }
    if (data !== undefined) {
      return (0, exports.bufferToTensor)(data, bufferToTensorOptions);
    } else {
      throw new Error("Input data provided is not supported - aborted tensor creation");
    }
  };
  exports.tensorFromImage = tensorFromImage;
  var tensorFromTexture = (texture, options2) => {
    const { width, height, download, dispose } = options2;
    const dims = [1, height, width, 4];
    return new tensor_impl_js_1.Tensor({ location: "texture", type: "float32", texture, dims, download, dispose });
  };
  exports.tensorFromTexture = tensorFromTexture;
  var tensorFromGpuBuffer = (gpuBuffer, options2) => {
    const { dataType, dims, download, dispose } = options2;
    return new tensor_impl_js_1.Tensor({ location: "gpu-buffer", type: dataType ?? "float32", gpuBuffer, dims, download, dispose });
  };
  exports.tensorFromGpuBuffer = tensorFromGpuBuffer;
  var tensorFromMLTensor = (mlTensor, options2) => {
    const { dataType, dims, download, dispose } = options2;
    return new tensor_impl_js_1.Tensor({ location: "ml-tensor", type: dataType ?? "float32", mlTensor, dims, download, dispose });
  };
  exports.tensorFromMLTensor = tensorFromMLTensor;
  var tensorFromPinnedBuffer = (type, buffer, dims) => new tensor_impl_js_1.Tensor({ location: "cpu-pinned", type, data: buffer, dims: dims ?? [buffer.length] });
  exports.tensorFromPinnedBuffer = tensorFromPinnedBuffer;
});

// node_modules/onnxruntime-common/dist/cjs/tensor-impl-type-mapping.js
var require_tensor_impl_type_mapping = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.checkTypedArray = exports.NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP = exports.NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP = undefined;
  exports.NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP = new Map([
    ["float32", Float32Array],
    ["uint8", Uint8Array],
    ["int8", Int8Array],
    ["uint16", Uint16Array],
    ["int16", Int16Array],
    ["int32", Int32Array],
    ["bool", Uint8Array],
    ["float64", Float64Array],
    ["uint32", Uint32Array],
    ["int4", Uint8Array],
    ["uint4", Uint8Array]
  ]);
  exports.NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP = new Map([
    [Float32Array, "float32"],
    [Uint8Array, "uint8"],
    [Int8Array, "int8"],
    [Uint16Array, "uint16"],
    [Int16Array, "int16"],
    [Int32Array, "int32"],
    [Float64Array, "float64"],
    [Uint32Array, "uint32"]
  ]);
  var isTypedArrayChecked = false;
  var checkTypedArray = () => {
    if (!isTypedArrayChecked) {
      isTypedArrayChecked = true;
      const isBigInt64ArrayAvailable = typeof BigInt64Array !== "undefined" && BigInt64Array.from;
      const isBigUint64ArrayAvailable = typeof BigUint64Array !== "undefined" && BigUint64Array.from;
      const Float16Array2 = globalThis.Float16Array;
      const isFloat16ArrayAvailable = typeof Float16Array2 !== "undefined" && Float16Array2.from;
      if (isBigInt64ArrayAvailable) {
        exports.NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("int64", BigInt64Array);
        exports.NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigInt64Array, "int64");
      }
      if (isBigUint64ArrayAvailable) {
        exports.NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("uint64", BigUint64Array);
        exports.NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigUint64Array, "uint64");
      }
      if (isFloat16ArrayAvailable) {
        exports.NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("float16", Float16Array2);
        exports.NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(Float16Array2, "float16");
      } else {
        exports.NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("float16", Uint16Array);
      }
    }
  };
  exports.checkTypedArray = checkTypedArray;
});

// node_modules/onnxruntime-common/dist/cjs/tensor-utils-impl.js
var require_tensor_utils_impl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.tensorReshape = exports.calculateSize = undefined;
  var tensor_impl_js_1 = require_tensor_impl();
  var calculateSize = (dims) => {
    let size = 1;
    for (let i = 0;i < dims.length; i++) {
      const dim = dims[i];
      if (typeof dim !== "number" || !Number.isSafeInteger(dim)) {
        throw new TypeError(`dims[${i}] must be an integer, got: ${dim}`);
      }
      if (dim < 0) {
        throw new RangeError(`dims[${i}] must be a non-negative integer, got: ${dim}`);
      }
      size *= dim;
    }
    return size;
  };
  exports.calculateSize = calculateSize;
  var tensorReshape = (tensor, dims) => {
    switch (tensor.location) {
      case "cpu":
        return new tensor_impl_js_1.Tensor(tensor.type, tensor.data, dims);
      case "cpu-pinned":
        return new tensor_impl_js_1.Tensor({
          location: "cpu-pinned",
          data: tensor.data,
          type: tensor.type,
          dims
        });
      case "texture":
        return new tensor_impl_js_1.Tensor({
          location: "texture",
          texture: tensor.texture,
          type: tensor.type,
          dims
        });
      case "gpu-buffer":
        return new tensor_impl_js_1.Tensor({
          location: "gpu-buffer",
          gpuBuffer: tensor.gpuBuffer,
          type: tensor.type,
          dims
        });
      case "ml-tensor":
        return new tensor_impl_js_1.Tensor({
          location: "ml-tensor",
          mlTensor: tensor.mlTensor,
          type: tensor.type,
          dims
        });
      default:
        throw new Error(`tensorReshape: tensor location ${tensor.location} is not supported`);
    }
  };
  exports.tensorReshape = tensorReshape;
});

// node_modules/onnxruntime-common/dist/cjs/tensor-impl.js
var require_tensor_impl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Tensor = undefined;
  var tensor_conversion_impl_js_1 = require_tensor_conversion_impl();
  var tensor_factory_impl_js_1 = require_tensor_factory_impl();
  var tensor_impl_type_mapping_js_1 = require_tensor_impl_type_mapping();
  var tensor_utils_impl_js_1 = require_tensor_utils_impl();

  class Tensor {
    constructor(arg0, arg1, arg2) {
      (0, tensor_impl_type_mapping_js_1.checkTypedArray)();
      let type;
      let dims;
      if (typeof arg0 === "object" && "location" in arg0) {
        this.dataLocation = arg0.location;
        type = arg0.type;
        dims = arg0.dims;
        switch (arg0.location) {
          case "cpu-pinned": {
            const expectedTypedArrayConstructor = tensor_impl_type_mapping_js_1.NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(type);
            if (!expectedTypedArrayConstructor) {
              throw new TypeError(`unsupported type "${type}" to create tensor from pinned buffer`);
            }
            if (!(arg0.data instanceof expectedTypedArrayConstructor)) {
              throw new TypeError(`buffer should be of type ${expectedTypedArrayConstructor.name}`);
            }
            this.cpuData = arg0.data;
            break;
          }
          case "texture": {
            if (type !== "float32") {
              throw new TypeError(`unsupported type "${type}" to create tensor from texture`);
            }
            this.gpuTextureData = arg0.texture;
            this.downloader = arg0.download;
            this.disposer = arg0.dispose;
            break;
          }
          case "gpu-buffer": {
            if (type !== "float32" && type !== "float16" && type !== "int32" && type !== "int64" && type !== "uint32" && type !== "uint8" && type !== "bool" && type !== "uint4" && type !== "int4") {
              throw new TypeError(`unsupported type "${type}" to create tensor from gpu buffer`);
            }
            this.gpuBufferData = arg0.gpuBuffer;
            this.downloader = arg0.download;
            this.disposer = arg0.dispose;
            break;
          }
          case "ml-tensor": {
            if (type !== "float32" && type !== "float16" && type !== "int32" && type !== "int64" && type !== "uint32" && type !== "uint64" && type !== "int8" && type !== "uint8" && type !== "bool" && type !== "uint4" && type !== "int4") {
              throw new TypeError(`unsupported type "${type}" to create tensor from MLTensor`);
            }
            this.mlTensorData = arg0.mlTensor;
            this.downloader = arg0.download;
            this.disposer = arg0.dispose;
            break;
          }
          default:
            throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`);
        }
      } else {
        let data;
        let maybeDims;
        if (typeof arg0 === "string") {
          type = arg0;
          maybeDims = arg2;
          if (arg0 === "string") {
            if (!Array.isArray(arg1)) {
              throw new TypeError("A string tensor's data must be a string array.");
            }
            data = arg1;
          } else {
            const typedArrayConstructor = tensor_impl_type_mapping_js_1.NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(arg0);
            if (typedArrayConstructor === undefined) {
              throw new TypeError(`Unsupported tensor type: ${arg0}.`);
            }
            if (Array.isArray(arg1)) {
              if (arg0 === "float16" && typedArrayConstructor === Uint16Array || arg0 === "uint4" || arg0 === "int4") {
                throw new TypeError(`Creating a ${arg0} tensor from number array is not supported. Please use ${typedArrayConstructor.name} as data.`);
              } else if (arg0 === "uint64" || arg0 === "int64") {
                data = typedArrayConstructor.from(arg1, BigInt);
              } else {
                data = typedArrayConstructor.from(arg1);
              }
            } else if (arg1 instanceof typedArrayConstructor) {
              data = arg1;
            } else if (arg1 instanceof Uint8ClampedArray) {
              if (arg0 === "uint8") {
                data = Uint8Array.from(arg1);
              } else {
                throw new TypeError(`A Uint8ClampedArray tensor's data must be type of uint8`);
              }
            } else if (arg0 === "float16" && arg1 instanceof Uint16Array && typedArrayConstructor !== Uint16Array) {
              data = new globalThis.Float16Array(arg1.buffer, arg1.byteOffset, arg1.length);
            } else {
              throw new TypeError(`A ${type} tensor's data must be type of ${typedArrayConstructor}`);
            }
          }
        } else {
          maybeDims = arg1;
          if (Array.isArray(arg0)) {
            if (arg0.length === 0) {
              throw new TypeError("Tensor type cannot be inferred from an empty array.");
            }
            const firstElementType = typeof arg0[0];
            if (firstElementType === "string") {
              type = "string";
              data = arg0;
            } else if (firstElementType === "boolean") {
              type = "bool";
              data = Uint8Array.from(arg0);
            } else {
              throw new TypeError(`Invalid element type of data array: ${firstElementType}.`);
            }
          } else if (arg0 instanceof Uint8ClampedArray) {
            type = "uint8";
            data = Uint8Array.from(arg0);
          } else {
            const mappedType = tensor_impl_type_mapping_js_1.NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.get(arg0.constructor);
            if (mappedType === undefined) {
              throw new TypeError(`Unsupported type for tensor data: ${arg0.constructor}.`);
            }
            type = mappedType;
            data = arg0;
          }
        }
        if (maybeDims === undefined) {
          maybeDims = [data.length];
        } else if (!Array.isArray(maybeDims)) {
          throw new TypeError("A tensor's dims must be a number array");
        }
        dims = maybeDims;
        this.cpuData = data;
        this.dataLocation = "cpu";
      }
      const size = (0, tensor_utils_impl_js_1.calculateSize)(dims);
      if (this.cpuData && size !== this.cpuData.length) {
        if ((type === "uint4" || type === "int4") && Math.ceil(size / 2) === this.cpuData.length) {} else {
          throw new Error(`Tensor's size(${size}) does not match data length(${this.cpuData.length}).`);
        }
      }
      this.type = type;
      this.dims = dims;
      this.size = size;
    }
    static async fromImage(image, options2) {
      return (0, tensor_factory_impl_js_1.tensorFromImage)(image, options2);
    }
    static fromTexture(texture, options2) {
      return (0, tensor_factory_impl_js_1.tensorFromTexture)(texture, options2);
    }
    static fromGpuBuffer(gpuBuffer, options2) {
      return (0, tensor_factory_impl_js_1.tensorFromGpuBuffer)(gpuBuffer, options2);
    }
    static fromMLTensor(mlTensor, options2) {
      return (0, tensor_factory_impl_js_1.tensorFromMLTensor)(mlTensor, options2);
    }
    static fromPinnedBuffer(type, buffer, dims) {
      return (0, tensor_factory_impl_js_1.tensorFromPinnedBuffer)(type, buffer, dims);
    }
    toDataURL(options2) {
      return (0, tensor_conversion_impl_js_1.tensorToDataURL)(this, options2);
    }
    toImageData(options2) {
      return (0, tensor_conversion_impl_js_1.tensorToImageData)(this, options2);
    }
    get data() {
      this.ensureValid();
      if (!this.cpuData) {
        throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, " + "or use `texture` or `gpuBuffer` property to access the GPU data directly.");
      }
      return this.cpuData;
    }
    get location() {
      return this.dataLocation;
    }
    get texture() {
      this.ensureValid();
      if (!this.gpuTextureData) {
        throw new Error("The data is not stored as a WebGL texture.");
      }
      return this.gpuTextureData;
    }
    get gpuBuffer() {
      this.ensureValid();
      if (!this.gpuBufferData) {
        throw new Error("The data is not stored as a WebGPU buffer.");
      }
      return this.gpuBufferData;
    }
    get mlTensor() {
      this.ensureValid();
      if (!this.mlTensorData) {
        throw new Error("The data is not stored as a WebNN MLTensor.");
      }
      return this.mlTensorData;
    }
    async getData(releaseData) {
      this.ensureValid();
      switch (this.dataLocation) {
        case "cpu":
        case "cpu-pinned":
          return this.data;
        case "texture":
        case "gpu-buffer":
        case "ml-tensor": {
          if (!this.downloader) {
            throw new Error("The current tensor is not created with a specified data downloader.");
          }
          if (this.isDownloading) {
            throw new Error("The current tensor is being downloaded.");
          }
          try {
            this.isDownloading = true;
            const data = await this.downloader();
            this.downloader = undefined;
            this.dataLocation = "cpu";
            this.cpuData = data;
            if (releaseData && this.disposer) {
              this.disposer();
              this.disposer = undefined;
            }
            return data;
          } finally {
            this.isDownloading = false;
          }
        }
        default:
          throw new Error(`cannot get data from location: ${this.dataLocation}`);
      }
    }
    dispose() {
      if (this.isDownloading) {
        throw new Error("The current tensor is being downloaded.");
      }
      if (this.disposer) {
        this.disposer();
        this.disposer = undefined;
      }
      this.cpuData = undefined;
      this.gpuTextureData = undefined;
      this.gpuBufferData = undefined;
      this.mlTensorData = undefined;
      this.downloader = undefined;
      this.isDownloading = undefined;
      this.dataLocation = "none";
    }
    ensureValid() {
      if (this.dataLocation === "none") {
        throw new Error("The tensor is disposed.");
      }
    }
    reshape(dims) {
      this.ensureValid();
      if (this.downloader || this.disposer) {
        throw new Error("Cannot reshape a tensor that owns GPU resource.");
      }
      return (0, tensor_utils_impl_js_1.tensorReshape)(this, dims);
    }
  }
  exports.Tensor = Tensor;
});

// node_modules/onnxruntime-common/dist/cjs/tensor.js
var require_tensor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Tensor = undefined;
  var tensor_impl_js_1 = require_tensor_impl();
  exports.Tensor = tensor_impl_js_1.Tensor;
});

// node_modules/onnxruntime-common/dist/cjs/trace.js
var require_trace = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TRACE_FUNC_END = exports.TRACE_FUNC_BEGIN = exports.TRACE = undefined;
  var env_impl_js_1 = require_env_impl();
  var TRACE = (deviceType, label) => {
    if (typeof env_impl_js_1.env.trace === "undefined" ? !env_impl_js_1.env.wasm.trace : !env_impl_js_1.env.trace) {
      return;
    }
    console.timeStamp(`${deviceType}::ORT::${label}`);
  };
  exports.TRACE = TRACE;
  var TRACE_FUNC = (msg, extraMsg) => {
    const stack = new Error().stack?.split(/\r\n|\r|\n/g) || [];
    let hasTraceFunc = false;
    for (let i = 0;i < stack.length; i++) {
      if (hasTraceFunc && !stack[i].includes("TRACE_FUNC")) {
        let label = `FUNC_${msg}::${stack[i].trim().split(" ")[1]}`;
        if (extraMsg) {
          label += `::${extraMsg}`;
        }
        (0, exports.TRACE)("CPU", label);
        return;
      }
      if (stack[i].includes("TRACE_FUNC")) {
        hasTraceFunc = true;
      }
    }
  };
  var TRACE_FUNC_BEGIN = (extraMsg) => {
    if (typeof env_impl_js_1.env.trace === "undefined" ? !env_impl_js_1.env.wasm.trace : !env_impl_js_1.env.trace) {
      return;
    }
    TRACE_FUNC("BEGIN", extraMsg);
  };
  exports.TRACE_FUNC_BEGIN = TRACE_FUNC_BEGIN;
  var TRACE_FUNC_END = (extraMsg) => {
    if (typeof env_impl_js_1.env.trace === "undefined" ? !env_impl_js_1.env.wasm.trace : !env_impl_js_1.env.trace) {
      return;
    }
    TRACE_FUNC("END", extraMsg);
  };
  exports.TRACE_FUNC_END = TRACE_FUNC_END;
});

// node_modules/onnxruntime-common/dist/cjs/inference-session-impl.js
var require_inference_session_impl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InferenceSession = undefined;
  var backend_impl_js_1 = require_backend_impl();
  var tensor_js_1 = require_tensor();
  var trace_js_1 = require_trace();

  class InferenceSession {
    constructor(handler) {
      this.handler = handler;
    }
    async run(feeds, arg1, arg2) {
      (0, trace_js_1.TRACE_FUNC_BEGIN)();
      const fetches = {};
      let options2 = {};
      if (typeof feeds !== "object" || feeds === null || feeds instanceof tensor_js_1.Tensor || Array.isArray(feeds)) {
        throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");
      }
      let isFetchesEmpty = true;
      if (typeof arg1 === "object") {
        if (arg1 === null) {
          throw new TypeError("Unexpected argument[1]: cannot be null.");
        }
        if (arg1 instanceof tensor_js_1.Tensor) {
          throw new TypeError("'fetches' cannot be a Tensor");
        }
        if (Array.isArray(arg1)) {
          if (arg1.length === 0) {
            throw new TypeError("'fetches' cannot be an empty array.");
          }
          isFetchesEmpty = false;
          for (const name of arg1) {
            if (typeof name !== "string") {
              throw new TypeError("'fetches' must be a string array or an object.");
            }
            if (this.outputNames.indexOf(name) === -1) {
              throw new RangeError(`'fetches' contains invalid output name: ${name}.`);
            }
            fetches[name] = null;
          }
          if (typeof arg2 === "object" && arg2 !== null) {
            options2 = arg2;
          } else if (typeof arg2 !== "undefined") {
            throw new TypeError("'options' must be an object.");
          }
        } else {
          let isFetches = false;
          const arg1Keys = Object.getOwnPropertyNames(arg1);
          for (const name of this.outputNames) {
            if (arg1Keys.indexOf(name) !== -1) {
              const v = arg1[name];
              if (v === null || v instanceof tensor_js_1.Tensor) {
                isFetches = true;
                isFetchesEmpty = false;
                fetches[name] = v;
              }
            }
          }
          if (isFetches) {
            if (typeof arg2 === "object" && arg2 !== null) {
              options2 = arg2;
            } else if (typeof arg2 !== "undefined") {
              throw new TypeError("'options' must be an object.");
            }
          } else {
            options2 = arg1;
          }
        }
      } else if (typeof arg1 !== "undefined") {
        throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");
      }
      for (const name of this.inputNames) {
        if (typeof feeds[name] === "undefined") {
          throw new Error(`input '${name}' is missing in 'feeds'.`);
        }
      }
      if (isFetchesEmpty) {
        for (const name of this.outputNames) {
          fetches[name] = null;
        }
      }
      const results = await this.handler.run(feeds, fetches, options2);
      const returnValue = {};
      for (const key in results) {
        if (Object.hasOwnProperty.call(results, key)) {
          const result = results[key];
          if (result instanceof tensor_js_1.Tensor) {
            returnValue[key] = result;
          } else {
            returnValue[key] = new tensor_js_1.Tensor(result.type, result.data, result.dims);
          }
        }
      }
      (0, trace_js_1.TRACE_FUNC_END)();
      return returnValue;
    }
    async release() {
      return this.handler.dispose();
    }
    static async create(arg0, arg1, arg2, arg3) {
      (0, trace_js_1.TRACE_FUNC_BEGIN)();
      let filePathOrUint8Array;
      let options2 = {};
      if (typeof arg0 === "string") {
        filePathOrUint8Array = arg0;
        if (typeof arg1 === "object" && arg1 !== null) {
          options2 = arg1;
        } else if (typeof arg1 !== "undefined") {
          throw new TypeError("'options' must be an object.");
        }
      } else if (arg0 instanceof Uint8Array) {
        filePathOrUint8Array = arg0;
        if (typeof arg1 === "object" && arg1 !== null) {
          options2 = arg1;
        } else if (typeof arg1 !== "undefined") {
          throw new TypeError("'options' must be an object.");
        }
      } else if (arg0 instanceof ArrayBuffer || typeof SharedArrayBuffer !== "undefined" && arg0 instanceof SharedArrayBuffer) {
        const buffer = arg0;
        let byteOffset = 0;
        let byteLength = arg0.byteLength;
        if (typeof arg1 === "object" && arg1 !== null) {
          options2 = arg1;
        } else if (typeof arg1 === "number") {
          byteOffset = arg1;
          if (!Number.isSafeInteger(byteOffset)) {
            throw new RangeError("'byteOffset' must be an integer.");
          }
          if (byteOffset < 0 || byteOffset >= buffer.byteLength) {
            throw new RangeError(`'byteOffset' is out of range [0, ${buffer.byteLength}).`);
          }
          byteLength = arg0.byteLength - byteOffset;
          if (typeof arg2 === "number") {
            byteLength = arg2;
            if (!Number.isSafeInteger(byteLength)) {
              throw new RangeError("'byteLength' must be an integer.");
            }
            if (byteLength <= 0 || byteOffset + byteLength > buffer.byteLength) {
              throw new RangeError(`'byteLength' is out of range (0, ${buffer.byteLength - byteOffset}].`);
            }
            if (typeof arg3 === "object" && arg3 !== null) {
              options2 = arg3;
            } else if (typeof arg3 !== "undefined") {
              throw new TypeError("'options' must be an object.");
            }
          } else if (typeof arg2 !== "undefined") {
            throw new TypeError("'byteLength' must be a number.");
          }
        } else if (typeof arg1 !== "undefined") {
          throw new TypeError("'options' must be an object.");
        }
        filePathOrUint8Array = new Uint8Array(buffer, byteOffset, byteLength);
      } else {
        throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");
      }
      const [backend, optionsWithValidatedEPs] = await (0, backend_impl_js_1.resolveBackendAndExecutionProviders)(options2);
      const handler = await backend.createInferenceSessionHandler(filePathOrUint8Array, optionsWithValidatedEPs);
      (0, trace_js_1.TRACE_FUNC_END)();
      return new InferenceSession(handler);
    }
    startProfiling() {
      this.handler.startProfiling();
    }
    endProfiling() {
      this.handler.endProfiling();
    }
    get inputNames() {
      return this.handler.inputNames;
    }
    get outputNames() {
      return this.handler.outputNames;
    }
  }
  exports.InferenceSession = InferenceSession;
});

// node_modules/onnxruntime-common/dist/cjs/inference-session.js
var require_inference_session = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InferenceSession = undefined;
  var inference_session_impl_js_1 = require_inference_session_impl();
  exports.InferenceSession = inference_session_impl_js_1.InferenceSession;
});

// node_modules/onnxruntime-common/dist/cjs/tensor-conversion.js
var require_tensor_conversion = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/onnxruntime-common/dist/cjs/tensor-factory.js
var require_tensor_factory = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/onnxruntime-common/dist/cjs/onnx-model.js
var require_onnx_model = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/onnxruntime-common/dist/cjs/onnx-value.js
var require_onnx_value = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/onnxruntime-common/dist/cjs/index.js
var require_cjs = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_backend(), exports);
  __exportStar(require_env(), exports);
  __exportStar(require_inference_session(), exports);
  __exportStar(require_tensor(), exports);
  __exportStar(require_tensor_conversion(), exports);
  __exportStar(require_tensor_factory(), exports);
  __exportStar(require_trace(), exports);
  __exportStar(require_onnx_model(), exports);
  __exportStar(require_onnx_value(), exports);
});

// node_modules/onnxruntime-node/dist/binding.js
var require_binding = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.initOrt = exports.binding = undefined;
  var onnxruntime_common_1 = require_cjs();
  exports.binding = __require(`../bin/napi-v3/${process.platform}/${process.arch}/onnxruntime_binding.node`);
  var ortInitialized = false;
  var initOrt = () => {
    if (!ortInitialized) {
      ortInitialized = true;
      let logLevel = 2;
      if (onnxruntime_common_1.env.logLevel) {
        switch (onnxruntime_common_1.env.logLevel) {
          case "verbose":
            logLevel = 0;
            break;
          case "info":
            logLevel = 1;
            break;
          case "warning":
            logLevel = 2;
            break;
          case "error":
            logLevel = 3;
            break;
          case "fatal":
            logLevel = 4;
            break;
          default:
            throw new Error(`Unsupported log level: ${onnxruntime_common_1.env.logLevel}`);
        }
      }
      exports.binding.initOrtOnce(logLevel, onnxruntime_common_1.Tensor);
    }
  };
  exports.initOrt = initOrt;
});

// node_modules/onnxruntime-node/dist/backend.js
var require_backend2 = __commonJS((exports) => {
  var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _OnnxruntimeSessionHandler_inferenceSession;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.listSupportedBackends = exports.onnxruntimeBackend = undefined;
  var binding_1 = require_binding();

  class OnnxruntimeSessionHandler {
    constructor(pathOrBuffer, options2) {
      _OnnxruntimeSessionHandler_inferenceSession.set(this, undefined);
      (0, binding_1.initOrt)();
      __classPrivateFieldSet(this, _OnnxruntimeSessionHandler_inferenceSession, new binding_1.binding.InferenceSession, "f");
      if (typeof pathOrBuffer === "string") {
        __classPrivateFieldGet(this, _OnnxruntimeSessionHandler_inferenceSession, "f").loadModel(pathOrBuffer, options2);
      } else {
        __classPrivateFieldGet(this, _OnnxruntimeSessionHandler_inferenceSession, "f").loadModel(pathOrBuffer.buffer, pathOrBuffer.byteOffset, pathOrBuffer.byteLength, options2);
      }
      this.inputNames = __classPrivateFieldGet(this, _OnnxruntimeSessionHandler_inferenceSession, "f").inputNames;
      this.outputNames = __classPrivateFieldGet(this, _OnnxruntimeSessionHandler_inferenceSession, "f").outputNames;
    }
    async dispose() {
      __classPrivateFieldGet(this, _OnnxruntimeSessionHandler_inferenceSession, "f").dispose();
    }
    startProfiling() {}
    endProfiling() {
      __classPrivateFieldGet(this, _OnnxruntimeSessionHandler_inferenceSession, "f").endProfiling();
    }
    async run(feeds, fetches, options2) {
      return new Promise((resolve, reject) => {
        setImmediate(() => {
          try {
            resolve(__classPrivateFieldGet(this, _OnnxruntimeSessionHandler_inferenceSession, "f").run(feeds, fetches, options2));
          } catch (e) {
            reject(e);
          }
        });
      });
    }
  }
  _OnnxruntimeSessionHandler_inferenceSession = new WeakMap;

  class OnnxruntimeBackend {
    async init() {
      return Promise.resolve();
    }
    async createInferenceSessionHandler(pathOrBuffer, options2) {
      return new Promise((resolve, reject) => {
        setImmediate(() => {
          try {
            resolve(new OnnxruntimeSessionHandler(pathOrBuffer, options2 || {}));
          } catch (e) {
            reject(e);
          }
        });
      });
    }
  }
  exports.onnxruntimeBackend = new OnnxruntimeBackend;
  exports.listSupportedBackends = binding_1.binding.listSupportedBackends;
});

// node_modules/onnxruntime-node/dist/version.js
var require_version2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.version = undefined;
  exports.version = "1.21.0";
});

// node_modules/onnxruntime-node/dist/index.js
var require_dist = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.listSupportedBackends = undefined;
  __exportStar(require_cjs(), exports);
  var backend_1 = require_backend2();
  Object.defineProperty(exports, "listSupportedBackends", { enumerable: true, get: function() {
    return backend_1.listSupportedBackends;
  } });
  var onnxruntime_common_1 = require_cjs();
  var version_1 = require_version2();
  var backend_2 = require_backend2();
  var backends = (0, backend_2.listSupportedBackends)();
  for (const backend of backends) {
    (0, onnxruntime_common_1.registerBackend)(backend.name, backend_2.onnxruntimeBackend, 100);
  }
  Object.defineProperty(onnxruntime_common_1.env.versions, "node", { value: version_1.version, enumerable: true });
});

// node_modules/fastembed/lib/esm/fastembed.js
import fs from "fs";
import https from "https";
import path from "path";
function normalize(v) {
  const norm = Math.sqrt(v.reduce((acc, val) => acc + val * val, 0));
  const epsilon = 0.000000000001;
  return v.map((val) => val / Math.max(norm, epsilon));
}
function getEmbeddings(data, dimensions) {
  const [x, y, z2] = dimensions;
  return new Array(x).fill(undefined).map((_, index) => {
    const startIndex = index * y * z2;
    const endIndex = startIndex + z2;
    return data.slice(startIndex, endIndex);
  });
}

class Embedding {
}
function isAddedTokenMap(token) {
  return typeof token === "object" && token !== null && "token" in token && "single_word" in token && "rstrip" in token && "lstrip" in token && "normalized" in token;
}
var import_progress, import_tar, ort, ExecutionProvider, EmbeddingModel, FlagEmbedding;
var init_fastembed = __esm(() => {
  init_tokenizers();
  import_progress = __toESM(require_node_progress(), 1);
  import_tar = __toESM(require_tar(), 1);
  ort = __toESM(require_dist(), 1);
  (function(ExecutionProvider2) {
    ExecutionProvider2["CPU"] = "cpu";
    ExecutionProvider2["CUDA"] = "cuda";
    ExecutionProvider2["WebGL"] = "webgl";
    ExecutionProvider2["WASM"] = "wasm";
    ExecutionProvider2["XNNPACK"] = "xnnpack";
  })(ExecutionProvider || (ExecutionProvider = {}));
  (function(EmbeddingModel2) {
    EmbeddingModel2["AllMiniLML6V2"] = "fast-all-MiniLM-L6-v2";
    EmbeddingModel2["BGEBaseEN"] = "fast-bge-base-en";
    EmbeddingModel2["BGEBaseENV15"] = "fast-bge-base-en-v1.5";
    EmbeddingModel2["BGESmallEN"] = "fast-bge-small-en";
    EmbeddingModel2["BGESmallENV15"] = "fast-bge-small-en-v1.5";
    EmbeddingModel2["BGESmallZH"] = "fast-bge-small-zh-v1.5";
    EmbeddingModel2["MLE5Large"] = "fast-multilingual-e5-large";
  })(EmbeddingModel || (EmbeddingModel = {}));
  FlagEmbedding = class FlagEmbedding extends Embedding {
    constructor(tokenizer, session, model) {
      super();
      this.tokenizer = tokenizer;
      this.session = session;
      this.model = model;
    }
    static async init({ model = EmbeddingModel.BGESmallENV15, executionProviders = [ExecutionProvider.CPU], maxLength = 512, cacheDir = "local_cache", showDownloadProgress = true } = {}) {
      const modelDir = await FlagEmbedding.retrieveModel(model, cacheDir, showDownloadProgress);
      const tokenizer = this.loadTokenizer(modelDir, maxLength);
      const modelPath = path.join(modelDir.toString(), model === EmbeddingModel.MLE5Large || model === EmbeddingModel.AllMiniLML6V2 ? "model.onnx" : "model_optimized.onnx");
      if (!fs.existsSync(modelPath)) {
        throw new Error(`Model file not found at ${modelPath}`);
      }
      const session = await ort.InferenceSession.create(modelPath, {
        executionProviders,
        graphOptimizationLevel: "all"
      });
      return new FlagEmbedding(tokenizer, session, model);
    }
    static loadTokenizer(modelDir, maxLength) {
      const tokenizerPath = path.join(modelDir.toString(), "tokenizer.json");
      if (!fs.existsSync(tokenizerPath)) {
        throw new Error(`Tokenizer file not found at ${tokenizerPath}`);
      }
      const configPath = path.join(modelDir.toString(), "config.json");
      if (!fs.existsSync(configPath)) {
        throw new Error(`Config file not found at ${configPath}`);
      }
      const config2 = JSON.parse(fs.readFileSync(configPath, "utf-8"));
      const tokenizerFilePath = path.join(modelDir.toString(), "tokenizer_config.json");
      if (!fs.existsSync(tokenizerFilePath)) {
        throw new Error(`Tokenizer file not found at ${tokenizerFilePath}`);
      }
      const tokenizerConfig = JSON.parse(fs.readFileSync(tokenizerFilePath, "utf-8"));
      maxLength = Math.min(maxLength, tokenizerConfig["model_max_length"]);
      const tokensMapPath = path.join(modelDir.toString(), "special_tokens_map.json");
      if (!fs.existsSync(tokensMapPath)) {
        throw new Error(`Tokens map file not found at ${tokensMapPath}`);
      }
      const tokensMap = JSON.parse(fs.readFileSync(tokensMapPath, "utf-8"));
      const tokenizer = $Tokenizer.fromFile(tokenizerPath);
      tokenizer.setTruncation(maxLength);
      tokenizer.setPadding({
        maxLength,
        padId: config2["pad_token_id"],
        padToken: tokenizerConfig["pad_token"]
      });
      for (let token of Object.values(tokensMap)) {
        if (typeof token === "string") {
          tokenizer.addSpecialTokens([token]);
        } else if (isAddedTokenMap(token)) {
          const addedToken = new $AddedToken(token["content"], true, {
            singleWord: token["single_word"],
            leftStrip: token["lstrip"],
            rightStrip: token["rstrip"],
            normalized: token["normalized"]
          });
          tokenizer.addAddedTokens([addedToken]);
        }
      }
      return tokenizer;
    }
    static async downloadFileFromGCS(outputFilePath, model, showDownloadProgress = true) {
      if (fs.existsSync(outputFilePath)) {
        return outputFilePath;
      }
      if (model === EmbeddingModel.AllMiniLML6V2) {
        model = "sentence-transformers" + model.substring(model.indexOf("-"));
      }
      const url2 = `https://storage.googleapis.com/qdrant-fastembed/${model}.tar.gz`;
      const fileStream = fs.createWriteStream(outputFilePath);
      return new Promise((resolve, reject) => {
        https.get(url2, { headers: { "User-Agent": "Mozilla/5.0" } }, (response) => {
          const totalSizeInBytes = parseInt(response.headers["content-length"] || "0", 10);
          if (totalSizeInBytes === 0) {
            console.warn(`Warning: Content-length header is missing or zero in the response from ${url2}.`);
          }
          if (showDownloadProgress) {
            const progressBar = new import_progress.default(`Downloading ${model} [:bar] :percent :etas`, {
              complete: "=",
              width: 20,
              total: totalSizeInBytes
            });
            response.on("data", (chunk) => {
              progressBar.tick(chunk.length, { speed: "N/A" });
            });
          }
          response.on("error", (error48) => {
            reject(error48);
          });
          response.pipe(fileStream);
          fileStream.on("finish", () => {
            fileStream.close();
            resolve(outputFilePath);
          });
          fileStream.on("error", (error48) => {
            reject(error48);
          });
        }).on("error", (error48) => {
          fs.unlink(outputFilePath, () => {
            reject(error48);
          });
        });
      });
    }
    static async decompressToCache(targzPath, cacheDir) {
      if (path.extname(targzPath.toString()) === ".gz") {
        await import_tar.default.x({
          file: targzPath,
          cwd: cacheDir
        });
      } else {
        throw new Error(`Unsupported file extension: ${targzPath}`);
      }
    }
    static async retrieveModel(model, cacheDir, showDownloadProgress = true) {
      if (!fs.existsSync(cacheDir)) {
        fs.mkdirSync(cacheDir, {
          mode: 511
        });
      }
      const modelDir = path.join(cacheDir.toString(), model);
      if (fs.existsSync(modelDir)) {
        return modelDir;
      }
      const modelTarGz = path.join(cacheDir.toString(), `${model}.tar.gz`);
      await this.downloadFileFromGCS(modelTarGz, model, showDownloadProgress);
      await this.decompressToCache(modelTarGz, cacheDir);
      fs.unlinkSync(modelTarGz);
      return modelDir;
    }
    async* embed(textStrings, batchSize = 256) {
      for (let i = 0;i < textStrings.length; i += batchSize) {
        const batchTexts = textStrings.slice(i, i + batchSize);
        const encodedTexts = await Promise.all(batchTexts.map((textString) => this.tokenizer.encode(textString)));
        const idsArray = [];
        const maskArray = [];
        const typeIdsArray = [];
        encodedTexts.forEach((text) => {
          const ids = text.getIds().map(BigInt);
          const mask = text.getAttentionMask().map(BigInt);
          const typeIds = text.getTypeIds().map(BigInt);
          idsArray.push(ids);
          maskArray.push(mask);
          typeIdsArray.push(typeIds);
        });
        const maxLength = idsArray[0].length;
        const batchInputIds = new ort.Tensor("int64", idsArray.flat(), [batchTexts.length, maxLength]);
        const batchAttentionMask = new ort.Tensor("int64", maskArray.flat(), [batchTexts.length, maxLength]);
        const batchTokenTypeId = new ort.Tensor("int64", typeIdsArray.flat(), [batchTexts.length, maxLength]);
        const inputs = {
          input_ids: batchInputIds,
          attention_mask: batchAttentionMask,
          token_type_ids: batchTokenTypeId
        };
        if (this.model === EmbeddingModel.MLE5Large) {
          delete inputs.token_type_ids;
        }
        const output = await this.session.run(inputs);
        const embeddings = getEmbeddings(output.last_hidden_state.data, output.last_hidden_state.dims);
        yield embeddings.map(normalize);
      }
    }
    passageEmbed(texts, batchSize = 256) {
      texts = texts.map((text) => `passage: ${text}`);
      return this.embed(texts, batchSize);
    }
    async queryEmbed(query) {
      return (await this.embed([`query: ${query}`]).next()).value[0];
    }
    listSupportedModels() {
      return [
        {
          model: EmbeddingModel.BGESmallEN,
          dim: 384,
          description: "Fast English model"
        },
        {
          model: EmbeddingModel.BGESmallENV15,
          dim: 384,
          description: "v1.5 release of the fast, default English model"
        },
        {
          model: EmbeddingModel.BGEBaseEN,
          dim: 768,
          description: "Base English model"
        },
        {
          model: EmbeddingModel.BGEBaseENV15,
          dim: 768,
          description: "v1.5 release of Base English model"
        },
        {
          model: EmbeddingModel.BGESmallZH,
          dim: 512,
          description: "v1.5 release of the fast, Chinese model"
        },
        {
          model: EmbeddingModel.AllMiniLML6V2,
          dim: 384,
          description: "Sentence Transformer model, MiniLM-L6-v2"
        },
        {
          model: EmbeddingModel.MLE5Large,
          dim: 1024,
          description: "Multilingual model, e5-large. Recommend using this model for non-English languages"
        }
      ];
    }
  };
});

// node_modules/fastembed/lib/esm/index.js
var exports_esm = {};
__export(exports_esm, {
  FlagEmbedding: () => FlagEmbedding,
  ExecutionProvider: () => ExecutionProvider,
  EmbeddingModel: () => EmbeddingModel
});
var init_esm = __esm(() => {
  init_fastembed();
});

// node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/core/core.js
function $constructor2(name, initializer3, params) {
  function init(inst, def) {
    var _a2;
    Object.defineProperty(inst, "_zod", {
      value: inst._zod ?? {},
      enumerable: false
    });
    (_a2 = inst._zod).traits ?? (_a2.traits = new Set);
    inst._zod.traits.add(name);
    initializer3(inst, def);
    for (const k in _.prototype) {
      if (!(k in inst))
        Object.defineProperty(inst, k, { value: _.prototype[k].bind(inst) });
    }
    inst._zod.constr = _;
    inst._zod.def = def;
  }
  const Parent = params?.Parent ?? Object;

  class Definition extends Parent {
  }
  Object.defineProperty(Definition, "name", { value: name });
  function _(def) {
    var _a2;
    const inst = params?.Parent ? new Definition : this;
    init(inst, def);
    (_a2 = inst._zod).deferred ?? (_a2.deferred = []);
    for (const fn of inst._zod.deferred) {
      fn();
    }
    return inst;
  }
  Object.defineProperty(_, "init", { value: init });
  Object.defineProperty(_, Symbol.hasInstance, {
    value: (inst) => {
      if (params?.Parent && inst instanceof params.Parent)
        return true;
      return inst?._zod?.traits?.has(name);
    }
  });
  Object.defineProperty(_, "name", { value: name });
  return _;
}
function config2(newConfig) {
  if (newConfig)
    Object.assign(globalConfig2, newConfig);
  return globalConfig2;
}
var NEVER2, $brand2, $ZodAsyncError2, globalConfig2;
var init_core3 = __esm(() => {
  NEVER2 = Object.freeze({
    status: "aborted"
  });
  $brand2 = Symbol("zod_brand");
  $ZodAsyncError2 = class $ZodAsyncError2 extends Error {
    constructor() {
      super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
    }
  };
  globalConfig2 = {};
});

// node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/core/util.js
var exports_util2 = {};
__export(exports_util2, {
  unwrapMessage: () => unwrapMessage2,
  stringifyPrimitive: () => stringifyPrimitive2,
  required: () => required2,
  randomString: () => randomString2,
  propertyKeyTypes: () => propertyKeyTypes2,
  promiseAllObject: () => promiseAllObject2,
  primitiveTypes: () => primitiveTypes2,
  prefixIssues: () => prefixIssues2,
  pick: () => pick2,
  partial: () => partial2,
  optionalKeys: () => optionalKeys2,
  omit: () => omit2,
  numKeys: () => numKeys2,
  nullish: () => nullish3,
  normalizeParams: () => normalizeParams2,
  merge: () => merge2,
  jsonStringifyReplacer: () => jsonStringifyReplacer2,
  joinValues: () => joinValues2,
  issue: () => issue2,
  isPlainObject: () => isPlainObject2,
  isObject: () => isObject2,
  getSizableOrigin: () => getSizableOrigin2,
  getParsedType: () => getParsedType2,
  getLengthableOrigin: () => getLengthableOrigin2,
  getEnumValues: () => getEnumValues2,
  getElementAtPath: () => getElementAtPath2,
  floatSafeRemainder: () => floatSafeRemainder2,
  finalizeIssue: () => finalizeIssue2,
  extend: () => extend2,
  escapeRegex: () => escapeRegex2,
  esc: () => esc2,
  defineLazy: () => defineLazy2,
  createTransparentProxy: () => createTransparentProxy2,
  clone: () => clone2,
  cleanRegex: () => cleanRegex2,
  cleanEnum: () => cleanEnum2,
  captureStackTrace: () => captureStackTrace2,
  cached: () => cached2,
  assignProp: () => assignProp2,
  assertNotEqual: () => assertNotEqual2,
  assertNever: () => assertNever2,
  assertIs: () => assertIs2,
  assertEqual: () => assertEqual2,
  assert: () => assert2,
  allowsEval: () => allowsEval2,
  aborted: () => aborted2,
  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES2,
  Class: () => Class2,
  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES2
});
function assertEqual2(val) {
  return val;
}
function assertNotEqual2(val) {
  return val;
}
function assertIs2(_arg) {}
function assertNever2(_x) {
  throw new Error;
}
function assert2(_) {}
function getEnumValues2(entries) {
  const numericValues = Object.values(entries).filter((v) => typeof v === "number");
  const values = Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);
  return values;
}
function joinValues2(array2, separator = "|") {
  return array2.map((val) => stringifyPrimitive2(val)).join(separator);
}
function jsonStringifyReplacer2(_, value) {
  if (typeof value === "bigint")
    return value.toString();
  return value;
}
function cached2(getter) {
  const set2 = false;
  return {
    get value() {
      if (!set2) {
        const value = getter();
        Object.defineProperty(this, "value", { value });
        return value;
      }
      throw new Error("cached value already set");
    }
  };
}
function nullish3(input) {
  return input === null || input === undefined;
}
function cleanRegex2(source) {
  const start = source.startsWith("^") ? 1 : 0;
  const end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start, end);
}
function floatSafeRemainder2(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
function defineLazy2(object2, key, getter) {
  const set2 = false;
  Object.defineProperty(object2, key, {
    get() {
      if (!set2) {
        const value = getter();
        object2[key] = value;
        return value;
      }
      throw new Error("cached value already set");
    },
    set(v) {
      Object.defineProperty(object2, key, {
        value: v
      });
    },
    configurable: true
  });
}
function assignProp2(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: true,
    enumerable: true,
    configurable: true
  });
}
function getElementAtPath2(obj, path2) {
  if (!path2)
    return obj;
  return path2.reduce((acc, key) => acc?.[key], obj);
}
function promiseAllObject2(promisesObj) {
  const keys = Object.keys(promisesObj);
  const promises = keys.map((key) => promisesObj[key]);
  return Promise.all(promises).then((results) => {
    const resolvedObj = {};
    for (let i = 0;i < keys.length; i++) {
      resolvedObj[keys[i]] = results[i];
    }
    return resolvedObj;
  });
}
function randomString2(length = 10) {
  const chars = "abcdefghijklmnopqrstuvwxyz";
  let str2 = "";
  for (let i = 0;i < length; i++) {
    str2 += chars[Math.floor(Math.random() * chars.length)];
  }
  return str2;
}
function esc2(str2) {
  return JSON.stringify(str2);
}
function isObject2(data) {
  return typeof data === "object" && data !== null && !Array.isArray(data);
}
function isPlainObject2(o) {
  if (isObject2(o) === false)
    return false;
  const ctor = o.constructor;
  if (ctor === undefined)
    return true;
  const prot = ctor.prototype;
  if (isObject2(prot) === false)
    return false;
  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
    return false;
  }
  return true;
}
function numKeys2(data) {
  let keyCount = 0;
  for (const key in data) {
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      keyCount++;
    }
  }
  return keyCount;
}
function escapeRegex2(str2) {
  return str2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone2(inst, def, params) {
  const cl = new inst._zod.constr(def ?? inst._zod.def);
  if (!def || params?.parent)
    cl._zod.parent = inst;
  return cl;
}
function normalizeParams2(_params) {
  const params = _params;
  if (!params)
    return {};
  if (typeof params === "string")
    return { error: () => params };
  if (params?.message !== undefined) {
    if (params?.error !== undefined)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  delete params.message;
  if (typeof params.error === "string")
    return { ...params, error: () => params.error };
  return params;
}
function createTransparentProxy2(getter) {
  let target;
  return new Proxy({}, {
    get(_, prop, receiver) {
      target ?? (target = getter());
      return Reflect.get(target, prop, receiver);
    },
    set(_, prop, value, receiver) {
      target ?? (target = getter());
      return Reflect.set(target, prop, value, receiver);
    },
    has(_, prop) {
      target ?? (target = getter());
      return Reflect.has(target, prop);
    },
    deleteProperty(_, prop) {
      target ?? (target = getter());
      return Reflect.deleteProperty(target, prop);
    },
    ownKeys(_) {
      target ?? (target = getter());
      return Reflect.ownKeys(target);
    },
    getOwnPropertyDescriptor(_, prop) {
      target ?? (target = getter());
      return Reflect.getOwnPropertyDescriptor(target, prop);
    },
    defineProperty(_, prop, descriptor) {
      target ?? (target = getter());
      return Reflect.defineProperty(target, prop, descriptor);
    }
  });
}
function stringifyPrimitive2(value) {
  if (typeof value === "bigint")
    return value.toString() + "n";
  if (typeof value === "string")
    return `"${value}"`;
  return `${value}`;
}
function optionalKeys2(shape) {
  return Object.keys(shape).filter((k) => {
    return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
  });
}
function pick2(schema, mask) {
  const newShape = {};
  const currDef = schema._zod.def;
  for (const key in mask) {
    if (!(key in currDef.shape)) {
      throw new Error(`Unrecognized key: "${key}"`);
    }
    if (!mask[key])
      continue;
    newShape[key] = currDef.shape[key];
  }
  return clone2(schema, {
    ...schema._zod.def,
    shape: newShape,
    checks: []
  });
}
function omit2(schema, mask) {
  const newShape = { ...schema._zod.def.shape };
  const currDef = schema._zod.def;
  for (const key in mask) {
    if (!(key in currDef.shape)) {
      throw new Error(`Unrecognized key: "${key}"`);
    }
    if (!mask[key])
      continue;
    delete newShape[key];
  }
  return clone2(schema, {
    ...schema._zod.def,
    shape: newShape,
    checks: []
  });
}
function extend2(schema, shape) {
  if (!isPlainObject2(shape)) {
    throw new Error("Invalid input to extend: expected a plain object");
  }
  const def = {
    ...schema._zod.def,
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp2(this, "shape", _shape);
      return _shape;
    },
    checks: []
  };
  return clone2(schema, def);
}
function merge2(a, b) {
  return clone2(a, {
    ...a._zod.def,
    get shape() {
      const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
      assignProp2(this, "shape", _shape);
      return _shape;
    },
    catchall: b._zod.def.catchall,
    checks: []
  });
}
function partial2(Class2, schema, mask) {
  const oldShape = schema._zod.def.shape;
  const shape = { ...oldShape };
  if (mask) {
    for (const key in mask) {
      if (!(key in oldShape)) {
        throw new Error(`Unrecognized key: "${key}"`);
      }
      if (!mask[key])
        continue;
      shape[key] = Class2 ? new Class2({
        type: "optional",
        innerType: oldShape[key]
      }) : oldShape[key];
    }
  } else {
    for (const key in oldShape) {
      shape[key] = Class2 ? new Class2({
        type: "optional",
        innerType: oldShape[key]
      }) : oldShape[key];
    }
  }
  return clone2(schema, {
    ...schema._zod.def,
    shape,
    checks: []
  });
}
function required2(Class2, schema, mask) {
  const oldShape = schema._zod.def.shape;
  const shape = { ...oldShape };
  if (mask) {
    for (const key in mask) {
      if (!(key in shape)) {
        throw new Error(`Unrecognized key: "${key}"`);
      }
      if (!mask[key])
        continue;
      shape[key] = new Class2({
        type: "nonoptional",
        innerType: oldShape[key]
      });
    }
  } else {
    for (const key in oldShape) {
      shape[key] = new Class2({
        type: "nonoptional",
        innerType: oldShape[key]
      });
    }
  }
  return clone2(schema, {
    ...schema._zod.def,
    shape,
    checks: []
  });
}
function aborted2(x, startIndex = 0) {
  for (let i = startIndex;i < x.issues.length; i++) {
    if (x.issues[i]?.continue !== true)
      return true;
  }
  return false;
}
function prefixIssues2(path2, issues) {
  return issues.map((iss) => {
    var _a2;
    (_a2 = iss).path ?? (_a2.path = []);
    iss.path.unshift(path2);
    return iss;
  });
}
function unwrapMessage2(message) {
  return typeof message === "string" ? message : message?.message;
}
function finalizeIssue2(iss, ctx, config3) {
  const full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    const message = unwrapMessage2(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage2(ctx?.error?.(iss)) ?? unwrapMessage2(config3.customError?.(iss)) ?? unwrapMessage2(config3.localeError?.(iss)) ?? "Invalid input";
    full.message = message;
  }
  delete full.inst;
  delete full.continue;
  if (!ctx?.reportInput) {
    delete full.input;
  }
  return full;
}
function getSizableOrigin2(input) {
  if (input instanceof Set)
    return "set";
  if (input instanceof Map)
    return "map";
  if (input instanceof File)
    return "file";
  return "unknown";
}
function getLengthableOrigin2(input) {
  if (Array.isArray(input))
    return "array";
  if (typeof input === "string")
    return "string";
  return "unknown";
}
function issue2(...args) {
  const [iss, input, inst] = args;
  if (typeof iss === "string") {
    return {
      message: iss,
      code: "custom",
      input,
      inst
    };
  }
  return { ...iss };
}
function cleanEnum2(obj) {
  return Object.entries(obj).filter(([k, _]) => {
    return Number.isNaN(Number.parseInt(k, 10));
  }).map((el) => el[1]);
}

class Class2 {
  constructor(..._args) {}
}
var captureStackTrace2, allowsEval2, getParsedType2 = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(data) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return "promise";
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return "map";
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return "set";
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return "date";
      }
      if (typeof File !== "undefined" && data instanceof File) {
        return "file";
      }
      return "object";
    default:
      throw new Error(`Unknown data type: ${t}`);
  }
}, propertyKeyTypes2, primitiveTypes2, NUMBER_FORMAT_RANGES2, BIGINT_FORMAT_RANGES2;
var init_util2 = __esm(() => {
  captureStackTrace2 = Error.captureStackTrace ? Error.captureStackTrace : (..._args) => {};
  allowsEval2 = cached2(() => {
    if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) {
      return false;
    }
    try {
      const F = Function;
      new F("");
      return true;
    } catch (_) {
      return false;
    }
  });
  propertyKeyTypes2 = new Set(["string", "number", "symbol"]);
  primitiveTypes2 = new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
  NUMBER_FORMAT_RANGES2 = {
    safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
    int32: [-2147483648, 2147483647],
    uint32: [0, 4294967295],
    float32: [-340282346638528860000000000000000000000, 340282346638528860000000000000000000000],
    float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
  };
  BIGINT_FORMAT_RANGES2 = {
    int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],
    uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]
  };
});

// node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/core/errors.js
function flattenError2(error48, mapper = (issue3) => issue3.message) {
  const fieldErrors = {};
  const formErrors = [];
  for (const sub of error48.issues) {
    if (sub.path.length > 0) {
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
      fieldErrors[sub.path[0]].push(mapper(sub));
    } else {
      formErrors.push(mapper(sub));
    }
  }
  return { formErrors, fieldErrors };
}
function formatError2(error48, _mapper) {
  const mapper = _mapper || function(issue3) {
    return issue3.message;
  };
  const fieldErrors = { _errors: [] };
  const processError = (error49) => {
    for (const issue3 of error49.issues) {
      if (issue3.code === "invalid_union" && issue3.errors.length) {
        issue3.errors.map((issues) => processError({ issues }));
      } else if (issue3.code === "invalid_key") {
        processError({ issues: issue3.issues });
      } else if (issue3.code === "invalid_element") {
        processError({ issues: issue3.issues });
      } else if (issue3.path.length === 0) {
        fieldErrors._errors.push(mapper(issue3));
      } else {
        let curr = fieldErrors;
        let i = 0;
        while (i < issue3.path.length) {
          const el = issue3.path[i];
          const terminal = i === issue3.path.length - 1;
          if (!terminal) {
            curr[el] = curr[el] || { _errors: [] };
          } else {
            curr[el] = curr[el] || { _errors: [] };
            curr[el]._errors.push(mapper(issue3));
          }
          curr = curr[el];
          i++;
        }
      }
    }
  };
  processError(error48);
  return fieldErrors;
}
var initializer3 = (inst, def) => {
  inst.name = "$ZodError";
  Object.defineProperty(inst, "_zod", {
    value: inst._zod,
    enumerable: false
  });
  Object.defineProperty(inst, "issues", {
    value: def,
    enumerable: false
  });
  Object.defineProperty(inst, "message", {
    get() {
      return JSON.stringify(def, jsonStringifyReplacer2, 2);
    },
    enumerable: true
  });
  Object.defineProperty(inst, "toString", {
    value: () => inst.message,
    enumerable: false
  });
}, $ZodError2, $ZodRealError2;
var init_errors3 = __esm(() => {
  init_core3();
  init_util2();
  $ZodError2 = $constructor2("$ZodError", initializer3);
  $ZodRealError2 = $constructor2("$ZodError", initializer3, { Parent: Error });
});

// node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/core/parse.js
var _parse2 = (_Err) => (schema, value, _ctx, _params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError2;
  }
  if (result.issues.length) {
    const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue2(iss, ctx, config2())));
    captureStackTrace2(e, _params?.callee);
    throw e;
  }
  return result.value;
}, _parseAsync2 = (_Err) => async (schema, value, _ctx, params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  if (result.issues.length) {
    const e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue2(iss, ctx, config2())));
    captureStackTrace2(e, params?.callee);
    throw e;
  }
  return result.value;
}, _safeParse2 = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError2;
  }
  return result.issues.length ? {
    success: false,
    error: new (_Err ?? $ZodError2)(result.issues.map((iss) => finalizeIssue2(iss, ctx, config2())))
  } : { success: true, data: result.value };
}, safeParse3, _safeParseAsync2 = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  return result.issues.length ? {
    success: false,
    error: new _Err(result.issues.map((iss) => finalizeIssue2(iss, ctx, config2())))
  } : { success: true, data: result.value };
}, safeParseAsync3;
var init_parse3 = __esm(() => {
  init_core3();
  init_errors3();
  init_util2();
  safeParse3 = /* @__PURE__ */ _safeParse2($ZodRealError2);
  safeParseAsync3 = /* @__PURE__ */ _safeParseAsync2($ZodRealError2);
});

// node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/core/regexes.js
function emoji3() {
  return new RegExp(_emoji3, "u");
}
function timeSource2(args) {
  const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
  const regex = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  return regex;
}
function time3(args) {
  return new RegExp(`^${timeSource2(args)}$`);
}
function datetime3(args) {
  const time4 = timeSource2({ precision: args.precision });
  const opts = ["Z"];
  if (args.local)
    opts.push("");
  if (args.offset)
    opts.push(`([+-]\\d{2}:\\d{2})`);
  const timeRegex = `${time4}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource2}T(?:${timeRegex})$`);
}
var cuid5, cuid23, ulid3, xid3, ksuid3, nanoid3, duration3, guid3, uuid3 = (version2) => {
  if (!version2)
    return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000)$/;
  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version2}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
}, email3, _emoji3 = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`, ipv43, ipv63, cidrv43, cidrv63, base643, base64url3, hostname3, e1643, dateSource2 = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`, date5, string4 = (params) => {
  const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
  return new RegExp(`^${regex}$`);
}, integer2, number4, boolean4, _null4, lowercase3, uppercase2;
var init_regexes2 = __esm(() => {
  cuid5 = /^[cC][^\s-]{8,}$/;
  cuid23 = /^[0-9a-z]+$/;
  ulid3 = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
  xid3 = /^[0-9a-vA-V]{20}$/;
  ksuid3 = /^[A-Za-z0-9]{27}$/;
  nanoid3 = /^[a-zA-Z0-9_-]{21}$/;
  duration3 = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
  guid3 = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
  email3 = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
  ipv43 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
  ipv63 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$/;
  cidrv43 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
  cidrv63 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
  base643 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
  base64url3 = /^[A-Za-z0-9_-]*$/;
  hostname3 = /^([a-zA-Z0-9-]+\.)*[a-zA-Z0-9-]+$/;
  e1643 = /^\+(?:[0-9]){6,14}[0-9]$/;
  date5 = /* @__PURE__ */ new RegExp(`^${dateSource2}$`);
  integer2 = /^\d+$/;
  number4 = /^-?\d+(?:\.\d+)?/i;
  boolean4 = /true|false/i;
  _null4 = /null/i;
  lowercase3 = /^[^A-Z]*$/;
  uppercase2 = /^[^a-z]*$/;
});

// node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/core/checks.js
var $ZodCheck2, numericOriginMap2, $ZodCheckLessThan2, $ZodCheckGreaterThan2, $ZodCheckMultipleOf2, $ZodCheckNumberFormat2, $ZodCheckMaxLength2, $ZodCheckMinLength2, $ZodCheckLengthEquals2, $ZodCheckStringFormat2, $ZodCheckRegex2, $ZodCheckLowerCase2, $ZodCheckUpperCase2, $ZodCheckIncludes2, $ZodCheckStartsWith2, $ZodCheckEndsWith2, $ZodCheckOverwrite2;
var init_checks3 = __esm(() => {
  init_core3();
  init_regexes2();
  init_util2();
  $ZodCheck2 = /* @__PURE__ */ $constructor2("$ZodCheck", (inst, def) => {
    var _a2;
    inst._zod ?? (inst._zod = {});
    inst._zod.def = def;
    (_a2 = inst._zod).onattach ?? (_a2.onattach = []);
  });
  numericOriginMap2 = {
    number: "number",
    bigint: "bigint",
    object: "date"
  };
  $ZodCheckLessThan2 = /* @__PURE__ */ $constructor2("$ZodCheckLessThan", (inst, def) => {
    $ZodCheck2.init(inst, def);
    const origin = numericOriginMap2[typeof def.value];
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
      if (def.value < curr) {
        if (def.inclusive)
          bag.maximum = def.value;
        else
          bag.exclusiveMaximum = def.value;
      }
    });
    inst._zod.check = (payload) => {
      if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
        return;
      }
      payload.issues.push({
        origin,
        code: "too_big",
        maximum: def.value,
        input: payload.value,
        inclusive: def.inclusive,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckGreaterThan2 = /* @__PURE__ */ $constructor2("$ZodCheckGreaterThan", (inst, def) => {
    $ZodCheck2.init(inst, def);
    const origin = numericOriginMap2[typeof def.value];
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
      if (def.value > curr) {
        if (def.inclusive)
          bag.minimum = def.value;
        else
          bag.exclusiveMinimum = def.value;
      }
    });
    inst._zod.check = (payload) => {
      if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
        return;
      }
      payload.issues.push({
        origin,
        code: "too_small",
        minimum: def.value,
        input: payload.value,
        inclusive: def.inclusive,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckMultipleOf2 = /* @__PURE__ */ $constructor2("$ZodCheckMultipleOf", (inst, def) => {
    $ZodCheck2.init(inst, def);
    inst._zod.onattach.push((inst2) => {
      var _a2;
      (_a2 = inst2._zod.bag).multipleOf ?? (_a2.multipleOf = def.value);
    });
    inst._zod.check = (payload) => {
      if (typeof payload.value !== typeof def.value)
        throw new Error("Cannot mix number and bigint in multiple_of check.");
      const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder2(payload.value, def.value) === 0;
      if (isMultiple)
        return;
      payload.issues.push({
        origin: typeof payload.value,
        code: "not_multiple_of",
        divisor: def.value,
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckNumberFormat2 = /* @__PURE__ */ $constructor2("$ZodCheckNumberFormat", (inst, def) => {
    $ZodCheck2.init(inst, def);
    def.format = def.format || "float64";
    const isInt = def.format?.includes("int");
    const origin = isInt ? "int" : "number";
    const [minimum, maximum] = NUMBER_FORMAT_RANGES2[def.format];
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.format = def.format;
      bag.minimum = minimum;
      bag.maximum = maximum;
      if (isInt)
        bag.pattern = integer2;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      if (isInt) {
        if (!Number.isInteger(input)) {
          payload.issues.push({
            expected: origin,
            format: def.format,
            code: "invalid_type",
            input,
            inst
          });
          return;
        }
        if (!Number.isSafeInteger(input)) {
          if (input > 0) {
            payload.issues.push({
              input,
              code: "too_big",
              maximum: Number.MAX_SAFE_INTEGER,
              note: "Integers must be within the safe integer range.",
              inst,
              origin,
              continue: !def.abort
            });
          } else {
            payload.issues.push({
              input,
              code: "too_small",
              minimum: Number.MIN_SAFE_INTEGER,
              note: "Integers must be within the safe integer range.",
              inst,
              origin,
              continue: !def.abort
            });
          }
          return;
        }
      }
      if (input < minimum) {
        payload.issues.push({
          origin: "number",
          input,
          code: "too_small",
          minimum,
          inclusive: true,
          inst,
          continue: !def.abort
        });
      }
      if (input > maximum) {
        payload.issues.push({
          origin: "number",
          input,
          code: "too_big",
          maximum,
          inst
        });
      }
    };
  });
  $ZodCheckMaxLength2 = /* @__PURE__ */ $constructor2("$ZodCheckMaxLength", (inst, def) => {
    var _a2;
    $ZodCheck2.init(inst, def);
    (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
      const val = payload.value;
      return !nullish3(val) && val.length !== undefined;
    });
    inst._zod.onattach.push((inst2) => {
      const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
      if (def.maximum < curr)
        inst2._zod.bag.maximum = def.maximum;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      const length = input.length;
      if (length <= def.maximum)
        return;
      const origin = getLengthableOrigin2(input);
      payload.issues.push({
        origin,
        code: "too_big",
        maximum: def.maximum,
        inclusive: true,
        input,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckMinLength2 = /* @__PURE__ */ $constructor2("$ZodCheckMinLength", (inst, def) => {
    var _a2;
    $ZodCheck2.init(inst, def);
    (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
      const val = payload.value;
      return !nullish3(val) && val.length !== undefined;
    });
    inst._zod.onattach.push((inst2) => {
      const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
      if (def.minimum > curr)
        inst2._zod.bag.minimum = def.minimum;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      const length = input.length;
      if (length >= def.minimum)
        return;
      const origin = getLengthableOrigin2(input);
      payload.issues.push({
        origin,
        code: "too_small",
        minimum: def.minimum,
        inclusive: true,
        input,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckLengthEquals2 = /* @__PURE__ */ $constructor2("$ZodCheckLengthEquals", (inst, def) => {
    var _a2;
    $ZodCheck2.init(inst, def);
    (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
      const val = payload.value;
      return !nullish3(val) && val.length !== undefined;
    });
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.minimum = def.length;
      bag.maximum = def.length;
      bag.length = def.length;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      const length = input.length;
      if (length === def.length)
        return;
      const origin = getLengthableOrigin2(input);
      const tooBig = length > def.length;
      payload.issues.push({
        origin,
        ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
        inclusive: true,
        exact: true,
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckStringFormat2 = /* @__PURE__ */ $constructor2("$ZodCheckStringFormat", (inst, def) => {
    var _a2, _b;
    $ZodCheck2.init(inst, def);
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.format = def.format;
      if (def.pattern) {
        bag.patterns ?? (bag.patterns = new Set);
        bag.patterns.add(def.pattern);
      }
    });
    if (def.pattern)
      (_a2 = inst._zod).check ?? (_a2.check = (payload) => {
        def.pattern.lastIndex = 0;
        if (def.pattern.test(payload.value))
          return;
        payload.issues.push({
          origin: "string",
          code: "invalid_format",
          format: def.format,
          input: payload.value,
          ...def.pattern ? { pattern: def.pattern.toString() } : {},
          inst,
          continue: !def.abort
        });
      });
    else
      (_b = inst._zod).check ?? (_b.check = () => {});
  });
  $ZodCheckRegex2 = /* @__PURE__ */ $constructor2("$ZodCheckRegex", (inst, def) => {
    $ZodCheckStringFormat2.init(inst, def);
    inst._zod.check = (payload) => {
      def.pattern.lastIndex = 0;
      if (def.pattern.test(payload.value))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: "regex",
        input: payload.value,
        pattern: def.pattern.toString(),
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckLowerCase2 = /* @__PURE__ */ $constructor2("$ZodCheckLowerCase", (inst, def) => {
    def.pattern ?? (def.pattern = lowercase3);
    $ZodCheckStringFormat2.init(inst, def);
  });
  $ZodCheckUpperCase2 = /* @__PURE__ */ $constructor2("$ZodCheckUpperCase", (inst, def) => {
    def.pattern ?? (def.pattern = uppercase2);
    $ZodCheckStringFormat2.init(inst, def);
  });
  $ZodCheckIncludes2 = /* @__PURE__ */ $constructor2("$ZodCheckIncludes", (inst, def) => {
    $ZodCheck2.init(inst, def);
    const escapedRegex = escapeRegex2(def.includes);
    const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
    def.pattern = pattern;
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.patterns ?? (bag.patterns = new Set);
      bag.patterns.add(pattern);
    });
    inst._zod.check = (payload) => {
      if (payload.value.includes(def.includes, def.position))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: "includes",
        includes: def.includes,
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckStartsWith2 = /* @__PURE__ */ $constructor2("$ZodCheckStartsWith", (inst, def) => {
    $ZodCheck2.init(inst, def);
    const pattern = new RegExp(`^${escapeRegex2(def.prefix)}.*`);
    def.pattern ?? (def.pattern = pattern);
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.patterns ?? (bag.patterns = new Set);
      bag.patterns.add(pattern);
    });
    inst._zod.check = (payload) => {
      if (payload.value.startsWith(def.prefix))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: "starts_with",
        prefix: def.prefix,
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckEndsWith2 = /* @__PURE__ */ $constructor2("$ZodCheckEndsWith", (inst, def) => {
    $ZodCheck2.init(inst, def);
    const pattern = new RegExp(`.*${escapeRegex2(def.suffix)}$`);
    def.pattern ?? (def.pattern = pattern);
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.patterns ?? (bag.patterns = new Set);
      bag.patterns.add(pattern);
    });
    inst._zod.check = (payload) => {
      if (payload.value.endsWith(def.suffix))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: "ends_with",
        suffix: def.suffix,
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckOverwrite2 = /* @__PURE__ */ $constructor2("$ZodCheckOverwrite", (inst, def) => {
    $ZodCheck2.init(inst, def);
    inst._zod.check = (payload) => {
      payload.value = def.tx(payload.value);
    };
  });
});

// node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/core/doc.js
class Doc2 {
  constructor(args = []) {
    this.content = [];
    this.indent = 0;
    if (this)
      this.args = args;
  }
  indented(fn) {
    this.indent += 1;
    fn(this);
    this.indent -= 1;
  }
  write(arg) {
    if (typeof arg === "function") {
      arg(this, { execution: "sync" });
      arg(this, { execution: "async" });
      return;
    }
    const content = arg;
    const lines = content.split(`
`).filter((x) => x);
    const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
    const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
    for (const line of dedented) {
      this.content.push(line);
    }
  }
  compile() {
    const F = Function;
    const args = this?.args;
    const content = this?.content ?? [``];
    const lines = [...content.map((x) => `  ${x}`)];
    return new F(...args, lines.join(`
`));
  }
}

// node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/core/versions.js
var version2;
var init_versions2 = __esm(() => {
  version2 = {
    major: 4,
    minor: 0,
    patch: 0
  };
});

// node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/core/schemas.js
function isValidBase642(data) {
  if (data === "")
    return true;
  if (data.length % 4 !== 0)
    return false;
  try {
    atob(data);
    return true;
  } catch {
    return false;
  }
}
function isValidBase64URL2(data) {
  if (!base64url3.test(data))
    return false;
  const base644 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
  const padded = base644.padEnd(Math.ceil(base644.length / 4) * 4, "=");
  return isValidBase642(padded);
}
function isValidJWT2(token, algorithm = null) {
  try {
    const tokensParts = token.split(".");
    if (tokensParts.length !== 3)
      return false;
    const [header] = tokensParts;
    if (!header)
      return false;
    const parsedHeader = JSON.parse(atob(header));
    if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")
      return false;
    if (!parsedHeader.alg)
      return false;
    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
      return false;
    return true;
  } catch {
    return false;
  }
}
function handleArrayResult2(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues2(index, result.issues));
  }
  final.value[index] = result.value;
}
function handleObjectResult(result, final, key) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues2(key, result.issues));
  }
  final.value[key] = result.value;
}
function handleOptionalObjectResult(result, final, key, input) {
  if (result.issues.length) {
    if (input[key] === undefined) {
      if (key in input) {
        final.value[key] = undefined;
      } else {
        final.value[key] = result.value;
      }
    } else {
      final.issues.push(...prefixIssues2(key, result.issues));
    }
  } else if (result.value === undefined) {
    if (key in input)
      final.value[key] = undefined;
  } else {
    final.value[key] = result.value;
  }
}
function handleUnionResults2(results, final, inst, ctx) {
  for (const result of results) {
    if (result.issues.length === 0) {
      final.value = result.value;
      return final;
    }
  }
  final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue2(iss, ctx, config2())))
  });
  return final;
}
function mergeValues2(a, b) {
  if (a === b) {
    return { valid: true, data: a };
  }
  if (a instanceof Date && b instanceof Date && +a === +b) {
    return { valid: true, data: a };
  }
  if (isPlainObject2(a) && isPlainObject2(b)) {
    const bKeys = Object.keys(b);
    const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues2(a[key], b[key]);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
        };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) {
      return { valid: false, mergeErrorPath: [] };
    }
    const newArray = [];
    for (let index = 0;index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues2(itemA, itemB);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
        };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  }
  return { valid: false, mergeErrorPath: [] };
}
function handleIntersectionResults2(result, left, right) {
  if (left.issues.length) {
    result.issues.push(...left.issues);
  }
  if (right.issues.length) {
    result.issues.push(...right.issues);
  }
  if (aborted2(result))
    return result;
  const merged = mergeValues2(left.value, right.value);
  if (!merged.valid) {
    throw new Error(`Unmergable intersection. Error path: ` + `${JSON.stringify(merged.mergeErrorPath)}`);
  }
  result.value = merged.data;
  return result;
}
function handleDefaultResult2(payload, def) {
  if (payload.value === undefined) {
    payload.value = def.defaultValue;
  }
  return payload;
}
function handleNonOptionalResult2(payload, inst) {
  if (!payload.issues.length && payload.value === undefined) {
    payload.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: payload.value,
      inst
    });
  }
  return payload;
}
function handlePipeResult2(left, def, ctx) {
  if (aborted2(left)) {
    return left;
  }
  return def.out._zod.run({ value: left.value, issues: left.issues }, ctx);
}
function handleReadonlyResult2(payload) {
  payload.value = Object.freeze(payload.value);
  return payload;
}
function handleRefineResult2(result, payload, input, inst) {
  if (!result) {
    const _iss = {
      code: "custom",
      input,
      inst,
      path: [...inst._zod.def.path ?? []],
      continue: !inst._zod.def.abort
    };
    if (inst._zod.def.params)
      _iss.params = inst._zod.def.params;
    payload.issues.push(issue2(_iss));
  }
}
var $ZodType2, $ZodString2, $ZodStringFormat2, $ZodGUID2, $ZodUUID2, $ZodEmail2, $ZodURL2, $ZodEmoji2, $ZodNanoID2, $ZodCUID3, $ZodCUID22, $ZodULID2, $ZodXID2, $ZodKSUID2, $ZodISODateTime2, $ZodISODate2, $ZodISOTime2, $ZodISODuration2, $ZodIPv42, $ZodIPv62, $ZodCIDRv42, $ZodCIDRv62, $ZodBase642, $ZodBase64URL2, $ZodE1642, $ZodJWT2, $ZodNumber2, $ZodNumberFormat2, $ZodBoolean2, $ZodNull2, $ZodUnknown2, $ZodNever2, $ZodArray2, $ZodObject2, $ZodUnion2, $ZodDiscriminatedUnion2, $ZodIntersection2, $ZodRecord2, $ZodEnum2, $ZodLiteral2, $ZodTransform2, $ZodOptional2, $ZodNullable2, $ZodDefault2, $ZodPrefault2, $ZodNonOptional2, $ZodCatch2, $ZodPipe2, $ZodReadonly2, $ZodCustom2;
var init_schemas3 = __esm(() => {
  init_checks3();
  init_core3();
  init_parse3();
  init_regexes2();
  init_util2();
  init_versions2();
  init_util2();
  $ZodType2 = /* @__PURE__ */ $constructor2("$ZodType", (inst, def) => {
    var _a2;
    inst ?? (inst = {});
    inst._zod.def = def;
    inst._zod.bag = inst._zod.bag || {};
    inst._zod.version = version2;
    const checks3 = [...inst._zod.def.checks ?? []];
    if (inst._zod.traits.has("$ZodCheck")) {
      checks3.unshift(inst);
    }
    for (const ch of checks3) {
      for (const fn of ch._zod.onattach) {
        fn(inst);
      }
    }
    if (checks3.length === 0) {
      (_a2 = inst._zod).deferred ?? (_a2.deferred = []);
      inst._zod.deferred?.push(() => {
        inst._zod.run = inst._zod.parse;
      });
    } else {
      const runChecks = (payload, checks4, ctx) => {
        let isAborted = aborted2(payload);
        let asyncResult;
        for (const ch of checks4) {
          if (ch._zod.def.when) {
            const shouldRun = ch._zod.def.when(payload);
            if (!shouldRun)
              continue;
          } else if (isAborted) {
            continue;
          }
          const currLen = payload.issues.length;
          const _ = ch._zod.check(payload);
          if (_ instanceof Promise && ctx?.async === false) {
            throw new $ZodAsyncError2;
          }
          if (asyncResult || _ instanceof Promise) {
            asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
              await _;
              const nextLen = payload.issues.length;
              if (nextLen === currLen)
                return;
              if (!isAborted)
                isAborted = aborted2(payload, currLen);
            });
          } else {
            const nextLen = payload.issues.length;
            if (nextLen === currLen)
              continue;
            if (!isAborted)
              isAborted = aborted2(payload, currLen);
          }
        }
        if (asyncResult) {
          return asyncResult.then(() => {
            return payload;
          });
        }
        return payload;
      };
      inst._zod.run = (payload, ctx) => {
        const result = inst._zod.parse(payload, ctx);
        if (result instanceof Promise) {
          if (ctx.async === false)
            throw new $ZodAsyncError2;
          return result.then((result2) => runChecks(result2, checks3, ctx));
        }
        return runChecks(result, checks3, ctx);
      };
    }
    inst["~standard"] = {
      validate: (value) => {
        try {
          const r = safeParse3(inst, value);
          return r.success ? { value: r.data } : { issues: r.error?.issues };
        } catch (_) {
          return safeParseAsync3(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });
        }
      },
      vendor: "zod",
      version: 1
    };
  });
  $ZodString2 = /* @__PURE__ */ $constructor2("$ZodString", (inst, def) => {
    $ZodType2.init(inst, def);
    inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string4(inst._zod.bag);
    inst._zod.parse = (payload, _) => {
      if (def.coerce)
        try {
          payload.value = String(payload.value);
        } catch (_2) {}
      if (typeof payload.value === "string")
        return payload;
      payload.issues.push({
        expected: "string",
        code: "invalid_type",
        input: payload.value,
        inst
      });
      return payload;
    };
  });
  $ZodStringFormat2 = /* @__PURE__ */ $constructor2("$ZodStringFormat", (inst, def) => {
    $ZodCheckStringFormat2.init(inst, def);
    $ZodString2.init(inst, def);
  });
  $ZodGUID2 = /* @__PURE__ */ $constructor2("$ZodGUID", (inst, def) => {
    def.pattern ?? (def.pattern = guid3);
    $ZodStringFormat2.init(inst, def);
  });
  $ZodUUID2 = /* @__PURE__ */ $constructor2("$ZodUUID", (inst, def) => {
    if (def.version) {
      const versionMap = {
        v1: 1,
        v2: 2,
        v3: 3,
        v4: 4,
        v5: 5,
        v6: 6,
        v7: 7,
        v8: 8
      };
      const v = versionMap[def.version];
      if (v === undefined)
        throw new Error(`Invalid UUID version: "${def.version}"`);
      def.pattern ?? (def.pattern = uuid3(v));
    } else
      def.pattern ?? (def.pattern = uuid3());
    $ZodStringFormat2.init(inst, def);
  });
  $ZodEmail2 = /* @__PURE__ */ $constructor2("$ZodEmail", (inst, def) => {
    def.pattern ?? (def.pattern = email3);
    $ZodStringFormat2.init(inst, def);
  });
  $ZodURL2 = /* @__PURE__ */ $constructor2("$ZodURL", (inst, def) => {
    $ZodStringFormat2.init(inst, def);
    inst._zod.check = (payload) => {
      try {
        const orig = payload.value;
        const url2 = new URL(orig);
        const href = url2.href;
        if (def.hostname) {
          def.hostname.lastIndex = 0;
          if (!def.hostname.test(url2.hostname)) {
            payload.issues.push({
              code: "invalid_format",
              format: "url",
              note: "Invalid hostname",
              pattern: hostname3.source,
              input: payload.value,
              inst,
              continue: !def.abort
            });
          }
        }
        if (def.protocol) {
          def.protocol.lastIndex = 0;
          if (!def.protocol.test(url2.protocol.endsWith(":") ? url2.protocol.slice(0, -1) : url2.protocol)) {
            payload.issues.push({
              code: "invalid_format",
              format: "url",
              note: "Invalid protocol",
              pattern: def.protocol.source,
              input: payload.value,
              inst,
              continue: !def.abort
            });
          }
        }
        if (!orig.endsWith("/") && href.endsWith("/")) {
          payload.value = href.slice(0, -1);
        } else {
          payload.value = href;
        }
        return;
      } catch (_) {
        payload.issues.push({
          code: "invalid_format",
          format: "url",
          input: payload.value,
          inst,
          continue: !def.abort
        });
      }
    };
  });
  $ZodEmoji2 = /* @__PURE__ */ $constructor2("$ZodEmoji", (inst, def) => {
    def.pattern ?? (def.pattern = emoji3());
    $ZodStringFormat2.init(inst, def);
  });
  $ZodNanoID2 = /* @__PURE__ */ $constructor2("$ZodNanoID", (inst, def) => {
    def.pattern ?? (def.pattern = nanoid3);
    $ZodStringFormat2.init(inst, def);
  });
  $ZodCUID3 = /* @__PURE__ */ $constructor2("$ZodCUID", (inst, def) => {
    def.pattern ?? (def.pattern = cuid5);
    $ZodStringFormat2.init(inst, def);
  });
  $ZodCUID22 = /* @__PURE__ */ $constructor2("$ZodCUID2", (inst, def) => {
    def.pattern ?? (def.pattern = cuid23);
    $ZodStringFormat2.init(inst, def);
  });
  $ZodULID2 = /* @__PURE__ */ $constructor2("$ZodULID", (inst, def) => {
    def.pattern ?? (def.pattern = ulid3);
    $ZodStringFormat2.init(inst, def);
  });
  $ZodXID2 = /* @__PURE__ */ $constructor2("$ZodXID", (inst, def) => {
    def.pattern ?? (def.pattern = xid3);
    $ZodStringFormat2.init(inst, def);
  });
  $ZodKSUID2 = /* @__PURE__ */ $constructor2("$ZodKSUID", (inst, def) => {
    def.pattern ?? (def.pattern = ksuid3);
    $ZodStringFormat2.init(inst, def);
  });
  $ZodISODateTime2 = /* @__PURE__ */ $constructor2("$ZodISODateTime", (inst, def) => {
    def.pattern ?? (def.pattern = datetime3(def));
    $ZodStringFormat2.init(inst, def);
  });
  $ZodISODate2 = /* @__PURE__ */ $constructor2("$ZodISODate", (inst, def) => {
    def.pattern ?? (def.pattern = date5);
    $ZodStringFormat2.init(inst, def);
  });
  $ZodISOTime2 = /* @__PURE__ */ $constructor2("$ZodISOTime", (inst, def) => {
    def.pattern ?? (def.pattern = time3(def));
    $ZodStringFormat2.init(inst, def);
  });
  $ZodISODuration2 = /* @__PURE__ */ $constructor2("$ZodISODuration", (inst, def) => {
    def.pattern ?? (def.pattern = duration3);
    $ZodStringFormat2.init(inst, def);
  });
  $ZodIPv42 = /* @__PURE__ */ $constructor2("$ZodIPv4", (inst, def) => {
    def.pattern ?? (def.pattern = ipv43);
    $ZodStringFormat2.init(inst, def);
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.format = `ipv4`;
    });
  });
  $ZodIPv62 = /* @__PURE__ */ $constructor2("$ZodIPv6", (inst, def) => {
    def.pattern ?? (def.pattern = ipv63);
    $ZodStringFormat2.init(inst, def);
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.format = `ipv6`;
    });
    inst._zod.check = (payload) => {
      try {
        new URL(`http://[${payload.value}]`);
      } catch {
        payload.issues.push({
          code: "invalid_format",
          format: "ipv6",
          input: payload.value,
          inst,
          continue: !def.abort
        });
      }
    };
  });
  $ZodCIDRv42 = /* @__PURE__ */ $constructor2("$ZodCIDRv4", (inst, def) => {
    def.pattern ?? (def.pattern = cidrv43);
    $ZodStringFormat2.init(inst, def);
  });
  $ZodCIDRv62 = /* @__PURE__ */ $constructor2("$ZodCIDRv6", (inst, def) => {
    def.pattern ?? (def.pattern = cidrv63);
    $ZodStringFormat2.init(inst, def);
    inst._zod.check = (payload) => {
      const [address, prefix] = payload.value.split("/");
      try {
        if (!prefix)
          throw new Error;
        const prefixNum = Number(prefix);
        if (`${prefixNum}` !== prefix)
          throw new Error;
        if (prefixNum < 0 || prefixNum > 128)
          throw new Error;
        new URL(`http://[${address}]`);
      } catch {
        payload.issues.push({
          code: "invalid_format",
          format: "cidrv6",
          input: payload.value,
          inst,
          continue: !def.abort
        });
      }
    };
  });
  $ZodBase642 = /* @__PURE__ */ $constructor2("$ZodBase64", (inst, def) => {
    def.pattern ?? (def.pattern = base643);
    $ZodStringFormat2.init(inst, def);
    inst._zod.onattach.push((inst2) => {
      inst2._zod.bag.contentEncoding = "base64";
    });
    inst._zod.check = (payload) => {
      if (isValidBase642(payload.value))
        return;
      payload.issues.push({
        code: "invalid_format",
        format: "base64",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodBase64URL2 = /* @__PURE__ */ $constructor2("$ZodBase64URL", (inst, def) => {
    def.pattern ?? (def.pattern = base64url3);
    $ZodStringFormat2.init(inst, def);
    inst._zod.onattach.push((inst2) => {
      inst2._zod.bag.contentEncoding = "base64url";
    });
    inst._zod.check = (payload) => {
      if (isValidBase64URL2(payload.value))
        return;
      payload.issues.push({
        code: "invalid_format",
        format: "base64url",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodE1642 = /* @__PURE__ */ $constructor2("$ZodE164", (inst, def) => {
    def.pattern ?? (def.pattern = e1643);
    $ZodStringFormat2.init(inst, def);
  });
  $ZodJWT2 = /* @__PURE__ */ $constructor2("$ZodJWT", (inst, def) => {
    $ZodStringFormat2.init(inst, def);
    inst._zod.check = (payload) => {
      if (isValidJWT2(payload.value, def.alg))
        return;
      payload.issues.push({
        code: "invalid_format",
        format: "jwt",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodNumber2 = /* @__PURE__ */ $constructor2("$ZodNumber", (inst, def) => {
    $ZodType2.init(inst, def);
    inst._zod.pattern = inst._zod.bag.pattern ?? number4;
    inst._zod.parse = (payload, _ctx) => {
      if (def.coerce)
        try {
          payload.value = Number(payload.value);
        } catch (_) {}
      const input = payload.value;
      if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
        return payload;
      }
      const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : undefined : undefined;
      payload.issues.push({
        expected: "number",
        code: "invalid_type",
        input,
        inst,
        ...received ? { received } : {}
      });
      return payload;
    };
  });
  $ZodNumberFormat2 = /* @__PURE__ */ $constructor2("$ZodNumber", (inst, def) => {
    $ZodCheckNumberFormat2.init(inst, def);
    $ZodNumber2.init(inst, def);
  });
  $ZodBoolean2 = /* @__PURE__ */ $constructor2("$ZodBoolean", (inst, def) => {
    $ZodType2.init(inst, def);
    inst._zod.pattern = boolean4;
    inst._zod.parse = (payload, _ctx) => {
      if (def.coerce)
        try {
          payload.value = Boolean(payload.value);
        } catch (_) {}
      const input = payload.value;
      if (typeof input === "boolean")
        return payload;
      payload.issues.push({
        expected: "boolean",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    };
  });
  $ZodNull2 = /* @__PURE__ */ $constructor2("$ZodNull", (inst, def) => {
    $ZodType2.init(inst, def);
    inst._zod.pattern = _null4;
    inst._zod.values = new Set([null]);
    inst._zod.parse = (payload, _ctx) => {
      const input = payload.value;
      if (input === null)
        return payload;
      payload.issues.push({
        expected: "null",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    };
  });
  $ZodUnknown2 = /* @__PURE__ */ $constructor2("$ZodUnknown", (inst, def) => {
    $ZodType2.init(inst, def);
    inst._zod.parse = (payload) => payload;
  });
  $ZodNever2 = /* @__PURE__ */ $constructor2("$ZodNever", (inst, def) => {
    $ZodType2.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
      payload.issues.push({
        expected: "never",
        code: "invalid_type",
        input: payload.value,
        inst
      });
      return payload;
    };
  });
  $ZodArray2 = /* @__PURE__ */ $constructor2("$ZodArray", (inst, def) => {
    $ZodType2.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      const input = payload.value;
      if (!Array.isArray(input)) {
        payload.issues.push({
          expected: "array",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      }
      payload.value = Array(input.length);
      const proms = [];
      for (let i = 0;i < input.length; i++) {
        const item = input[i];
        const result = def.element._zod.run({
          value: item,
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => handleArrayResult2(result2, payload, i)));
        } else {
          handleArrayResult2(result, payload, i);
        }
      }
      if (proms.length) {
        return Promise.all(proms).then(() => payload);
      }
      return payload;
    };
  });
  $ZodObject2 = /* @__PURE__ */ $constructor2("$ZodObject", (inst, def) => {
    $ZodType2.init(inst, def);
    const _normalized = cached2(() => {
      const keys = Object.keys(def.shape);
      for (const k of keys) {
        if (!(def.shape[k] instanceof $ZodType2)) {
          throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
        }
      }
      const okeys = optionalKeys2(def.shape);
      return {
        shape: def.shape,
        keys,
        keySet: new Set(keys),
        numKeys: keys.length,
        optionalKeys: new Set(okeys)
      };
    });
    defineLazy2(inst._zod, "propValues", () => {
      const shape = def.shape;
      const propValues = {};
      for (const key in shape) {
        const field = shape[key]._zod;
        if (field.values) {
          propValues[key] ?? (propValues[key] = new Set);
          for (const v of field.values)
            propValues[key].add(v);
        }
      }
      return propValues;
    });
    const generateFastpass = (shape) => {
      const doc2 = new Doc2(["shape", "payload", "ctx"]);
      const normalized = _normalized.value;
      const parseStr = (key) => {
        const k = esc2(key);
        return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
      };
      doc2.write(`const input = payload.value;`);
      const ids = Object.create(null);
      let counter = 0;
      for (const key of normalized.keys) {
        ids[key] = `key_${counter++}`;
      }
      doc2.write(`const newResult = {}`);
      for (const key of normalized.keys) {
        if (normalized.optionalKeys.has(key)) {
          const id = ids[key];
          doc2.write(`const ${id} = ${parseStr(key)};`);
          const k = esc2(key);
          doc2.write(`
        if (${id}.issues.length) {
          if (input[${k}] === undefined) {
            if (${k} in input) {
              newResult[${k}] = undefined;
            }
          } else {
            payload.issues = payload.issues.concat(
              ${id}.issues.map((iss) => ({
                ...iss,
                path: iss.path ? [${k}, ...iss.path] : [${k}],
              }))
            );
          }
        } else if (${id}.value === undefined) {
          if (${k} in input) newResult[${k}] = undefined;
        } else {
          newResult[${k}] = ${id}.value;
        }
        `);
        } else {
          const id = ids[key];
          doc2.write(`const ${id} = ${parseStr(key)};`);
          doc2.write(`
          if (${id}.issues.length) payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${esc2(key)}, ...iss.path] : [${esc2(key)}]
          })));`);
          doc2.write(`newResult[${esc2(key)}] = ${id}.value`);
        }
      }
      doc2.write(`payload.value = newResult;`);
      doc2.write(`return payload;`);
      const fn = doc2.compile();
      return (payload, ctx) => fn(shape, payload, ctx);
    };
    let fastpass;
    const isObject3 = isObject2;
    const jit = !globalConfig2.jitless;
    const allowsEval3 = allowsEval2;
    const fastEnabled = jit && allowsEval3.value;
    const catchall = def.catchall;
    let value;
    inst._zod.parse = (payload, ctx) => {
      value ?? (value = _normalized.value);
      const input = payload.value;
      if (!isObject3(input)) {
        payload.issues.push({
          expected: "object",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      }
      const proms = [];
      if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
        if (!fastpass)
          fastpass = generateFastpass(def.shape);
        payload = fastpass(payload, ctx);
      } else {
        payload.value = {};
        const shape = value.shape;
        for (const key of value.keys) {
          const el = shape[key];
          const r = el._zod.run({ value: input[key], issues: [] }, ctx);
          const isOptional = el._zod.optin === "optional" && el._zod.optout === "optional";
          if (r instanceof Promise) {
            proms.push(r.then((r2) => isOptional ? handleOptionalObjectResult(r2, payload, key, input) : handleObjectResult(r2, payload, key)));
          } else if (isOptional) {
            handleOptionalObjectResult(r, payload, key, input);
          } else {
            handleObjectResult(r, payload, key);
          }
        }
      }
      if (!catchall) {
        return proms.length ? Promise.all(proms).then(() => payload) : payload;
      }
      const unrecognized = [];
      const keySet = value.keySet;
      const _catchall = catchall._zod;
      const t = _catchall.def.type;
      for (const key of Object.keys(input)) {
        if (keySet.has(key))
          continue;
        if (t === "never") {
          unrecognized.push(key);
          continue;
        }
        const r = _catchall.run({ value: input[key], issues: [] }, ctx);
        if (r instanceof Promise) {
          proms.push(r.then((r2) => handleObjectResult(r2, payload, key)));
        } else {
          handleObjectResult(r, payload, key);
        }
      }
      if (unrecognized.length) {
        payload.issues.push({
          code: "unrecognized_keys",
          keys: unrecognized,
          input,
          inst
        });
      }
      if (!proms.length)
        return payload;
      return Promise.all(proms).then(() => {
        return payload;
      });
    };
  });
  $ZodUnion2 = /* @__PURE__ */ $constructor2("$ZodUnion", (inst, def) => {
    $ZodType2.init(inst, def);
    defineLazy2(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : undefined);
    defineLazy2(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : undefined);
    defineLazy2(inst._zod, "values", () => {
      if (def.options.every((o) => o._zod.values)) {
        return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
      }
      return;
    });
    defineLazy2(inst._zod, "pattern", () => {
      if (def.options.every((o) => o._zod.pattern)) {
        const patterns = def.options.map((o) => o._zod.pattern);
        return new RegExp(`^(${patterns.map((p) => cleanRegex2(p.source)).join("|")})$`);
      }
      return;
    });
    inst._zod.parse = (payload, ctx) => {
      let async = false;
      const results = [];
      for (const option of def.options) {
        const result = option._zod.run({
          value: payload.value,
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          results.push(result);
          async = true;
        } else {
          if (result.issues.length === 0)
            return result;
          results.push(result);
        }
      }
      if (!async)
        return handleUnionResults2(results, payload, inst, ctx);
      return Promise.all(results).then((results2) => {
        return handleUnionResults2(results2, payload, inst, ctx);
      });
    };
  });
  $ZodDiscriminatedUnion2 = /* @__PURE__ */ $constructor2("$ZodDiscriminatedUnion", (inst, def) => {
    $ZodUnion2.init(inst, def);
    const _super = inst._zod.parse;
    defineLazy2(inst._zod, "propValues", () => {
      const propValues = {};
      for (const option of def.options) {
        const pv = option._zod.propValues;
        if (!pv || Object.keys(pv).length === 0)
          throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
        for (const [k, v] of Object.entries(pv)) {
          if (!propValues[k])
            propValues[k] = new Set;
          for (const val of v) {
            propValues[k].add(val);
          }
        }
      }
      return propValues;
    });
    const disc = cached2(() => {
      const opts = def.options;
      const map2 = new Map;
      for (const o of opts) {
        const values = o._zod.propValues[def.discriminator];
        if (!values || values.size === 0)
          throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
        for (const v of values) {
          if (map2.has(v)) {
            throw new Error(`Duplicate discriminator value "${String(v)}"`);
          }
          map2.set(v, o);
        }
      }
      return map2;
    });
    inst._zod.parse = (payload, ctx) => {
      const input = payload.value;
      if (!isObject2(input)) {
        payload.issues.push({
          code: "invalid_type",
          expected: "object",
          input,
          inst
        });
        return payload;
      }
      const opt = disc.value.get(input?.[def.discriminator]);
      if (opt) {
        return opt._zod.run(payload, ctx);
      }
      if (def.unionFallback) {
        return _super(payload, ctx);
      }
      payload.issues.push({
        code: "invalid_union",
        errors: [],
        note: "No matching discriminator",
        input,
        path: [def.discriminator],
        inst
      });
      return payload;
    };
  });
  $ZodIntersection2 = /* @__PURE__ */ $constructor2("$ZodIntersection", (inst, def) => {
    $ZodType2.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      const input = payload.value;
      const left = def.left._zod.run({ value: input, issues: [] }, ctx);
      const right = def.right._zod.run({ value: input, issues: [] }, ctx);
      const async = left instanceof Promise || right instanceof Promise;
      if (async) {
        return Promise.all([left, right]).then(([left2, right2]) => {
          return handleIntersectionResults2(payload, left2, right2);
        });
      }
      return handleIntersectionResults2(payload, left, right);
    };
  });
  $ZodRecord2 = /* @__PURE__ */ $constructor2("$ZodRecord", (inst, def) => {
    $ZodType2.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      const input = payload.value;
      if (!isPlainObject2(input)) {
        payload.issues.push({
          expected: "record",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      }
      const proms = [];
      if (def.keyType._zod.values) {
        const values = def.keyType._zod.values;
        payload.value = {};
        for (const key of values) {
          if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
            const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
            if (result instanceof Promise) {
              proms.push(result.then((result2) => {
                if (result2.issues.length) {
                  payload.issues.push(...prefixIssues2(key, result2.issues));
                }
                payload.value[key] = result2.value;
              }));
            } else {
              if (result.issues.length) {
                payload.issues.push(...prefixIssues2(key, result.issues));
              }
              payload.value[key] = result.value;
            }
          }
        }
        let unrecognized;
        for (const key in input) {
          if (!values.has(key)) {
            unrecognized = unrecognized ?? [];
            unrecognized.push(key);
          }
        }
        if (unrecognized && unrecognized.length > 0) {
          payload.issues.push({
            code: "unrecognized_keys",
            input,
            inst,
            keys: unrecognized
          });
        }
      } else {
        payload.value = {};
        for (const key of Reflect.ownKeys(input)) {
          if (key === "__proto__")
            continue;
          const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
          if (keyResult instanceof Promise) {
            throw new Error("Async schemas not supported in object keys currently");
          }
          if (keyResult.issues.length) {
            payload.issues.push({
              origin: "record",
              code: "invalid_key",
              issues: keyResult.issues.map((iss) => finalizeIssue2(iss, ctx, config2())),
              input: key,
              path: [key],
              inst
            });
            payload.value[keyResult.value] = keyResult.value;
            continue;
          }
          const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => {
              if (result2.issues.length) {
                payload.issues.push(...prefixIssues2(key, result2.issues));
              }
              payload.value[keyResult.value] = result2.value;
            }));
          } else {
            if (result.issues.length) {
              payload.issues.push(...prefixIssues2(key, result.issues));
            }
            payload.value[keyResult.value] = result.value;
          }
        }
      }
      if (proms.length) {
        return Promise.all(proms).then(() => payload);
      }
      return payload;
    };
  });
  $ZodEnum2 = /* @__PURE__ */ $constructor2("$ZodEnum", (inst, def) => {
    $ZodType2.init(inst, def);
    const values = getEnumValues2(def.entries);
    inst._zod.values = new Set(values);
    inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes2.has(typeof k)).map((o) => typeof o === "string" ? escapeRegex2(o) : o.toString()).join("|")})$`);
    inst._zod.parse = (payload, _ctx) => {
      const input = payload.value;
      if (inst._zod.values.has(input)) {
        return payload;
      }
      payload.issues.push({
        code: "invalid_value",
        values,
        input,
        inst
      });
      return payload;
    };
  });
  $ZodLiteral2 = /* @__PURE__ */ $constructor2("$ZodLiteral", (inst, def) => {
    $ZodType2.init(inst, def);
    inst._zod.values = new Set(def.values);
    inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o === "string" ? escapeRegex2(o) : o ? o.toString() : String(o)).join("|")})$`);
    inst._zod.parse = (payload, _ctx) => {
      const input = payload.value;
      if (inst._zod.values.has(input)) {
        return payload;
      }
      payload.issues.push({
        code: "invalid_value",
        values: def.values,
        input,
        inst
      });
      return payload;
    };
  });
  $ZodTransform2 = /* @__PURE__ */ $constructor2("$ZodTransform", (inst, def) => {
    $ZodType2.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
      const _out = def.transform(payload.value, payload);
      if (_ctx.async) {
        const output = _out instanceof Promise ? _out : Promise.resolve(_out);
        return output.then((output2) => {
          payload.value = output2;
          return payload;
        });
      }
      if (_out instanceof Promise) {
        throw new $ZodAsyncError2;
      }
      payload.value = _out;
      return payload;
    };
  });
  $ZodOptional2 = /* @__PURE__ */ $constructor2("$ZodOptional", (inst, def) => {
    $ZodType2.init(inst, def);
    inst._zod.optin = "optional";
    inst._zod.optout = "optional";
    defineLazy2(inst._zod, "values", () => {
      return def.innerType._zod.values ? new Set([...def.innerType._zod.values, undefined]) : undefined;
    });
    defineLazy2(inst._zod, "pattern", () => {
      const pattern = def.innerType._zod.pattern;
      return pattern ? new RegExp(`^(${cleanRegex2(pattern.source)})?$`) : undefined;
    });
    inst._zod.parse = (payload, ctx) => {
      if (def.innerType._zod.optin === "optional") {
        return def.innerType._zod.run(payload, ctx);
      }
      if (payload.value === undefined) {
        return payload;
      }
      return def.innerType._zod.run(payload, ctx);
    };
  });
  $ZodNullable2 = /* @__PURE__ */ $constructor2("$ZodNullable", (inst, def) => {
    $ZodType2.init(inst, def);
    defineLazy2(inst._zod, "optin", () => def.innerType._zod.optin);
    defineLazy2(inst._zod, "optout", () => def.innerType._zod.optout);
    defineLazy2(inst._zod, "pattern", () => {
      const pattern = def.innerType._zod.pattern;
      return pattern ? new RegExp(`^(${cleanRegex2(pattern.source)}|null)$`) : undefined;
    });
    defineLazy2(inst._zod, "values", () => {
      return def.innerType._zod.values ? new Set([...def.innerType._zod.values, null]) : undefined;
    });
    inst._zod.parse = (payload, ctx) => {
      if (payload.value === null)
        return payload;
      return def.innerType._zod.run(payload, ctx);
    };
  });
  $ZodDefault2 = /* @__PURE__ */ $constructor2("$ZodDefault", (inst, def) => {
    $ZodType2.init(inst, def);
    inst._zod.optin = "optional";
    defineLazy2(inst._zod, "values", () => def.innerType._zod.values);
    inst._zod.parse = (payload, ctx) => {
      if (payload.value === undefined) {
        payload.value = def.defaultValue;
        return payload;
      }
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise) {
        return result.then((result2) => handleDefaultResult2(result2, def));
      }
      return handleDefaultResult2(result, def);
    };
  });
  $ZodPrefault2 = /* @__PURE__ */ $constructor2("$ZodPrefault", (inst, def) => {
    $ZodType2.init(inst, def);
    inst._zod.optin = "optional";
    defineLazy2(inst._zod, "values", () => def.innerType._zod.values);
    inst._zod.parse = (payload, ctx) => {
      if (payload.value === undefined) {
        payload.value = def.defaultValue;
      }
      return def.innerType._zod.run(payload, ctx);
    };
  });
  $ZodNonOptional2 = /* @__PURE__ */ $constructor2("$ZodNonOptional", (inst, def) => {
    $ZodType2.init(inst, def);
    defineLazy2(inst._zod, "values", () => {
      const v = def.innerType._zod.values;
      return v ? new Set([...v].filter((x) => x !== undefined)) : undefined;
    });
    inst._zod.parse = (payload, ctx) => {
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise) {
        return result.then((result2) => handleNonOptionalResult2(result2, inst));
      }
      return handleNonOptionalResult2(result, inst);
    };
  });
  $ZodCatch2 = /* @__PURE__ */ $constructor2("$ZodCatch", (inst, def) => {
    $ZodType2.init(inst, def);
    inst._zod.optin = "optional";
    defineLazy2(inst._zod, "optout", () => def.innerType._zod.optout);
    defineLazy2(inst._zod, "values", () => def.innerType._zod.values);
    inst._zod.parse = (payload, ctx) => {
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise) {
        return result.then((result2) => {
          payload.value = result2.value;
          if (result2.issues.length) {
            payload.value = def.catchValue({
              ...payload,
              error: {
                issues: result2.issues.map((iss) => finalizeIssue2(iss, ctx, config2()))
              },
              input: payload.value
            });
            payload.issues = [];
          }
          return payload;
        });
      }
      payload.value = result.value;
      if (result.issues.length) {
        payload.value = def.catchValue({
          ...payload,
          error: {
            issues: result.issues.map((iss) => finalizeIssue2(iss, ctx, config2()))
          },
          input: payload.value
        });
        payload.issues = [];
      }
      return payload;
    };
  });
  $ZodPipe2 = /* @__PURE__ */ $constructor2("$ZodPipe", (inst, def) => {
    $ZodType2.init(inst, def);
    defineLazy2(inst._zod, "values", () => def.in._zod.values);
    defineLazy2(inst._zod, "optin", () => def.in._zod.optin);
    defineLazy2(inst._zod, "optout", () => def.out._zod.optout);
    inst._zod.parse = (payload, ctx) => {
      const left = def.in._zod.run(payload, ctx);
      if (left instanceof Promise) {
        return left.then((left2) => handlePipeResult2(left2, def, ctx));
      }
      return handlePipeResult2(left, def, ctx);
    };
  });
  $ZodReadonly2 = /* @__PURE__ */ $constructor2("$ZodReadonly", (inst, def) => {
    $ZodType2.init(inst, def);
    defineLazy2(inst._zod, "propValues", () => def.innerType._zod.propValues);
    defineLazy2(inst._zod, "values", () => def.innerType._zod.values);
    defineLazy2(inst._zod, "optin", () => def.innerType._zod.optin);
    defineLazy2(inst._zod, "optout", () => def.innerType._zod.optout);
    inst._zod.parse = (payload, ctx) => {
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise) {
        return result.then(handleReadonlyResult2);
      }
      return handleReadonlyResult2(result);
    };
  });
  $ZodCustom2 = /* @__PURE__ */ $constructor2("$ZodCustom", (inst, def) => {
    $ZodCheck2.init(inst, def);
    $ZodType2.init(inst, def);
    inst._zod.parse = (payload, _) => {
      return payload;
    };
    inst._zod.check = (payload) => {
      const input = payload.value;
      const r = def.fn(input);
      if (r instanceof Promise) {
        return r.then((r2) => handleRefineResult2(r2, payload, input, inst));
      }
      handleRefineResult2(r, payload, input, inst);
      return;
    };
  });
});

// node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/locales/en.js
function en_default2() {
  return {
    localeError: error48()
  };
}
var parsedType2 = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "number";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
}, error48 = () => {
  const Sizable = {
    string: { unit: "characters", verb: "to have" },
    file: { unit: "bytes", verb: "to have" },
    array: { unit: "items", verb: "to have" },
    set: { unit: "items", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Invalid input: expected ${issue3.expected}, received ${parsedType2(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive2(issue3.values[0])}`;
        return `Invalid option: expected one of ${joinValues2(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Too big: expected ${issue3.origin ?? "value"} to have ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Too big: expected ${issue3.origin ?? "value"} to be ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Too small: expected ${issue3.origin} to have ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Too small: expected ${issue3.origin} to be ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Invalid string: must start with "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Invalid string: must end with "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Invalid string: must include "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Invalid string: must match pattern ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Invalid number: must be a multiple of ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Unrecognized key${issue3.keys.length > 1 ? "s" : ""}: ${joinValues2(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Invalid key in ${issue3.origin}`;
      case "invalid_union":
        return "Invalid input";
      case "invalid_element":
        return `Invalid value in ${issue3.origin}`;
      default:
        return `Invalid input`;
    }
  };
};
var init_en2 = __esm(() => {
  init_util2();
});

// node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/locales/index.js
var init_locales2 = () => {};

// node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/core/registries.js
class $ZodRegistry2 {
  constructor() {
    this._map = new Map;
    this._idmap = new Map;
  }
  add(schema, ..._meta) {
    const meta3 = _meta[0];
    this._map.set(schema, meta3);
    if (meta3 && typeof meta3 === "object" && "id" in meta3) {
      if (this._idmap.has(meta3.id)) {
        throw new Error(`ID ${meta3.id} already exists in the registry`);
      }
      this._idmap.set(meta3.id, schema);
    }
    return this;
  }
  clear() {
    this._map = new Map;
    this._idmap = new Map;
    return this;
  }
  remove(schema) {
    const meta3 = this._map.get(schema);
    if (meta3 && typeof meta3 === "object" && "id" in meta3) {
      this._idmap.delete(meta3.id);
    }
    this._map.delete(schema);
    return this;
  }
  get(schema) {
    const p = schema._zod.parent;
    if (p) {
      const pm = { ...this.get(p) ?? {} };
      delete pm.id;
      return { ...pm, ...this._map.get(schema) };
    }
    return this._map.get(schema);
  }
  has(schema) {
    return this._map.has(schema);
  }
}
function registry2() {
  return new $ZodRegistry2;
}
var $output2, $input2, globalRegistry2;
var init_registries2 = __esm(() => {
  $output2 = Symbol("ZodOutput");
  $input2 = Symbol("ZodInput");
  globalRegistry2 = /* @__PURE__ */ registry2();
});

// node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/core/api.js
function _string2(Class3, params) {
  return new Class3({
    type: "string",
    ...normalizeParams2(params)
  });
}
function _email2(Class3, params) {
  return new Class3({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _guid2(Class3, params) {
  return new Class3({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _uuid2(Class3, params) {
  return new Class3({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _uuidv42(Class3, params) {
  return new Class3({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...normalizeParams2(params)
  });
}
function _uuidv62(Class3, params) {
  return new Class3({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...normalizeParams2(params)
  });
}
function _uuidv72(Class3, params) {
  return new Class3({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...normalizeParams2(params)
  });
}
function _url2(Class3, params) {
  return new Class3({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _emoji4(Class3, params) {
  return new Class3({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _nanoid2(Class3, params) {
  return new Class3({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _cuid3(Class3, params) {
  return new Class3({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _cuid22(Class3, params) {
  return new Class3({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _ulid2(Class3, params) {
  return new Class3({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _xid2(Class3, params) {
  return new Class3({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _ksuid2(Class3, params) {
  return new Class3({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _ipv42(Class3, params) {
  return new Class3({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _ipv62(Class3, params) {
  return new Class3({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _cidrv42(Class3, params) {
  return new Class3({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _cidrv62(Class3, params) {
  return new Class3({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _base642(Class3, params) {
  return new Class3({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _base64url2(Class3, params) {
  return new Class3({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _e1642(Class3, params) {
  return new Class3({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _jwt2(Class3, params) {
  return new Class3({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params)
  });
}
function _isoDateTime2(Class3, params) {
  return new Class3({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...normalizeParams2(params)
  });
}
function _isoDate2(Class3, params) {
  return new Class3({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams2(params)
  });
}
function _isoTime2(Class3, params) {
  return new Class3({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams2(params)
  });
}
function _isoDuration2(Class3, params) {
  return new Class3({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams2(params)
  });
}
function _number2(Class3, params) {
  return new Class3({
    type: "number",
    checks: [],
    ...normalizeParams2(params)
  });
}
function _int2(Class3, params) {
  return new Class3({
    type: "number",
    check: "number_format",
    abort: false,
    format: "safeint",
    ...normalizeParams2(params)
  });
}
function _boolean2(Class3, params) {
  return new Class3({
    type: "boolean",
    ...normalizeParams2(params)
  });
}
function _null5(Class3, params) {
  return new Class3({
    type: "null",
    ...normalizeParams2(params)
  });
}
function _unknown2(Class3) {
  return new Class3({
    type: "unknown"
  });
}
function _never2(Class3, params) {
  return new Class3({
    type: "never",
    ...normalizeParams2(params)
  });
}
function _lt2(value, params) {
  return new $ZodCheckLessThan2({
    check: "less_than",
    ...normalizeParams2(params),
    value,
    inclusive: false
  });
}
function _lte2(value, params) {
  return new $ZodCheckLessThan2({
    check: "less_than",
    ...normalizeParams2(params),
    value,
    inclusive: true
  });
}
function _gt2(value, params) {
  return new $ZodCheckGreaterThan2({
    check: "greater_than",
    ...normalizeParams2(params),
    value,
    inclusive: false
  });
}
function _gte2(value, params) {
  return new $ZodCheckGreaterThan2({
    check: "greater_than",
    ...normalizeParams2(params),
    value,
    inclusive: true
  });
}
function _multipleOf2(value, params) {
  return new $ZodCheckMultipleOf2({
    check: "multiple_of",
    ...normalizeParams2(params),
    value
  });
}
function _maxLength2(maximum, params) {
  const ch = new $ZodCheckMaxLength2({
    check: "max_length",
    ...normalizeParams2(params),
    maximum
  });
  return ch;
}
function _minLength2(minimum, params) {
  return new $ZodCheckMinLength2({
    check: "min_length",
    ...normalizeParams2(params),
    minimum
  });
}
function _length2(length, params) {
  return new $ZodCheckLengthEquals2({
    check: "length_equals",
    ...normalizeParams2(params),
    length
  });
}
function _regex2(pattern, params) {
  return new $ZodCheckRegex2({
    check: "string_format",
    format: "regex",
    ...normalizeParams2(params),
    pattern
  });
}
function _lowercase2(params) {
  return new $ZodCheckLowerCase2({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams2(params)
  });
}
function _uppercase2(params) {
  return new $ZodCheckUpperCase2({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams2(params)
  });
}
function _includes2(includes, params) {
  return new $ZodCheckIncludes2({
    check: "string_format",
    format: "includes",
    ...normalizeParams2(params),
    includes
  });
}
function _startsWith2(prefix, params) {
  return new $ZodCheckStartsWith2({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams2(params),
    prefix
  });
}
function _endsWith2(suffix, params) {
  return new $ZodCheckEndsWith2({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams2(params),
    suffix
  });
}
function _overwrite2(tx) {
  return new $ZodCheckOverwrite2({
    check: "overwrite",
    tx
  });
}
function _normalize2(form) {
  return _overwrite2((input) => input.normalize(form));
}
function _trim2() {
  return _overwrite2((input) => input.trim());
}
function _toLowerCase2() {
  return _overwrite2((input) => input.toLowerCase());
}
function _toUpperCase2() {
  return _overwrite2((input) => input.toUpperCase());
}
function _array2(Class3, element, params) {
  return new Class3({
    type: "array",
    element,
    ...normalizeParams2(params)
  });
}
function _custom2(Class3, fn, _params) {
  const norm = normalizeParams2(_params);
  norm.abort ?? (norm.abort = true);
  const schema = new Class3({
    type: "custom",
    check: "custom",
    fn,
    ...norm
  });
  return schema;
}
function _refine2(Class3, fn, _params) {
  const schema = new Class3({
    type: "custom",
    check: "custom",
    fn,
    ...normalizeParams2(_params)
  });
  return schema;
}
var init_api2 = __esm(() => {
  init_checks3();
  init_util2();
});

// node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/core/function.js
var init_function = () => {};

// node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/core/to-json-schema.js
var init_to_json_schema2 = () => {};

// node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/core/json-schema.js
var init_json_schema2 = () => {};

// node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/core/index.js
var init_core4 = __esm(() => {
  init_util2();
  init_regexes2();
  init_locales2();
  init_json_schema2();
  init_core3();
  init_parse3();
  init_errors3();
  init_schemas3();
  init_checks3();
  init_versions2();
  init_registries2();
  init_function();
  init_api2();
  init_to_json_schema2();
});

// node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/mini/parse.js
var init_parse4 = __esm(() => {
  init_core4();
});

// node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/mini/schemas.js
var init_schemas4 = () => {};

// node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/mini/checks.js
var init_checks4 = () => {};

// node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/mini/iso.js
var init_iso2 = () => {};

// node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/mini/coerce.js
var init_coerce2 = () => {};

// node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/mini/external.js
var init_external2 = __esm(() => {
  init_core4();
  init_locales2();
  init_iso2();
  init_coerce2();
  init_parse4();
  init_schemas4();
  init_checks4();
});

// node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/mini/index.js
var init_mini = __esm(() => {
  init_external2();
});

// node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4-mini/index.js
var init_v4_mini = __esm(() => {
  init_mini();
});

// node_modules/@modelcontextprotocol/sdk/dist/esm/server/zod-compat.js
function isZ4Schema(s) {
  const schema = s;
  return !!schema._zod;
}
function safeParse4(schema, data) {
  if (isZ4Schema(schema)) {
    const result2 = safeParse3(schema, data);
    return result2;
  }
  const v3Schema = schema;
  const result = v3Schema.safeParse(data);
  return result;
}
function getObjectShape(schema) {
  if (!schema)
    return;
  let rawShape;
  if (isZ4Schema(schema)) {
    const v4Schema = schema;
    rawShape = v4Schema._zod?.def?.shape;
  } else {
    const v3Schema = schema;
    rawShape = v3Schema.shape;
  }
  if (!rawShape)
    return;
  if (typeof rawShape === "function") {
    try {
      return rawShape();
    } catch {
      return;
    }
  }
  return rawShape;
}
function getLiteralValue(schema) {
  if (isZ4Schema(schema)) {
    const v4Schema = schema;
    const def2 = v4Schema._zod?.def;
    if (def2) {
      if (def2.value !== undefined)
        return def2.value;
      if (Array.isArray(def2.values) && def2.values.length > 0) {
        return def2.values[0];
      }
    }
  }
  const v3Schema = schema;
  const def = v3Schema._def;
  if (def) {
    if (def.value !== undefined)
      return def.value;
    if (Array.isArray(def.values) && def.values.length > 0) {
      return def.values[0];
    }
  }
  const directValue = schema.value;
  if (directValue !== undefined)
    return directValue;
  return;
}
var init_zod_compat = __esm(() => {
  init_v4_mini();
});

// node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/classic/checks.js
var init_checks5 = __esm(() => {
  init_core4();
});

// node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/classic/iso.js
var exports_iso3 = {};
__export(exports_iso3, {
  time: () => time4,
  duration: () => duration4,
  datetime: () => datetime4,
  date: () => date6,
  ZodISOTime: () => ZodISOTime2,
  ZodISODuration: () => ZodISODuration2,
  ZodISODateTime: () => ZodISODateTime2,
  ZodISODate: () => ZodISODate2
});
function datetime4(params) {
  return _isoDateTime2(ZodISODateTime2, params);
}
function date6(params) {
  return _isoDate2(ZodISODate2, params);
}
function time4(params) {
  return _isoTime2(ZodISOTime2, params);
}
function duration4(params) {
  return _isoDuration2(ZodISODuration2, params);
}
var ZodISODateTime2, ZodISODate2, ZodISOTime2, ZodISODuration2;
var init_iso3 = __esm(() => {
  init_core4();
  init_schemas5();
  ZodISODateTime2 = /* @__PURE__ */ $constructor2("ZodISODateTime", (inst, def) => {
    $ZodISODateTime2.init(inst, def);
    ZodStringFormat2.init(inst, def);
  });
  ZodISODate2 = /* @__PURE__ */ $constructor2("ZodISODate", (inst, def) => {
    $ZodISODate2.init(inst, def);
    ZodStringFormat2.init(inst, def);
  });
  ZodISOTime2 = /* @__PURE__ */ $constructor2("ZodISOTime", (inst, def) => {
    $ZodISOTime2.init(inst, def);
    ZodStringFormat2.init(inst, def);
  });
  ZodISODuration2 = /* @__PURE__ */ $constructor2("ZodISODuration", (inst, def) => {
    $ZodISODuration2.init(inst, def);
    ZodStringFormat2.init(inst, def);
  });
});

// node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/classic/errors.js
var initializer4 = (inst, issues) => {
  $ZodError2.init(inst, issues);
  inst.name = "ZodError";
  Object.defineProperties(inst, {
    format: {
      value: (mapper) => formatError2(inst, mapper)
    },
    flatten: {
      value: (mapper) => flattenError2(inst, mapper)
    },
    addIssue: {
      value: (issue3) => inst.issues.push(issue3)
    },
    addIssues: {
      value: (issues2) => inst.issues.push(...issues2)
    },
    isEmpty: {
      get() {
        return inst.issues.length === 0;
      }
    }
  });
}, ZodError2, ZodRealError2;
var init_errors4 = __esm(() => {
  init_core4();
  init_core4();
  ZodError2 = $constructor2("ZodError", initializer4);
  ZodRealError2 = $constructor2("ZodError", initializer4, {
    Parent: Error
  });
});

// node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/classic/parse.js
var parse9, parseAsync4, safeParse5, safeParseAsync4;
var init_parse5 = __esm(() => {
  init_core4();
  init_errors4();
  parse9 = /* @__PURE__ */ _parse2(ZodRealError2);
  parseAsync4 = /* @__PURE__ */ _parseAsync2(ZodRealError2);
  safeParse5 = /* @__PURE__ */ _safeParse2(ZodRealError2);
  safeParseAsync4 = /* @__PURE__ */ _safeParseAsync2(ZodRealError2);
});

// node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/classic/schemas.js
function string5(params) {
  return _string2(ZodString2, params);
}
function number5(params) {
  return _number2(ZodNumber2, params);
}
function int2(params) {
  return _int2(ZodNumberFormat2, params);
}
function boolean5(params) {
  return _boolean2(ZodBoolean2, params);
}
function _null6(params) {
  return _null5(ZodNull2, params);
}
function unknown2() {
  return _unknown2(ZodUnknown2);
}
function never2(params) {
  return _never2(ZodNever2, params);
}
function array2(element, params) {
  return _array2(ZodArray2, element, params);
}
function object3(shape, params) {
  const def = {
    type: "object",
    get shape() {
      exports_util2.assignProp(this, "shape", { ...shape });
      return this.shape;
    },
    ...exports_util2.normalizeParams(params)
  };
  return new ZodObject2(def);
}
function looseObject2(shape, params) {
  return new ZodObject2({
    type: "object",
    get shape() {
      exports_util2.assignProp(this, "shape", { ...shape });
      return this.shape;
    },
    catchall: unknown2(),
    ...exports_util2.normalizeParams(params)
  });
}
function union2(options2, params) {
  return new ZodUnion2({
    type: "union",
    options: options2,
    ...exports_util2.normalizeParams(params)
  });
}
function discriminatedUnion2(discriminator, options2, params) {
  return new ZodDiscriminatedUnion2({
    type: "union",
    options: options2,
    discriminator,
    ...exports_util2.normalizeParams(params)
  });
}
function intersection2(left, right) {
  return new ZodIntersection2({
    type: "intersection",
    left,
    right
  });
}
function record2(keyType, valueType, params) {
  return new ZodRecord2({
    type: "record",
    keyType,
    valueType,
    ...exports_util2.normalizeParams(params)
  });
}
function _enum3(values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new ZodEnum2({
    type: "enum",
    entries,
    ...exports_util2.normalizeParams(params)
  });
}
function literal2(value, params) {
  return new ZodLiteral2({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...exports_util2.normalizeParams(params)
  });
}
function transform2(fn) {
  return new ZodTransform2({
    type: "transform",
    transform: fn
  });
}
function optional2(innerType) {
  return new ZodOptional2({
    type: "optional",
    innerType
  });
}
function nullable2(innerType) {
  return new ZodNullable2({
    type: "nullable",
    innerType
  });
}
function _default3(innerType, defaultValue) {
  return new ZodDefault2({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : defaultValue;
    }
  });
}
function prefault2(innerType, defaultValue) {
  return new ZodPrefault2({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : defaultValue;
    }
  });
}
function nonoptional2(innerType, params) {
  return new ZodNonOptional2({
    type: "nonoptional",
    innerType,
    ...exports_util2.normalizeParams(params)
  });
}
function _catch3(innerType, catchValue) {
  return new ZodCatch2({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
function pipe2(in_, out) {
  return new ZodPipe2({
    type: "pipe",
    in: in_,
    out
  });
}
function readonly2(innerType) {
  return new ZodReadonly2({
    type: "readonly",
    innerType
  });
}
function check2(fn) {
  const ch = new $ZodCheck2({
    check: "custom"
  });
  ch._zod.check = fn;
  return ch;
}
function custom2(fn, _params) {
  return _custom2(ZodCustom2, fn ?? (() => true), _params);
}
function refine2(fn, _params = {}) {
  return _refine2(ZodCustom2, fn, _params);
}
function superRefine2(fn) {
  const ch = check2((payload) => {
    payload.addIssue = (issue3) => {
      if (typeof issue3 === "string") {
        payload.issues.push(exports_util2.issue(issue3, payload.value, ch._zod.def));
      } else {
        const _issue = issue3;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = ch);
        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
        payload.issues.push(exports_util2.issue(_issue));
      }
    };
    return fn(payload.value, payload);
  });
  return ch;
}
function preprocess2(fn, schema) {
  return pipe2(transform2(fn), schema);
}
var ZodType2, _ZodString2, ZodString2, ZodStringFormat2, ZodEmail2, ZodGUID2, ZodUUID2, ZodURL2, ZodEmoji2, ZodNanoID2, ZodCUID3, ZodCUID22, ZodULID2, ZodXID2, ZodKSUID2, ZodIPv42, ZodIPv62, ZodCIDRv42, ZodCIDRv62, ZodBase642, ZodBase64URL2, ZodE1642, ZodJWT2, ZodNumber2, ZodNumberFormat2, ZodBoolean2, ZodNull2, ZodUnknown2, ZodNever2, ZodArray2, ZodObject2, ZodUnion2, ZodDiscriminatedUnion2, ZodIntersection2, ZodRecord2, ZodEnum2, ZodLiteral2, ZodTransform2, ZodOptional2, ZodNullable2, ZodDefault2, ZodPrefault2, ZodNonOptional2, ZodCatch2, ZodPipe2, ZodReadonly2, ZodCustom2;
var init_schemas5 = __esm(() => {
  init_core4();
  init_core4();
  init_checks5();
  init_iso3();
  init_parse5();
  ZodType2 = /* @__PURE__ */ $constructor2("ZodType", (inst, def) => {
    $ZodType2.init(inst, def);
    inst.def = def;
    Object.defineProperty(inst, "_def", { value: def });
    inst.check = (...checks5) => {
      return inst.clone({
        ...def,
        checks: [
          ...def.checks ?? [],
          ...checks5.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
        ]
      });
    };
    inst.clone = (def2, params) => clone2(inst, def2, params);
    inst.brand = () => inst;
    inst.register = (reg, meta3) => {
      reg.add(inst, meta3);
      return inst;
    };
    inst.parse = (data, params) => parse9(inst, data, params, { callee: inst.parse });
    inst.safeParse = (data, params) => safeParse5(inst, data, params);
    inst.parseAsync = async (data, params) => parseAsync4(inst, data, params, { callee: inst.parseAsync });
    inst.safeParseAsync = async (data, params) => safeParseAsync4(inst, data, params);
    inst.spa = inst.safeParseAsync;
    inst.refine = (check2, params) => inst.check(refine2(check2, params));
    inst.superRefine = (refinement) => inst.check(superRefine2(refinement));
    inst.overwrite = (fn) => inst.check(_overwrite2(fn));
    inst.optional = () => optional2(inst);
    inst.nullable = () => nullable2(inst);
    inst.nullish = () => optional2(nullable2(inst));
    inst.nonoptional = (params) => nonoptional2(inst, params);
    inst.array = () => array2(inst);
    inst.or = (arg) => union2([inst, arg]);
    inst.and = (arg) => intersection2(inst, arg);
    inst.transform = (tx) => pipe2(inst, transform2(tx));
    inst.default = (def2) => _default3(inst, def2);
    inst.prefault = (def2) => prefault2(inst, def2);
    inst.catch = (params) => _catch3(inst, params);
    inst.pipe = (target) => pipe2(inst, target);
    inst.readonly = () => readonly2(inst);
    inst.describe = (description) => {
      const cl = inst.clone();
      globalRegistry2.add(cl, { description });
      return cl;
    };
    Object.defineProperty(inst, "description", {
      get() {
        return globalRegistry2.get(inst)?.description;
      },
      configurable: true
    });
    inst.meta = (...args) => {
      if (args.length === 0) {
        return globalRegistry2.get(inst);
      }
      const cl = inst.clone();
      globalRegistry2.add(cl, args[0]);
      return cl;
    };
    inst.isOptional = () => inst.safeParse(undefined).success;
    inst.isNullable = () => inst.safeParse(null).success;
    return inst;
  });
  _ZodString2 = /* @__PURE__ */ $constructor2("_ZodString", (inst, def) => {
    $ZodString2.init(inst, def);
    ZodType2.init(inst, def);
    const bag = inst._zod.bag;
    inst.format = bag.format ?? null;
    inst.minLength = bag.minimum ?? null;
    inst.maxLength = bag.maximum ?? null;
    inst.regex = (...args) => inst.check(_regex2(...args));
    inst.includes = (...args) => inst.check(_includes2(...args));
    inst.startsWith = (...args) => inst.check(_startsWith2(...args));
    inst.endsWith = (...args) => inst.check(_endsWith2(...args));
    inst.min = (...args) => inst.check(_minLength2(...args));
    inst.max = (...args) => inst.check(_maxLength2(...args));
    inst.length = (...args) => inst.check(_length2(...args));
    inst.nonempty = (...args) => inst.check(_minLength2(1, ...args));
    inst.lowercase = (params) => inst.check(_lowercase2(params));
    inst.uppercase = (params) => inst.check(_uppercase2(params));
    inst.trim = () => inst.check(_trim2());
    inst.normalize = (...args) => inst.check(_normalize2(...args));
    inst.toLowerCase = () => inst.check(_toLowerCase2());
    inst.toUpperCase = () => inst.check(_toUpperCase2());
  });
  ZodString2 = /* @__PURE__ */ $constructor2("ZodString", (inst, def) => {
    $ZodString2.init(inst, def);
    _ZodString2.init(inst, def);
    inst.email = (params) => inst.check(_email2(ZodEmail2, params));
    inst.url = (params) => inst.check(_url2(ZodURL2, params));
    inst.jwt = (params) => inst.check(_jwt2(ZodJWT2, params));
    inst.emoji = (params) => inst.check(_emoji4(ZodEmoji2, params));
    inst.guid = (params) => inst.check(_guid2(ZodGUID2, params));
    inst.uuid = (params) => inst.check(_uuid2(ZodUUID2, params));
    inst.uuidv4 = (params) => inst.check(_uuidv42(ZodUUID2, params));
    inst.uuidv6 = (params) => inst.check(_uuidv62(ZodUUID2, params));
    inst.uuidv7 = (params) => inst.check(_uuidv72(ZodUUID2, params));
    inst.nanoid = (params) => inst.check(_nanoid2(ZodNanoID2, params));
    inst.guid = (params) => inst.check(_guid2(ZodGUID2, params));
    inst.cuid = (params) => inst.check(_cuid3(ZodCUID3, params));
    inst.cuid2 = (params) => inst.check(_cuid22(ZodCUID22, params));
    inst.ulid = (params) => inst.check(_ulid2(ZodULID2, params));
    inst.base64 = (params) => inst.check(_base642(ZodBase642, params));
    inst.base64url = (params) => inst.check(_base64url2(ZodBase64URL2, params));
    inst.xid = (params) => inst.check(_xid2(ZodXID2, params));
    inst.ksuid = (params) => inst.check(_ksuid2(ZodKSUID2, params));
    inst.ipv4 = (params) => inst.check(_ipv42(ZodIPv42, params));
    inst.ipv6 = (params) => inst.check(_ipv62(ZodIPv62, params));
    inst.cidrv4 = (params) => inst.check(_cidrv42(ZodCIDRv42, params));
    inst.cidrv6 = (params) => inst.check(_cidrv62(ZodCIDRv62, params));
    inst.e164 = (params) => inst.check(_e1642(ZodE1642, params));
    inst.datetime = (params) => inst.check(datetime4(params));
    inst.date = (params) => inst.check(date6(params));
    inst.time = (params) => inst.check(time4(params));
    inst.duration = (params) => inst.check(duration4(params));
  });
  ZodStringFormat2 = /* @__PURE__ */ $constructor2("ZodStringFormat", (inst, def) => {
    $ZodStringFormat2.init(inst, def);
    _ZodString2.init(inst, def);
  });
  ZodEmail2 = /* @__PURE__ */ $constructor2("ZodEmail", (inst, def) => {
    $ZodEmail2.init(inst, def);
    ZodStringFormat2.init(inst, def);
  });
  ZodGUID2 = /* @__PURE__ */ $constructor2("ZodGUID", (inst, def) => {
    $ZodGUID2.init(inst, def);
    ZodStringFormat2.init(inst, def);
  });
  ZodUUID2 = /* @__PURE__ */ $constructor2("ZodUUID", (inst, def) => {
    $ZodUUID2.init(inst, def);
    ZodStringFormat2.init(inst, def);
  });
  ZodURL2 = /* @__PURE__ */ $constructor2("ZodURL", (inst, def) => {
    $ZodURL2.init(inst, def);
    ZodStringFormat2.init(inst, def);
  });
  ZodEmoji2 = /* @__PURE__ */ $constructor2("ZodEmoji", (inst, def) => {
    $ZodEmoji2.init(inst, def);
    ZodStringFormat2.init(inst, def);
  });
  ZodNanoID2 = /* @__PURE__ */ $constructor2("ZodNanoID", (inst, def) => {
    $ZodNanoID2.init(inst, def);
    ZodStringFormat2.init(inst, def);
  });
  ZodCUID3 = /* @__PURE__ */ $constructor2("ZodCUID", (inst, def) => {
    $ZodCUID3.init(inst, def);
    ZodStringFormat2.init(inst, def);
  });
  ZodCUID22 = /* @__PURE__ */ $constructor2("ZodCUID2", (inst, def) => {
    $ZodCUID22.init(inst, def);
    ZodStringFormat2.init(inst, def);
  });
  ZodULID2 = /* @__PURE__ */ $constructor2("ZodULID", (inst, def) => {
    $ZodULID2.init(inst, def);
    ZodStringFormat2.init(inst, def);
  });
  ZodXID2 = /* @__PURE__ */ $constructor2("ZodXID", (inst, def) => {
    $ZodXID2.init(inst, def);
    ZodStringFormat2.init(inst, def);
  });
  ZodKSUID2 = /* @__PURE__ */ $constructor2("ZodKSUID", (inst, def) => {
    $ZodKSUID2.init(inst, def);
    ZodStringFormat2.init(inst, def);
  });
  ZodIPv42 = /* @__PURE__ */ $constructor2("ZodIPv4", (inst, def) => {
    $ZodIPv42.init(inst, def);
    ZodStringFormat2.init(inst, def);
  });
  ZodIPv62 = /* @__PURE__ */ $constructor2("ZodIPv6", (inst, def) => {
    $ZodIPv62.init(inst, def);
    ZodStringFormat2.init(inst, def);
  });
  ZodCIDRv42 = /* @__PURE__ */ $constructor2("ZodCIDRv4", (inst, def) => {
    $ZodCIDRv42.init(inst, def);
    ZodStringFormat2.init(inst, def);
  });
  ZodCIDRv62 = /* @__PURE__ */ $constructor2("ZodCIDRv6", (inst, def) => {
    $ZodCIDRv62.init(inst, def);
    ZodStringFormat2.init(inst, def);
  });
  ZodBase642 = /* @__PURE__ */ $constructor2("ZodBase64", (inst, def) => {
    $ZodBase642.init(inst, def);
    ZodStringFormat2.init(inst, def);
  });
  ZodBase64URL2 = /* @__PURE__ */ $constructor2("ZodBase64URL", (inst, def) => {
    $ZodBase64URL2.init(inst, def);
    ZodStringFormat2.init(inst, def);
  });
  ZodE1642 = /* @__PURE__ */ $constructor2("ZodE164", (inst, def) => {
    $ZodE1642.init(inst, def);
    ZodStringFormat2.init(inst, def);
  });
  ZodJWT2 = /* @__PURE__ */ $constructor2("ZodJWT", (inst, def) => {
    $ZodJWT2.init(inst, def);
    ZodStringFormat2.init(inst, def);
  });
  ZodNumber2 = /* @__PURE__ */ $constructor2("ZodNumber", (inst, def) => {
    $ZodNumber2.init(inst, def);
    ZodType2.init(inst, def);
    inst.gt = (value, params) => inst.check(_gt2(value, params));
    inst.gte = (value, params) => inst.check(_gte2(value, params));
    inst.min = (value, params) => inst.check(_gte2(value, params));
    inst.lt = (value, params) => inst.check(_lt2(value, params));
    inst.lte = (value, params) => inst.check(_lte2(value, params));
    inst.max = (value, params) => inst.check(_lte2(value, params));
    inst.int = (params) => inst.check(int2(params));
    inst.safe = (params) => inst.check(int2(params));
    inst.positive = (params) => inst.check(_gt2(0, params));
    inst.nonnegative = (params) => inst.check(_gte2(0, params));
    inst.negative = (params) => inst.check(_lt2(0, params));
    inst.nonpositive = (params) => inst.check(_lte2(0, params));
    inst.multipleOf = (value, params) => inst.check(_multipleOf2(value, params));
    inst.step = (value, params) => inst.check(_multipleOf2(value, params));
    inst.finite = () => inst;
    const bag = inst._zod.bag;
    inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
    inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
    inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
    inst.isFinite = true;
    inst.format = bag.format ?? null;
  });
  ZodNumberFormat2 = /* @__PURE__ */ $constructor2("ZodNumberFormat", (inst, def) => {
    $ZodNumberFormat2.init(inst, def);
    ZodNumber2.init(inst, def);
  });
  ZodBoolean2 = /* @__PURE__ */ $constructor2("ZodBoolean", (inst, def) => {
    $ZodBoolean2.init(inst, def);
    ZodType2.init(inst, def);
  });
  ZodNull2 = /* @__PURE__ */ $constructor2("ZodNull", (inst, def) => {
    $ZodNull2.init(inst, def);
    ZodType2.init(inst, def);
  });
  ZodUnknown2 = /* @__PURE__ */ $constructor2("ZodUnknown", (inst, def) => {
    $ZodUnknown2.init(inst, def);
    ZodType2.init(inst, def);
  });
  ZodNever2 = /* @__PURE__ */ $constructor2("ZodNever", (inst, def) => {
    $ZodNever2.init(inst, def);
    ZodType2.init(inst, def);
  });
  ZodArray2 = /* @__PURE__ */ $constructor2("ZodArray", (inst, def) => {
    $ZodArray2.init(inst, def);
    ZodType2.init(inst, def);
    inst.element = def.element;
    inst.min = (minLength, params) => inst.check(_minLength2(minLength, params));
    inst.nonempty = (params) => inst.check(_minLength2(1, params));
    inst.max = (maxLength, params) => inst.check(_maxLength2(maxLength, params));
    inst.length = (len, params) => inst.check(_length2(len, params));
    inst.unwrap = () => inst.element;
  });
  ZodObject2 = /* @__PURE__ */ $constructor2("ZodObject", (inst, def) => {
    $ZodObject2.init(inst, def);
    ZodType2.init(inst, def);
    exports_util2.defineLazy(inst, "shape", () => def.shape);
    inst.keyof = () => _enum3(Object.keys(inst._zod.def.shape));
    inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });
    inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown2() });
    inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown2() });
    inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never2() });
    inst.strip = () => inst.clone({ ...inst._zod.def, catchall: undefined });
    inst.extend = (incoming) => {
      return exports_util2.extend(inst, incoming);
    };
    inst.merge = (other) => exports_util2.merge(inst, other);
    inst.pick = (mask) => exports_util2.pick(inst, mask);
    inst.omit = (mask) => exports_util2.omit(inst, mask);
    inst.partial = (...args) => exports_util2.partial(ZodOptional2, inst, args[0]);
    inst.required = (...args) => exports_util2.required(ZodNonOptional2, inst, args[0]);
  });
  ZodUnion2 = /* @__PURE__ */ $constructor2("ZodUnion", (inst, def) => {
    $ZodUnion2.init(inst, def);
    ZodType2.init(inst, def);
    inst.options = def.options;
  });
  ZodDiscriminatedUnion2 = /* @__PURE__ */ $constructor2("ZodDiscriminatedUnion", (inst, def) => {
    ZodUnion2.init(inst, def);
    $ZodDiscriminatedUnion2.init(inst, def);
  });
  ZodIntersection2 = /* @__PURE__ */ $constructor2("ZodIntersection", (inst, def) => {
    $ZodIntersection2.init(inst, def);
    ZodType2.init(inst, def);
  });
  ZodRecord2 = /* @__PURE__ */ $constructor2("ZodRecord", (inst, def) => {
    $ZodRecord2.init(inst, def);
    ZodType2.init(inst, def);
    inst.keyType = def.keyType;
    inst.valueType = def.valueType;
  });
  ZodEnum2 = /* @__PURE__ */ $constructor2("ZodEnum", (inst, def) => {
    $ZodEnum2.init(inst, def);
    ZodType2.init(inst, def);
    inst.enum = def.entries;
    inst.options = Object.values(def.entries);
    const keys = new Set(Object.keys(def.entries));
    inst.extract = (values, params) => {
      const newEntries = {};
      for (const value of values) {
        if (keys.has(value)) {
          newEntries[value] = def.entries[value];
        } else
          throw new Error(`Key ${value} not found in enum`);
      }
      return new ZodEnum2({
        ...def,
        checks: [],
        ...exports_util2.normalizeParams(params),
        entries: newEntries
      });
    };
    inst.exclude = (values, params) => {
      const newEntries = { ...def.entries };
      for (const value of values) {
        if (keys.has(value)) {
          delete newEntries[value];
        } else
          throw new Error(`Key ${value} not found in enum`);
      }
      return new ZodEnum2({
        ...def,
        checks: [],
        ...exports_util2.normalizeParams(params),
        entries: newEntries
      });
    };
  });
  ZodLiteral2 = /* @__PURE__ */ $constructor2("ZodLiteral", (inst, def) => {
    $ZodLiteral2.init(inst, def);
    ZodType2.init(inst, def);
    inst.values = new Set(def.values);
    Object.defineProperty(inst, "value", {
      get() {
        if (def.values.length > 1) {
          throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
        }
        return def.values[0];
      }
    });
  });
  ZodTransform2 = /* @__PURE__ */ $constructor2("ZodTransform", (inst, def) => {
    $ZodTransform2.init(inst, def);
    ZodType2.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
      payload.addIssue = (issue3) => {
        if (typeof issue3 === "string") {
          payload.issues.push(exports_util2.issue(issue3, payload.value, def));
        } else {
          const _issue = issue3;
          if (_issue.fatal)
            _issue.continue = false;
          _issue.code ?? (_issue.code = "custom");
          _issue.input ?? (_issue.input = payload.value);
          _issue.inst ?? (_issue.inst = inst);
          _issue.continue ?? (_issue.continue = true);
          payload.issues.push(exports_util2.issue(_issue));
        }
      };
      const output = def.transform(payload.value, payload);
      if (output instanceof Promise) {
        return output.then((output2) => {
          payload.value = output2;
          return payload;
        });
      }
      payload.value = output;
      return payload;
    };
  });
  ZodOptional2 = /* @__PURE__ */ $constructor2("ZodOptional", (inst, def) => {
    $ZodOptional2.init(inst, def);
    ZodType2.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
  });
  ZodNullable2 = /* @__PURE__ */ $constructor2("ZodNullable", (inst, def) => {
    $ZodNullable2.init(inst, def);
    ZodType2.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
  });
  ZodDefault2 = /* @__PURE__ */ $constructor2("ZodDefault", (inst, def) => {
    $ZodDefault2.init(inst, def);
    ZodType2.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
    inst.removeDefault = inst.unwrap;
  });
  ZodPrefault2 = /* @__PURE__ */ $constructor2("ZodPrefault", (inst, def) => {
    $ZodPrefault2.init(inst, def);
    ZodType2.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
  });
  ZodNonOptional2 = /* @__PURE__ */ $constructor2("ZodNonOptional", (inst, def) => {
    $ZodNonOptional2.init(inst, def);
    ZodType2.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
  });
  ZodCatch2 = /* @__PURE__ */ $constructor2("ZodCatch", (inst, def) => {
    $ZodCatch2.init(inst, def);
    ZodType2.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
    inst.removeCatch = inst.unwrap;
  });
  ZodPipe2 = /* @__PURE__ */ $constructor2("ZodPipe", (inst, def) => {
    $ZodPipe2.init(inst, def);
    ZodType2.init(inst, def);
    inst.in = def.in;
    inst.out = def.out;
  });
  ZodReadonly2 = /* @__PURE__ */ $constructor2("ZodReadonly", (inst, def) => {
    $ZodReadonly2.init(inst, def);
    ZodType2.init(inst, def);
  });
  ZodCustom2 = /* @__PURE__ */ $constructor2("ZodCustom", (inst, def) => {
    $ZodCustom2.init(inst, def);
    ZodType2.init(inst, def);
  });
});

// node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/classic/compat.js
var init_compat2 = () => {};

// node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/classic/coerce.js
var init_coerce3 = () => {};

// node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/classic/external.js
var init_external3 = __esm(() => {
  init_core4();
  init_core4();
  init_en2();
  init_locales2();
  init_iso3();
  init_coerce3();
  init_schemas5();
  init_checks5();
  init_errors4();
  init_parse5();
  init_compat2();
  config2(en_default2());
});

// node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/classic/index.js
var init_classic = __esm(() => {
  init_external3();
});

// node_modules/@modelcontextprotocol/sdk/node_modules/zod/v4/index.js
var init_v4 = __esm(() => {
  init_classic();
});

// node_modules/@modelcontextprotocol/sdk/dist/esm/types.js
var LATEST_PROTOCOL_VERSION = "2025-11-25", SUPPORTED_PROTOCOL_VERSIONS, RELATED_TASK_META_KEY = "io.modelcontextprotocol/related-task", JSONRPC_VERSION = "2.0", AssertObjectSchema, ProgressTokenSchema, CursorSchema, TaskCreationParamsSchema, TaskMetadataSchema, RelatedTaskMetadataSchema, RequestMetaSchema, BaseRequestParamsSchema, TaskAugmentedRequestParamsSchema, isTaskAugmentedRequestParams = (value) => TaskAugmentedRequestParamsSchema.safeParse(value).success, RequestSchema, NotificationsParamsSchema, NotificationSchema, ResultSchema, RequestIdSchema, JSONRPCRequestSchema, isJSONRPCRequest = (value) => JSONRPCRequestSchema.safeParse(value).success, JSONRPCNotificationSchema, isJSONRPCNotification = (value) => JSONRPCNotificationSchema.safeParse(value).success, JSONRPCResultResponseSchema, isJSONRPCResultResponse = (value) => JSONRPCResultResponseSchema.safeParse(value).success, ErrorCode, JSONRPCErrorResponseSchema, isJSONRPCErrorResponse = (value) => JSONRPCErrorResponseSchema.safeParse(value).success, JSONRPCMessageSchema, JSONRPCResponseSchema, EmptyResultSchema, CancelledNotificationParamsSchema, CancelledNotificationSchema, IconSchema, IconsSchema, BaseMetadataSchema, ImplementationSchema, FormElicitationCapabilitySchema, ElicitationCapabilitySchema, ClientTasksCapabilitySchema, ServerTasksCapabilitySchema, ClientCapabilitiesSchema, InitializeRequestParamsSchema, InitializeRequestSchema, ServerCapabilitiesSchema, InitializeResultSchema, InitializedNotificationSchema, PingRequestSchema, ProgressSchema, ProgressNotificationParamsSchema, ProgressNotificationSchema, PaginatedRequestParamsSchema, PaginatedRequestSchema, PaginatedResultSchema, TaskStatusSchema, TaskSchema, CreateTaskResultSchema, TaskStatusNotificationParamsSchema, TaskStatusNotificationSchema, GetTaskRequestSchema, GetTaskResultSchema, GetTaskPayloadRequestSchema, GetTaskPayloadResultSchema, ListTasksRequestSchema, ListTasksResultSchema, CancelTaskRequestSchema, CancelTaskResultSchema, ResourceContentsSchema, TextResourceContentsSchema, Base64Schema, BlobResourceContentsSchema, RoleSchema, AnnotationsSchema, ResourceSchema, ResourceTemplateSchema, ListResourcesRequestSchema, ListResourcesResultSchema, ListResourceTemplatesRequestSchema, ListResourceTemplatesResultSchema, ResourceRequestParamsSchema, ReadResourceRequestParamsSchema, ReadResourceRequestSchema, ReadResourceResultSchema, ResourceListChangedNotificationSchema, SubscribeRequestParamsSchema, SubscribeRequestSchema, UnsubscribeRequestParamsSchema, UnsubscribeRequestSchema, ResourceUpdatedNotificationParamsSchema, ResourceUpdatedNotificationSchema, PromptArgumentSchema, PromptSchema, ListPromptsRequestSchema, ListPromptsResultSchema, GetPromptRequestParamsSchema, GetPromptRequestSchema, TextContentSchema, ImageContentSchema, AudioContentSchema, ToolUseContentSchema, EmbeddedResourceSchema, ResourceLinkSchema, ContentBlockSchema, PromptMessageSchema, GetPromptResultSchema, PromptListChangedNotificationSchema, ToolAnnotationsSchema, ToolExecutionSchema, ToolSchema, ListToolsRequestSchema, ListToolsResultSchema, CallToolResultSchema, CompatibilityCallToolResultSchema, CallToolRequestParamsSchema, CallToolRequestSchema, ToolListChangedNotificationSchema, ListChangedOptionsBaseSchema, LoggingLevelSchema, SetLevelRequestParamsSchema, SetLevelRequestSchema, LoggingMessageNotificationParamsSchema, LoggingMessageNotificationSchema, ModelHintSchema, ModelPreferencesSchema, ToolChoiceSchema, ToolResultContentSchema, SamplingContentSchema, SamplingMessageContentBlockSchema, SamplingMessageSchema, CreateMessageRequestParamsSchema, CreateMessageRequestSchema, CreateMessageResultSchema, CreateMessageResultWithToolsSchema, BooleanSchemaSchema, StringSchemaSchema, NumberSchemaSchema, UntitledSingleSelectEnumSchemaSchema, TitledSingleSelectEnumSchemaSchema, LegacyTitledEnumSchemaSchema, SingleSelectEnumSchemaSchema, UntitledMultiSelectEnumSchemaSchema, TitledMultiSelectEnumSchemaSchema, MultiSelectEnumSchemaSchema, EnumSchemaSchema, PrimitiveSchemaDefinitionSchema, ElicitRequestFormParamsSchema, ElicitRequestURLParamsSchema, ElicitRequestParamsSchema, ElicitRequestSchema, ElicitationCompleteNotificationParamsSchema, ElicitationCompleteNotificationSchema, ElicitResultSchema, ResourceTemplateReferenceSchema, PromptReferenceSchema, CompleteRequestParamsSchema, CompleteRequestSchema, CompleteResultSchema, RootSchema, ListRootsRequestSchema, ListRootsResultSchema, RootsListChangedNotificationSchema, ClientRequestSchema, ClientNotificationSchema, ClientResultSchema, ServerRequestSchema, ServerNotificationSchema, ServerResultSchema, McpError, UrlElicitationRequiredError;
var init_types = __esm(() => {
  init_v4();
  SUPPORTED_PROTOCOL_VERSIONS = [LATEST_PROTOCOL_VERSION, "2025-06-18", "2025-03-26", "2024-11-05", "2024-10-07"];
  AssertObjectSchema = custom2((v) => v !== null && (typeof v === "object" || typeof v === "function"));
  ProgressTokenSchema = union2([string5(), number5().int()]);
  CursorSchema = string5();
  TaskCreationParamsSchema = looseObject2({
    ttl: union2([number5(), _null6()]).optional(),
    pollInterval: number5().optional()
  });
  TaskMetadataSchema = object3({
    ttl: number5().optional()
  });
  RelatedTaskMetadataSchema = object3({
    taskId: string5()
  });
  RequestMetaSchema = looseObject2({
    progressToken: ProgressTokenSchema.optional(),
    [RELATED_TASK_META_KEY]: RelatedTaskMetadataSchema.optional()
  });
  BaseRequestParamsSchema = object3({
    _meta: RequestMetaSchema.optional()
  });
  TaskAugmentedRequestParamsSchema = BaseRequestParamsSchema.extend({
    task: TaskMetadataSchema.optional()
  });
  RequestSchema = object3({
    method: string5(),
    params: BaseRequestParamsSchema.loose().optional()
  });
  NotificationsParamsSchema = object3({
    _meta: RequestMetaSchema.optional()
  });
  NotificationSchema = object3({
    method: string5(),
    params: NotificationsParamsSchema.loose().optional()
  });
  ResultSchema = looseObject2({
    _meta: RequestMetaSchema.optional()
  });
  RequestIdSchema = union2([string5(), number5().int()]);
  JSONRPCRequestSchema = object3({
    jsonrpc: literal2(JSONRPC_VERSION),
    id: RequestIdSchema,
    ...RequestSchema.shape
  }).strict();
  JSONRPCNotificationSchema = object3({
    jsonrpc: literal2(JSONRPC_VERSION),
    ...NotificationSchema.shape
  }).strict();
  JSONRPCResultResponseSchema = object3({
    jsonrpc: literal2(JSONRPC_VERSION),
    id: RequestIdSchema,
    result: ResultSchema
  }).strict();
  (function(ErrorCode2) {
    ErrorCode2[ErrorCode2["ConnectionClosed"] = -32000] = "ConnectionClosed";
    ErrorCode2[ErrorCode2["RequestTimeout"] = -32001] = "RequestTimeout";
    ErrorCode2[ErrorCode2["ParseError"] = -32700] = "ParseError";
    ErrorCode2[ErrorCode2["InvalidRequest"] = -32600] = "InvalidRequest";
    ErrorCode2[ErrorCode2["MethodNotFound"] = -32601] = "MethodNotFound";
    ErrorCode2[ErrorCode2["InvalidParams"] = -32602] = "InvalidParams";
    ErrorCode2[ErrorCode2["InternalError"] = -32603] = "InternalError";
    ErrorCode2[ErrorCode2["UrlElicitationRequired"] = -32042] = "UrlElicitationRequired";
  })(ErrorCode || (ErrorCode = {}));
  JSONRPCErrorResponseSchema = object3({
    jsonrpc: literal2(JSONRPC_VERSION),
    id: RequestIdSchema.optional(),
    error: object3({
      code: number5().int(),
      message: string5(),
      data: unknown2().optional()
    })
  }).strict();
  JSONRPCMessageSchema = union2([
    JSONRPCRequestSchema,
    JSONRPCNotificationSchema,
    JSONRPCResultResponseSchema,
    JSONRPCErrorResponseSchema
  ]);
  JSONRPCResponseSchema = union2([JSONRPCResultResponseSchema, JSONRPCErrorResponseSchema]);
  EmptyResultSchema = ResultSchema.strict();
  CancelledNotificationParamsSchema = NotificationsParamsSchema.extend({
    requestId: RequestIdSchema.optional(),
    reason: string5().optional()
  });
  CancelledNotificationSchema = NotificationSchema.extend({
    method: literal2("notifications/cancelled"),
    params: CancelledNotificationParamsSchema
  });
  IconSchema = object3({
    src: string5(),
    mimeType: string5().optional(),
    sizes: array2(string5()).optional(),
    theme: _enum3(["light", "dark"]).optional()
  });
  IconsSchema = object3({
    icons: array2(IconSchema).optional()
  });
  BaseMetadataSchema = object3({
    name: string5(),
    title: string5().optional()
  });
  ImplementationSchema = BaseMetadataSchema.extend({
    ...BaseMetadataSchema.shape,
    ...IconsSchema.shape,
    version: string5(),
    websiteUrl: string5().optional(),
    description: string5().optional()
  });
  FormElicitationCapabilitySchema = intersection2(object3({
    applyDefaults: boolean5().optional()
  }), record2(string5(), unknown2()));
  ElicitationCapabilitySchema = preprocess2((value) => {
    if (value && typeof value === "object" && !Array.isArray(value)) {
      if (Object.keys(value).length === 0) {
        return { form: {} };
      }
    }
    return value;
  }, intersection2(object3({
    form: FormElicitationCapabilitySchema.optional(),
    url: AssertObjectSchema.optional()
  }), record2(string5(), unknown2()).optional()));
  ClientTasksCapabilitySchema = looseObject2({
    list: AssertObjectSchema.optional(),
    cancel: AssertObjectSchema.optional(),
    requests: looseObject2({
      sampling: looseObject2({
        createMessage: AssertObjectSchema.optional()
      }).optional(),
      elicitation: looseObject2({
        create: AssertObjectSchema.optional()
      }).optional()
    }).optional()
  });
  ServerTasksCapabilitySchema = looseObject2({
    list: AssertObjectSchema.optional(),
    cancel: AssertObjectSchema.optional(),
    requests: looseObject2({
      tools: looseObject2({
        call: AssertObjectSchema.optional()
      }).optional()
    }).optional()
  });
  ClientCapabilitiesSchema = object3({
    experimental: record2(string5(), AssertObjectSchema).optional(),
    sampling: object3({
      context: AssertObjectSchema.optional(),
      tools: AssertObjectSchema.optional()
    }).optional(),
    elicitation: ElicitationCapabilitySchema.optional(),
    roots: object3({
      listChanged: boolean5().optional()
    }).optional(),
    tasks: ClientTasksCapabilitySchema.optional()
  });
  InitializeRequestParamsSchema = BaseRequestParamsSchema.extend({
    protocolVersion: string5(),
    capabilities: ClientCapabilitiesSchema,
    clientInfo: ImplementationSchema
  });
  InitializeRequestSchema = RequestSchema.extend({
    method: literal2("initialize"),
    params: InitializeRequestParamsSchema
  });
  ServerCapabilitiesSchema = object3({
    experimental: record2(string5(), AssertObjectSchema).optional(),
    logging: AssertObjectSchema.optional(),
    completions: AssertObjectSchema.optional(),
    prompts: object3({
      listChanged: boolean5().optional()
    }).optional(),
    resources: object3({
      subscribe: boolean5().optional(),
      listChanged: boolean5().optional()
    }).optional(),
    tools: object3({
      listChanged: boolean5().optional()
    }).optional(),
    tasks: ServerTasksCapabilitySchema.optional()
  });
  InitializeResultSchema = ResultSchema.extend({
    protocolVersion: string5(),
    capabilities: ServerCapabilitiesSchema,
    serverInfo: ImplementationSchema,
    instructions: string5().optional()
  });
  InitializedNotificationSchema = NotificationSchema.extend({
    method: literal2("notifications/initialized"),
    params: NotificationsParamsSchema.optional()
  });
  PingRequestSchema = RequestSchema.extend({
    method: literal2("ping"),
    params: BaseRequestParamsSchema.optional()
  });
  ProgressSchema = object3({
    progress: number5(),
    total: optional2(number5()),
    message: optional2(string5())
  });
  ProgressNotificationParamsSchema = object3({
    ...NotificationsParamsSchema.shape,
    ...ProgressSchema.shape,
    progressToken: ProgressTokenSchema
  });
  ProgressNotificationSchema = NotificationSchema.extend({
    method: literal2("notifications/progress"),
    params: ProgressNotificationParamsSchema
  });
  PaginatedRequestParamsSchema = BaseRequestParamsSchema.extend({
    cursor: CursorSchema.optional()
  });
  PaginatedRequestSchema = RequestSchema.extend({
    params: PaginatedRequestParamsSchema.optional()
  });
  PaginatedResultSchema = ResultSchema.extend({
    nextCursor: CursorSchema.optional()
  });
  TaskStatusSchema = _enum3(["working", "input_required", "completed", "failed", "cancelled"]);
  TaskSchema = object3({
    taskId: string5(),
    status: TaskStatusSchema,
    ttl: union2([number5(), _null6()]),
    createdAt: string5(),
    lastUpdatedAt: string5(),
    pollInterval: optional2(number5()),
    statusMessage: optional2(string5())
  });
  CreateTaskResultSchema = ResultSchema.extend({
    task: TaskSchema
  });
  TaskStatusNotificationParamsSchema = NotificationsParamsSchema.merge(TaskSchema);
  TaskStatusNotificationSchema = NotificationSchema.extend({
    method: literal2("notifications/tasks/status"),
    params: TaskStatusNotificationParamsSchema
  });
  GetTaskRequestSchema = RequestSchema.extend({
    method: literal2("tasks/get"),
    params: BaseRequestParamsSchema.extend({
      taskId: string5()
    })
  });
  GetTaskResultSchema = ResultSchema.merge(TaskSchema);
  GetTaskPayloadRequestSchema = RequestSchema.extend({
    method: literal2("tasks/result"),
    params: BaseRequestParamsSchema.extend({
      taskId: string5()
    })
  });
  GetTaskPayloadResultSchema = ResultSchema.loose();
  ListTasksRequestSchema = PaginatedRequestSchema.extend({
    method: literal2("tasks/list")
  });
  ListTasksResultSchema = PaginatedResultSchema.extend({
    tasks: array2(TaskSchema)
  });
  CancelTaskRequestSchema = RequestSchema.extend({
    method: literal2("tasks/cancel"),
    params: BaseRequestParamsSchema.extend({
      taskId: string5()
    })
  });
  CancelTaskResultSchema = ResultSchema.merge(TaskSchema);
  ResourceContentsSchema = object3({
    uri: string5(),
    mimeType: optional2(string5()),
    _meta: record2(string5(), unknown2()).optional()
  });
  TextResourceContentsSchema = ResourceContentsSchema.extend({
    text: string5()
  });
  Base64Schema = string5().refine((val) => {
    try {
      atob(val);
      return true;
    } catch {
      return false;
    }
  }, { message: "Invalid Base64 string" });
  BlobResourceContentsSchema = ResourceContentsSchema.extend({
    blob: Base64Schema
  });
  RoleSchema = _enum3(["user", "assistant"]);
  AnnotationsSchema = object3({
    audience: array2(RoleSchema).optional(),
    priority: number5().min(0).max(1).optional(),
    lastModified: exports_iso3.datetime({ offset: true }).optional()
  });
  ResourceSchema = object3({
    ...BaseMetadataSchema.shape,
    ...IconsSchema.shape,
    uri: string5(),
    description: optional2(string5()),
    mimeType: optional2(string5()),
    annotations: AnnotationsSchema.optional(),
    _meta: optional2(looseObject2({}))
  });
  ResourceTemplateSchema = object3({
    ...BaseMetadataSchema.shape,
    ...IconsSchema.shape,
    uriTemplate: string5(),
    description: optional2(string5()),
    mimeType: optional2(string5()),
    annotations: AnnotationsSchema.optional(),
    _meta: optional2(looseObject2({}))
  });
  ListResourcesRequestSchema = PaginatedRequestSchema.extend({
    method: literal2("resources/list")
  });
  ListResourcesResultSchema = PaginatedResultSchema.extend({
    resources: array2(ResourceSchema)
  });
  ListResourceTemplatesRequestSchema = PaginatedRequestSchema.extend({
    method: literal2("resources/templates/list")
  });
  ListResourceTemplatesResultSchema = PaginatedResultSchema.extend({
    resourceTemplates: array2(ResourceTemplateSchema)
  });
  ResourceRequestParamsSchema = BaseRequestParamsSchema.extend({
    uri: string5()
  });
  ReadResourceRequestParamsSchema = ResourceRequestParamsSchema;
  ReadResourceRequestSchema = RequestSchema.extend({
    method: literal2("resources/read"),
    params: ReadResourceRequestParamsSchema
  });
  ReadResourceResultSchema = ResultSchema.extend({
    contents: array2(union2([TextResourceContentsSchema, BlobResourceContentsSchema]))
  });
  ResourceListChangedNotificationSchema = NotificationSchema.extend({
    method: literal2("notifications/resources/list_changed"),
    params: NotificationsParamsSchema.optional()
  });
  SubscribeRequestParamsSchema = ResourceRequestParamsSchema;
  SubscribeRequestSchema = RequestSchema.extend({
    method: literal2("resources/subscribe"),
    params: SubscribeRequestParamsSchema
  });
  UnsubscribeRequestParamsSchema = ResourceRequestParamsSchema;
  UnsubscribeRequestSchema = RequestSchema.extend({
    method: literal2("resources/unsubscribe"),
    params: UnsubscribeRequestParamsSchema
  });
  ResourceUpdatedNotificationParamsSchema = NotificationsParamsSchema.extend({
    uri: string5()
  });
  ResourceUpdatedNotificationSchema = NotificationSchema.extend({
    method: literal2("notifications/resources/updated"),
    params: ResourceUpdatedNotificationParamsSchema
  });
  PromptArgumentSchema = object3({
    name: string5(),
    description: optional2(string5()),
    required: optional2(boolean5())
  });
  PromptSchema = object3({
    ...BaseMetadataSchema.shape,
    ...IconsSchema.shape,
    description: optional2(string5()),
    arguments: optional2(array2(PromptArgumentSchema)),
    _meta: optional2(looseObject2({}))
  });
  ListPromptsRequestSchema = PaginatedRequestSchema.extend({
    method: literal2("prompts/list")
  });
  ListPromptsResultSchema = PaginatedResultSchema.extend({
    prompts: array2(PromptSchema)
  });
  GetPromptRequestParamsSchema = BaseRequestParamsSchema.extend({
    name: string5(),
    arguments: record2(string5(), string5()).optional()
  });
  GetPromptRequestSchema = RequestSchema.extend({
    method: literal2("prompts/get"),
    params: GetPromptRequestParamsSchema
  });
  TextContentSchema = object3({
    type: literal2("text"),
    text: string5(),
    annotations: AnnotationsSchema.optional(),
    _meta: record2(string5(), unknown2()).optional()
  });
  ImageContentSchema = object3({
    type: literal2("image"),
    data: Base64Schema,
    mimeType: string5(),
    annotations: AnnotationsSchema.optional(),
    _meta: record2(string5(), unknown2()).optional()
  });
  AudioContentSchema = object3({
    type: literal2("audio"),
    data: Base64Schema,
    mimeType: string5(),
    annotations: AnnotationsSchema.optional(),
    _meta: record2(string5(), unknown2()).optional()
  });
  ToolUseContentSchema = object3({
    type: literal2("tool_use"),
    name: string5(),
    id: string5(),
    input: record2(string5(), unknown2()),
    _meta: record2(string5(), unknown2()).optional()
  });
  EmbeddedResourceSchema = object3({
    type: literal2("resource"),
    resource: union2([TextResourceContentsSchema, BlobResourceContentsSchema]),
    annotations: AnnotationsSchema.optional(),
    _meta: record2(string5(), unknown2()).optional()
  });
  ResourceLinkSchema = ResourceSchema.extend({
    type: literal2("resource_link")
  });
  ContentBlockSchema = union2([
    TextContentSchema,
    ImageContentSchema,
    AudioContentSchema,
    ResourceLinkSchema,
    EmbeddedResourceSchema
  ]);
  PromptMessageSchema = object3({
    role: RoleSchema,
    content: ContentBlockSchema
  });
  GetPromptResultSchema = ResultSchema.extend({
    description: string5().optional(),
    messages: array2(PromptMessageSchema)
  });
  PromptListChangedNotificationSchema = NotificationSchema.extend({
    method: literal2("notifications/prompts/list_changed"),
    params: NotificationsParamsSchema.optional()
  });
  ToolAnnotationsSchema = object3({
    title: string5().optional(),
    readOnlyHint: boolean5().optional(),
    destructiveHint: boolean5().optional(),
    idempotentHint: boolean5().optional(),
    openWorldHint: boolean5().optional()
  });
  ToolExecutionSchema = object3({
    taskSupport: _enum3(["required", "optional", "forbidden"]).optional()
  });
  ToolSchema = object3({
    ...BaseMetadataSchema.shape,
    ...IconsSchema.shape,
    description: string5().optional(),
    inputSchema: object3({
      type: literal2("object"),
      properties: record2(string5(), AssertObjectSchema).optional(),
      required: array2(string5()).optional()
    }).catchall(unknown2()),
    outputSchema: object3({
      type: literal2("object"),
      properties: record2(string5(), AssertObjectSchema).optional(),
      required: array2(string5()).optional()
    }).catchall(unknown2()).optional(),
    annotations: ToolAnnotationsSchema.optional(),
    execution: ToolExecutionSchema.optional(),
    _meta: record2(string5(), unknown2()).optional()
  });
  ListToolsRequestSchema = PaginatedRequestSchema.extend({
    method: literal2("tools/list")
  });
  ListToolsResultSchema = PaginatedResultSchema.extend({
    tools: array2(ToolSchema)
  });
  CallToolResultSchema = ResultSchema.extend({
    content: array2(ContentBlockSchema).default([]),
    structuredContent: record2(string5(), unknown2()).optional(),
    isError: boolean5().optional()
  });
  CompatibilityCallToolResultSchema = CallToolResultSchema.or(ResultSchema.extend({
    toolResult: unknown2()
  }));
  CallToolRequestParamsSchema = TaskAugmentedRequestParamsSchema.extend({
    name: string5(),
    arguments: record2(string5(), unknown2()).optional()
  });
  CallToolRequestSchema = RequestSchema.extend({
    method: literal2("tools/call"),
    params: CallToolRequestParamsSchema
  });
  ToolListChangedNotificationSchema = NotificationSchema.extend({
    method: literal2("notifications/tools/list_changed"),
    params: NotificationsParamsSchema.optional()
  });
  ListChangedOptionsBaseSchema = object3({
    autoRefresh: boolean5().default(true),
    debounceMs: number5().int().nonnegative().default(300)
  });
  LoggingLevelSchema = _enum3(["debug", "info", "notice", "warning", "error", "critical", "alert", "emergency"]);
  SetLevelRequestParamsSchema = BaseRequestParamsSchema.extend({
    level: LoggingLevelSchema
  });
  SetLevelRequestSchema = RequestSchema.extend({
    method: literal2("logging/setLevel"),
    params: SetLevelRequestParamsSchema
  });
  LoggingMessageNotificationParamsSchema = NotificationsParamsSchema.extend({
    level: LoggingLevelSchema,
    logger: string5().optional(),
    data: unknown2()
  });
  LoggingMessageNotificationSchema = NotificationSchema.extend({
    method: literal2("notifications/message"),
    params: LoggingMessageNotificationParamsSchema
  });
  ModelHintSchema = object3({
    name: string5().optional()
  });
  ModelPreferencesSchema = object3({
    hints: array2(ModelHintSchema).optional(),
    costPriority: number5().min(0).max(1).optional(),
    speedPriority: number5().min(0).max(1).optional(),
    intelligencePriority: number5().min(0).max(1).optional()
  });
  ToolChoiceSchema = object3({
    mode: _enum3(["auto", "required", "none"]).optional()
  });
  ToolResultContentSchema = object3({
    type: literal2("tool_result"),
    toolUseId: string5().describe("The unique identifier for the corresponding tool call."),
    content: array2(ContentBlockSchema).default([]),
    structuredContent: object3({}).loose().optional(),
    isError: boolean5().optional(),
    _meta: record2(string5(), unknown2()).optional()
  });
  SamplingContentSchema = discriminatedUnion2("type", [TextContentSchema, ImageContentSchema, AudioContentSchema]);
  SamplingMessageContentBlockSchema = discriminatedUnion2("type", [
    TextContentSchema,
    ImageContentSchema,
    AudioContentSchema,
    ToolUseContentSchema,
    ToolResultContentSchema
  ]);
  SamplingMessageSchema = object3({
    role: RoleSchema,
    content: union2([SamplingMessageContentBlockSchema, array2(SamplingMessageContentBlockSchema)]),
    _meta: record2(string5(), unknown2()).optional()
  });
  CreateMessageRequestParamsSchema = TaskAugmentedRequestParamsSchema.extend({
    messages: array2(SamplingMessageSchema),
    modelPreferences: ModelPreferencesSchema.optional(),
    systemPrompt: string5().optional(),
    includeContext: _enum3(["none", "thisServer", "allServers"]).optional(),
    temperature: number5().optional(),
    maxTokens: number5().int(),
    stopSequences: array2(string5()).optional(),
    metadata: AssertObjectSchema.optional(),
    tools: array2(ToolSchema).optional(),
    toolChoice: ToolChoiceSchema.optional()
  });
  CreateMessageRequestSchema = RequestSchema.extend({
    method: literal2("sampling/createMessage"),
    params: CreateMessageRequestParamsSchema
  });
  CreateMessageResultSchema = ResultSchema.extend({
    model: string5(),
    stopReason: optional2(_enum3(["endTurn", "stopSequence", "maxTokens"]).or(string5())),
    role: RoleSchema,
    content: SamplingContentSchema
  });
  CreateMessageResultWithToolsSchema = ResultSchema.extend({
    model: string5(),
    stopReason: optional2(_enum3(["endTurn", "stopSequence", "maxTokens", "toolUse"]).or(string5())),
    role: RoleSchema,
    content: union2([SamplingMessageContentBlockSchema, array2(SamplingMessageContentBlockSchema)])
  });
  BooleanSchemaSchema = object3({
    type: literal2("boolean"),
    title: string5().optional(),
    description: string5().optional(),
    default: boolean5().optional()
  });
  StringSchemaSchema = object3({
    type: literal2("string"),
    title: string5().optional(),
    description: string5().optional(),
    minLength: number5().optional(),
    maxLength: number5().optional(),
    format: _enum3(["email", "uri", "date", "date-time"]).optional(),
    default: string5().optional()
  });
  NumberSchemaSchema = object3({
    type: _enum3(["number", "integer"]),
    title: string5().optional(),
    description: string5().optional(),
    minimum: number5().optional(),
    maximum: number5().optional(),
    default: number5().optional()
  });
  UntitledSingleSelectEnumSchemaSchema = object3({
    type: literal2("string"),
    title: string5().optional(),
    description: string5().optional(),
    enum: array2(string5()),
    default: string5().optional()
  });
  TitledSingleSelectEnumSchemaSchema = object3({
    type: literal2("string"),
    title: string5().optional(),
    description: string5().optional(),
    oneOf: array2(object3({
      const: string5(),
      title: string5()
    })),
    default: string5().optional()
  });
  LegacyTitledEnumSchemaSchema = object3({
    type: literal2("string"),
    title: string5().optional(),
    description: string5().optional(),
    enum: array2(string5()),
    enumNames: array2(string5()).optional(),
    default: string5().optional()
  });
  SingleSelectEnumSchemaSchema = union2([UntitledSingleSelectEnumSchemaSchema, TitledSingleSelectEnumSchemaSchema]);
  UntitledMultiSelectEnumSchemaSchema = object3({
    type: literal2("array"),
    title: string5().optional(),
    description: string5().optional(),
    minItems: number5().optional(),
    maxItems: number5().optional(),
    items: object3({
      type: literal2("string"),
      enum: array2(string5())
    }),
    default: array2(string5()).optional()
  });
  TitledMultiSelectEnumSchemaSchema = object3({
    type: literal2("array"),
    title: string5().optional(),
    description: string5().optional(),
    minItems: number5().optional(),
    maxItems: number5().optional(),
    items: object3({
      anyOf: array2(object3({
        const: string5(),
        title: string5()
      }))
    }),
    default: array2(string5()).optional()
  });
  MultiSelectEnumSchemaSchema = union2([UntitledMultiSelectEnumSchemaSchema, TitledMultiSelectEnumSchemaSchema]);
  EnumSchemaSchema = union2([LegacyTitledEnumSchemaSchema, SingleSelectEnumSchemaSchema, MultiSelectEnumSchemaSchema]);
  PrimitiveSchemaDefinitionSchema = union2([EnumSchemaSchema, BooleanSchemaSchema, StringSchemaSchema, NumberSchemaSchema]);
  ElicitRequestFormParamsSchema = TaskAugmentedRequestParamsSchema.extend({
    mode: literal2("form").optional(),
    message: string5(),
    requestedSchema: object3({
      type: literal2("object"),
      properties: record2(string5(), PrimitiveSchemaDefinitionSchema),
      required: array2(string5()).optional()
    })
  });
  ElicitRequestURLParamsSchema = TaskAugmentedRequestParamsSchema.extend({
    mode: literal2("url"),
    message: string5(),
    elicitationId: string5(),
    url: string5().url()
  });
  ElicitRequestParamsSchema = union2([ElicitRequestFormParamsSchema, ElicitRequestURLParamsSchema]);
  ElicitRequestSchema = RequestSchema.extend({
    method: literal2("elicitation/create"),
    params: ElicitRequestParamsSchema
  });
  ElicitationCompleteNotificationParamsSchema = NotificationsParamsSchema.extend({
    elicitationId: string5()
  });
  ElicitationCompleteNotificationSchema = NotificationSchema.extend({
    method: literal2("notifications/elicitation/complete"),
    params: ElicitationCompleteNotificationParamsSchema
  });
  ElicitResultSchema = ResultSchema.extend({
    action: _enum3(["accept", "decline", "cancel"]),
    content: preprocess2((val) => val === null ? undefined : val, record2(string5(), union2([string5(), number5(), boolean5(), array2(string5())])).optional())
  });
  ResourceTemplateReferenceSchema = object3({
    type: literal2("ref/resource"),
    uri: string5()
  });
  PromptReferenceSchema = object3({
    type: literal2("ref/prompt"),
    name: string5()
  });
  CompleteRequestParamsSchema = BaseRequestParamsSchema.extend({
    ref: union2([PromptReferenceSchema, ResourceTemplateReferenceSchema]),
    argument: object3({
      name: string5(),
      value: string5()
    }),
    context: object3({
      arguments: record2(string5(), string5()).optional()
    }).optional()
  });
  CompleteRequestSchema = RequestSchema.extend({
    method: literal2("completion/complete"),
    params: CompleteRequestParamsSchema
  });
  CompleteResultSchema = ResultSchema.extend({
    completion: looseObject2({
      values: array2(string5()).max(100),
      total: optional2(number5().int()),
      hasMore: optional2(boolean5())
    })
  });
  RootSchema = object3({
    uri: string5().startsWith("file://"),
    name: string5().optional(),
    _meta: record2(string5(), unknown2()).optional()
  });
  ListRootsRequestSchema = RequestSchema.extend({
    method: literal2("roots/list"),
    params: BaseRequestParamsSchema.optional()
  });
  ListRootsResultSchema = ResultSchema.extend({
    roots: array2(RootSchema)
  });
  RootsListChangedNotificationSchema = NotificationSchema.extend({
    method: literal2("notifications/roots/list_changed"),
    params: NotificationsParamsSchema.optional()
  });
  ClientRequestSchema = union2([
    PingRequestSchema,
    InitializeRequestSchema,
    CompleteRequestSchema,
    SetLevelRequestSchema,
    GetPromptRequestSchema,
    ListPromptsRequestSchema,
    ListResourcesRequestSchema,
    ListResourceTemplatesRequestSchema,
    ReadResourceRequestSchema,
    SubscribeRequestSchema,
    UnsubscribeRequestSchema,
    CallToolRequestSchema,
    ListToolsRequestSchema,
    GetTaskRequestSchema,
    GetTaskPayloadRequestSchema,
    ListTasksRequestSchema,
    CancelTaskRequestSchema
  ]);
  ClientNotificationSchema = union2([
    CancelledNotificationSchema,
    ProgressNotificationSchema,
    InitializedNotificationSchema,
    RootsListChangedNotificationSchema,
    TaskStatusNotificationSchema
  ]);
  ClientResultSchema = union2([
    EmptyResultSchema,
    CreateMessageResultSchema,
    CreateMessageResultWithToolsSchema,
    ElicitResultSchema,
    ListRootsResultSchema,
    GetTaskResultSchema,
    ListTasksResultSchema,
    CreateTaskResultSchema
  ]);
  ServerRequestSchema = union2([
    PingRequestSchema,
    CreateMessageRequestSchema,
    ElicitRequestSchema,
    ListRootsRequestSchema,
    GetTaskRequestSchema,
    GetTaskPayloadRequestSchema,
    ListTasksRequestSchema,
    CancelTaskRequestSchema
  ]);
  ServerNotificationSchema = union2([
    CancelledNotificationSchema,
    ProgressNotificationSchema,
    LoggingMessageNotificationSchema,
    ResourceUpdatedNotificationSchema,
    ResourceListChangedNotificationSchema,
    ToolListChangedNotificationSchema,
    PromptListChangedNotificationSchema,
    TaskStatusNotificationSchema,
    ElicitationCompleteNotificationSchema
  ]);
  ServerResultSchema = union2([
    EmptyResultSchema,
    InitializeResultSchema,
    CompleteResultSchema,
    GetPromptResultSchema,
    ListPromptsResultSchema,
    ListResourcesResultSchema,
    ListResourceTemplatesResultSchema,
    ReadResourceResultSchema,
    CallToolResultSchema,
    ListToolsResultSchema,
    GetTaskResultSchema,
    ListTasksResultSchema,
    CreateTaskResultSchema
  ]);
  McpError = class McpError extends Error {
    constructor(code, message, data) {
      super(`MCP error ${code}: ${message}`);
      this.code = code;
      this.data = data;
      this.name = "McpError";
    }
    static fromError(code, message, data) {
      if (code === ErrorCode.UrlElicitationRequired && data) {
        const errorData = data;
        if (errorData.elicitations) {
          return new UrlElicitationRequiredError(errorData.elicitations, message);
        }
      }
      return new McpError(code, message, data);
    }
  };
  UrlElicitationRequiredError = class UrlElicitationRequiredError extends McpError {
    constructor(elicitations, message = `URL elicitation${elicitations.length > 1 ? "s" : ""} required`) {
      super(ErrorCode.UrlElicitationRequired, message, {
        elicitations
      });
    }
    get elicitations() {
      return this.data?.elicitations ?? [];
    }
  };
});

// node_modules/@modelcontextprotocol/sdk/dist/esm/experimental/tasks/interfaces.js
function isTerminal(status) {
  return status === "completed" || status === "failed" || status === "cancelled";
}

// node_modules/zod-to-json-schema/dist/esm/Options.js
var ignoreOverride;
var init_Options = __esm(() => {
  ignoreOverride = Symbol("Let zodToJsonSchema decide on which parser to use");
});

// node_modules/zod-to-json-schema/dist/esm/Refs.js
var init_Refs = __esm(() => {
  init_Options();
});
// node_modules/zod-to-json-schema/dist/esm/parsers/any.js
var init_any = () => {};

// node_modules/zod-to-json-schema/dist/esm/parsers/array.js
var init_array = __esm(() => {
  init_parseDef();
});

// node_modules/zod-to-json-schema/dist/esm/parsers/bigint.js
var init_bigint = () => {};
// node_modules/zod-to-json-schema/dist/esm/parsers/branded.js
var init_branded = __esm(() => {
  init_parseDef();
});

// node_modules/zod-to-json-schema/dist/esm/parsers/catch.js
var init_catch = __esm(() => {
  init_parseDef();
});

// node_modules/zod-to-json-schema/dist/esm/parsers/date.js
var init_date = () => {};

// node_modules/zod-to-json-schema/dist/esm/parsers/default.js
var init_default = __esm(() => {
  init_parseDef();
});

// node_modules/zod-to-json-schema/dist/esm/parsers/effects.js
var init_effects = __esm(() => {
  init_parseDef();
  init_any();
});
// node_modules/zod-to-json-schema/dist/esm/parsers/intersection.js
var init_intersection = __esm(() => {
  init_parseDef();
});
// node_modules/zod-to-json-schema/dist/esm/parsers/string.js
var ALPHA_NUMERIC;
var init_string = __esm(() => {
  ALPHA_NUMERIC = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
});

// node_modules/zod-to-json-schema/dist/esm/parsers/record.js
var init_record = __esm(() => {
  init_parseDef();
  init_string();
  init_branded();
  init_any();
});

// node_modules/zod-to-json-schema/dist/esm/parsers/map.js
var init_map = __esm(() => {
  init_parseDef();
  init_record();
  init_any();
});
// node_modules/zod-to-json-schema/dist/esm/parsers/never.js
var init_never = __esm(() => {
  init_any();
});
// node_modules/zod-to-json-schema/dist/esm/parsers/union.js
var init_union = __esm(() => {
  init_parseDef();
});

// node_modules/zod-to-json-schema/dist/esm/parsers/nullable.js
var init_nullable = __esm(() => {
  init_parseDef();
  init_union();
});

// node_modules/zod-to-json-schema/dist/esm/parsers/number.js
var init_number = () => {};

// node_modules/zod-to-json-schema/dist/esm/parsers/object.js
var init_object = __esm(() => {
  init_parseDef();
});

// node_modules/zod-to-json-schema/dist/esm/parsers/optional.js
var init_optional = __esm(() => {
  init_parseDef();
  init_any();
});

// node_modules/zod-to-json-schema/dist/esm/parsers/pipeline.js
var init_pipeline = __esm(() => {
  init_parseDef();
});

// node_modules/zod-to-json-schema/dist/esm/parsers/promise.js
var init_promise = __esm(() => {
  init_parseDef();
});

// node_modules/zod-to-json-schema/dist/esm/parsers/set.js
var init_set = __esm(() => {
  init_parseDef();
});

// node_modules/zod-to-json-schema/dist/esm/parsers/tuple.js
var init_tuple = __esm(() => {
  init_parseDef();
});

// node_modules/zod-to-json-schema/dist/esm/parsers/undefined.js
var init_undefined = __esm(() => {
  init_any();
});

// node_modules/zod-to-json-schema/dist/esm/parsers/unknown.js
var init_unknown = __esm(() => {
  init_any();
});

// node_modules/zod-to-json-schema/dist/esm/parsers/readonly.js
var init_readonly = __esm(() => {
  init_parseDef();
});

// node_modules/zod-to-json-schema/dist/esm/selectParser.js
var init_selectParser = __esm(() => {
  init_any();
  init_array();
  init_bigint();
  init_branded();
  init_catch();
  init_date();
  init_default();
  init_effects();
  init_intersection();
  init_map();
  init_never();
  init_nullable();
  init_number();
  init_object();
  init_optional();
  init_pipeline();
  init_promise();
  init_record();
  init_set();
  init_string();
  init_tuple();
  init_undefined();
  init_union();
  init_unknown();
  init_readonly();
});

// node_modules/zod-to-json-schema/dist/esm/parseDef.js
var init_parseDef = __esm(() => {
  init_Options();
  init_selectParser();
  init_any();
});

// node_modules/zod-to-json-schema/dist/esm/parseTypes.js
var init_parseTypes = () => {};

// node_modules/zod-to-json-schema/dist/esm/zodToJsonSchema.js
var init_zodToJsonSchema = __esm(() => {
  init_parseDef();
  init_Refs();
  init_any();
});

// node_modules/zod-to-json-schema/dist/esm/index.js
var init_esm2 = __esm(() => {
  init_zodToJsonSchema();
  init_Options();
  init_Refs();
  init_parseDef();
  init_parseTypes();
  init_any();
  init_array();
  init_bigint();
  init_branded();
  init_catch();
  init_date();
  init_default();
  init_effects();
  init_intersection();
  init_map();
  init_never();
  init_nullable();
  init_number();
  init_object();
  init_optional();
  init_pipeline();
  init_promise();
  init_readonly();
  init_record();
  init_set();
  init_string();
  init_tuple();
  init_undefined();
  init_union();
  init_unknown();
  init_selectParser();
  init_zodToJsonSchema();
});

// node_modules/@modelcontextprotocol/sdk/dist/esm/server/zod-json-schema-compat.js
function getMethodLiteral(schema) {
  const shape = getObjectShape(schema);
  const methodSchema = shape?.method;
  if (!methodSchema) {
    throw new Error("Schema is missing a method literal");
  }
  const value = getLiteralValue(methodSchema);
  if (typeof value !== "string") {
    throw new Error("Schema method literal must be a string");
  }
  return value;
}
function parseWithCompat(schema, data) {
  const result = safeParse4(schema, data);
  if (!result.success) {
    throw result.error;
  }
  return result.data;
}
var init_zod_json_schema_compat = __esm(() => {
  init_zod_compat();
  init_esm2();
});

// node_modules/@modelcontextprotocol/sdk/dist/esm/shared/protocol.js
class Protocol {
  constructor(_options) {
    this._options = _options;
    this._requestMessageId = 0;
    this._requestHandlers = new Map;
    this._requestHandlerAbortControllers = new Map;
    this._notificationHandlers = new Map;
    this._responseHandlers = new Map;
    this._progressHandlers = new Map;
    this._timeoutInfo = new Map;
    this._pendingDebouncedNotifications = new Set;
    this._taskProgressTokens = new Map;
    this._requestResolvers = new Map;
    this.setNotificationHandler(CancelledNotificationSchema, (notification) => {
      this._oncancel(notification);
    });
    this.setNotificationHandler(ProgressNotificationSchema, (notification) => {
      this._onprogress(notification);
    });
    this.setRequestHandler(PingRequestSchema, (_request) => ({}));
    this._taskStore = _options?.taskStore;
    this._taskMessageQueue = _options?.taskMessageQueue;
    if (this._taskStore) {
      this.setRequestHandler(GetTaskRequestSchema, async (request, extra) => {
        const task = await this._taskStore.getTask(request.params.taskId, extra.sessionId);
        if (!task) {
          throw new McpError(ErrorCode.InvalidParams, "Failed to retrieve task: Task not found");
        }
        return {
          ...task
        };
      });
      this.setRequestHandler(GetTaskPayloadRequestSchema, async (request, extra) => {
        const handleTaskResult = async () => {
          const taskId = request.params.taskId;
          if (this._taskMessageQueue) {
            let queuedMessage;
            while (queuedMessage = await this._taskMessageQueue.dequeue(taskId, extra.sessionId)) {
              if (queuedMessage.type === "response" || queuedMessage.type === "error") {
                const message = queuedMessage.message;
                const requestId = message.id;
                const resolver = this._requestResolvers.get(requestId);
                if (resolver) {
                  this._requestResolvers.delete(requestId);
                  if (queuedMessage.type === "response") {
                    resolver(message);
                  } else {
                    const errorMessage = message;
                    const error49 = new McpError(errorMessage.error.code, errorMessage.error.message, errorMessage.error.data);
                    resolver(error49);
                  }
                } else {
                  const messageType = queuedMessage.type === "response" ? "Response" : "Error";
                  this._onerror(new Error(`${messageType} handler missing for request ${requestId}`));
                }
                continue;
              }
              await this._transport?.send(queuedMessage.message, { relatedRequestId: extra.requestId });
            }
          }
          const task = await this._taskStore.getTask(taskId, extra.sessionId);
          if (!task) {
            throw new McpError(ErrorCode.InvalidParams, `Task not found: ${taskId}`);
          }
          if (!isTerminal(task.status)) {
            await this._waitForTaskUpdate(taskId, extra.signal);
            return await handleTaskResult();
          }
          if (isTerminal(task.status)) {
            const result = await this._taskStore.getTaskResult(taskId, extra.sessionId);
            this._clearTaskQueue(taskId);
            return {
              ...result,
              _meta: {
                ...result._meta,
                [RELATED_TASK_META_KEY]: {
                  taskId
                }
              }
            };
          }
          return await handleTaskResult();
        };
        return await handleTaskResult();
      });
      this.setRequestHandler(ListTasksRequestSchema, async (request, extra) => {
        try {
          const { tasks, nextCursor } = await this._taskStore.listTasks(request.params?.cursor, extra.sessionId);
          return {
            tasks,
            nextCursor,
            _meta: {}
          };
        } catch (error49) {
          throw new McpError(ErrorCode.InvalidParams, `Failed to list tasks: ${error49 instanceof Error ? error49.message : String(error49)}`);
        }
      });
      this.setRequestHandler(CancelTaskRequestSchema, async (request, extra) => {
        try {
          const task = await this._taskStore.getTask(request.params.taskId, extra.sessionId);
          if (!task) {
            throw new McpError(ErrorCode.InvalidParams, `Task not found: ${request.params.taskId}`);
          }
          if (isTerminal(task.status)) {
            throw new McpError(ErrorCode.InvalidParams, `Cannot cancel task in terminal status: ${task.status}`);
          }
          await this._taskStore.updateTaskStatus(request.params.taskId, "cancelled", "Client cancelled task execution.", extra.sessionId);
          this._clearTaskQueue(request.params.taskId);
          const cancelledTask = await this._taskStore.getTask(request.params.taskId, extra.sessionId);
          if (!cancelledTask) {
            throw new McpError(ErrorCode.InvalidParams, `Task not found after cancellation: ${request.params.taskId}`);
          }
          return {
            _meta: {},
            ...cancelledTask
          };
        } catch (error49) {
          if (error49 instanceof McpError) {
            throw error49;
          }
          throw new McpError(ErrorCode.InvalidRequest, `Failed to cancel task: ${error49 instanceof Error ? error49.message : String(error49)}`);
        }
      });
    }
  }
  async _oncancel(notification) {
    if (!notification.params.requestId) {
      return;
    }
    const controller = this._requestHandlerAbortControllers.get(notification.params.requestId);
    controller?.abort(notification.params.reason);
  }
  _setupTimeout(messageId, timeout, maxTotalTimeout, onTimeout, resetTimeoutOnProgress = false) {
    this._timeoutInfo.set(messageId, {
      timeoutId: setTimeout(onTimeout, timeout),
      startTime: Date.now(),
      timeout,
      maxTotalTimeout,
      resetTimeoutOnProgress,
      onTimeout
    });
  }
  _resetTimeout(messageId) {
    const info = this._timeoutInfo.get(messageId);
    if (!info)
      return false;
    const totalElapsed = Date.now() - info.startTime;
    if (info.maxTotalTimeout && totalElapsed >= info.maxTotalTimeout) {
      this._timeoutInfo.delete(messageId);
      throw McpError.fromError(ErrorCode.RequestTimeout, "Maximum total timeout exceeded", {
        maxTotalTimeout: info.maxTotalTimeout,
        totalElapsed
      });
    }
    clearTimeout(info.timeoutId);
    info.timeoutId = setTimeout(info.onTimeout, info.timeout);
    return true;
  }
  _cleanupTimeout(messageId) {
    const info = this._timeoutInfo.get(messageId);
    if (info) {
      clearTimeout(info.timeoutId);
      this._timeoutInfo.delete(messageId);
    }
  }
  async connect(transport) {
    this._transport = transport;
    const _onclose = this.transport?.onclose;
    this._transport.onclose = () => {
      _onclose?.();
      this._onclose();
    };
    const _onerror = this.transport?.onerror;
    this._transport.onerror = (error49) => {
      _onerror?.(error49);
      this._onerror(error49);
    };
    const _onmessage = this._transport?.onmessage;
    this._transport.onmessage = (message, extra) => {
      _onmessage?.(message, extra);
      if (isJSONRPCResultResponse(message) || isJSONRPCErrorResponse(message)) {
        this._onresponse(message);
      } else if (isJSONRPCRequest(message)) {
        this._onrequest(message, extra);
      } else if (isJSONRPCNotification(message)) {
        this._onnotification(message);
      } else {
        this._onerror(new Error(`Unknown message type: ${JSON.stringify(message)}`));
      }
    };
    await this._transport.start();
  }
  _onclose() {
    const responseHandlers = this._responseHandlers;
    this._responseHandlers = new Map;
    this._progressHandlers.clear();
    this._taskProgressTokens.clear();
    this._pendingDebouncedNotifications.clear();
    const error49 = McpError.fromError(ErrorCode.ConnectionClosed, "Connection closed");
    this._transport = undefined;
    this.onclose?.();
    for (const handler of responseHandlers.values()) {
      handler(error49);
    }
  }
  _onerror(error49) {
    this.onerror?.(error49);
  }
  _onnotification(notification) {
    const handler = this._notificationHandlers.get(notification.method) ?? this.fallbackNotificationHandler;
    if (handler === undefined) {
      return;
    }
    Promise.resolve().then(() => handler(notification)).catch((error49) => this._onerror(new Error(`Uncaught error in notification handler: ${error49}`)));
  }
  _onrequest(request, extra) {
    const handler = this._requestHandlers.get(request.method) ?? this.fallbackRequestHandler;
    const capturedTransport = this._transport;
    const relatedTaskId = request.params?._meta?.[RELATED_TASK_META_KEY]?.taskId;
    if (handler === undefined) {
      const errorResponse = {
        jsonrpc: "2.0",
        id: request.id,
        error: {
          code: ErrorCode.MethodNotFound,
          message: "Method not found"
        }
      };
      if (relatedTaskId && this._taskMessageQueue) {
        this._enqueueTaskMessage(relatedTaskId, {
          type: "error",
          message: errorResponse,
          timestamp: Date.now()
        }, capturedTransport?.sessionId).catch((error49) => this._onerror(new Error(`Failed to enqueue error response: ${error49}`)));
      } else {
        capturedTransport?.send(errorResponse).catch((error49) => this._onerror(new Error(`Failed to send an error response: ${error49}`)));
      }
      return;
    }
    const abortController = new AbortController;
    this._requestHandlerAbortControllers.set(request.id, abortController);
    const taskCreationParams = isTaskAugmentedRequestParams(request.params) ? request.params.task : undefined;
    const taskStore = this._taskStore ? this.requestTaskStore(request, capturedTransport?.sessionId) : undefined;
    const fullExtra = {
      signal: abortController.signal,
      sessionId: capturedTransport?.sessionId,
      _meta: request.params?._meta,
      sendNotification: async (notification) => {
        const notificationOptions = { relatedRequestId: request.id };
        if (relatedTaskId) {
          notificationOptions.relatedTask = { taskId: relatedTaskId };
        }
        await this.notification(notification, notificationOptions);
      },
      sendRequest: async (r, resultSchema, options2) => {
        const requestOptions = { ...options2, relatedRequestId: request.id };
        if (relatedTaskId && !requestOptions.relatedTask) {
          requestOptions.relatedTask = { taskId: relatedTaskId };
        }
        const effectiveTaskId = requestOptions.relatedTask?.taskId ?? relatedTaskId;
        if (effectiveTaskId && taskStore) {
          await taskStore.updateTaskStatus(effectiveTaskId, "input_required");
        }
        return await this.request(r, resultSchema, requestOptions);
      },
      authInfo: extra?.authInfo,
      requestId: request.id,
      requestInfo: extra?.requestInfo,
      taskId: relatedTaskId,
      taskStore,
      taskRequestedTtl: taskCreationParams?.ttl,
      closeSSEStream: extra?.closeSSEStream,
      closeStandaloneSSEStream: extra?.closeStandaloneSSEStream
    };
    Promise.resolve().then(() => {
      if (taskCreationParams) {
        this.assertTaskHandlerCapability(request.method);
      }
    }).then(() => handler(request, fullExtra)).then(async (result) => {
      if (abortController.signal.aborted) {
        return;
      }
      const response = {
        result,
        jsonrpc: "2.0",
        id: request.id
      };
      if (relatedTaskId && this._taskMessageQueue) {
        await this._enqueueTaskMessage(relatedTaskId, {
          type: "response",
          message: response,
          timestamp: Date.now()
        }, capturedTransport?.sessionId);
      } else {
        await capturedTransport?.send(response);
      }
    }, async (error49) => {
      if (abortController.signal.aborted) {
        return;
      }
      const errorResponse = {
        jsonrpc: "2.0",
        id: request.id,
        error: {
          code: Number.isSafeInteger(error49["code"]) ? error49["code"] : ErrorCode.InternalError,
          message: error49.message ?? "Internal error",
          ...error49["data"] !== undefined && { data: error49["data"] }
        }
      };
      if (relatedTaskId && this._taskMessageQueue) {
        await this._enqueueTaskMessage(relatedTaskId, {
          type: "error",
          message: errorResponse,
          timestamp: Date.now()
        }, capturedTransport?.sessionId);
      } else {
        await capturedTransport?.send(errorResponse);
      }
    }).catch((error49) => this._onerror(new Error(`Failed to send response: ${error49}`))).finally(() => {
      this._requestHandlerAbortControllers.delete(request.id);
    });
  }
  _onprogress(notification) {
    const { progressToken, ...params } = notification.params;
    const messageId = Number(progressToken);
    const handler = this._progressHandlers.get(messageId);
    if (!handler) {
      this._onerror(new Error(`Received a progress notification for an unknown token: ${JSON.stringify(notification)}`));
      return;
    }
    const responseHandler = this._responseHandlers.get(messageId);
    const timeoutInfo = this._timeoutInfo.get(messageId);
    if (timeoutInfo && responseHandler && timeoutInfo.resetTimeoutOnProgress) {
      try {
        this._resetTimeout(messageId);
      } catch (error49) {
        this._responseHandlers.delete(messageId);
        this._progressHandlers.delete(messageId);
        this._cleanupTimeout(messageId);
        responseHandler(error49);
        return;
      }
    }
    handler(params);
  }
  _onresponse(response) {
    const messageId = Number(response.id);
    const resolver = this._requestResolvers.get(messageId);
    if (resolver) {
      this._requestResolvers.delete(messageId);
      if (isJSONRPCResultResponse(response)) {
        resolver(response);
      } else {
        const error49 = new McpError(response.error.code, response.error.message, response.error.data);
        resolver(error49);
      }
      return;
    }
    const handler = this._responseHandlers.get(messageId);
    if (handler === undefined) {
      this._onerror(new Error(`Received a response for an unknown message ID: ${JSON.stringify(response)}`));
      return;
    }
    this._responseHandlers.delete(messageId);
    this._cleanupTimeout(messageId);
    let isTaskResponse = false;
    if (isJSONRPCResultResponse(response) && response.result && typeof response.result === "object") {
      const result = response.result;
      if (result.task && typeof result.task === "object") {
        const task = result.task;
        if (typeof task.taskId === "string") {
          isTaskResponse = true;
          this._taskProgressTokens.set(task.taskId, messageId);
        }
      }
    }
    if (!isTaskResponse) {
      this._progressHandlers.delete(messageId);
    }
    if (isJSONRPCResultResponse(response)) {
      handler(response);
    } else {
      const error49 = McpError.fromError(response.error.code, response.error.message, response.error.data);
      handler(error49);
    }
  }
  get transport() {
    return this._transport;
  }
  async close() {
    await this._transport?.close();
  }
  async* requestStream(request, resultSchema, options2) {
    const { task } = options2 ?? {};
    if (!task) {
      try {
        const result = await this.request(request, resultSchema, options2);
        yield { type: "result", result };
      } catch (error49) {
        yield {
          type: "error",
          error: error49 instanceof McpError ? error49 : new McpError(ErrorCode.InternalError, String(error49))
        };
      }
      return;
    }
    let taskId;
    try {
      const createResult = await this.request(request, CreateTaskResultSchema, options2);
      if (createResult.task) {
        taskId = createResult.task.taskId;
        yield { type: "taskCreated", task: createResult.task };
      } else {
        throw new McpError(ErrorCode.InternalError, "Task creation did not return a task");
      }
      while (true) {
        const task2 = await this.getTask({ taskId }, options2);
        yield { type: "taskStatus", task: task2 };
        if (isTerminal(task2.status)) {
          if (task2.status === "completed") {
            const result = await this.getTaskResult({ taskId }, resultSchema, options2);
            yield { type: "result", result };
          } else if (task2.status === "failed") {
            yield {
              type: "error",
              error: new McpError(ErrorCode.InternalError, `Task ${taskId} failed`)
            };
          } else if (task2.status === "cancelled") {
            yield {
              type: "error",
              error: new McpError(ErrorCode.InternalError, `Task ${taskId} was cancelled`)
            };
          }
          return;
        }
        if (task2.status === "input_required") {
          const result = await this.getTaskResult({ taskId }, resultSchema, options2);
          yield { type: "result", result };
          return;
        }
        const pollInterval = task2.pollInterval ?? this._options?.defaultTaskPollInterval ?? 1000;
        await new Promise((resolve) => setTimeout(resolve, pollInterval));
        options2?.signal?.throwIfAborted();
      }
    } catch (error49) {
      yield {
        type: "error",
        error: error49 instanceof McpError ? error49 : new McpError(ErrorCode.InternalError, String(error49))
      };
    }
  }
  request(request, resultSchema, options2) {
    const { relatedRequestId, resumptionToken, onresumptiontoken, task, relatedTask } = options2 ?? {};
    return new Promise((resolve, reject) => {
      const earlyReject = (error49) => {
        reject(error49);
      };
      if (!this._transport) {
        earlyReject(new Error("Not connected"));
        return;
      }
      if (this._options?.enforceStrictCapabilities === true) {
        try {
          this.assertCapabilityForMethod(request.method);
          if (task) {
            this.assertTaskCapability(request.method);
          }
        } catch (e) {
          earlyReject(e);
          return;
        }
      }
      options2?.signal?.throwIfAborted();
      const messageId = this._requestMessageId++;
      const jsonrpcRequest = {
        ...request,
        jsonrpc: "2.0",
        id: messageId
      };
      if (options2?.onprogress) {
        this._progressHandlers.set(messageId, options2.onprogress);
        jsonrpcRequest.params = {
          ...request.params,
          _meta: {
            ...request.params?._meta || {},
            progressToken: messageId
          }
        };
      }
      if (task) {
        jsonrpcRequest.params = {
          ...jsonrpcRequest.params,
          task
        };
      }
      if (relatedTask) {
        jsonrpcRequest.params = {
          ...jsonrpcRequest.params,
          _meta: {
            ...jsonrpcRequest.params?._meta || {},
            [RELATED_TASK_META_KEY]: relatedTask
          }
        };
      }
      const cancel = (reason) => {
        this._responseHandlers.delete(messageId);
        this._progressHandlers.delete(messageId);
        this._cleanupTimeout(messageId);
        this._transport?.send({
          jsonrpc: "2.0",
          method: "notifications/cancelled",
          params: {
            requestId: messageId,
            reason: String(reason)
          }
        }, { relatedRequestId, resumptionToken, onresumptiontoken }).catch((error50) => this._onerror(new Error(`Failed to send cancellation: ${error50}`)));
        const error49 = reason instanceof McpError ? reason : new McpError(ErrorCode.RequestTimeout, String(reason));
        reject(error49);
      };
      this._responseHandlers.set(messageId, (response) => {
        if (options2?.signal?.aborted) {
          return;
        }
        if (response instanceof Error) {
          return reject(response);
        }
        try {
          const parseResult = safeParse4(resultSchema, response.result);
          if (!parseResult.success) {
            reject(parseResult.error);
          } else {
            resolve(parseResult.data);
          }
        } catch (error49) {
          reject(error49);
        }
      });
      options2?.signal?.addEventListener("abort", () => {
        cancel(options2?.signal?.reason);
      });
      const timeout = options2?.timeout ?? DEFAULT_REQUEST_TIMEOUT_MSEC;
      const timeoutHandler = () => cancel(McpError.fromError(ErrorCode.RequestTimeout, "Request timed out", { timeout }));
      this._setupTimeout(messageId, timeout, options2?.maxTotalTimeout, timeoutHandler, options2?.resetTimeoutOnProgress ?? false);
      const relatedTaskId = relatedTask?.taskId;
      if (relatedTaskId) {
        const responseResolver = (response) => {
          const handler = this._responseHandlers.get(messageId);
          if (handler) {
            handler(response);
          } else {
            this._onerror(new Error(`Response handler missing for side-channeled request ${messageId}`));
          }
        };
        this._requestResolvers.set(messageId, responseResolver);
        this._enqueueTaskMessage(relatedTaskId, {
          type: "request",
          message: jsonrpcRequest,
          timestamp: Date.now()
        }).catch((error49) => {
          this._cleanupTimeout(messageId);
          reject(error49);
        });
      } else {
        this._transport.send(jsonrpcRequest, { relatedRequestId, resumptionToken, onresumptiontoken }).catch((error49) => {
          this._cleanupTimeout(messageId);
          reject(error49);
        });
      }
    });
  }
  async getTask(params, options2) {
    return this.request({ method: "tasks/get", params }, GetTaskResultSchema, options2);
  }
  async getTaskResult(params, resultSchema, options2) {
    return this.request({ method: "tasks/result", params }, resultSchema, options2);
  }
  async listTasks(params, options2) {
    return this.request({ method: "tasks/list", params }, ListTasksResultSchema, options2);
  }
  async cancelTask(params, options2) {
    return this.request({ method: "tasks/cancel", params }, CancelTaskResultSchema, options2);
  }
  async notification(notification, options2) {
    if (!this._transport) {
      throw new Error("Not connected");
    }
    this.assertNotificationCapability(notification.method);
    const relatedTaskId = options2?.relatedTask?.taskId;
    if (relatedTaskId) {
      const jsonrpcNotification2 = {
        ...notification,
        jsonrpc: "2.0",
        params: {
          ...notification.params,
          _meta: {
            ...notification.params?._meta || {},
            [RELATED_TASK_META_KEY]: options2.relatedTask
          }
        }
      };
      await this._enqueueTaskMessage(relatedTaskId, {
        type: "notification",
        message: jsonrpcNotification2,
        timestamp: Date.now()
      });
      return;
    }
    const debouncedMethods = this._options?.debouncedNotificationMethods ?? [];
    const canDebounce = debouncedMethods.includes(notification.method) && !notification.params && !options2?.relatedRequestId && !options2?.relatedTask;
    if (canDebounce) {
      if (this._pendingDebouncedNotifications.has(notification.method)) {
        return;
      }
      this._pendingDebouncedNotifications.add(notification.method);
      Promise.resolve().then(() => {
        this._pendingDebouncedNotifications.delete(notification.method);
        if (!this._transport) {
          return;
        }
        let jsonrpcNotification2 = {
          ...notification,
          jsonrpc: "2.0"
        };
        if (options2?.relatedTask) {
          jsonrpcNotification2 = {
            ...jsonrpcNotification2,
            params: {
              ...jsonrpcNotification2.params,
              _meta: {
                ...jsonrpcNotification2.params?._meta || {},
                [RELATED_TASK_META_KEY]: options2.relatedTask
              }
            }
          };
        }
        this._transport?.send(jsonrpcNotification2, options2).catch((error49) => this._onerror(error49));
      });
      return;
    }
    let jsonrpcNotification = {
      ...notification,
      jsonrpc: "2.0"
    };
    if (options2?.relatedTask) {
      jsonrpcNotification = {
        ...jsonrpcNotification,
        params: {
          ...jsonrpcNotification.params,
          _meta: {
            ...jsonrpcNotification.params?._meta || {},
            [RELATED_TASK_META_KEY]: options2.relatedTask
          }
        }
      };
    }
    await this._transport.send(jsonrpcNotification, options2);
  }
  setRequestHandler(requestSchema, handler) {
    const method = getMethodLiteral(requestSchema);
    this.assertRequestHandlerCapability(method);
    this._requestHandlers.set(method, (request, extra) => {
      const parsed = parseWithCompat(requestSchema, request);
      return Promise.resolve(handler(parsed, extra));
    });
  }
  removeRequestHandler(method) {
    this._requestHandlers.delete(method);
  }
  assertCanSetRequestHandler(method) {
    if (this._requestHandlers.has(method)) {
      throw new Error(`A request handler for ${method} already exists, which would be overridden`);
    }
  }
  setNotificationHandler(notificationSchema, handler) {
    const method = getMethodLiteral(notificationSchema);
    this._notificationHandlers.set(method, (notification) => {
      const parsed = parseWithCompat(notificationSchema, notification);
      return Promise.resolve(handler(parsed));
    });
  }
  removeNotificationHandler(method) {
    this._notificationHandlers.delete(method);
  }
  _cleanupTaskProgressHandler(taskId) {
    const progressToken = this._taskProgressTokens.get(taskId);
    if (progressToken !== undefined) {
      this._progressHandlers.delete(progressToken);
      this._taskProgressTokens.delete(taskId);
    }
  }
  async _enqueueTaskMessage(taskId, message, sessionId) {
    if (!this._taskStore || !this._taskMessageQueue) {
      throw new Error("Cannot enqueue task message: taskStore and taskMessageQueue are not configured");
    }
    const maxQueueSize = this._options?.maxTaskQueueSize;
    await this._taskMessageQueue.enqueue(taskId, message, sessionId, maxQueueSize);
  }
  async _clearTaskQueue(taskId, sessionId) {
    if (this._taskMessageQueue) {
      const messages = await this._taskMessageQueue.dequeueAll(taskId, sessionId);
      for (const message of messages) {
        if (message.type === "request" && isJSONRPCRequest(message.message)) {
          const requestId = message.message.id;
          const resolver = this._requestResolvers.get(requestId);
          if (resolver) {
            resolver(new McpError(ErrorCode.InternalError, "Task cancelled or completed"));
            this._requestResolvers.delete(requestId);
          } else {
            this._onerror(new Error(`Resolver missing for request ${requestId} during task ${taskId} cleanup`));
          }
        }
      }
    }
  }
  async _waitForTaskUpdate(taskId, signal) {
    let interval = this._options?.defaultTaskPollInterval ?? 1000;
    try {
      const task = await this._taskStore?.getTask(taskId);
      if (task?.pollInterval) {
        interval = task.pollInterval;
      }
    } catch {}
    return new Promise((resolve, reject) => {
      if (signal.aborted) {
        reject(new McpError(ErrorCode.InvalidRequest, "Request cancelled"));
        return;
      }
      const timeoutId = setTimeout(resolve, interval);
      signal.addEventListener("abort", () => {
        clearTimeout(timeoutId);
        reject(new McpError(ErrorCode.InvalidRequest, "Request cancelled"));
      }, { once: true });
    });
  }
  requestTaskStore(request, sessionId) {
    const taskStore = this._taskStore;
    if (!taskStore) {
      throw new Error("No task store configured");
    }
    return {
      createTask: async (taskParams) => {
        if (!request) {
          throw new Error("No request provided");
        }
        return await taskStore.createTask(taskParams, request.id, {
          method: request.method,
          params: request.params
        }, sessionId);
      },
      getTask: async (taskId) => {
        const task = await taskStore.getTask(taskId, sessionId);
        if (!task) {
          throw new McpError(ErrorCode.InvalidParams, "Failed to retrieve task: Task not found");
        }
        return task;
      },
      storeTaskResult: async (taskId, status, result) => {
        await taskStore.storeTaskResult(taskId, status, result, sessionId);
        const task = await taskStore.getTask(taskId, sessionId);
        if (task) {
          const notification = TaskStatusNotificationSchema.parse({
            method: "notifications/tasks/status",
            params: task
          });
          await this.notification(notification);
          if (isTerminal(task.status)) {
            this._cleanupTaskProgressHandler(taskId);
          }
        }
      },
      getTaskResult: (taskId) => {
        return taskStore.getTaskResult(taskId, sessionId);
      },
      updateTaskStatus: async (taskId, status, statusMessage) => {
        const task = await taskStore.getTask(taskId, sessionId);
        if (!task) {
          throw new McpError(ErrorCode.InvalidParams, `Task "${taskId}" not found - it may have been cleaned up`);
        }
        if (isTerminal(task.status)) {
          throw new McpError(ErrorCode.InvalidParams, `Cannot update task "${taskId}" from terminal status "${task.status}" to "${status}". Terminal states (completed, failed, cancelled) cannot transition to other states.`);
        }
        await taskStore.updateTaskStatus(taskId, status, statusMessage, sessionId);
        const updatedTask = await taskStore.getTask(taskId, sessionId);
        if (updatedTask) {
          const notification = TaskStatusNotificationSchema.parse({
            method: "notifications/tasks/status",
            params: updatedTask
          });
          await this.notification(notification);
          if (isTerminal(updatedTask.status)) {
            this._cleanupTaskProgressHandler(taskId);
          }
        }
      },
      listTasks: (cursor) => {
        return taskStore.listTasks(cursor, sessionId);
      }
    };
  }
}
function isPlainObject3(value) {
  return value !== null && typeof value === "object" && !Array.isArray(value);
}
function mergeCapabilities(base, additional) {
  const result = { ...base };
  for (const key in additional) {
    const k = key;
    const addValue = additional[k];
    if (addValue === undefined)
      continue;
    const baseValue = result[k];
    if (isPlainObject3(baseValue) && isPlainObject3(addValue)) {
      result[k] = { ...baseValue, ...addValue };
    } else {
      result[k] = addValue;
    }
  }
  return result;
}
var DEFAULT_REQUEST_TIMEOUT_MSEC = 60000;
var init_protocol = __esm(() => {
  init_zod_compat();
  init_types();
  init_zod_json_schema_compat();
});

// node_modules/ajv/dist/compile/codegen/code.js
var require_code = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = undefined;

  class _CodeOrName {
  }
  exports._CodeOrName = _CodeOrName;
  exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;

  class Name extends _CodeOrName {
    constructor(s) {
      super();
      if (!exports.IDENTIFIER.test(s))
        throw new Error("CodeGen: name must be a valid identifier");
      this.str = s;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      return false;
    }
    get names() {
      return { [this.str]: 1 };
    }
  }
  exports.Name = Name;

  class _Code extends _CodeOrName {
    constructor(code) {
      super();
      this._items = typeof code === "string" ? [code] : code;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      if (this._items.length > 1)
        return false;
      const item = this._items[0];
      return item === "" || item === '""';
    }
    get str() {
      var _a2;
      return (_a2 = this._str) !== null && _a2 !== undefined ? _a2 : this._str = this._items.reduce((s, c) => `${s}${c}`, "");
    }
    get names() {
      var _a2;
      return (_a2 = this._names) !== null && _a2 !== undefined ? _a2 : this._names = this._items.reduce((names, c) => {
        if (c instanceof Name)
          names[c.str] = (names[c.str] || 0) + 1;
        return names;
      }, {});
    }
  }
  exports._Code = _Code;
  exports.nil = new _Code("");
  function _(strs, ...args) {
    const code = [strs[0]];
    let i = 0;
    while (i < args.length) {
      addCodeArg(code, args[i]);
      code.push(strs[++i]);
    }
    return new _Code(code);
  }
  exports._ = _;
  var plus = new _Code("+");
  function str2(strs, ...args) {
    const expr = [safeStringify(strs[0])];
    let i = 0;
    while (i < args.length) {
      expr.push(plus);
      addCodeArg(expr, args[i]);
      expr.push(plus, safeStringify(strs[++i]));
    }
    optimize(expr);
    return new _Code(expr);
  }
  exports.str = str2;
  function addCodeArg(code, arg) {
    if (arg instanceof _Code)
      code.push(...arg._items);
    else if (arg instanceof Name)
      code.push(arg);
    else
      code.push(interpolate(arg));
  }
  exports.addCodeArg = addCodeArg;
  function optimize(expr) {
    let i = 1;
    while (i < expr.length - 1) {
      if (expr[i] === plus) {
        const res = mergeExprItems(expr[i - 1], expr[i + 1]);
        if (res !== undefined) {
          expr.splice(i - 1, 3, res);
          continue;
        }
        expr[i++] = "+";
      }
      i++;
    }
  }
  function mergeExprItems(a, b) {
    if (b === '""')
      return a;
    if (a === '""')
      return b;
    if (typeof a == "string") {
      if (b instanceof Name || a[a.length - 1] !== '"')
        return;
      if (typeof b != "string")
        return `${a.slice(0, -1)}${b}"`;
      if (b[0] === '"')
        return a.slice(0, -1) + b.slice(1);
      return;
    }
    if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
      return `"${a}${b.slice(1)}`;
    return;
  }
  function strConcat(c1, c2) {
    return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str2`${c1}${c2}`;
  }
  exports.strConcat = strConcat;
  function interpolate(x) {
    return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
  }
  function stringify(x) {
    return new _Code(safeStringify(x));
  }
  exports.stringify = stringify;
  function safeStringify(x) {
    return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
  }
  exports.safeStringify = safeStringify;
  function getProperty(key) {
    return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
  }
  exports.getProperty = getProperty;
  function getEsmExportName(key) {
    if (typeof key == "string" && exports.IDENTIFIER.test(key)) {
      return new _Code(`${key}`);
    }
    throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
  }
  exports.getEsmExportName = getEsmExportName;
  function regexpCode(rx) {
    return new _Code(rx.toString());
  }
  exports.regexpCode = regexpCode;
});

// node_modules/ajv/dist/compile/codegen/scope.js
var require_scope = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = undefined;
  var code_1 = require_code();

  class ValueError extends Error {
    constructor(name) {
      super(`CodeGen: "code" for ${name} not defined`);
      this.value = name.value;
    }
  }
  var UsedValueState;
  (function(UsedValueState2) {
    UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
    UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
  })(UsedValueState || (exports.UsedValueState = UsedValueState = {}));
  exports.varKinds = {
    const: new code_1.Name("const"),
    let: new code_1.Name("let"),
    var: new code_1.Name("var")
  };

  class Scope {
    constructor({ prefixes, parent } = {}) {
      this._names = {};
      this._prefixes = prefixes;
      this._parent = parent;
    }
    toName(nameOrPrefix) {
      return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
    }
    name(prefix) {
      return new code_1.Name(this._newName(prefix));
    }
    _newName(prefix) {
      const ng = this._names[prefix] || this._nameGroup(prefix);
      return `${prefix}${ng.index++}`;
    }
    _nameGroup(prefix) {
      var _a2, _b;
      if (((_b = (_a2 = this._parent) === null || _a2 === undefined ? undefined : _a2._prefixes) === null || _b === undefined ? undefined : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
        throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
      }
      return this._names[prefix] = { prefix, index: 0 };
    }
  }
  exports.Scope = Scope;

  class ValueScopeName extends code_1.Name {
    constructor(prefix, nameStr) {
      super(nameStr);
      this.prefix = prefix;
    }
    setValue(value, { property, itemIndex }) {
      this.value = value;
      this.scopePath = (0, code_1._)`.${new code_1.Name(property)}[${itemIndex}]`;
    }
  }
  exports.ValueScopeName = ValueScopeName;
  var line = (0, code_1._)`\n`;

  class ValueScope extends Scope {
    constructor(opts) {
      super(opts);
      this._values = {};
      this._scope = opts.scope;
      this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
    }
    get() {
      return this._scope;
    }
    name(prefix) {
      return new ValueScopeName(prefix, this._newName(prefix));
    }
    value(nameOrPrefix, value) {
      var _a2;
      if (value.ref === undefined)
        throw new Error("CodeGen: ref must be passed in value");
      const name = this.toName(nameOrPrefix);
      const { prefix } = name;
      const valueKey = (_a2 = value.key) !== null && _a2 !== undefined ? _a2 : value.ref;
      let vs = this._values[prefix];
      if (vs) {
        const _name = vs.get(valueKey);
        if (_name)
          return _name;
      } else {
        vs = this._values[prefix] = new Map;
      }
      vs.set(valueKey, name);
      const s = this._scope[prefix] || (this._scope[prefix] = []);
      const itemIndex = s.length;
      s[itemIndex] = value.ref;
      name.setValue(value, { property: prefix, itemIndex });
      return name;
    }
    getValue(prefix, keyOrRef) {
      const vs = this._values[prefix];
      if (!vs)
        return;
      return vs.get(keyOrRef);
    }
    scopeRefs(scopeName, values = this._values) {
      return this._reduceValues(values, (name) => {
        if (name.scopePath === undefined)
          throw new Error(`CodeGen: name "${name}" has no value`);
        return (0, code_1._)`${scopeName}${name.scopePath}`;
      });
    }
    scopeCode(values = this._values, usedValues, getCode) {
      return this._reduceValues(values, (name) => {
        if (name.value === undefined)
          throw new Error(`CodeGen: name "${name}" has no value`);
        return name.value.code;
      }, usedValues, getCode);
    }
    _reduceValues(values, valueCode, usedValues = {}, getCode) {
      let code = code_1.nil;
      for (const prefix in values) {
        const vs = values[prefix];
        if (!vs)
          continue;
        const nameSet = usedValues[prefix] = usedValues[prefix] || new Map;
        vs.forEach((name) => {
          if (nameSet.has(name))
            return;
          nameSet.set(name, UsedValueState.Started);
          let c = valueCode(name);
          if (c) {
            const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
            code = (0, code_1._)`${code}${def} ${name} = ${c};${this.opts._n}`;
          } else if (c = getCode === null || getCode === undefined ? undefined : getCode(name)) {
            code = (0, code_1._)`${code}${c}${this.opts._n}`;
          } else {
            throw new ValueError(name);
          }
          nameSet.set(name, UsedValueState.Completed);
        });
      }
      return code;
    }
  }
  exports.ValueScope = ValueScope;
});

// node_modules/ajv/dist/compile/codegen/index.js
var require_codegen = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = undefined;
  var code_1 = require_code();
  var scope_1 = require_scope();
  var code_2 = require_code();
  Object.defineProperty(exports, "_", { enumerable: true, get: function() {
    return code_2._;
  } });
  Object.defineProperty(exports, "str", { enumerable: true, get: function() {
    return code_2.str;
  } });
  Object.defineProperty(exports, "strConcat", { enumerable: true, get: function() {
    return code_2.strConcat;
  } });
  Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
    return code_2.nil;
  } });
  Object.defineProperty(exports, "getProperty", { enumerable: true, get: function() {
    return code_2.getProperty;
  } });
  Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
    return code_2.stringify;
  } });
  Object.defineProperty(exports, "regexpCode", { enumerable: true, get: function() {
    return code_2.regexpCode;
  } });
  Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
    return code_2.Name;
  } });
  var scope_2 = require_scope();
  Object.defineProperty(exports, "Scope", { enumerable: true, get: function() {
    return scope_2.Scope;
  } });
  Object.defineProperty(exports, "ValueScope", { enumerable: true, get: function() {
    return scope_2.ValueScope;
  } });
  Object.defineProperty(exports, "ValueScopeName", { enumerable: true, get: function() {
    return scope_2.ValueScopeName;
  } });
  Object.defineProperty(exports, "varKinds", { enumerable: true, get: function() {
    return scope_2.varKinds;
  } });
  exports.operators = {
    GT: new code_1._Code(">"),
    GTE: new code_1._Code(">="),
    LT: new code_1._Code("<"),
    LTE: new code_1._Code("<="),
    EQ: new code_1._Code("==="),
    NEQ: new code_1._Code("!=="),
    NOT: new code_1._Code("!"),
    OR: new code_1._Code("||"),
    AND: new code_1._Code("&&"),
    ADD: new code_1._Code("+")
  };

  class Node {
    optimizeNodes() {
      return this;
    }
    optimizeNames(_names, _constants) {
      return this;
    }
  }

  class Def extends Node {
    constructor(varKind, name, rhs) {
      super();
      this.varKind = varKind;
      this.name = name;
      this.rhs = rhs;
    }
    render({ es5, _n }) {
      const varKind = es5 ? scope_1.varKinds.var : this.varKind;
      const rhs = this.rhs === undefined ? "" : ` = ${this.rhs}`;
      return `${varKind} ${this.name}${rhs};` + _n;
    }
    optimizeNames(names, constants) {
      if (!names[this.name.str])
        return;
      if (this.rhs)
        this.rhs = optimizeExpr(this.rhs, names, constants);
      return this;
    }
    get names() {
      return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
    }
  }

  class Assign extends Node {
    constructor(lhs, rhs, sideEffects) {
      super();
      this.lhs = lhs;
      this.rhs = rhs;
      this.sideEffects = sideEffects;
    }
    render({ _n }) {
      return `${this.lhs} = ${this.rhs};` + _n;
    }
    optimizeNames(names, constants) {
      if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)
        return;
      this.rhs = optimizeExpr(this.rhs, names, constants);
      return this;
    }
    get names() {
      const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
      return addExprNames(names, this.rhs);
    }
  }

  class AssignOp extends Assign {
    constructor(lhs, op, rhs, sideEffects) {
      super(lhs, rhs, sideEffects);
      this.op = op;
    }
    render({ _n }) {
      return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
    }
  }

  class Label extends Node {
    constructor(label) {
      super();
      this.label = label;
      this.names = {};
    }
    render({ _n }) {
      return `${this.label}:` + _n;
    }
  }

  class Break extends Node {
    constructor(label) {
      super();
      this.label = label;
      this.names = {};
    }
    render({ _n }) {
      const label = this.label ? ` ${this.label}` : "";
      return `break${label};` + _n;
    }
  }

  class Throw extends Node {
    constructor(error49) {
      super();
      this.error = error49;
    }
    render({ _n }) {
      return `throw ${this.error};` + _n;
    }
    get names() {
      return this.error.names;
    }
  }

  class AnyCode extends Node {
    constructor(code) {
      super();
      this.code = code;
    }
    render({ _n }) {
      return `${this.code};` + _n;
    }
    optimizeNodes() {
      return `${this.code}` ? this : undefined;
    }
    optimizeNames(names, constants) {
      this.code = optimizeExpr(this.code, names, constants);
      return this;
    }
    get names() {
      return this.code instanceof code_1._CodeOrName ? this.code.names : {};
    }
  }

  class ParentNode extends Node {
    constructor(nodes = []) {
      super();
      this.nodes = nodes;
    }
    render(opts) {
      return this.nodes.reduce((code, n) => code + n.render(opts), "");
    }
    optimizeNodes() {
      const { nodes } = this;
      let i = nodes.length;
      while (i--) {
        const n = nodes[i].optimizeNodes();
        if (Array.isArray(n))
          nodes.splice(i, 1, ...n);
        else if (n)
          nodes[i] = n;
        else
          nodes.splice(i, 1);
      }
      return nodes.length > 0 ? this : undefined;
    }
    optimizeNames(names, constants) {
      const { nodes } = this;
      let i = nodes.length;
      while (i--) {
        const n = nodes[i];
        if (n.optimizeNames(names, constants))
          continue;
        subtractNames(names, n.names);
        nodes.splice(i, 1);
      }
      return nodes.length > 0 ? this : undefined;
    }
    get names() {
      return this.nodes.reduce((names, n) => addNames(names, n.names), {});
    }
  }

  class BlockNode extends ParentNode {
    render(opts) {
      return "{" + opts._n + super.render(opts) + "}" + opts._n;
    }
  }

  class Root extends ParentNode {
  }

  class Else extends BlockNode {
  }
  Else.kind = "else";

  class If extends BlockNode {
    constructor(condition, nodes) {
      super(nodes);
      this.condition = condition;
    }
    render(opts) {
      let code = `if(${this.condition})` + super.render(opts);
      if (this.else)
        code += "else " + this.else.render(opts);
      return code;
    }
    optimizeNodes() {
      super.optimizeNodes();
      const cond = this.condition;
      if (cond === true)
        return this.nodes;
      let e = this.else;
      if (e) {
        const ns = e.optimizeNodes();
        e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
      }
      if (e) {
        if (cond === false)
          return e instanceof If ? e : e.nodes;
        if (this.nodes.length)
          return this;
        return new If(not(cond), e instanceof If ? [e] : e.nodes);
      }
      if (cond === false || !this.nodes.length)
        return;
      return this;
    }
    optimizeNames(names, constants) {
      var _a2;
      this.else = (_a2 = this.else) === null || _a2 === undefined ? undefined : _a2.optimizeNames(names, constants);
      if (!(super.optimizeNames(names, constants) || this.else))
        return;
      this.condition = optimizeExpr(this.condition, names, constants);
      return this;
    }
    get names() {
      const names = super.names;
      addExprNames(names, this.condition);
      if (this.else)
        addNames(names, this.else.names);
      return names;
    }
  }
  If.kind = "if";

  class For extends BlockNode {
  }
  For.kind = "for";

  class ForLoop extends For {
    constructor(iteration) {
      super();
      this.iteration = iteration;
    }
    render(opts) {
      return `for(${this.iteration})` + super.render(opts);
    }
    optimizeNames(names, constants) {
      if (!super.optimizeNames(names, constants))
        return;
      this.iteration = optimizeExpr(this.iteration, names, constants);
      return this;
    }
    get names() {
      return addNames(super.names, this.iteration.names);
    }
  }

  class ForRange extends For {
    constructor(varKind, name, from, to) {
      super();
      this.varKind = varKind;
      this.name = name;
      this.from = from;
      this.to = to;
    }
    render(opts) {
      const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
      const { name, from, to } = this;
      return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
    }
    get names() {
      const names = addExprNames(super.names, this.from);
      return addExprNames(names, this.to);
    }
  }

  class ForIter extends For {
    constructor(loop, varKind, name, iterable) {
      super();
      this.loop = loop;
      this.varKind = varKind;
      this.name = name;
      this.iterable = iterable;
    }
    render(opts) {
      return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
    }
    optimizeNames(names, constants) {
      if (!super.optimizeNames(names, constants))
        return;
      this.iterable = optimizeExpr(this.iterable, names, constants);
      return this;
    }
    get names() {
      return addNames(super.names, this.iterable.names);
    }
  }

  class Func extends BlockNode {
    constructor(name, args, async) {
      super();
      this.name = name;
      this.args = args;
      this.async = async;
    }
    render(opts) {
      const _async = this.async ? "async " : "";
      return `${_async}function ${this.name}(${this.args})` + super.render(opts);
    }
  }
  Func.kind = "func";

  class Return extends ParentNode {
    render(opts) {
      return "return " + super.render(opts);
    }
  }
  Return.kind = "return";

  class Try extends BlockNode {
    render(opts) {
      let code = "try" + super.render(opts);
      if (this.catch)
        code += this.catch.render(opts);
      if (this.finally)
        code += this.finally.render(opts);
      return code;
    }
    optimizeNodes() {
      var _a2, _b;
      super.optimizeNodes();
      (_a2 = this.catch) === null || _a2 === undefined || _a2.optimizeNodes();
      (_b = this.finally) === null || _b === undefined || _b.optimizeNodes();
      return this;
    }
    optimizeNames(names, constants) {
      var _a2, _b;
      super.optimizeNames(names, constants);
      (_a2 = this.catch) === null || _a2 === undefined || _a2.optimizeNames(names, constants);
      (_b = this.finally) === null || _b === undefined || _b.optimizeNames(names, constants);
      return this;
    }
    get names() {
      const names = super.names;
      if (this.catch)
        addNames(names, this.catch.names);
      if (this.finally)
        addNames(names, this.finally.names);
      return names;
    }
  }

  class Catch extends BlockNode {
    constructor(error49) {
      super();
      this.error = error49;
    }
    render(opts) {
      return `catch(${this.error})` + super.render(opts);
    }
  }
  Catch.kind = "catch";

  class Finally extends BlockNode {
    render(opts) {
      return "finally" + super.render(opts);
    }
  }
  Finally.kind = "finally";

  class CodeGen {
    constructor(extScope, opts = {}) {
      this._values = {};
      this._blockStarts = [];
      this._constants = {};
      this.opts = { ...opts, _n: opts.lines ? `
` : "" };
      this._extScope = extScope;
      this._scope = new scope_1.Scope({ parent: extScope });
      this._nodes = [new Root];
    }
    toString() {
      return this._root.render(this.opts);
    }
    name(prefix) {
      return this._scope.name(prefix);
    }
    scopeName(prefix) {
      return this._extScope.name(prefix);
    }
    scopeValue(prefixOrName, value) {
      const name = this._extScope.value(prefixOrName, value);
      const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set);
      vs.add(name);
      return name;
    }
    getScopeValue(prefix, keyOrRef) {
      return this._extScope.getValue(prefix, keyOrRef);
    }
    scopeRefs(scopeName) {
      return this._extScope.scopeRefs(scopeName, this._values);
    }
    scopeCode() {
      return this._extScope.scopeCode(this._values);
    }
    _def(varKind, nameOrPrefix, rhs, constant) {
      const name = this._scope.toName(nameOrPrefix);
      if (rhs !== undefined && constant)
        this._constants[name.str] = rhs;
      this._leafNode(new Def(varKind, name, rhs));
      return name;
    }
    const(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
    }
    let(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
    }
    var(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
    }
    assign(lhs, rhs, sideEffects) {
      return this._leafNode(new Assign(lhs, rhs, sideEffects));
    }
    add(lhs, rhs) {
      return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
    }
    code(c) {
      if (typeof c == "function")
        c();
      else if (c !== code_1.nil)
        this._leafNode(new AnyCode(c));
      return this;
    }
    object(...keyValues) {
      const code = ["{"];
      for (const [key, value] of keyValues) {
        if (code.length > 1)
          code.push(",");
        code.push(key);
        if (key !== value || this.opts.es5) {
          code.push(":");
          (0, code_1.addCodeArg)(code, value);
        }
      }
      code.push("}");
      return new code_1._Code(code);
    }
    if(condition, thenBody, elseBody) {
      this._blockNode(new If(condition));
      if (thenBody && elseBody) {
        this.code(thenBody).else().code(elseBody).endIf();
      } else if (thenBody) {
        this.code(thenBody).endIf();
      } else if (elseBody) {
        throw new Error('CodeGen: "else" body without "then" body');
      }
      return this;
    }
    elseIf(condition) {
      return this._elseNode(new If(condition));
    }
    else() {
      return this._elseNode(new Else);
    }
    endIf() {
      return this._endBlockNode(If, Else);
    }
    _for(node, forBody) {
      this._blockNode(node);
      if (forBody)
        this.code(forBody).endFor();
      return this;
    }
    for(iteration, forBody) {
      return this._for(new ForLoop(iteration), forBody);
    }
    forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
      const name = this._scope.toName(nameOrPrefix);
      return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
    }
    forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
      const name = this._scope.toName(nameOrPrefix);
      if (this.opts.es5) {
        const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
        return this.forRange("_i", 0, (0, code_1._)`${arr}.length`, (i) => {
          this.var(name, (0, code_1._)`${arr}[${i}]`);
          forBody(name);
        });
      }
      return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
    }
    forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
      if (this.opts.ownProperties) {
        return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);
      }
      const name = this._scope.toName(nameOrPrefix);
      return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
    }
    endFor() {
      return this._endBlockNode(For);
    }
    label(label) {
      return this._leafNode(new Label(label));
    }
    break(label) {
      return this._leafNode(new Break(label));
    }
    return(value) {
      const node = new Return;
      this._blockNode(node);
      this.code(value);
      if (node.nodes.length !== 1)
        throw new Error('CodeGen: "return" should have one node');
      return this._endBlockNode(Return);
    }
    try(tryBody, catchCode, finallyCode) {
      if (!catchCode && !finallyCode)
        throw new Error('CodeGen: "try" without "catch" and "finally"');
      const node = new Try;
      this._blockNode(node);
      this.code(tryBody);
      if (catchCode) {
        const error49 = this.name("e");
        this._currNode = node.catch = new Catch(error49);
        catchCode(error49);
      }
      if (finallyCode) {
        this._currNode = node.finally = new Finally;
        this.code(finallyCode);
      }
      return this._endBlockNode(Catch, Finally);
    }
    throw(error49) {
      return this._leafNode(new Throw(error49));
    }
    block(body, nodeCount) {
      this._blockStarts.push(this._nodes.length);
      if (body)
        this.code(body).endBlock(nodeCount);
      return this;
    }
    endBlock(nodeCount) {
      const len = this._blockStarts.pop();
      if (len === undefined)
        throw new Error("CodeGen: not in self-balancing block");
      const toClose = this._nodes.length - len;
      if (toClose < 0 || nodeCount !== undefined && toClose !== nodeCount) {
        throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
      }
      this._nodes.length = len;
      return this;
    }
    func(name, args = code_1.nil, async, funcBody) {
      this._blockNode(new Func(name, args, async));
      if (funcBody)
        this.code(funcBody).endFunc();
      return this;
    }
    endFunc() {
      return this._endBlockNode(Func);
    }
    optimize(n = 1) {
      while (n-- > 0) {
        this._root.optimizeNodes();
        this._root.optimizeNames(this._root.names, this._constants);
      }
    }
    _leafNode(node) {
      this._currNode.nodes.push(node);
      return this;
    }
    _blockNode(node) {
      this._currNode.nodes.push(node);
      this._nodes.push(node);
    }
    _endBlockNode(N1, N2) {
      const n = this._currNode;
      if (n instanceof N1 || N2 && n instanceof N2) {
        this._nodes.pop();
        return this;
      }
      throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
    }
    _elseNode(node) {
      const n = this._currNode;
      if (!(n instanceof If)) {
        throw new Error('CodeGen: "else" without "if"');
      }
      this._currNode = n.else = node;
      return this;
    }
    get _root() {
      return this._nodes[0];
    }
    get _currNode() {
      const ns = this._nodes;
      return ns[ns.length - 1];
    }
    set _currNode(node) {
      const ns = this._nodes;
      ns[ns.length - 1] = node;
    }
  }
  exports.CodeGen = CodeGen;
  function addNames(names, from) {
    for (const n in from)
      names[n] = (names[n] || 0) + (from[n] || 0);
    return names;
  }
  function addExprNames(names, from) {
    return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;
  }
  function optimizeExpr(expr, names, constants) {
    if (expr instanceof code_1.Name)
      return replaceName(expr);
    if (!canOptimize(expr))
      return expr;
    return new code_1._Code(expr._items.reduce((items, c) => {
      if (c instanceof code_1.Name)
        c = replaceName(c);
      if (c instanceof code_1._Code)
        items.push(...c._items);
      else
        items.push(c);
      return items;
    }, []));
    function replaceName(n) {
      const c = constants[n.str];
      if (c === undefined || names[n.str] !== 1)
        return n;
      delete names[n.str];
      return c;
    }
    function canOptimize(e) {
      return e instanceof code_1._Code && e._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== undefined);
    }
  }
  function subtractNames(names, from) {
    for (const n in from)
      names[n] = (names[n] || 0) - (from[n] || 0);
  }
  function not(x) {
    return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._)`!${par(x)}`;
  }
  exports.not = not;
  var andCode = mappend(exports.operators.AND);
  function and(...args) {
    return args.reduce(andCode);
  }
  exports.and = and;
  var orCode = mappend(exports.operators.OR);
  function or(...args) {
    return args.reduce(orCode);
  }
  exports.or = or;
  function mappend(op) {
    return (x, y) => x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._)`${par(x)} ${op} ${par(y)}`;
  }
  function par(x) {
    return x instanceof code_1.Name ? x : (0, code_1._)`(${x})`;
  }
});

// node_modules/ajv/dist/compile/util.js
var require_util = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = undefined;
  var codegen_1 = require_codegen();
  var code_1 = require_code();
  function toHash(arr) {
    const hash2 = {};
    for (const item of arr)
      hash2[item] = true;
    return hash2;
  }
  exports.toHash = toHash;
  function alwaysValidSchema(it, schema) {
    if (typeof schema == "boolean")
      return schema;
    if (Object.keys(schema).length === 0)
      return true;
    checkUnknownRules(it, schema);
    return !schemaHasRules(schema, it.self.RULES.all);
  }
  exports.alwaysValidSchema = alwaysValidSchema;
  function checkUnknownRules(it, schema = it.schema) {
    const { opts, self: self2 } = it;
    if (!opts.strictSchema)
      return;
    if (typeof schema === "boolean")
      return;
    const rules = self2.RULES.keywords;
    for (const key in schema) {
      if (!rules[key])
        checkStrictMode(it, `unknown keyword: "${key}"`);
    }
  }
  exports.checkUnknownRules = checkUnknownRules;
  function schemaHasRules(schema, rules) {
    if (typeof schema == "boolean")
      return !schema;
    for (const key in schema)
      if (rules[key])
        return true;
    return false;
  }
  exports.schemaHasRules = schemaHasRules;
  function schemaHasRulesButRef(schema, RULES) {
    if (typeof schema == "boolean")
      return !schema;
    for (const key in schema)
      if (key !== "$ref" && RULES.all[key])
        return true;
    return false;
  }
  exports.schemaHasRulesButRef = schemaHasRulesButRef;
  function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {
    if (!$data) {
      if (typeof schema == "number" || typeof schema == "boolean")
        return schema;
      if (typeof schema == "string")
        return (0, codegen_1._)`${schema}`;
    }
    return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;
  }
  exports.schemaRefOrVal = schemaRefOrVal;
  function unescapeFragment(str2) {
    return unescapeJsonPointer(decodeURIComponent(str2));
  }
  exports.unescapeFragment = unescapeFragment;
  function escapeFragment(str2) {
    return encodeURIComponent(escapeJsonPointer(str2));
  }
  exports.escapeFragment = escapeFragment;
  function escapeJsonPointer(str2) {
    if (typeof str2 == "number")
      return `${str2}`;
    return str2.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  exports.escapeJsonPointer = escapeJsonPointer;
  function unescapeJsonPointer(str2) {
    return str2.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  exports.unescapeJsonPointer = unescapeJsonPointer;
  function eachItem(xs, f) {
    if (Array.isArray(xs)) {
      for (const x of xs)
        f(x);
    } else {
      f(xs);
    }
  }
  exports.eachItem = eachItem;
  function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues: mergeValues3, resultToName }) {
    return (gen, from, to, toName) => {
      const res = to === undefined ? from : to instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1.Name ? (mergeToName(gen, to, from), from) : mergeValues3(from, to);
      return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
    };
  }
  exports.mergeEvaluated = {
    props: makeMergeEvaluated({
      mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => {
        gen.if((0, codegen_1._)`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._)`${to} || {}`).code((0, codegen_1._)`Object.assign(${to}, ${from})`));
      }),
      mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => {
        if (from === true) {
          gen.assign(to, true);
        } else {
          gen.assign(to, (0, codegen_1._)`${to} || {}`);
          setEvaluated(gen, to, from);
        }
      }),
      mergeValues: (from, to) => from === true ? true : { ...from, ...to },
      resultToName: evaluatedPropsToName
    }),
    items: makeMergeEvaluated({
      mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
      mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._)`${to} > ${from} ? ${to} : ${from}`)),
      mergeValues: (from, to) => from === true ? true : Math.max(from, to),
      resultToName: (gen, items) => gen.var("items", items)
    })
  };
  function evaluatedPropsToName(gen, ps) {
    if (ps === true)
      return gen.var("props", true);
    const props = gen.var("props", (0, codegen_1._)`{}`);
    if (ps !== undefined)
      setEvaluated(gen, props, ps);
    return props;
  }
  exports.evaluatedPropsToName = evaluatedPropsToName;
  function setEvaluated(gen, props, ps) {
    Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p)}`, true));
  }
  exports.setEvaluated = setEvaluated;
  var snippets = {};
  function useFunc(gen, f) {
    return gen.scopeValue("func", {
      ref: f,
      code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code))
    });
  }
  exports.useFunc = useFunc;
  var Type;
  (function(Type2) {
    Type2[Type2["Num"] = 0] = "Num";
    Type2[Type2["Str"] = 1] = "Str";
  })(Type || (exports.Type = Type = {}));
  function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
    if (dataProp instanceof codegen_1.Name) {
      const isNumber = dataPropType === Type.Num;
      return jsPropertySyntax ? isNumber ? (0, codegen_1._)`"[" + ${dataProp} + "]"` : (0, codegen_1._)`"['" + ${dataProp} + "']"` : isNumber ? (0, codegen_1._)`"/" + ${dataProp}` : (0, codegen_1._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
    }
    return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
  }
  exports.getErrorPath = getErrorPath;
  function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
    if (!mode)
      return;
    msg = `strict mode: ${msg}`;
    if (mode === true)
      throw new Error(msg);
    it.self.logger.warn(msg);
  }
  exports.checkStrictMode = checkStrictMode;
});

// node_modules/ajv/dist/compile/names.js
var require_names = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var names = {
    data: new codegen_1.Name("data"),
    valCxt: new codegen_1.Name("valCxt"),
    instancePath: new codegen_1.Name("instancePath"),
    parentData: new codegen_1.Name("parentData"),
    parentDataProperty: new codegen_1.Name("parentDataProperty"),
    rootData: new codegen_1.Name("rootData"),
    dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
    vErrors: new codegen_1.Name("vErrors"),
    errors: new codegen_1.Name("errors"),
    this: new codegen_1.Name("this"),
    self: new codegen_1.Name("self"),
    scope: new codegen_1.Name("scope"),
    json: new codegen_1.Name("json"),
    jsonPos: new codegen_1.Name("jsonPos"),
    jsonLen: new codegen_1.Name("jsonLen"),
    jsonPart: new codegen_1.Name("jsonPart")
  };
  exports.default = names;
});

// node_modules/ajv/dist/compile/errors.js
var require_errors = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = undefined;
  var codegen_1 = require_codegen();
  var util_1 = require_util();
  var names_1 = require_names();
  exports.keywordError = {
    message: ({ keyword }) => (0, codegen_1.str)`must pass "${keyword}" keyword validation`
  };
  exports.keyword$DataError = {
    message: ({ keyword, schemaType }) => schemaType ? (0, codegen_1.str)`"${keyword}" keyword must be ${schemaType} ($data)` : (0, codegen_1.str)`"${keyword}" keyword is invalid ($data)`
  };
  function reportError(cxt, error49 = exports.keywordError, errorPaths, overrideAllErrors) {
    const { it } = cxt;
    const { gen, compositeRule, allErrors } = it;
    const errObj = errorObjectCode(cxt, error49, errorPaths);
    if (overrideAllErrors !== null && overrideAllErrors !== undefined ? overrideAllErrors : compositeRule || allErrors) {
      addError(gen, errObj);
    } else {
      returnErrors(it, (0, codegen_1._)`[${errObj}]`);
    }
  }
  exports.reportError = reportError;
  function reportExtraError(cxt, error49 = exports.keywordError, errorPaths) {
    const { it } = cxt;
    const { gen, compositeRule, allErrors } = it;
    const errObj = errorObjectCode(cxt, error49, errorPaths);
    addError(gen, errObj);
    if (!(compositeRule || allErrors)) {
      returnErrors(it, names_1.default.vErrors);
    }
  }
  exports.reportExtraError = reportExtraError;
  function resetErrorsCount(gen, errsCount) {
    gen.assign(names_1.default.errors, errsCount);
    gen.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._)`${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
  }
  exports.resetErrorsCount = resetErrorsCount;
  function extendErrors({ gen, keyword, schemaValue, data, errsCount, it }) {
    if (errsCount === undefined)
      throw new Error("ajv implementation error");
    const err = gen.name("err");
    gen.forRange("i", errsCount, names_1.default.errors, (i) => {
      gen.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i}]`);
      gen.if((0, codegen_1._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._)`${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));
      gen.assign((0, codegen_1._)`${err}.schemaPath`, (0, codegen_1.str)`${it.errSchemaPath}/${keyword}`);
      if (it.opts.verbose) {
        gen.assign((0, codegen_1._)`${err}.schema`, schemaValue);
        gen.assign((0, codegen_1._)`${err}.data`, data);
      }
    });
  }
  exports.extendErrors = extendErrors;
  function addError(gen, errObj) {
    const err = gen.const("err", errObj);
    gen.if((0, codegen_1._)`${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`), (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`);
    gen.code((0, codegen_1._)`${names_1.default.errors}++`);
  }
  function returnErrors(it, errs) {
    const { gen, validateName, schemaEnv } = it;
    if (schemaEnv.$async) {
      gen.throw((0, codegen_1._)`new ${it.ValidationError}(${errs})`);
    } else {
      gen.assign((0, codegen_1._)`${validateName}.errors`, errs);
      gen.return(false);
    }
  }
  var E = {
    keyword: new codegen_1.Name("keyword"),
    schemaPath: new codegen_1.Name("schemaPath"),
    params: new codegen_1.Name("params"),
    propertyName: new codegen_1.Name("propertyName"),
    message: new codegen_1.Name("message"),
    schema: new codegen_1.Name("schema"),
    parentSchema: new codegen_1.Name("parentSchema")
  };
  function errorObjectCode(cxt, error49, errorPaths) {
    const { createErrors } = cxt.it;
    if (createErrors === false)
      return (0, codegen_1._)`{}`;
    return errorObject(cxt, error49, errorPaths);
  }
  function errorObject(cxt, error49, errorPaths = {}) {
    const { gen, it } = cxt;
    const keyValues = [
      errorInstancePath(it, errorPaths),
      errorSchemaPath(cxt, errorPaths)
    ];
    extraErrorProps(cxt, error49, keyValues);
    return gen.object(...keyValues);
  }
  function errorInstancePath({ errorPath }, { instancePath }) {
    const instPath = instancePath ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}` : errorPath;
    return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
  }
  function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
    let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str)`${errSchemaPath}/${keyword}`;
    if (schemaPath) {
      schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
    }
    return [E.schemaPath, schPath];
  }
  function extraErrorProps(cxt, { params, message }, keyValues) {
    const { keyword, data, schemaValue, it } = cxt;
    const { opts, propertyName, topSchemaRef, schemaPath } = it;
    keyValues.push([E.keyword, keyword], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._)`{}`]);
    if (opts.messages) {
      keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
    }
    if (opts.verbose) {
      keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
    }
    if (propertyName)
      keyValues.push([E.propertyName, propertyName]);
  }
});

// node_modules/ajv/dist/compile/validate/boolSchema.js
var require_boolSchema = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.boolOrEmptySchema = exports.topBoolOrEmptySchema = undefined;
  var errors_1 = require_errors();
  var codegen_1 = require_codegen();
  var names_1 = require_names();
  var boolError = {
    message: "boolean schema is false"
  };
  function topBoolOrEmptySchema(it) {
    const { gen, schema, validateName } = it;
    if (schema === false) {
      falseSchemaError(it, false);
    } else if (typeof schema == "object" && schema.$async === true) {
      gen.return(names_1.default.data);
    } else {
      gen.assign((0, codegen_1._)`${validateName}.errors`, null);
      gen.return(true);
    }
  }
  exports.topBoolOrEmptySchema = topBoolOrEmptySchema;
  function boolOrEmptySchema(it, valid) {
    const { gen, schema } = it;
    if (schema === false) {
      gen.var(valid, false);
      falseSchemaError(it);
    } else {
      gen.var(valid, true);
    }
  }
  exports.boolOrEmptySchema = boolOrEmptySchema;
  function falseSchemaError(it, overrideAllErrors) {
    const { gen, data } = it;
    const cxt = {
      gen,
      keyword: "false schema",
      data,
      schema: false,
      schemaCode: false,
      schemaValue: false,
      params: {},
      it
    };
    (0, errors_1.reportError)(cxt, boolError, undefined, overrideAllErrors);
  }
});

// node_modules/ajv/dist/compile/rules.js
var require_rules = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getRules = exports.isJSONType = undefined;
  var _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
  var jsonTypes = new Set(_jsonTypes);
  function isJSONType(x) {
    return typeof x == "string" && jsonTypes.has(x);
  }
  exports.isJSONType = isJSONType;
  function getRules() {
    const groups = {
      number: { type: "number", rules: [] },
      string: { type: "string", rules: [] },
      array: { type: "array", rules: [] },
      object: { type: "object", rules: [] }
    };
    return {
      types: { ...groups, integer: true, boolean: true, null: true },
      rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
      post: { rules: [] },
      all: {},
      keywords: {}
    };
  }
  exports.getRules = getRules;
});

// node_modules/ajv/dist/compile/validate/applicability.js
var require_applicability = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.shouldUseRule = exports.shouldUseGroup = exports.schemaHasRulesForType = undefined;
  function schemaHasRulesForType({ schema, self: self2 }, type) {
    const group = self2.RULES.types[type];
    return group && group !== true && shouldUseGroup(schema, group);
  }
  exports.schemaHasRulesForType = schemaHasRulesForType;
  function shouldUseGroup(schema, group) {
    return group.rules.some((rule) => shouldUseRule(schema, rule));
  }
  exports.shouldUseGroup = shouldUseGroup;
  function shouldUseRule(schema, rule) {
    var _a2;
    return schema[rule.keyword] !== undefined || ((_a2 = rule.definition.implements) === null || _a2 === undefined ? undefined : _a2.some((kwd) => schema[kwd] !== undefined));
  }
  exports.shouldUseRule = shouldUseRule;
});

// node_modules/ajv/dist/compile/validate/dataType.js
var require_dataType = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = undefined;
  var rules_1 = require_rules();
  var applicability_1 = require_applicability();
  var errors_1 = require_errors();
  var codegen_1 = require_codegen();
  var util_1 = require_util();
  var DataType;
  (function(DataType2) {
    DataType2[DataType2["Correct"] = 0] = "Correct";
    DataType2[DataType2["Wrong"] = 1] = "Wrong";
  })(DataType || (exports.DataType = DataType = {}));
  function getSchemaTypes(schema) {
    const types = getJSONTypes(schema.type);
    const hasNull = types.includes("null");
    if (hasNull) {
      if (schema.nullable === false)
        throw new Error("type: null contradicts nullable: false");
    } else {
      if (!types.length && schema.nullable !== undefined) {
        throw new Error('"nullable" cannot be used without "type"');
      }
      if (schema.nullable === true)
        types.push("null");
    }
    return types;
  }
  exports.getSchemaTypes = getSchemaTypes;
  function getJSONTypes(ts) {
    const types = Array.isArray(ts) ? ts : ts ? [ts] : [];
    if (types.every(rules_1.isJSONType))
      return types;
    throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
  }
  exports.getJSONTypes = getJSONTypes;
  function coerceAndCheckDataType(it, types) {
    const { gen, data, opts } = it;
    const coerceTo = coerceToTypes(types, opts.coerceTypes);
    const checkTypes = types.length > 0 && !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));
    if (checkTypes) {
      const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);
      gen.if(wrongType, () => {
        if (coerceTo.length)
          coerceData(it, types, coerceTo);
        else
          reportTypeError(it);
      });
    }
    return checkTypes;
  }
  exports.coerceAndCheckDataType = coerceAndCheckDataType;
  var COERCIBLE = new Set(["string", "number", "integer", "boolean", "null"]);
  function coerceToTypes(types, coerceTypes) {
    return coerceTypes ? types.filter((t) => COERCIBLE.has(t) || coerceTypes === "array" && t === "array") : [];
  }
  function coerceData(it, types, coerceTo) {
    const { gen, data, opts } = it;
    const dataType = gen.let("dataType", (0, codegen_1._)`typeof ${data}`);
    const coerced = gen.let("coerced", (0, codegen_1._)`undefined`);
    if (opts.coerceTypes === "array") {
      gen.if((0, codegen_1._)`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1._)`${data}[0]`).assign(dataType, (0, codegen_1._)`typeof ${data}`).if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));
    }
    gen.if((0, codegen_1._)`${coerced} !== undefined`);
    for (const t of coerceTo) {
      if (COERCIBLE.has(t) || t === "array" && opts.coerceTypes === "array") {
        coerceSpecificType(t);
      }
    }
    gen.else();
    reportTypeError(it);
    gen.endIf();
    gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {
      gen.assign(data, coerced);
      assignParentData(it, coerced);
    });
    function coerceSpecificType(t) {
      switch (t) {
        case "string":
          gen.elseIf((0, codegen_1._)`${dataType} == "number" || ${dataType} == "boolean"`).assign(coerced, (0, codegen_1._)`"" + ${data}`).elseIf((0, codegen_1._)`${data} === null`).assign(coerced, (0, codegen_1._)`""`);
          return;
        case "number":
          gen.elseIf((0, codegen_1._)`${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1._)`+${data}`);
          return;
        case "integer":
          gen.elseIf((0, codegen_1._)`${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1._)`+${data}`);
          return;
        case "boolean":
          gen.elseIf((0, codegen_1._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
          return;
        case "null":
          gen.elseIf((0, codegen_1._)`${data} === "" || ${data} === 0 || ${data} === false`);
          gen.assign(coerced, null);
          return;
        case "array":
          gen.elseIf((0, codegen_1._)`${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1._)`[${data}]`);
      }
    }
  }
  function assignParentData({ gen, parentData, parentDataProperty }, expr) {
    gen.if((0, codegen_1._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr));
  }
  function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
    const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
    let cond;
    switch (dataType) {
      case "null":
        return (0, codegen_1._)`${data} ${EQ} null`;
      case "array":
        cond = (0, codegen_1._)`Array.isArray(${data})`;
        break;
      case "object":
        cond = (0, codegen_1._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
        break;
      case "integer":
        cond = numCond((0, codegen_1._)`!(${data} % 1) && !isNaN(${data})`);
        break;
      case "number":
        cond = numCond();
        break;
      default:
        return (0, codegen_1._)`typeof ${data} ${EQ} ${dataType}`;
    }
    return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
    function numCond(_cond = codegen_1.nil) {
      return (0, codegen_1.and)((0, codegen_1._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._)`isFinite(${data})` : codegen_1.nil);
    }
  }
  exports.checkDataType = checkDataType;
  function checkDataTypes(dataTypes, data, strictNums, correct) {
    if (dataTypes.length === 1) {
      return checkDataType(dataTypes[0], data, strictNums, correct);
    }
    let cond;
    const types = (0, util_1.toHash)(dataTypes);
    if (types.array && types.object) {
      const notObj = (0, codegen_1._)`typeof ${data} != "object"`;
      cond = types.null ? notObj : (0, codegen_1._)`!${data} || ${notObj}`;
      delete types.null;
      delete types.array;
      delete types.object;
    } else {
      cond = codegen_1.nil;
    }
    if (types.number)
      delete types.integer;
    for (const t in types)
      cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));
    return cond;
  }
  exports.checkDataTypes = checkDataTypes;
  var typeError = {
    message: ({ schema }) => `must be ${schema}`,
    params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._)`{type: ${schema}}` : (0, codegen_1._)`{type: ${schemaValue}}`
  };
  function reportTypeError(it) {
    const cxt = getTypeErrorContext(it);
    (0, errors_1.reportError)(cxt, typeError);
  }
  exports.reportTypeError = reportTypeError;
  function getTypeErrorContext(it) {
    const { gen, data, schema } = it;
    const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");
    return {
      gen,
      keyword: "type",
      data,
      schema: schema.type,
      schemaCode,
      schemaValue: schemaCode,
      parentSchema: schema,
      params: {},
      it
    };
  }
});

// node_modules/ajv/dist/compile/validate/defaults.js
var require_defaults = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.assignDefaults = undefined;
  var codegen_1 = require_codegen();
  var util_1 = require_util();
  function assignDefaults(it, ty) {
    const { properties, items } = it.schema;
    if (ty === "object" && properties) {
      for (const key in properties) {
        assignDefault(it, key, properties[key].default);
      }
    } else if (ty === "array" && Array.isArray(items)) {
      items.forEach((sch, i) => assignDefault(it, i, sch.default));
    }
  }
  exports.assignDefaults = assignDefaults;
  function assignDefault(it, prop, defaultValue) {
    const { gen, compositeRule, data, opts } = it;
    if (defaultValue === undefined)
      return;
    const childData = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(prop)}`;
    if (compositeRule) {
      (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
      return;
    }
    let condition = (0, codegen_1._)`${childData} === undefined`;
    if (opts.useDefaults === "empty") {
      condition = (0, codegen_1._)`${condition} || ${childData} === null || ${childData} === ""`;
    }
    gen.if(condition, (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
  }
});

// node_modules/ajv/dist/vocabularies/code.js
var require_code2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateUnion = exports.validateArray = exports.usePattern = exports.callValidateCode = exports.schemaProperties = exports.allSchemaProperties = exports.noPropertyInData = exports.propertyInData = exports.isOwnProperty = exports.hasPropFunc = exports.reportMissingProp = exports.checkMissingProp = exports.checkReportMissingProp = undefined;
  var codegen_1 = require_codegen();
  var util_1 = require_util();
  var names_1 = require_names();
  var util_2 = require_util();
  function checkReportMissingProp(cxt, prop) {
    const { gen, data, it } = cxt;
    gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
      cxt.setParams({ missingProperty: (0, codegen_1._)`${prop}` }, true);
      cxt.error();
    });
  }
  exports.checkReportMissingProp = checkReportMissingProp;
  function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
    return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._)`${missing} = ${prop}`)));
  }
  exports.checkMissingProp = checkMissingProp;
  function reportMissingProp(cxt, missing) {
    cxt.setParams({ missingProperty: missing }, true);
    cxt.error();
  }
  exports.reportMissingProp = reportMissingProp;
  function hasPropFunc(gen) {
    return gen.scopeValue("func", {
      ref: Object.prototype.hasOwnProperty,
      code: (0, codegen_1._)`Object.prototype.hasOwnProperty`
    });
  }
  exports.hasPropFunc = hasPropFunc;
  function isOwnProperty(gen, data, property) {
    return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
  }
  exports.isOwnProperty = isOwnProperty;
  function propertyInData(gen, data, property, ownProperties) {
    const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} !== undefined`;
    return ownProperties ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
  }
  exports.propertyInData = propertyInData;
  function noPropertyInData(gen, data, property, ownProperties) {
    const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} === undefined`;
    return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
  }
  exports.noPropertyInData = noPropertyInData;
  function allSchemaProperties(schemaMap) {
    return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
  }
  exports.allSchemaProperties = allSchemaProperties;
  function schemaProperties(it, schemaMap) {
    return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));
  }
  exports.schemaProperties = schemaProperties;
  function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
    const dataAndSchema = passSchema ? (0, codegen_1._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
    const valCxt = [
      [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
      [names_1.default.parentData, it.parentData],
      [names_1.default.parentDataProperty, it.parentDataProperty],
      [names_1.default.rootData, names_1.default.rootData]
    ];
    if (it.opts.dynamicRef)
      valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
    const args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
    return context !== codegen_1.nil ? (0, codegen_1._)`${func}.call(${context}, ${args})` : (0, codegen_1._)`${func}(${args})`;
  }
  exports.callValidateCode = callValidateCode;
  var newRegExp = (0, codegen_1._)`new RegExp`;
  function usePattern({ gen, it: { opts } }, pattern) {
    const u = opts.unicodeRegExp ? "u" : "";
    const { regExp } = opts.code;
    const rx = regExp(pattern, u);
    return gen.scopeValue("pattern", {
      key: rx.toString(),
      ref: rx,
      code: (0, codegen_1._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`
    });
  }
  exports.usePattern = usePattern;
  function validateArray(cxt) {
    const { gen, data, keyword, it } = cxt;
    const valid = gen.name("valid");
    if (it.allErrors) {
      const validArr = gen.let("valid", true);
      validateItems(() => gen.assign(validArr, false));
      return validArr;
    }
    gen.var(valid, true);
    validateItems(() => gen.break());
    return valid;
    function validateItems(notValid) {
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      gen.forRange("i", 0, len, (i) => {
        cxt.subschema({
          keyword,
          dataProp: i,
          dataPropType: util_1.Type.Num
        }, valid);
        gen.if((0, codegen_1.not)(valid), notValid);
      });
    }
  }
  exports.validateArray = validateArray;
  function validateUnion(cxt) {
    const { gen, schema, keyword, it } = cxt;
    if (!Array.isArray(schema))
      throw new Error("ajv implementation error");
    const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));
    if (alwaysValid && !it.opts.unevaluated)
      return;
    const valid = gen.let("valid", false);
    const schValid = gen.name("_valid");
    gen.block(() => schema.forEach((_sch, i) => {
      const schCxt = cxt.subschema({
        keyword,
        schemaProp: i,
        compositeRule: true
      }, schValid);
      gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`);
      const merged = cxt.mergeValidEvaluated(schCxt, schValid);
      if (!merged)
        gen.if((0, codegen_1.not)(valid));
    }));
    cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
  }
  exports.validateUnion = validateUnion;
});

// node_modules/ajv/dist/compile/validate/keyword.js
var require_keyword = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = undefined;
  var codegen_1 = require_codegen();
  var names_1 = require_names();
  var code_1 = require_code2();
  var errors_1 = require_errors();
  function macroKeywordCode(cxt, def) {
    const { gen, keyword, schema, parentSchema, it } = cxt;
    const macroSchema = def.macro.call(it.self, schema, parentSchema, it);
    const schemaRef = useKeyword(gen, keyword, macroSchema);
    if (it.opts.validateSchema !== false)
      it.self.validateSchema(macroSchema, true);
    const valid = gen.name("valid");
    cxt.subschema({
      schema: macroSchema,
      schemaPath: codegen_1.nil,
      errSchemaPath: `${it.errSchemaPath}/${keyword}`,
      topSchemaRef: schemaRef,
      compositeRule: true
    }, valid);
    cxt.pass(valid, () => cxt.error(true));
  }
  exports.macroKeywordCode = macroKeywordCode;
  function funcKeywordCode(cxt, def) {
    var _a2;
    const { gen, keyword, schema, parentSchema, $data, it } = cxt;
    checkAsyncKeyword(it, def);
    const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;
    const validateRef = useKeyword(gen, keyword, validate);
    const valid = gen.let("valid");
    cxt.block$data(valid, validateKeyword);
    cxt.ok((_a2 = def.valid) !== null && _a2 !== undefined ? _a2 : valid);
    function validateKeyword() {
      if (def.errors === false) {
        assignValid();
        if (def.modifying)
          modifyData(cxt);
        reportErrs(() => cxt.error());
      } else {
        const ruleErrs = def.async ? validateAsync() : validateSync();
        if (def.modifying)
          modifyData(cxt);
        reportErrs(() => addErrs(cxt, ruleErrs));
      }
    }
    function validateAsync() {
      const ruleErrs = gen.let("ruleErrs", null);
      gen.try(() => assignValid((0, codegen_1._)`await `), (e) => gen.assign(valid, false).if((0, codegen_1._)`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._)`${e}.errors`), () => gen.throw(e)));
      return ruleErrs;
    }
    function validateSync() {
      const validateErrs = (0, codegen_1._)`${validateRef}.errors`;
      gen.assign(validateErrs, null);
      assignValid(codegen_1.nil);
      return validateErrs;
    }
    function assignValid(_await = def.async ? (0, codegen_1._)`await ` : codegen_1.nil) {
      const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;
      const passSchema = !(("compile" in def) && !$data || def.schema === false);
      gen.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
    }
    function reportErrs(errors5) {
      var _a3;
      gen.if((0, codegen_1.not)((_a3 = def.valid) !== null && _a3 !== undefined ? _a3 : valid), errors5);
    }
  }
  exports.funcKeywordCode = funcKeywordCode;
  function modifyData(cxt) {
    const { gen, data, it } = cxt;
    gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._)`${it.parentData}[${it.parentDataProperty}]`));
  }
  function addErrs(cxt, errs) {
    const { gen } = cxt;
    gen.if((0, codegen_1._)`Array.isArray(${errs})`, () => {
      gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
      (0, errors_1.extendErrors)(cxt);
    }, () => cxt.error());
  }
  function checkAsyncKeyword({ schemaEnv }, def) {
    if (def.async && !schemaEnv.$async)
      throw new Error("async keyword in sync schema");
  }
  function useKeyword(gen, keyword, result) {
    if (result === undefined)
      throw new Error(`keyword "${keyword}" failed to compile`);
    return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
  }
  function validSchemaType(schema, schemaType, allowUndefined = false) {
    return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema) : st === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == "undefined");
  }
  exports.validSchemaType = validSchemaType;
  function validateKeywordUsage({ schema, opts, self: self2, errSchemaPath }, def, keyword) {
    if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {
      throw new Error("ajv implementation error");
    }
    const deps = def.dependencies;
    if (deps === null || deps === undefined ? undefined : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
      throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
    }
    if (def.validateSchema) {
      const valid = def.validateSchema(schema[keyword]);
      if (!valid) {
        const msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` + self2.errorsText(def.validateSchema.errors);
        if (opts.validateSchema === "log")
          self2.logger.error(msg);
        else
          throw new Error(msg);
      }
    }
  }
  exports.validateKeywordUsage = validateKeywordUsage;
});

// node_modules/ajv/dist/compile/validate/subschema.js
var require_subschema = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.extendSubschemaMode = exports.extendSubschemaData = exports.getSubschema = undefined;
  var codegen_1 = require_codegen();
  var util_1 = require_util();
  function getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
    if (keyword !== undefined && schema !== undefined) {
      throw new Error('both "keyword" and "schema" passed, only one allowed');
    }
    if (keyword !== undefined) {
      const sch = it.schema[keyword];
      return schemaProp === undefined ? {
        schema: sch,
        schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,
        errSchemaPath: `${it.errSchemaPath}/${keyword}`
      } : {
        schema: sch[schemaProp],
        schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,
        errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`
      };
    }
    if (schema !== undefined) {
      if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {
        throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
      }
      return {
        schema,
        schemaPath,
        topSchemaRef,
        errSchemaPath
      };
    }
    throw new Error('either "keyword" or "schema" must be passed');
  }
  exports.getSubschema = getSubschema;
  function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
    if (data !== undefined && dataProp !== undefined) {
      throw new Error('both "data" and "dataProp" passed, only one allowed');
    }
    const { gen } = it;
    if (dataProp !== undefined) {
      const { errorPath, dataPathArr, opts } = it;
      const nextData = gen.let("data", (0, codegen_1._)`${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
      dataContextProps(nextData);
      subschema.errorPath = (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
      subschema.parentDataProperty = (0, codegen_1._)`${dataProp}`;
      subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
    }
    if (data !== undefined) {
      const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true);
      dataContextProps(nextData);
      if (propertyName !== undefined)
        subschema.propertyName = propertyName;
    }
    if (dataTypes)
      subschema.dataTypes = dataTypes;
    function dataContextProps(_nextData) {
      subschema.data = _nextData;
      subschema.dataLevel = it.dataLevel + 1;
      subschema.dataTypes = [];
      it.definedProperties = new Set;
      subschema.parentData = it.data;
      subschema.dataNames = [...it.dataNames, _nextData];
    }
  }
  exports.extendSubschemaData = extendSubschemaData;
  function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
    if (compositeRule !== undefined)
      subschema.compositeRule = compositeRule;
    if (createErrors !== undefined)
      subschema.createErrors = createErrors;
    if (allErrors !== undefined)
      subschema.allErrors = allErrors;
    subschema.jtdDiscriminator = jtdDiscriminator;
    subschema.jtdMetadata = jtdMetadata;
  }
  exports.extendSubschemaMode = extendSubschemaMode;
});

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS((exports, module) => {
  module.exports = function equal(a, b) {
    if (a === b)
      return true;
    if (a && b && typeof a == "object" && typeof b == "object") {
      if (a.constructor !== b.constructor)
        return false;
      var length, i, keys;
      if (Array.isArray(a)) {
        length = a.length;
        if (length != b.length)
          return false;
        for (i = length;i-- !== 0; )
          if (!equal(a[i], b[i]))
            return false;
        return true;
      }
      if (a.constructor === RegExp)
        return a.source === b.source && a.flags === b.flags;
      if (a.valueOf !== Object.prototype.valueOf)
        return a.valueOf() === b.valueOf();
      if (a.toString !== Object.prototype.toString)
        return a.toString() === b.toString();
      keys = Object.keys(a);
      length = keys.length;
      if (length !== Object.keys(b).length)
        return false;
      for (i = length;i-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
          return false;
      for (i = length;i-- !== 0; ) {
        var key = keys[i];
        if (!equal(a[key], b[key]))
          return false;
      }
      return true;
    }
    return a !== a && b !== b;
  };
});

// node_modules/json-schema-traverse/index.js
var require_json_schema_traverse = __commonJS((exports, module) => {
  var traverse = module.exports = function(schema, opts, cb) {
    if (typeof opts == "function") {
      cb = opts;
      opts = {};
    }
    cb = opts.cb || cb;
    var pre = typeof cb == "function" ? cb : cb.pre || function() {};
    var post = cb.post || function() {};
    _traverse(opts, pre, post, schema, "", schema);
  };
  traverse.keywords = {
    additionalItems: true,
    items: true,
    contains: true,
    additionalProperties: true,
    propertyNames: true,
    not: true,
    if: true,
    then: true,
    else: true
  };
  traverse.arrayKeywords = {
    items: true,
    allOf: true,
    anyOf: true,
    oneOf: true
  };
  traverse.propsKeywords = {
    $defs: true,
    definitions: true,
    properties: true,
    patternProperties: true,
    dependencies: true
  };
  traverse.skipKeywords = {
    default: true,
    enum: true,
    const: true,
    required: true,
    maximum: true,
    minimum: true,
    exclusiveMaximum: true,
    exclusiveMinimum: true,
    multipleOf: true,
    maxLength: true,
    minLength: true,
    pattern: true,
    format: true,
    maxItems: true,
    minItems: true,
    uniqueItems: true,
    maxProperties: true,
    minProperties: true
  };
  function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
    if (schema && typeof schema == "object" && !Array.isArray(schema)) {
      pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      for (var key in schema) {
        var sch = schema[key];
        if (Array.isArray(sch)) {
          if (key in traverse.arrayKeywords) {
            for (var i = 0;i < sch.length; i++)
              _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
          }
        } else if (key in traverse.propsKeywords) {
          if (sch && typeof sch == "object") {
            for (var prop in sch)
              _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
          }
        } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
          _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
        }
      }
      post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    }
  }
  function escapeJsonPtr(str2) {
    return str2.replace(/~/g, "~0").replace(/\//g, "~1");
  }
});

// node_modules/ajv/dist/compile/resolve.js
var require_resolve = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = undefined;
  var util_1 = require_util();
  var equal = require_fast_deep_equal();
  var traverse = require_json_schema_traverse();
  var SIMPLE_INLINED = new Set([
    "type",
    "format",
    "pattern",
    "maxLength",
    "minLength",
    "maxProperties",
    "minProperties",
    "maxItems",
    "minItems",
    "maximum",
    "minimum",
    "uniqueItems",
    "multipleOf",
    "required",
    "enum",
    "const"
  ]);
  function inlineRef(schema, limit = true) {
    if (typeof schema == "boolean")
      return true;
    if (limit === true)
      return !hasRef(schema);
    if (!limit)
      return false;
    return countKeys(schema) <= limit;
  }
  exports.inlineRef = inlineRef;
  var REF_KEYWORDS = new Set([
    "$ref",
    "$recursiveRef",
    "$recursiveAnchor",
    "$dynamicRef",
    "$dynamicAnchor"
  ]);
  function hasRef(schema) {
    for (const key in schema) {
      if (REF_KEYWORDS.has(key))
        return true;
      const sch = schema[key];
      if (Array.isArray(sch) && sch.some(hasRef))
        return true;
      if (typeof sch == "object" && hasRef(sch))
        return true;
    }
    return false;
  }
  function countKeys(schema) {
    let count = 0;
    for (const key in schema) {
      if (key === "$ref")
        return Infinity;
      count++;
      if (SIMPLE_INLINED.has(key))
        continue;
      if (typeof schema[key] == "object") {
        (0, util_1.eachItem)(schema[key], (sch) => count += countKeys(sch));
      }
      if (count === Infinity)
        return Infinity;
    }
    return count;
  }
  function getFullPath(resolver, id = "", normalize2) {
    if (normalize2 !== false)
      id = normalizeId(id);
    const p = resolver.parse(id);
    return _getFullPath(resolver, p);
  }
  exports.getFullPath = getFullPath;
  function _getFullPath(resolver, p) {
    const serialized = resolver.serialize(p);
    return serialized.split("#")[0] + "#";
  }
  exports._getFullPath = _getFullPath;
  var TRAILING_SLASH_HASH = /#\/?$/;
  function normalizeId(id) {
    return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
  }
  exports.normalizeId = normalizeId;
  function resolveUrl(resolver, baseId, id) {
    id = normalizeId(id);
    return resolver.resolve(baseId, id);
  }
  exports.resolveUrl = resolveUrl;
  var ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
  function getSchemaRefs(schema, baseId) {
    if (typeof schema == "boolean")
      return {};
    const { schemaId, uriResolver } = this.opts;
    const schId = normalizeId(schema[schemaId] || baseId);
    const baseIds = { "": schId };
    const pathPrefix = getFullPath(uriResolver, schId, false);
    const localRefs = {};
    const schemaRefs = new Set;
    traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
      if (parentJsonPtr === undefined)
        return;
      const fullPath = pathPrefix + jsonPtr;
      let innerBaseId = baseIds[parentJsonPtr];
      if (typeof sch[schemaId] == "string")
        innerBaseId = addRef.call(this, sch[schemaId]);
      addAnchor.call(this, sch.$anchor);
      addAnchor.call(this, sch.$dynamicAnchor);
      baseIds[jsonPtr] = innerBaseId;
      function addRef(ref) {
        const _resolve = this.opts.uriResolver.resolve;
        ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref);
        if (schemaRefs.has(ref))
          throw ambiguos(ref);
        schemaRefs.add(ref);
        let schOrRef = this.refs[ref];
        if (typeof schOrRef == "string")
          schOrRef = this.refs[schOrRef];
        if (typeof schOrRef == "object") {
          checkAmbiguosRef(sch, schOrRef.schema, ref);
        } else if (ref !== normalizeId(fullPath)) {
          if (ref[0] === "#") {
            checkAmbiguosRef(sch, localRefs[ref], ref);
            localRefs[ref] = sch;
          } else {
            this.refs[ref] = fullPath;
          }
        }
        return ref;
      }
      function addAnchor(anchor) {
        if (typeof anchor == "string") {
          if (!ANCHOR.test(anchor))
            throw new Error(`invalid anchor "${anchor}"`);
          addRef.call(this, `#${anchor}`);
        }
      }
    });
    return localRefs;
    function checkAmbiguosRef(sch1, sch2, ref) {
      if (sch2 !== undefined && !equal(sch1, sch2))
        throw ambiguos(ref);
    }
    function ambiguos(ref) {
      return new Error(`reference "${ref}" resolves to more than one schema`);
    }
  }
  exports.getSchemaRefs = getSchemaRefs;
});

// node_modules/ajv/dist/compile/validate/index.js
var require_validate = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getData = exports.KeywordCxt = exports.validateFunctionCode = undefined;
  var boolSchema_1 = require_boolSchema();
  var dataType_1 = require_dataType();
  var applicability_1 = require_applicability();
  var dataType_2 = require_dataType();
  var defaults_1 = require_defaults();
  var keyword_1 = require_keyword();
  var subschema_1 = require_subschema();
  var codegen_1 = require_codegen();
  var names_1 = require_names();
  var resolve_1 = require_resolve();
  var util_1 = require_util();
  var errors_1 = require_errors();
  function validateFunctionCode(it) {
    if (isSchemaObj(it)) {
      checkKeywords(it);
      if (schemaCxtHasRules(it)) {
        topSchemaObjCode(it);
        return;
      }
    }
    validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
  }
  exports.validateFunctionCode = validateFunctionCode;
  function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
    if (opts.code.es5) {
      gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
        gen.code((0, codegen_1._)`"use strict"; ${funcSourceUrl(schema, opts)}`);
        destructureValCxtES5(gen, opts);
        gen.code(body);
      });
    } else {
      gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
    }
  }
  function destructureValCxt(opts) {
    return (0, codegen_1._)`{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
  }
  function destructureValCxtES5(gen, opts) {
    gen.if(names_1.default.valCxt, () => {
      gen.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`);
      gen.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`);
      gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
      gen.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`);
      if (opts.dynamicRef)
        gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
    }, () => {
      gen.var(names_1.default.instancePath, (0, codegen_1._)`""`);
      gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`);
      gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`);
      gen.var(names_1.default.rootData, names_1.default.data);
      if (opts.dynamicRef)
        gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);
    });
  }
  function topSchemaObjCode(it) {
    const { schema, opts, gen } = it;
    validateFunction(it, () => {
      if (opts.$comment && schema.$comment)
        commentKeyword(it);
      checkNoDefault(it);
      gen.let(names_1.default.vErrors, null);
      gen.let(names_1.default.errors, 0);
      if (opts.unevaluated)
        resetEvaluated(it);
      typeAndKeywords(it);
      returnResults(it);
    });
    return;
  }
  function resetEvaluated(it) {
    const { gen, validateName } = it;
    it.evaluated = gen.const("evaluated", (0, codegen_1._)`${validateName}.evaluated`);
    gen.if((0, codegen_1._)`${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._)`${it.evaluated}.props`, (0, codegen_1._)`undefined`));
    gen.if((0, codegen_1._)`${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._)`${it.evaluated}.items`, (0, codegen_1._)`undefined`));
  }
  function funcSourceUrl(schema, opts) {
    const schId = typeof schema == "object" && schema[opts.schemaId];
    return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;
  }
  function subschemaCode(it, valid) {
    if (isSchemaObj(it)) {
      checkKeywords(it);
      if (schemaCxtHasRules(it)) {
        subSchemaObjCode(it, valid);
        return;
      }
    }
    (0, boolSchema_1.boolOrEmptySchema)(it, valid);
  }
  function schemaCxtHasRules({ schema, self: self2 }) {
    if (typeof schema == "boolean")
      return !schema;
    for (const key in schema)
      if (self2.RULES.all[key])
        return true;
    return false;
  }
  function isSchemaObj(it) {
    return typeof it.schema != "boolean";
  }
  function subSchemaObjCode(it, valid) {
    const { schema, gen, opts } = it;
    if (opts.$comment && schema.$comment)
      commentKeyword(it);
    updateContext(it);
    checkAsyncSchema(it);
    const errsCount = gen.const("_errs", names_1.default.errors);
    typeAndKeywords(it, errsCount);
    gen.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
  }
  function checkKeywords(it) {
    (0, util_1.checkUnknownRules)(it);
    checkRefsAndKeywords(it);
  }
  function typeAndKeywords(it, errsCount) {
    if (it.opts.jtd)
      return schemaKeywords(it, [], false, errsCount);
    const types = (0, dataType_1.getSchemaTypes)(it.schema);
    const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);
    schemaKeywords(it, types, !checkedTypes, errsCount);
  }
  function checkRefsAndKeywords(it) {
    const { schema, errSchemaPath, opts, self: self2 } = it;
    if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self2.RULES)) {
      self2.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
    }
  }
  function checkNoDefault(it) {
    const { schema, opts } = it;
    if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {
      (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
    }
  }
  function updateContext(it) {
    const schId = it.schema[it.opts.schemaId];
    if (schId)
      it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
  }
  function checkAsyncSchema(it) {
    if (it.schema.$async && !it.schemaEnv.$async)
      throw new Error("async schema in sync schema");
  }
  function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
    const msg = schema.$comment;
    if (opts.$comment === true) {
      gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);
    } else if (typeof opts.$comment == "function") {
      const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`;
      const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
      gen.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
    }
  }
  function returnResults(it) {
    const { gen, schemaEnv, validateName, ValidationError, opts } = it;
    if (schemaEnv.$async) {
      gen.if((0, codegen_1._)`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`));
    } else {
      gen.assign((0, codegen_1._)`${validateName}.errors`, names_1.default.vErrors);
      if (opts.unevaluated)
        assignEvaluated(it);
      gen.return((0, codegen_1._)`${names_1.default.errors} === 0`);
    }
  }
  function assignEvaluated({ gen, evaluated, props, items }) {
    if (props instanceof codegen_1.Name)
      gen.assign((0, codegen_1._)`${evaluated}.props`, props);
    if (items instanceof codegen_1.Name)
      gen.assign((0, codegen_1._)`${evaluated}.items`, items);
  }
  function schemaKeywords(it, types, typeErrors, errsCount) {
    const { gen, schema, data, allErrors, opts, self: self2 } = it;
    const { RULES } = self2;
    if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
      gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
      return;
    }
    if (!opts.jtd)
      checkStrictTypes(it, types);
    gen.block(() => {
      for (const group of RULES.rules)
        groupKeywords(group);
      groupKeywords(RULES.post);
    });
    function groupKeywords(group) {
      if (!(0, applicability_1.shouldUseGroup)(schema, group))
        return;
      if (group.type) {
        gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
        iterateKeywords(it, group);
        if (types.length === 1 && types[0] === group.type && typeErrors) {
          gen.else();
          (0, dataType_2.reportTypeError)(it);
        }
        gen.endIf();
      } else {
        iterateKeywords(it, group);
      }
      if (!allErrors)
        gen.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`);
    }
  }
  function iterateKeywords(it, group) {
    const { gen, schema, opts: { useDefaults } } = it;
    if (useDefaults)
      (0, defaults_1.assignDefaults)(it, group.type);
    gen.block(() => {
      for (const rule of group.rules) {
        if ((0, applicability_1.shouldUseRule)(schema, rule)) {
          keywordCode(it, rule.keyword, rule.definition, group.type);
        }
      }
    });
  }
  function checkStrictTypes(it, types) {
    if (it.schemaEnv.meta || !it.opts.strictTypes)
      return;
    checkContextTypes(it, types);
    if (!it.opts.allowUnionTypes)
      checkMultipleTypes(it, types);
    checkKeywordTypes(it, it.dataTypes);
  }
  function checkContextTypes(it, types) {
    if (!types.length)
      return;
    if (!it.dataTypes.length) {
      it.dataTypes = types;
      return;
    }
    types.forEach((t) => {
      if (!includesType(it.dataTypes, t)) {
        strictTypesError(it, `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`);
      }
    });
    narrowSchemaTypes(it, types);
  }
  function checkMultipleTypes(it, ts) {
    if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
      strictTypesError(it, "use allowUnionTypes to allow union type keyword");
    }
  }
  function checkKeywordTypes(it, ts) {
    const rules = it.self.RULES.all;
    for (const keyword in rules) {
      const rule = rules[keyword];
      if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
        const { type } = rule.definition;
        if (type.length && !type.some((t) => hasApplicableType(ts, t))) {
          strictTypesError(it, `missing type "${type.join(",")}" for keyword "${keyword}"`);
        }
      }
    }
  }
  function hasApplicableType(schTs, kwdT) {
    return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
  }
  function includesType(ts, t) {
    return ts.includes(t) || t === "integer" && ts.includes("number");
  }
  function narrowSchemaTypes(it, withTypes) {
    const ts = [];
    for (const t of it.dataTypes) {
      if (includesType(withTypes, t))
        ts.push(t);
      else if (withTypes.includes("integer") && t === "number")
        ts.push("integer");
    }
    it.dataTypes = ts;
  }
  function strictTypesError(it, msg) {
    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
    msg += ` at "${schemaPath}" (strictTypes)`;
    (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
  }

  class KeywordCxt {
    constructor(it, def, keyword) {
      (0, keyword_1.validateKeywordUsage)(it, def, keyword);
      this.gen = it.gen;
      this.allErrors = it.allErrors;
      this.keyword = keyword;
      this.data = it.data;
      this.schema = it.schema[keyword];
      this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;
      this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);
      this.schemaType = def.schemaType;
      this.parentSchema = it.schema;
      this.params = {};
      this.it = it;
      this.def = def;
      if (this.$data) {
        this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
      } else {
        this.schemaCode = this.schemaValue;
        if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
          throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);
        }
      }
      if ("code" in def ? def.trackErrors : def.errors !== false) {
        this.errsCount = it.gen.const("_errs", names_1.default.errors);
      }
    }
    result(condition, successAction, failAction) {
      this.failResult((0, codegen_1.not)(condition), successAction, failAction);
    }
    failResult(condition, successAction, failAction) {
      this.gen.if(condition);
      if (failAction)
        failAction();
      else
        this.error();
      if (successAction) {
        this.gen.else();
        successAction();
        if (this.allErrors)
          this.gen.endIf();
      } else {
        if (this.allErrors)
          this.gen.endIf();
        else
          this.gen.else();
      }
    }
    pass(condition, failAction) {
      this.failResult((0, codegen_1.not)(condition), undefined, failAction);
    }
    fail(condition) {
      if (condition === undefined) {
        this.error();
        if (!this.allErrors)
          this.gen.if(false);
        return;
      }
      this.gen.if(condition);
      this.error();
      if (this.allErrors)
        this.gen.endIf();
      else
        this.gen.else();
    }
    fail$data(condition) {
      if (!this.$data)
        return this.fail(condition);
      const { schemaCode } = this;
      this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
    }
    error(append, errorParams, errorPaths) {
      if (errorParams) {
        this.setParams(errorParams);
        this._error(append, errorPaths);
        this.setParams({});
        return;
      }
      this._error(append, errorPaths);
    }
    _error(append, errorPaths) {
      (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
    }
    $dataError() {
      (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
    }
    reset() {
      if (this.errsCount === undefined)
        throw new Error('add "trackErrors" to keyword definition');
      (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
    }
    ok(cond) {
      if (!this.allErrors)
        this.gen.if(cond);
    }
    setParams(obj, assign) {
      if (assign)
        Object.assign(this.params, obj);
      else
        this.params = obj;
    }
    block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
      this.gen.block(() => {
        this.check$data(valid, $dataValid);
        codeBlock();
      });
    }
    check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
      if (!this.$data)
        return;
      const { gen, schemaCode, schemaType, def } = this;
      gen.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid));
      if (valid !== codegen_1.nil)
        gen.assign(valid, true);
      if (schemaType.length || def.validateSchema) {
        gen.elseIf(this.invalid$data());
        this.$dataError();
        if (valid !== codegen_1.nil)
          gen.assign(valid, false);
      }
      gen.else();
    }
    invalid$data() {
      const { gen, schemaCode, schemaType, def, it } = this;
      return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
      function wrong$DataType() {
        if (schemaType.length) {
          if (!(schemaCode instanceof codegen_1.Name))
            throw new Error("ajv implementation error");
          const st = Array.isArray(schemaType) ? schemaType : [schemaType];
          return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
        }
        return codegen_1.nil;
      }
      function invalid$DataSchema() {
        if (def.validateSchema) {
          const validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema });
          return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;
        }
        return codegen_1.nil;
      }
    }
    subschema(appl, valid) {
      const subschema = (0, subschema_1.getSubschema)(this.it, appl);
      (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
      (0, subschema_1.extendSubschemaMode)(subschema, appl);
      const nextContext = { ...this.it, ...subschema, items: undefined, props: undefined };
      subschemaCode(nextContext, valid);
      return nextContext;
    }
    mergeEvaluated(schemaCxt, toName) {
      const { it, gen } = this;
      if (!it.opts.unevaluated)
        return;
      if (it.props !== true && schemaCxt.props !== undefined) {
        it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
      }
      if (it.items !== true && schemaCxt.items !== undefined) {
        it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
      }
    }
    mergeValidEvaluated(schemaCxt, valid) {
      const { it, gen } = this;
      if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
        gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
        return true;
      }
    }
  }
  exports.KeywordCxt = KeywordCxt;
  function keywordCode(it, keyword, def, ruleType) {
    const cxt = new KeywordCxt(it, def, keyword);
    if ("code" in def) {
      def.code(cxt, ruleType);
    } else if (cxt.$data && def.validate) {
      (0, keyword_1.funcKeywordCode)(cxt, def);
    } else if ("macro" in def) {
      (0, keyword_1.macroKeywordCode)(cxt, def);
    } else if (def.compile || def.validate) {
      (0, keyword_1.funcKeywordCode)(cxt, def);
    }
  }
  var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
  var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
  function getData($data, { dataLevel, dataNames, dataPathArr }) {
    let jsonPointer;
    let data;
    if ($data === "")
      return names_1.default.rootData;
    if ($data[0] === "/") {
      if (!JSON_POINTER.test($data))
        throw new Error(`Invalid JSON-pointer: ${$data}`);
      jsonPointer = $data;
      data = names_1.default.rootData;
    } else {
      const matches = RELATIVE_JSON_POINTER.exec($data);
      if (!matches)
        throw new Error(`Invalid JSON-pointer: ${$data}`);
      const up = +matches[1];
      jsonPointer = matches[2];
      if (jsonPointer === "#") {
        if (up >= dataLevel)
          throw new Error(errorMsg("property/index", up));
        return dataPathArr[dataLevel - up];
      }
      if (up > dataLevel)
        throw new Error(errorMsg("data", up));
      data = dataNames[dataLevel - up];
      if (!jsonPointer)
        return data;
    }
    let expr = data;
    const segments = jsonPointer.split("/");
    for (const segment of segments) {
      if (segment) {
        data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
        expr = (0, codegen_1._)`${expr} && ${data}`;
      }
    }
    return expr;
    function errorMsg(pointerType, up) {
      return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
    }
  }
  exports.getData = getData;
});

// node_modules/ajv/dist/runtime/validation_error.js
var require_validation_error = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });

  class ValidationError extends Error {
    constructor(errors5) {
      super("validation failed");
      this.errors = errors5;
      this.ajv = this.validation = true;
    }
  }
  exports.default = ValidationError;
});

// node_modules/ajv/dist/compile/ref_error.js
var require_ref_error = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var resolve_1 = require_resolve();

  class MissingRefError extends Error {
    constructor(resolver, baseId, ref, msg) {
      super(msg || `can't resolve reference ${ref} from id ${baseId}`);
      this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);
      this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
    }
  }
  exports.default = MissingRefError;
});

// node_modules/ajv/dist/compile/index.js
var require_compile = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = undefined;
  var codegen_1 = require_codegen();
  var validation_error_1 = require_validation_error();
  var names_1 = require_names();
  var resolve_1 = require_resolve();
  var util_1 = require_util();
  var validate_1 = require_validate();

  class SchemaEnv {
    constructor(env) {
      var _a2;
      this.refs = {};
      this.dynamicAnchors = {};
      let schema;
      if (typeof env.schema == "object")
        schema = env.schema;
      this.schema = env.schema;
      this.schemaId = env.schemaId;
      this.root = env.root || this;
      this.baseId = (_a2 = env.baseId) !== null && _a2 !== undefined ? _a2 : (0, resolve_1.normalizeId)(schema === null || schema === undefined ? undefined : schema[env.schemaId || "$id"]);
      this.schemaPath = env.schemaPath;
      this.localRefs = env.localRefs;
      this.meta = env.meta;
      this.$async = schema === null || schema === undefined ? undefined : schema.$async;
      this.refs = {};
    }
  }
  exports.SchemaEnv = SchemaEnv;
  function compileSchema(sch) {
    const _sch = getCompilingSchema.call(this, sch);
    if (_sch)
      return _sch;
    const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
    const { es5, lines } = this.opts.code;
    const { ownProperties } = this.opts;
    const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
    let _ValidationError;
    if (sch.$async) {
      _ValidationError = gen.scopeValue("Error", {
        ref: validation_error_1.default,
        code: (0, codegen_1._)`require("ajv/dist/runtime/validation_error").default`
      });
    }
    const validateName = gen.scopeName("validate");
    sch.validateName = validateName;
    const schemaCxt = {
      gen,
      allErrors: this.opts.allErrors,
      data: names_1.default.data,
      parentData: names_1.default.parentData,
      parentDataProperty: names_1.default.parentDataProperty,
      dataNames: [names_1.default.data],
      dataPathArr: [codegen_1.nil],
      dataLevel: 0,
      dataTypes: [],
      definedProperties: new Set,
      topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) } : { ref: sch.schema }),
      validateName,
      ValidationError: _ValidationError,
      schema: sch.schema,
      schemaEnv: sch,
      rootId,
      baseId: sch.baseId || rootId,
      schemaPath: codegen_1.nil,
      errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
      errorPath: (0, codegen_1._)`""`,
      opts: this.opts,
      self: this
    };
    let sourceCode;
    try {
      this._compilations.add(sch);
      (0, validate_1.validateFunctionCode)(schemaCxt);
      gen.optimize(this.opts.code.optimize);
      const validateCode = gen.toString();
      sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
      if (this.opts.code.process)
        sourceCode = this.opts.code.process(sourceCode, sch);
      const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
      const validate = makeValidate(this, this.scope.get());
      this.scope.value(validateName, { ref: validate });
      validate.errors = null;
      validate.schema = sch.schema;
      validate.schemaEnv = sch;
      if (sch.$async)
        validate.$async = true;
      if (this.opts.code.source === true) {
        validate.source = { validateName, validateCode, scopeValues: gen._values };
      }
      if (this.opts.unevaluated) {
        const { props, items } = schemaCxt;
        validate.evaluated = {
          props: props instanceof codegen_1.Name ? undefined : props,
          items: items instanceof codegen_1.Name ? undefined : items,
          dynamicProps: props instanceof codegen_1.Name,
          dynamicItems: items instanceof codegen_1.Name
        };
        if (validate.source)
          validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);
      }
      sch.validate = validate;
      return sch;
    } catch (e) {
      delete sch.validate;
      delete sch.validateName;
      if (sourceCode)
        this.logger.error("Error compiling schema, function code:", sourceCode);
      throw e;
    } finally {
      this._compilations.delete(sch);
    }
  }
  exports.compileSchema = compileSchema;
  function resolveRef2(root, baseId, ref) {
    var _a2;
    ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);
    const schOrFunc = root.refs[ref];
    if (schOrFunc)
      return schOrFunc;
    let _sch = resolve.call(this, root, ref);
    if (_sch === undefined) {
      const schema = (_a2 = root.localRefs) === null || _a2 === undefined ? undefined : _a2[ref];
      const { schemaId } = this.opts;
      if (schema)
        _sch = new SchemaEnv({ schema, schemaId, root, baseId });
    }
    if (_sch === undefined)
      return;
    return root.refs[ref] = inlineOrCompile.call(this, _sch);
  }
  exports.resolveRef = resolveRef2;
  function inlineOrCompile(sch) {
    if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
      return sch.schema;
    return sch.validate ? sch : compileSchema.call(this, sch);
  }
  function getCompilingSchema(schEnv) {
    for (const sch of this._compilations) {
      if (sameSchemaEnv(sch, schEnv))
        return sch;
    }
  }
  exports.getCompilingSchema = getCompilingSchema;
  function sameSchemaEnv(s1, s2) {
    return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
  }
  function resolve(root, ref) {
    let sch;
    while (typeof (sch = this.refs[ref]) == "string")
      ref = sch;
    return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
  }
  function resolveSchema(root, ref) {
    const p = this.opts.uriResolver.parse(ref);
    const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);
    let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, undefined);
    if (Object.keys(root.schema).length > 0 && refPath === baseId) {
      return getJsonPointer.call(this, p, root);
    }
    const id = (0, resolve_1.normalizeId)(refPath);
    const schOrRef = this.refs[id] || this.schemas[id];
    if (typeof schOrRef == "string") {
      const sch = resolveSchema.call(this, root, schOrRef);
      if (typeof (sch === null || sch === undefined ? undefined : sch.schema) !== "object")
        return;
      return getJsonPointer.call(this, p, sch);
    }
    if (typeof (schOrRef === null || schOrRef === undefined ? undefined : schOrRef.schema) !== "object")
      return;
    if (!schOrRef.validate)
      compileSchema.call(this, schOrRef);
    if (id === (0, resolve_1.normalizeId)(ref)) {
      const { schema } = schOrRef;
      const { schemaId } = this.opts;
      const schId = schema[schemaId];
      if (schId)
        baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
      return new SchemaEnv({ schema, schemaId, root, baseId });
    }
    return getJsonPointer.call(this, p, schOrRef);
  }
  exports.resolveSchema = resolveSchema;
  var PREVENT_SCOPE_CHANGE = new Set([
    "properties",
    "patternProperties",
    "enum",
    "dependencies",
    "definitions"
  ]);
  function getJsonPointer(parsedRef, { baseId, schema, root }) {
    var _a2;
    if (((_a2 = parsedRef.fragment) === null || _a2 === undefined ? undefined : _a2[0]) !== "/")
      return;
    for (const part of parsedRef.fragment.slice(1).split("/")) {
      if (typeof schema === "boolean")
        return;
      const partSchema = schema[(0, util_1.unescapeFragment)(part)];
      if (partSchema === undefined)
        return;
      schema = partSchema;
      const schId = typeof schema === "object" && schema[this.opts.schemaId];
      if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
        baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
      }
    }
    let env;
    if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
      const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
      env = resolveSchema.call(this, root, $ref);
    }
    const { schemaId } = this.opts;
    env = env || new SchemaEnv({ schema, schemaId, root, baseId });
    if (env.schema !== env.root.schema)
      return env;
    return;
  }
});

// node_modules/ajv/dist/refs/data.json
var require_data = __commonJS((exports, module) => {
  module.exports = {
    $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
    description: "Meta-schema for $data reference (JSON AnySchema extension proposal)",
    type: "object",
    required: ["$data"],
    properties: {
      $data: {
        type: "string",
        anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }]
      }
    },
    additionalProperties: false
  };
});

// node_modules/fast-uri/lib/utils.js
var require_utils = __commonJS((exports, module) => {
  var isUUID = RegExp.prototype.test.bind(/^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu);
  var isIPv4 = RegExp.prototype.test.bind(/^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u);
  function stringArrayToHexStripped(input) {
    let acc = "";
    let code = 0;
    let i = 0;
    for (i = 0;i < input.length; i++) {
      code = input[i].charCodeAt(0);
      if (code === 48) {
        continue;
      }
      if (!(code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102)) {
        return "";
      }
      acc += input[i];
      break;
    }
    for (i += 1;i < input.length; i++) {
      code = input[i].charCodeAt(0);
      if (!(code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102)) {
        return "";
      }
      acc += input[i];
    }
    return acc;
  }
  var nonSimpleDomain = RegExp.prototype.test.bind(/[^!"$&'()*+,\-.;=_`a-z{}~]/u);
  function consumeIsZone(buffer) {
    buffer.length = 0;
    return true;
  }
  function consumeHextets(buffer, address, output) {
    if (buffer.length) {
      const hex3 = stringArrayToHexStripped(buffer);
      if (hex3 !== "") {
        address.push(hex3);
      } else {
        output.error = true;
        return false;
      }
      buffer.length = 0;
    }
    return true;
  }
  function getIPV6(input) {
    let tokenCount = 0;
    const output = { error: false, address: "", zone: "" };
    const address = [];
    const buffer = [];
    let endipv6Encountered = false;
    let endIpv6 = false;
    let consume = consumeHextets;
    for (let i = 0;i < input.length; i++) {
      const cursor = input[i];
      if (cursor === "[" || cursor === "]") {
        continue;
      }
      if (cursor === ":") {
        if (endipv6Encountered === true) {
          endIpv6 = true;
        }
        if (!consume(buffer, address, output)) {
          break;
        }
        if (++tokenCount > 7) {
          output.error = true;
          break;
        }
        if (i > 0 && input[i - 1] === ":") {
          endipv6Encountered = true;
        }
        address.push(":");
        continue;
      } else if (cursor === "%") {
        if (!consume(buffer, address, output)) {
          break;
        }
        consume = consumeIsZone;
      } else {
        buffer.push(cursor);
        continue;
      }
    }
    if (buffer.length) {
      if (consume === consumeIsZone) {
        output.zone = buffer.join("");
      } else if (endIpv6) {
        address.push(buffer.join(""));
      } else {
        address.push(stringArrayToHexStripped(buffer));
      }
    }
    output.address = address.join("");
    return output;
  }
  function normalizeIPv6(host) {
    if (findToken(host, ":") < 2) {
      return { host, isIPV6: false };
    }
    const ipv64 = getIPV6(host);
    if (!ipv64.error) {
      let newHost = ipv64.address;
      let escapedHost = ipv64.address;
      if (ipv64.zone) {
        newHost += "%" + ipv64.zone;
        escapedHost += "%25" + ipv64.zone;
      }
      return { host: newHost, isIPV6: true, escapedHost };
    } else {
      return { host, isIPV6: false };
    }
  }
  function findToken(str2, token) {
    let ind = 0;
    for (let i = 0;i < str2.length; i++) {
      if (str2[i] === token)
        ind++;
    }
    return ind;
  }
  function removeDotSegments(path2) {
    let input = path2;
    const output = [];
    let nextSlash = -1;
    let len = 0;
    while (len = input.length) {
      if (len === 1) {
        if (input === ".") {
          break;
        } else if (input === "/") {
          output.push("/");
          break;
        } else {
          output.push(input);
          break;
        }
      } else if (len === 2) {
        if (input[0] === ".") {
          if (input[1] === ".") {
            break;
          } else if (input[1] === "/") {
            input = input.slice(2);
            continue;
          }
        } else if (input[0] === "/") {
          if (input[1] === "." || input[1] === "/") {
            output.push("/");
            break;
          }
        }
      } else if (len === 3) {
        if (input === "/..") {
          if (output.length !== 0) {
            output.pop();
          }
          output.push("/");
          break;
        }
      }
      if (input[0] === ".") {
        if (input[1] === ".") {
          if (input[2] === "/") {
            input = input.slice(3);
            continue;
          }
        } else if (input[1] === "/") {
          input = input.slice(2);
          continue;
        }
      } else if (input[0] === "/") {
        if (input[1] === ".") {
          if (input[2] === "/") {
            input = input.slice(2);
            continue;
          } else if (input[2] === ".") {
            if (input[3] === "/") {
              input = input.slice(3);
              if (output.length !== 0) {
                output.pop();
              }
              continue;
            }
          }
        }
      }
      if ((nextSlash = input.indexOf("/", 1)) === -1) {
        output.push(input);
        break;
      } else {
        output.push(input.slice(0, nextSlash));
        input = input.slice(nextSlash);
      }
    }
    return output.join("");
  }
  function normalizeComponentEncoding(component, esc3) {
    const func = esc3 !== true ? escape : unescape;
    if (component.scheme !== undefined) {
      component.scheme = func(component.scheme);
    }
    if (component.userinfo !== undefined) {
      component.userinfo = func(component.userinfo);
    }
    if (component.host !== undefined) {
      component.host = func(component.host);
    }
    if (component.path !== undefined) {
      component.path = func(component.path);
    }
    if (component.query !== undefined) {
      component.query = func(component.query);
    }
    if (component.fragment !== undefined) {
      component.fragment = func(component.fragment);
    }
    return component;
  }
  function recomposeAuthority(component) {
    const uriTokens = [];
    if (component.userinfo !== undefined) {
      uriTokens.push(component.userinfo);
      uriTokens.push("@");
    }
    if (component.host !== undefined) {
      let host = unescape(component.host);
      if (!isIPv4(host)) {
        const ipV6res = normalizeIPv6(host);
        if (ipV6res.isIPV6 === true) {
          host = `[${ipV6res.escapedHost}]`;
        } else {
          host = component.host;
        }
      }
      uriTokens.push(host);
    }
    if (typeof component.port === "number" || typeof component.port === "string") {
      uriTokens.push(":");
      uriTokens.push(String(component.port));
    }
    return uriTokens.length ? uriTokens.join("") : undefined;
  }
  module.exports = {
    nonSimpleDomain,
    recomposeAuthority,
    normalizeComponentEncoding,
    removeDotSegments,
    isIPv4,
    isUUID,
    normalizeIPv6,
    stringArrayToHexStripped
  };
});

// node_modules/fast-uri/lib/schemes.js
var require_schemes = __commonJS((exports, module) => {
  var { isUUID } = require_utils();
  var URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
  var supportedSchemeNames = [
    "http",
    "https",
    "ws",
    "wss",
    "urn",
    "urn:uuid"
  ];
  function isValidSchemeName(name) {
    return supportedSchemeNames.indexOf(name) !== -1;
  }
  function wsIsSecure(wsComponent) {
    if (wsComponent.secure === true) {
      return true;
    } else if (wsComponent.secure === false) {
      return false;
    } else if (wsComponent.scheme) {
      return wsComponent.scheme.length === 3 && (wsComponent.scheme[0] === "w" || wsComponent.scheme[0] === "W") && (wsComponent.scheme[1] === "s" || wsComponent.scheme[1] === "S") && (wsComponent.scheme[2] === "s" || wsComponent.scheme[2] === "S");
    } else {
      return false;
    }
  }
  function httpParse(component) {
    if (!component.host) {
      component.error = component.error || "HTTP URIs must have a host.";
    }
    return component;
  }
  function httpSerialize(component) {
    const secure = String(component.scheme).toLowerCase() === "https";
    if (component.port === (secure ? 443 : 80) || component.port === "") {
      component.port = undefined;
    }
    if (!component.path) {
      component.path = "/";
    }
    return component;
  }
  function wsParse(wsComponent) {
    wsComponent.secure = wsIsSecure(wsComponent);
    wsComponent.resourceName = (wsComponent.path || "/") + (wsComponent.query ? "?" + wsComponent.query : "");
    wsComponent.path = undefined;
    wsComponent.query = undefined;
    return wsComponent;
  }
  function wsSerialize(wsComponent) {
    if (wsComponent.port === (wsIsSecure(wsComponent) ? 443 : 80) || wsComponent.port === "") {
      wsComponent.port = undefined;
    }
    if (typeof wsComponent.secure === "boolean") {
      wsComponent.scheme = wsComponent.secure ? "wss" : "ws";
      wsComponent.secure = undefined;
    }
    if (wsComponent.resourceName) {
      const [path2, query] = wsComponent.resourceName.split("?");
      wsComponent.path = path2 && path2 !== "/" ? path2 : undefined;
      wsComponent.query = query;
      wsComponent.resourceName = undefined;
    }
    wsComponent.fragment = undefined;
    return wsComponent;
  }
  function urnParse(urnComponent, options2) {
    if (!urnComponent.path) {
      urnComponent.error = "URN can not be parsed";
      return urnComponent;
    }
    const matches = urnComponent.path.match(URN_REG);
    if (matches) {
      const scheme = options2.scheme || urnComponent.scheme || "urn";
      urnComponent.nid = matches[1].toLowerCase();
      urnComponent.nss = matches[2];
      const urnScheme = `${scheme}:${options2.nid || urnComponent.nid}`;
      const schemeHandler = getSchemeHandler(urnScheme);
      urnComponent.path = undefined;
      if (schemeHandler) {
        urnComponent = schemeHandler.parse(urnComponent, options2);
      }
    } else {
      urnComponent.error = urnComponent.error || "URN can not be parsed.";
    }
    return urnComponent;
  }
  function urnSerialize(urnComponent, options2) {
    if (urnComponent.nid === undefined) {
      throw new Error("URN without nid cannot be serialized");
    }
    const scheme = options2.scheme || urnComponent.scheme || "urn";
    const nid = urnComponent.nid.toLowerCase();
    const urnScheme = `${scheme}:${options2.nid || nid}`;
    const schemeHandler = getSchemeHandler(urnScheme);
    if (schemeHandler) {
      urnComponent = schemeHandler.serialize(urnComponent, options2);
    }
    const uriComponent = urnComponent;
    const nss = urnComponent.nss;
    uriComponent.path = `${nid || options2.nid}:${nss}`;
    options2.skipEscape = true;
    return uriComponent;
  }
  function urnuuidParse(urnComponent, options2) {
    const uuidComponent = urnComponent;
    uuidComponent.uuid = uuidComponent.nss;
    uuidComponent.nss = undefined;
    if (!options2.tolerant && (!uuidComponent.uuid || !isUUID(uuidComponent.uuid))) {
      uuidComponent.error = uuidComponent.error || "UUID is not valid.";
    }
    return uuidComponent;
  }
  function urnuuidSerialize(uuidComponent) {
    const urnComponent = uuidComponent;
    urnComponent.nss = (uuidComponent.uuid || "").toLowerCase();
    return urnComponent;
  }
  var http = {
    scheme: "http",
    domainHost: true,
    parse: httpParse,
    serialize: httpSerialize
  };
  var https2 = {
    scheme: "https",
    domainHost: http.domainHost,
    parse: httpParse,
    serialize: httpSerialize
  };
  var ws = {
    scheme: "ws",
    domainHost: true,
    parse: wsParse,
    serialize: wsSerialize
  };
  var wss = {
    scheme: "wss",
    domainHost: ws.domainHost,
    parse: ws.parse,
    serialize: ws.serialize
  };
  var urn = {
    scheme: "urn",
    parse: urnParse,
    serialize: urnSerialize,
    skipNormalize: true
  };
  var urnuuid = {
    scheme: "urn:uuid",
    parse: urnuuidParse,
    serialize: urnuuidSerialize,
    skipNormalize: true
  };
  var SCHEMES = {
    http,
    https: https2,
    ws,
    wss,
    urn,
    "urn:uuid": urnuuid
  };
  Object.setPrototypeOf(SCHEMES, null);
  function getSchemeHandler(scheme) {
    return scheme && (SCHEMES[scheme] || SCHEMES[scheme.toLowerCase()]) || undefined;
  }
  module.exports = {
    wsIsSecure,
    SCHEMES,
    isValidSchemeName,
    getSchemeHandler
  };
});

// node_modules/fast-uri/index.js
var require_fast_uri = __commonJS((exports, module) => {
  var { normalizeIPv6, removeDotSegments, recomposeAuthority, normalizeComponentEncoding, isIPv4, nonSimpleDomain } = require_utils();
  var { SCHEMES, getSchemeHandler } = require_schemes();
  function normalize2(uri, options2) {
    if (typeof uri === "string") {
      uri = serialize(parse11(uri, options2), options2);
    } else if (typeof uri === "object") {
      uri = parse11(serialize(uri, options2), options2);
    }
    return uri;
  }
  function resolve(baseURI, relativeURI, options2) {
    const schemelessOptions = options2 ? Object.assign({ scheme: "null" }, options2) : { scheme: "null" };
    const resolved = resolveComponent(parse11(baseURI, schemelessOptions), parse11(relativeURI, schemelessOptions), schemelessOptions, true);
    schemelessOptions.skipEscape = true;
    return serialize(resolved, schemelessOptions);
  }
  function resolveComponent(base, relative, options2, skipNormalization) {
    const target = {};
    if (!skipNormalization) {
      base = parse11(serialize(base, options2), options2);
      relative = parse11(serialize(relative, options2), options2);
    }
    options2 = options2 || {};
    if (!options2.tolerant && relative.scheme) {
      target.scheme = relative.scheme;
      target.userinfo = relative.userinfo;
      target.host = relative.host;
      target.port = relative.port;
      target.path = removeDotSegments(relative.path || "");
      target.query = relative.query;
    } else {
      if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || "");
        target.query = relative.query;
      } else {
        if (!relative.path) {
          target.path = base.path;
          if (relative.query !== undefined) {
            target.query = relative.query;
          } else {
            target.query = base.query;
          }
        } else {
          if (relative.path[0] === "/") {
            target.path = removeDotSegments(relative.path);
          } else {
            if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {
              target.path = "/" + relative.path;
            } else if (!base.path) {
              target.path = relative.path;
            } else {
              target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
            }
            target.path = removeDotSegments(target.path);
          }
          target.query = relative.query;
        }
        target.userinfo = base.userinfo;
        target.host = base.host;
        target.port = base.port;
      }
      target.scheme = base.scheme;
    }
    target.fragment = relative.fragment;
    return target;
  }
  function equal(uriA, uriB, options2) {
    if (typeof uriA === "string") {
      uriA = unescape(uriA);
      uriA = serialize(normalizeComponentEncoding(parse11(uriA, options2), true), { ...options2, skipEscape: true });
    } else if (typeof uriA === "object") {
      uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options2, skipEscape: true });
    }
    if (typeof uriB === "string") {
      uriB = unescape(uriB);
      uriB = serialize(normalizeComponentEncoding(parse11(uriB, options2), true), { ...options2, skipEscape: true });
    } else if (typeof uriB === "object") {
      uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options2, skipEscape: true });
    }
    return uriA.toLowerCase() === uriB.toLowerCase();
  }
  function serialize(cmpts, opts) {
    const component = {
      host: cmpts.host,
      scheme: cmpts.scheme,
      userinfo: cmpts.userinfo,
      port: cmpts.port,
      path: cmpts.path,
      query: cmpts.query,
      nid: cmpts.nid,
      nss: cmpts.nss,
      uuid: cmpts.uuid,
      fragment: cmpts.fragment,
      reference: cmpts.reference,
      resourceName: cmpts.resourceName,
      secure: cmpts.secure,
      error: ""
    };
    const options2 = Object.assign({}, opts);
    const uriTokens = [];
    const schemeHandler = getSchemeHandler(options2.scheme || component.scheme);
    if (schemeHandler && schemeHandler.serialize)
      schemeHandler.serialize(component, options2);
    if (component.path !== undefined) {
      if (!options2.skipEscape) {
        component.path = escape(component.path);
        if (component.scheme !== undefined) {
          component.path = component.path.split("%3A").join(":");
        }
      } else {
        component.path = unescape(component.path);
      }
    }
    if (options2.reference !== "suffix" && component.scheme) {
      uriTokens.push(component.scheme, ":");
    }
    const authority = recomposeAuthority(component);
    if (authority !== undefined) {
      if (options2.reference !== "suffix") {
        uriTokens.push("//");
      }
      uriTokens.push(authority);
      if (component.path && component.path[0] !== "/") {
        uriTokens.push("/");
      }
    }
    if (component.path !== undefined) {
      let s = component.path;
      if (!options2.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
        s = removeDotSegments(s);
      }
      if (authority === undefined && s[0] === "/" && s[1] === "/") {
        s = "/%2F" + s.slice(2);
      }
      uriTokens.push(s);
    }
    if (component.query !== undefined) {
      uriTokens.push("?", component.query);
    }
    if (component.fragment !== undefined) {
      uriTokens.push("#", component.fragment);
    }
    return uriTokens.join("");
  }
  var URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
  function parse11(uri, opts) {
    const options2 = Object.assign({}, opts);
    const parsed = {
      scheme: undefined,
      userinfo: undefined,
      host: "",
      port: undefined,
      path: "",
      query: undefined,
      fragment: undefined
    };
    let isIP = false;
    if (options2.reference === "suffix") {
      if (options2.scheme) {
        uri = options2.scheme + ":" + uri;
      } else {
        uri = "//" + uri;
      }
    }
    const matches = uri.match(URI_PARSE);
    if (matches) {
      parsed.scheme = matches[1];
      parsed.userinfo = matches[3];
      parsed.host = matches[4];
      parsed.port = parseInt(matches[5], 10);
      parsed.path = matches[6] || "";
      parsed.query = matches[7];
      parsed.fragment = matches[8];
      if (isNaN(parsed.port)) {
        parsed.port = matches[5];
      }
      if (parsed.host) {
        const ipv4result = isIPv4(parsed.host);
        if (ipv4result === false) {
          const ipv6result = normalizeIPv6(parsed.host);
          parsed.host = ipv6result.host.toLowerCase();
          isIP = ipv6result.isIPV6;
        } else {
          isIP = true;
        }
      }
      if (parsed.scheme === undefined && parsed.userinfo === undefined && parsed.host === undefined && parsed.port === undefined && parsed.query === undefined && !parsed.path) {
        parsed.reference = "same-document";
      } else if (parsed.scheme === undefined) {
        parsed.reference = "relative";
      } else if (parsed.fragment === undefined) {
        parsed.reference = "absolute";
      } else {
        parsed.reference = "uri";
      }
      if (options2.reference && options2.reference !== "suffix" && options2.reference !== parsed.reference) {
        parsed.error = parsed.error || "URI is not a " + options2.reference + " reference.";
      }
      const schemeHandler = getSchemeHandler(options2.scheme || parsed.scheme);
      if (!options2.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
        if (parsed.host && (options2.domainHost || schemeHandler && schemeHandler.domainHost) && isIP === false && nonSimpleDomain(parsed.host)) {
          try {
            parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
          } catch (e) {
            parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e;
          }
        }
      }
      if (!schemeHandler || schemeHandler && !schemeHandler.skipNormalize) {
        if (uri.indexOf("%") !== -1) {
          if (parsed.scheme !== undefined) {
            parsed.scheme = unescape(parsed.scheme);
          }
          if (parsed.host !== undefined) {
            parsed.host = unescape(parsed.host);
          }
        }
        if (parsed.path) {
          parsed.path = escape(unescape(parsed.path));
        }
        if (parsed.fragment) {
          parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment));
        }
      }
      if (schemeHandler && schemeHandler.parse) {
        schemeHandler.parse(parsed, options2);
      }
    } else {
      parsed.error = parsed.error || "URI can not be parsed.";
    }
    return parsed;
  }
  var fastUri = {
    SCHEMES,
    normalize: normalize2,
    resolve,
    resolveComponent,
    equal,
    serialize,
    parse: parse11
  };
  module.exports = fastUri;
  module.exports.default = fastUri;
  module.exports.fastUri = fastUri;
});

// node_modules/ajv/dist/runtime/uri.js
var require_uri = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var uri = require_fast_uri();
  uri.code = 'require("ajv/dist/runtime/uri").default';
  exports.default = uri;
});

// node_modules/ajv/dist/core.js
var require_core = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = undefined;
  var validate_1 = require_validate();
  Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
    return validate_1.KeywordCxt;
  } });
  var codegen_1 = require_codegen();
  Object.defineProperty(exports, "_", { enumerable: true, get: function() {
    return codegen_1._;
  } });
  Object.defineProperty(exports, "str", { enumerable: true, get: function() {
    return codegen_1.str;
  } });
  Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
    return codegen_1.stringify;
  } });
  Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
    return codegen_1.nil;
  } });
  Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
    return codegen_1.Name;
  } });
  Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
    return codegen_1.CodeGen;
  } });
  var validation_error_1 = require_validation_error();
  var ref_error_1 = require_ref_error();
  var rules_1 = require_rules();
  var compile_1 = require_compile();
  var codegen_2 = require_codegen();
  var resolve_1 = require_resolve();
  var dataType_1 = require_dataType();
  var util_1 = require_util();
  var $dataRefSchema = require_data();
  var uri_1 = require_uri();
  var defaultRegExp = (str2, flags) => new RegExp(str2, flags);
  defaultRegExp.code = "new RegExp";
  var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
  var EXT_SCOPE_NAMES = new Set([
    "validate",
    "serialize",
    "parse",
    "wrapper",
    "root",
    "schema",
    "keyword",
    "pattern",
    "formats",
    "validate$data",
    "func",
    "obj",
    "Error"
  ]);
  var removedOptions = {
    errorDataPath: "",
    format: "`validateFormats: false` can be used instead.",
    nullable: '"nullable" keyword is supported by default.',
    jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
    extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
    missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
    processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
    sourceCode: "Use option `code: {source: true}`",
    strictDefaults: "It is default now, see option `strict`.",
    strictKeywords: "It is default now, see option `strict`.",
    uniqueItems: '"uniqueItems" keyword is always validated.',
    unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
    cache: "Map is used as cache, schema object as key.",
    serialize: "Map is used as cache, schema object as key.",
    ajvErrors: "It is default now."
  };
  var deprecatedOptions = {
    ignoreKeywordsWithRef: "",
    jsPropertySyntax: "",
    unicode: '"minLength"/"maxLength" account for unicode characters by default.'
  };
  var MAX_EXPRESSION = 200;
  function requiredOptions(o) {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
    const s = o.strict;
    const _optz = (_a2 = o.code) === null || _a2 === undefined ? undefined : _a2.optimize;
    const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0;
    const regExp = (_c = (_b = o.code) === null || _b === undefined ? undefined : _b.regExp) !== null && _c !== undefined ? _c : defaultRegExp;
    const uriResolver = (_d = o.uriResolver) !== null && _d !== undefined ? _d : uri_1.default;
    return {
      strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== undefined ? _e : s) !== null && _f !== undefined ? _f : true,
      strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== undefined ? _g : s) !== null && _h !== undefined ? _h : true,
      strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== undefined ? _j : s) !== null && _k !== undefined ? _k : "log",
      strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== undefined ? _l : s) !== null && _m !== undefined ? _m : "log",
      strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== undefined ? _o : s) !== null && _p !== undefined ? _p : false,
      code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
      loopRequired: (_q = o.loopRequired) !== null && _q !== undefined ? _q : MAX_EXPRESSION,
      loopEnum: (_r = o.loopEnum) !== null && _r !== undefined ? _r : MAX_EXPRESSION,
      meta: (_s = o.meta) !== null && _s !== undefined ? _s : true,
      messages: (_t = o.messages) !== null && _t !== undefined ? _t : true,
      inlineRefs: (_u = o.inlineRefs) !== null && _u !== undefined ? _u : true,
      schemaId: (_v = o.schemaId) !== null && _v !== undefined ? _v : "$id",
      addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== undefined ? _w : true,
      validateSchema: (_x = o.validateSchema) !== null && _x !== undefined ? _x : true,
      validateFormats: (_y = o.validateFormats) !== null && _y !== undefined ? _y : true,
      unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== undefined ? _z : true,
      int32range: (_0 = o.int32range) !== null && _0 !== undefined ? _0 : true,
      uriResolver
    };
  }

  class Ajv {
    constructor(opts = {}) {
      this.schemas = {};
      this.refs = {};
      this.formats = {};
      this._compilations = new Set;
      this._loading = {};
      this._cache = new Map;
      opts = this.opts = { ...opts, ...requiredOptions(opts) };
      const { es5, lines } = this.opts.code;
      this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
      this.logger = getLogger(opts.logger);
      const formatOpt = opts.validateFormats;
      opts.validateFormats = false;
      this.RULES = (0, rules_1.getRules)();
      checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
      checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
      this._metaOpts = getMetaSchemaOptions.call(this);
      if (opts.formats)
        addInitialFormats.call(this);
      this._addVocabularies();
      this._addDefaultMetaSchema();
      if (opts.keywords)
        addInitialKeywords.call(this, opts.keywords);
      if (typeof opts.meta == "object")
        this.addMetaSchema(opts.meta);
      addInitialSchemas.call(this);
      opts.validateFormats = formatOpt;
    }
    _addVocabularies() {
      this.addKeyword("$async");
    }
    _addDefaultMetaSchema() {
      const { $data, meta: meta3, schemaId } = this.opts;
      let _dataRefSchema = $dataRefSchema;
      if (schemaId === "id") {
        _dataRefSchema = { ...$dataRefSchema };
        _dataRefSchema.id = _dataRefSchema.$id;
        delete _dataRefSchema.$id;
      }
      if (meta3 && $data)
        this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
    }
    defaultMeta() {
      const { meta: meta3, schemaId } = this.opts;
      return this.opts.defaultMeta = typeof meta3 == "object" ? meta3[schemaId] || meta3 : undefined;
    }
    validate(schemaKeyRef, data) {
      let v;
      if (typeof schemaKeyRef == "string") {
        v = this.getSchema(schemaKeyRef);
        if (!v)
          throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
      } else {
        v = this.compile(schemaKeyRef);
      }
      const valid = v(data);
      if (!("$async" in v))
        this.errors = v.errors;
      return valid;
    }
    compile(schema, _meta) {
      const sch = this._addSchema(schema, _meta);
      return sch.validate || this._compileSchemaEnv(sch);
    }
    compileAsync(schema, meta3) {
      if (typeof this.opts.loadSchema != "function") {
        throw new Error("options.loadSchema should be a function");
      }
      const { loadSchema } = this.opts;
      return runCompileAsync.call(this, schema, meta3);
      async function runCompileAsync(_schema, _meta) {
        await loadMetaSchema.call(this, _schema.$schema);
        const sch = this._addSchema(_schema, _meta);
        return sch.validate || _compileAsync.call(this, sch);
      }
      async function loadMetaSchema($ref) {
        if ($ref && !this.getSchema($ref)) {
          await runCompileAsync.call(this, { $ref }, true);
        }
      }
      async function _compileAsync(sch) {
        try {
          return this._compileSchemaEnv(sch);
        } catch (e) {
          if (!(e instanceof ref_error_1.default))
            throw e;
          checkLoaded.call(this, e);
          await loadMissingSchema.call(this, e.missingSchema);
          return _compileAsync.call(this, sch);
        }
      }
      function checkLoaded({ missingSchema: ref, missingRef }) {
        if (this.refs[ref]) {
          throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
        }
      }
      async function loadMissingSchema(ref) {
        const _schema = await _loadSchema.call(this, ref);
        if (!this.refs[ref])
          await loadMetaSchema.call(this, _schema.$schema);
        if (!this.refs[ref])
          this.addSchema(_schema, ref, meta3);
      }
      async function _loadSchema(ref) {
        const p = this._loading[ref];
        if (p)
          return p;
        try {
          return await (this._loading[ref] = loadSchema(ref));
        } finally {
          delete this._loading[ref];
        }
      }
    }
    addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
      if (Array.isArray(schema)) {
        for (const sch of schema)
          this.addSchema(sch, undefined, _meta, _validateSchema);
        return this;
      }
      let id;
      if (typeof schema === "object") {
        const { schemaId } = this.opts;
        id = schema[schemaId];
        if (id !== undefined && typeof id != "string") {
          throw new Error(`schema ${schemaId} must be string`);
        }
      }
      key = (0, resolve_1.normalizeId)(key || id);
      this._checkUnique(key);
      this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
      return this;
    }
    addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
      this.addSchema(schema, key, true, _validateSchema);
      return this;
    }
    validateSchema(schema, throwOrLogError) {
      if (typeof schema == "boolean")
        return true;
      let $schema;
      $schema = schema.$schema;
      if ($schema !== undefined && typeof $schema != "string") {
        throw new Error("$schema must be a string");
      }
      $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
      if (!$schema) {
        this.logger.warn("meta-schema not available");
        this.errors = null;
        return true;
      }
      const valid = this.validate($schema, schema);
      if (!valid && throwOrLogError) {
        const message = "schema is invalid: " + this.errorsText();
        if (this.opts.validateSchema === "log")
          this.logger.error(message);
        else
          throw new Error(message);
      }
      return valid;
    }
    getSchema(keyRef) {
      let sch;
      while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
        keyRef = sch;
      if (sch === undefined) {
        const { schemaId } = this.opts;
        const root = new compile_1.SchemaEnv({ schema: {}, schemaId });
        sch = compile_1.resolveSchema.call(this, root, keyRef);
        if (!sch)
          return;
        this.refs[keyRef] = sch;
      }
      return sch.validate || this._compileSchemaEnv(sch);
    }
    removeSchema(schemaKeyRef) {
      if (schemaKeyRef instanceof RegExp) {
        this._removeAllSchemas(this.schemas, schemaKeyRef);
        this._removeAllSchemas(this.refs, schemaKeyRef);
        return this;
      }
      switch (typeof schemaKeyRef) {
        case "undefined":
          this._removeAllSchemas(this.schemas);
          this._removeAllSchemas(this.refs);
          this._cache.clear();
          return this;
        case "string": {
          const sch = getSchEnv.call(this, schemaKeyRef);
          if (typeof sch == "object")
            this._cache.delete(sch.schema);
          delete this.schemas[schemaKeyRef];
          delete this.refs[schemaKeyRef];
          return this;
        }
        case "object": {
          const cacheKey = schemaKeyRef;
          this._cache.delete(cacheKey);
          let id = schemaKeyRef[this.opts.schemaId];
          if (id) {
            id = (0, resolve_1.normalizeId)(id);
            delete this.schemas[id];
            delete this.refs[id];
          }
          return this;
        }
        default:
          throw new Error("ajv.removeSchema: invalid parameter");
      }
    }
    addVocabulary(definitions) {
      for (const def of definitions)
        this.addKeyword(def);
      return this;
    }
    addKeyword(kwdOrDef, def) {
      let keyword;
      if (typeof kwdOrDef == "string") {
        keyword = kwdOrDef;
        if (typeof def == "object") {
          this.logger.warn("these parameters are deprecated, see docs for addKeyword");
          def.keyword = keyword;
        }
      } else if (typeof kwdOrDef == "object" && def === undefined) {
        def = kwdOrDef;
        keyword = def.keyword;
        if (Array.isArray(keyword) && !keyword.length) {
          throw new Error("addKeywords: keyword must be string or non-empty array");
        }
      } else {
        throw new Error("invalid addKeywords parameters");
      }
      checkKeyword.call(this, keyword, def);
      if (!def) {
        (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));
        return this;
      }
      keywordMetaschema.call(this, def);
      const definition = {
        ...def,
        type: (0, dataType_1.getJSONTypes)(def.type),
        schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)
      };
      (0, util_1.eachItem)(keyword, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));
      return this;
    }
    getKeyword(keyword) {
      const rule = this.RULES.all[keyword];
      return typeof rule == "object" ? rule.definition : !!rule;
    }
    removeKeyword(keyword) {
      const { RULES } = this;
      delete RULES.keywords[keyword];
      delete RULES.all[keyword];
      for (const group of RULES.rules) {
        const i = group.rules.findIndex((rule) => rule.keyword === keyword);
        if (i >= 0)
          group.rules.splice(i, 1);
      }
      return this;
    }
    addFormat(name, format) {
      if (typeof format == "string")
        format = new RegExp(format);
      this.formats[name] = format;
      return this;
    }
    errorsText(errors5 = this.errors, { separator = ", ", dataVar = "data" } = {}) {
      if (!errors5 || errors5.length === 0)
        return "No errors";
      return errors5.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);
    }
    $dataMetaSchema(metaSchema, keywordsJsonPointers) {
      const rules = this.RULES.all;
      metaSchema = JSON.parse(JSON.stringify(metaSchema));
      for (const jsonPointer of keywordsJsonPointers) {
        const segments = jsonPointer.split("/").slice(1);
        let keywords = metaSchema;
        for (const seg of segments)
          keywords = keywords[seg];
        for (const key in rules) {
          const rule = rules[key];
          if (typeof rule != "object")
            continue;
          const { $data } = rule.definition;
          const schema = keywords[key];
          if ($data && schema)
            keywords[key] = schemaOrData(schema);
        }
      }
      return metaSchema;
    }
    _removeAllSchemas(schemas6, regex) {
      for (const keyRef in schemas6) {
        const sch = schemas6[keyRef];
        if (!regex || regex.test(keyRef)) {
          if (typeof sch == "string") {
            delete schemas6[keyRef];
          } else if (sch && !sch.meta) {
            this._cache.delete(sch.schema);
            delete schemas6[keyRef];
          }
        }
      }
    }
    _addSchema(schema, meta3, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
      let id;
      const { schemaId } = this.opts;
      if (typeof schema == "object") {
        id = schema[schemaId];
      } else {
        if (this.opts.jtd)
          throw new Error("schema must be object");
        else if (typeof schema != "boolean")
          throw new Error("schema must be object or boolean");
      }
      let sch = this._cache.get(schema);
      if (sch !== undefined)
        return sch;
      baseId = (0, resolve_1.normalizeId)(id || baseId);
      const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
      sch = new compile_1.SchemaEnv({ schema, schemaId, meta: meta3, baseId, localRefs });
      this._cache.set(sch.schema, sch);
      if (addSchema && !baseId.startsWith("#")) {
        if (baseId)
          this._checkUnique(baseId);
        this.refs[baseId] = sch;
      }
      if (validateSchema)
        this.validateSchema(schema, true);
      return sch;
    }
    _checkUnique(id) {
      if (this.schemas[id] || this.refs[id]) {
        throw new Error(`schema with key or id "${id}" already exists`);
      }
    }
    _compileSchemaEnv(sch) {
      if (sch.meta)
        this._compileMetaSchema(sch);
      else
        compile_1.compileSchema.call(this, sch);
      if (!sch.validate)
        throw new Error("ajv implementation error");
      return sch.validate;
    }
    _compileMetaSchema(sch) {
      const currentOpts = this.opts;
      this.opts = this._metaOpts;
      try {
        compile_1.compileSchema.call(this, sch);
      } finally {
        this.opts = currentOpts;
      }
    }
  }
  Ajv.ValidationError = validation_error_1.default;
  Ajv.MissingRefError = ref_error_1.default;
  exports.default = Ajv;
  function checkOptions(checkOpts, options2, msg, log = "error") {
    for (const key in checkOpts) {
      const opt = key;
      if (opt in options2)
        this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
    }
  }
  function getSchEnv(keyRef) {
    keyRef = (0, resolve_1.normalizeId)(keyRef);
    return this.schemas[keyRef] || this.refs[keyRef];
  }
  function addInitialSchemas() {
    const optsSchemas = this.opts.schemas;
    if (!optsSchemas)
      return;
    if (Array.isArray(optsSchemas))
      this.addSchema(optsSchemas);
    else
      for (const key in optsSchemas)
        this.addSchema(optsSchemas[key], key);
  }
  function addInitialFormats() {
    for (const name in this.opts.formats) {
      const format = this.opts.formats[name];
      if (format)
        this.addFormat(name, format);
    }
  }
  function addInitialKeywords(defs) {
    if (Array.isArray(defs)) {
      this.addVocabulary(defs);
      return;
    }
    this.logger.warn("keywords option as map is deprecated, pass array");
    for (const keyword in defs) {
      const def = defs[keyword];
      if (!def.keyword)
        def.keyword = keyword;
      this.addKeyword(def);
    }
  }
  function getMetaSchemaOptions() {
    const metaOpts = { ...this.opts };
    for (const opt of META_IGNORE_OPTIONS)
      delete metaOpts[opt];
    return metaOpts;
  }
  var noLogs = { log() {}, warn() {}, error() {} };
  function getLogger(logger) {
    if (logger === false)
      return noLogs;
    if (logger === undefined)
      return console;
    if (logger.log && logger.warn && logger.error)
      return logger;
    throw new Error("logger must implement log, warn and error methods");
  }
  var KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
  function checkKeyword(keyword, def) {
    const { RULES } = this;
    (0, util_1.eachItem)(keyword, (kwd) => {
      if (RULES.keywords[kwd])
        throw new Error(`Keyword ${kwd} is already defined`);
      if (!KEYWORD_NAME.test(kwd))
        throw new Error(`Keyword ${kwd} has invalid name`);
    });
    if (!def)
      return;
    if (def.$data && !(("code" in def) || ("validate" in def))) {
      throw new Error('$data keyword must have "code" or "validate" function');
    }
  }
  function addRule(keyword, definition, dataType) {
    var _a2;
    const post = definition === null || definition === undefined ? undefined : definition.post;
    if (dataType && post)
      throw new Error('keyword with "post" flag cannot have "type"');
    const { RULES } = this;
    let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);
    if (!ruleGroup) {
      ruleGroup = { type: dataType, rules: [] };
      RULES.rules.push(ruleGroup);
    }
    RULES.keywords[keyword] = true;
    if (!definition)
      return;
    const rule = {
      keyword,
      definition: {
        ...definition,
        type: (0, dataType_1.getJSONTypes)(definition.type),
        schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)
      }
    };
    if (definition.before)
      addBeforeRule.call(this, ruleGroup, rule, definition.before);
    else
      ruleGroup.rules.push(rule);
    RULES.all[keyword] = rule;
    (_a2 = definition.implements) === null || _a2 === undefined || _a2.forEach((kwd) => this.addKeyword(kwd));
  }
  function addBeforeRule(ruleGroup, rule, before) {
    const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
    if (i >= 0) {
      ruleGroup.rules.splice(i, 0, rule);
    } else {
      ruleGroup.rules.push(rule);
      this.logger.warn(`rule ${before} is not defined`);
    }
  }
  function keywordMetaschema(def) {
    let { metaSchema } = def;
    if (metaSchema === undefined)
      return;
    if (def.$data && this.opts.$data)
      metaSchema = schemaOrData(metaSchema);
    def.validateSchema = this.compile(metaSchema, true);
  }
  var $dataRef = {
    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
  };
  function schemaOrData(schema) {
    return { anyOf: [schema, $dataRef] };
  }
});

// node_modules/ajv/dist/vocabularies/core/id.js
var require_id = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var def = {
    keyword: "id",
    code() {
      throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
    }
  };
  exports.default = def;
});

// node_modules/ajv/dist/vocabularies/core/ref.js
var require_ref = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.callRef = exports.getValidate = undefined;
  var ref_error_1 = require_ref_error();
  var code_1 = require_code2();
  var codegen_1 = require_codegen();
  var names_1 = require_names();
  var compile_1 = require_compile();
  var util_1 = require_util();
  var def = {
    keyword: "$ref",
    schemaType: "string",
    code(cxt) {
      const { gen, schema: $ref, it } = cxt;
      const { baseId, schemaEnv: env, validateName, opts, self: self2 } = it;
      const { root } = env;
      if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
        return callRootRef();
      const schOrEnv = compile_1.resolveRef.call(self2, root, baseId, $ref);
      if (schOrEnv === undefined)
        throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);
      if (schOrEnv instanceof compile_1.SchemaEnv)
        return callValidate(schOrEnv);
      return inlineRefSchema(schOrEnv);
      function callRootRef() {
        if (env === root)
          return callRef(cxt, validateName, env, env.$async);
        const rootName = gen.scopeValue("root", { ref: root });
        return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root, root.$async);
      }
      function callValidate(sch) {
        const v = getValidate(cxt, sch);
        callRef(cxt, v, sch, sch.$async);
      }
      function inlineRefSchema(sch) {
        const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });
        const valid = gen.name("valid");
        const schCxt = cxt.subschema({
          schema: sch,
          dataTypes: [],
          schemaPath: codegen_1.nil,
          topSchemaRef: schName,
          errSchemaPath: $ref
        }, valid);
        cxt.mergeEvaluated(schCxt);
        cxt.ok(valid);
      }
    }
  };
  function getValidate(cxt, sch) {
    const { gen } = cxt;
    return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
  }
  exports.getValidate = getValidate;
  function callRef(cxt, v, sch, $async) {
    const { gen, it } = cxt;
    const { allErrors, schemaEnv: env, opts } = it;
    const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
    if ($async)
      callAsyncRef();
    else
      callSyncRef();
    function callAsyncRef() {
      if (!env.$async)
        throw new Error("async schema referenced by sync schema");
      const valid = gen.let("valid");
      gen.try(() => {
        gen.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);
        addEvaluatedFrom(v);
        if (!allErrors)
          gen.assign(valid, true);
      }, (e) => {
        gen.if((0, codegen_1._)`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
        addErrorsFrom(e);
        if (!allErrors)
          gen.assign(valid, false);
      });
      cxt.ok(valid);
    }
    function callSyncRef() {
      cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
    }
    function addErrorsFrom(source) {
      const errs = (0, codegen_1._)`${source}.errors`;
      gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`);
      gen.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
    }
    function addEvaluatedFrom(source) {
      var _a2;
      if (!it.opts.unevaluated)
        return;
      const schEvaluated = (_a2 = sch === null || sch === undefined ? undefined : sch.validate) === null || _a2 === undefined ? undefined : _a2.evaluated;
      if (it.props !== true) {
        if (schEvaluated && !schEvaluated.dynamicProps) {
          if (schEvaluated.props !== undefined) {
            it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);
          }
        } else {
          const props = gen.var("props", (0, codegen_1._)`${source}.evaluated.props`);
          it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);
        }
      }
      if (it.items !== true) {
        if (schEvaluated && !schEvaluated.dynamicItems) {
          if (schEvaluated.items !== undefined) {
            it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);
          }
        } else {
          const items = gen.var("items", (0, codegen_1._)`${source}.evaluated.items`);
          it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);
        }
      }
    }
  }
  exports.callRef = callRef;
  exports.default = def;
});

// node_modules/ajv/dist/vocabularies/core/index.js
var require_core2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var id_1 = require_id();
  var ref_1 = require_ref();
  var core3 = [
    "$schema",
    "$id",
    "$defs",
    "$vocabulary",
    { keyword: "$comment" },
    "definitions",
    id_1.default,
    ref_1.default
  ];
  exports.default = core3;
});

// node_modules/ajv/dist/vocabularies/validation/limitNumber.js
var require_limitNumber = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var ops = codegen_1.operators;
  var KWDs = {
    maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
    minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
    exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
    exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
  };
  var error49 = {
    message: ({ keyword, schemaCode }) => (0, codegen_1.str)`must be ${KWDs[keyword].okStr} ${schemaCode}`,
    params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
  };
  var def = {
    keyword: Object.keys(KWDs),
    type: "number",
    schemaType: "number",
    $data: true,
    error: error49,
    code(cxt) {
      const { keyword, data, schemaCode } = cxt;
      cxt.fail$data((0, codegen_1._)`${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
    }
  };
  exports.default = def;
});

// node_modules/ajv/dist/vocabularies/validation/multipleOf.js
var require_multipleOf = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var error49 = {
    message: ({ schemaCode }) => (0, codegen_1.str)`must be multiple of ${schemaCode}`,
    params: ({ schemaCode }) => (0, codegen_1._)`{multipleOf: ${schemaCode}}`
  };
  var def = {
    keyword: "multipleOf",
    type: "number",
    schemaType: "number",
    $data: true,
    error: error49,
    code(cxt) {
      const { gen, data, schemaCode, it } = cxt;
      const prec = it.opts.multipleOfPrecision;
      const res = gen.let("res");
      const invalid = prec ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1._)`${res} !== parseInt(${res})`;
      cxt.fail$data((0, codegen_1._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
    }
  };
  exports.default = def;
});

// node_modules/ajv/dist/runtime/ucs2length.js
var require_ucs2length = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  function ucs2length(str2) {
    const len = str2.length;
    let length = 0;
    let pos = 0;
    let value;
    while (pos < len) {
      length++;
      value = str2.charCodeAt(pos++);
      if (value >= 55296 && value <= 56319 && pos < len) {
        value = str2.charCodeAt(pos);
        if ((value & 64512) === 56320)
          pos++;
      }
    }
    return length;
  }
  exports.default = ucs2length;
  ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
});

// node_modules/ajv/dist/vocabularies/validation/limitLength.js
var require_limitLength = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var util_1 = require_util();
  var ucs2length_1 = require_ucs2length();
  var error49 = {
    message({ keyword, schemaCode }) {
      const comp = keyword === "maxLength" ? "more" : "fewer";
      return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`;
    },
    params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
  };
  var def = {
    keyword: ["maxLength", "minLength"],
    type: "string",
    schemaType: "number",
    $data: true,
    error: error49,
    code(cxt) {
      const { keyword, data, schemaCode, it } = cxt;
      const op = keyword === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
      const len = it.opts.unicode === false ? (0, codegen_1._)`${data}.length` : (0, codegen_1._)`${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
      cxt.fail$data((0, codegen_1._)`${len} ${op} ${schemaCode}`);
    }
  };
  exports.default = def;
});

// node_modules/ajv/dist/vocabularies/validation/pattern.js
var require_pattern = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var code_1 = require_code2();
  var codegen_1 = require_codegen();
  var error49 = {
    message: ({ schemaCode }) => (0, codegen_1.str)`must match pattern "${schemaCode}"`,
    params: ({ schemaCode }) => (0, codegen_1._)`{pattern: ${schemaCode}}`
  };
  var def = {
    keyword: "pattern",
    type: "string",
    schemaType: "string",
    $data: true,
    error: error49,
    code(cxt) {
      const { data, $data, schema, schemaCode, it } = cxt;
      const u = it.opts.unicodeRegExp ? "u" : "";
      const regExp = $data ? (0, codegen_1._)`(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);
      cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data})`);
    }
  };
  exports.default = def;
});

// node_modules/ajv/dist/vocabularies/validation/limitProperties.js
var require_limitProperties = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var error49 = {
    message({ keyword, schemaCode }) {
      const comp = keyword === "maxProperties" ? "more" : "fewer";
      return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`;
    },
    params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
  };
  var def = {
    keyword: ["maxProperties", "minProperties"],
    type: "object",
    schemaType: "number",
    $data: true,
    error: error49,
    code(cxt) {
      const { keyword, data, schemaCode } = cxt;
      const op = keyword === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
      cxt.fail$data((0, codegen_1._)`Object.keys(${data}).length ${op} ${schemaCode}`);
    }
  };
  exports.default = def;
});

// node_modules/ajv/dist/vocabularies/validation/required.js
var require_required = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var code_1 = require_code2();
  var codegen_1 = require_codegen();
  var util_1 = require_util();
  var error49 = {
    message: ({ params: { missingProperty } }) => (0, codegen_1.str)`must have required property '${missingProperty}'`,
    params: ({ params: { missingProperty } }) => (0, codegen_1._)`{missingProperty: ${missingProperty}}`
  };
  var def = {
    keyword: "required",
    type: "object",
    schemaType: "array",
    $data: true,
    error: error49,
    code(cxt) {
      const { gen, schema, schemaCode, data, $data, it } = cxt;
      const { opts } = it;
      if (!$data && schema.length === 0)
        return;
      const useLoop = schema.length >= opts.loopRequired;
      if (it.allErrors)
        allErrorsMode();
      else
        exitOnErrorMode();
      if (opts.strictRequired) {
        const props = cxt.parentSchema.properties;
        const { definedProperties } = cxt.it;
        for (const requiredKey of schema) {
          if ((props === null || props === undefined ? undefined : props[requiredKey]) === undefined && !definedProperties.has(requiredKey)) {
            const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
            const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
            (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);
          }
        }
      }
      function allErrorsMode() {
        if (useLoop || $data) {
          cxt.block$data(codegen_1.nil, loopAllRequired);
        } else {
          for (const prop of schema) {
            (0, code_1.checkReportMissingProp)(cxt, prop);
          }
        }
      }
      function exitOnErrorMode() {
        const missing = gen.let("missing");
        if (useLoop || $data) {
          const valid = gen.let("valid", true);
          cxt.block$data(valid, () => loopUntilMissing(missing, valid));
          cxt.ok(valid);
        } else {
          gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));
          (0, code_1.reportMissingProp)(cxt, missing);
          gen.else();
        }
      }
      function loopAllRequired() {
        gen.forOf("prop", schemaCode, (prop) => {
          cxt.setParams({ missingProperty: prop });
          gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
        });
      }
      function loopUntilMissing(missing, valid) {
        cxt.setParams({ missingProperty: missing });
        gen.forOf(missing, schemaCode, () => {
          gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));
          gen.if((0, codegen_1.not)(valid), () => {
            cxt.error();
            gen.break();
          });
        }, codegen_1.nil);
      }
    }
  };
  exports.default = def;
});

// node_modules/ajv/dist/vocabularies/validation/limitItems.js
var require_limitItems = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var error49 = {
    message({ keyword, schemaCode }) {
      const comp = keyword === "maxItems" ? "more" : "fewer";
      return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;
    },
    params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
  };
  var def = {
    keyword: ["maxItems", "minItems"],
    type: "array",
    schemaType: "number",
    $data: true,
    error: error49,
    code(cxt) {
      const { keyword, data, schemaCode } = cxt;
      const op = keyword === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
      cxt.fail$data((0, codegen_1._)`${data}.length ${op} ${schemaCode}`);
    }
  };
  exports.default = def;
});

// node_modules/ajv/dist/runtime/equal.js
var require_equal = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var equal = require_fast_deep_equal();
  equal.code = 'require("ajv/dist/runtime/equal").default';
  exports.default = equal;
});

// node_modules/ajv/dist/vocabularies/validation/uniqueItems.js
var require_uniqueItems = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var dataType_1 = require_dataType();
  var codegen_1 = require_codegen();
  var util_1 = require_util();
  var equal_1 = require_equal();
  var error49 = {
    message: ({ params: { i, j } }) => (0, codegen_1.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
    params: ({ params: { i, j } }) => (0, codegen_1._)`{i: ${i}, j: ${j}}`
  };
  var def = {
    keyword: "uniqueItems",
    type: "array",
    schemaType: "boolean",
    $data: true,
    error: error49,
    code(cxt) {
      const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
      if (!$data && !schema)
        return;
      const valid = gen.let("valid");
      const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
      cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`);
      cxt.ok(valid);
      function validateUniqueItems() {
        const i = gen.let("i", (0, codegen_1._)`${data}.length`);
        const j = gen.let("j");
        cxt.setParams({ i, j });
        gen.assign(valid, true);
        gen.if((0, codegen_1._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
      }
      function canOptimize() {
        return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
      }
      function loopN(i, j) {
        const item = gen.name("item");
        const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
        const indices = gen.const("indices", (0, codegen_1._)`{}`);
        gen.for((0, codegen_1._)`;${i}--;`, () => {
          gen.let(item, (0, codegen_1._)`${data}[${i}]`);
          gen.if(wrongType, (0, codegen_1._)`continue`);
          if (itemTypes.length > 1)
            gen.if((0, codegen_1._)`typeof ${item} == "string"`, (0, codegen_1._)`${item} += "_"`);
          gen.if((0, codegen_1._)`typeof ${indices}[${item}] == "number"`, () => {
            gen.assign(j, (0, codegen_1._)`${indices}[${item}]`);
            cxt.error();
            gen.assign(valid, false).break();
          }).code((0, codegen_1._)`${indices}[${item}] = ${i}`);
        });
      }
      function loopN2(i, j) {
        const eql = (0, util_1.useFunc)(gen, equal_1.default);
        const outer = gen.name("outer");
        gen.label(outer).for((0, codegen_1._)`;${i}--;`, () => gen.for((0, codegen_1._)`${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._)`${eql}(${data}[${i}], ${data}[${j}])`, () => {
          cxt.error();
          gen.assign(valid, false).break(outer);
        })));
      }
    }
  };
  exports.default = def;
});

// node_modules/ajv/dist/vocabularies/validation/const.js
var require_const = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var util_1 = require_util();
  var equal_1 = require_equal();
  var error49 = {
    message: "must be equal to constant",
    params: ({ schemaCode }) => (0, codegen_1._)`{allowedValue: ${schemaCode}}`
  };
  var def = {
    keyword: "const",
    $data: true,
    error: error49,
    code(cxt) {
      const { gen, data, $data, schemaCode, schema } = cxt;
      if ($data || schema && typeof schema == "object") {
        cxt.fail$data((0, codegen_1._)`!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);
      } else {
        cxt.fail((0, codegen_1._)`${schema} !== ${data}`);
      }
    }
  };
  exports.default = def;
});

// node_modules/ajv/dist/vocabularies/validation/enum.js
var require_enum = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var util_1 = require_util();
  var equal_1 = require_equal();
  var error49 = {
    message: "must be equal to one of the allowed values",
    params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`
  };
  var def = {
    keyword: "enum",
    schemaType: "array",
    $data: true,
    error: error49,
    code(cxt) {
      const { gen, data, $data, schema, schemaCode, it } = cxt;
      if (!$data && schema.length === 0)
        throw new Error("enum must have non-empty array");
      const useLoop = schema.length >= it.opts.loopEnum;
      let eql;
      const getEql = () => eql !== null && eql !== undefined ? eql : eql = (0, util_1.useFunc)(gen, equal_1.default);
      let valid;
      if (useLoop || $data) {
        valid = gen.let("valid");
        cxt.block$data(valid, loopEnum);
      } else {
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        const vSchema = gen.const("vSchema", schemaCode);
        valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
      }
      cxt.pass(valid);
      function loopEnum() {
        gen.assign(valid, false);
        gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1._)`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));
      }
      function equalCode(vSchema, i) {
        const sch = schema[i];
        return typeof sch === "object" && sch !== null ? (0, codegen_1._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1._)`${data} === ${sch}`;
      }
    }
  };
  exports.default = def;
});

// node_modules/ajv/dist/vocabularies/validation/index.js
var require_validation = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var limitNumber_1 = require_limitNumber();
  var multipleOf_1 = require_multipleOf();
  var limitLength_1 = require_limitLength();
  var pattern_1 = require_pattern();
  var limitProperties_1 = require_limitProperties();
  var required_1 = require_required();
  var limitItems_1 = require_limitItems();
  var uniqueItems_1 = require_uniqueItems();
  var const_1 = require_const();
  var enum_1 = require_enum();
  var validation = [
    limitNumber_1.default,
    multipleOf_1.default,
    limitLength_1.default,
    pattern_1.default,
    limitProperties_1.default,
    required_1.default,
    limitItems_1.default,
    uniqueItems_1.default,
    { keyword: "type", schemaType: ["string", "array"] },
    { keyword: "nullable", schemaType: "boolean" },
    const_1.default,
    enum_1.default
  ];
  exports.default = validation;
});

// node_modules/ajv/dist/vocabularies/applicator/additionalItems.js
var require_additionalItems = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateAdditionalItems = undefined;
  var codegen_1 = require_codegen();
  var util_1 = require_util();
  var error49 = {
    message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
    params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
  };
  var def = {
    keyword: "additionalItems",
    type: "array",
    schemaType: ["boolean", "object"],
    before: "uniqueItems",
    error: error49,
    code(cxt) {
      const { parentSchema, it } = cxt;
      const { items } = parentSchema;
      if (!Array.isArray(items)) {
        (0, util_1.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
        return;
      }
      validateAdditionalItems(cxt, items);
    }
  };
  function validateAdditionalItems(cxt, items) {
    const { gen, schema, data, keyword, it } = cxt;
    it.items = true;
    const len = gen.const("len", (0, codegen_1._)`${data}.length`);
    if (schema === false) {
      cxt.setParams({ len: items.length });
      cxt.pass((0, codegen_1._)`${len} <= ${items.length}`);
    } else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
      const valid = gen.var("valid", (0, codegen_1._)`${len} <= ${items.length}`);
      gen.if((0, codegen_1.not)(valid), () => validateItems(valid));
      cxt.ok(valid);
    }
    function validateItems(valid) {
      gen.forRange("i", items.length, len, (i) => {
        cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid);
        if (!it.allErrors)
          gen.if((0, codegen_1.not)(valid), () => gen.break());
      });
    }
  }
  exports.validateAdditionalItems = validateAdditionalItems;
  exports.default = def;
});

// node_modules/ajv/dist/vocabularies/applicator/items.js
var require_items = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateTuple = undefined;
  var codegen_1 = require_codegen();
  var util_1 = require_util();
  var code_1 = require_code2();
  var def = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "array", "boolean"],
    before: "uniqueItems",
    code(cxt) {
      const { schema, it } = cxt;
      if (Array.isArray(schema))
        return validateTuple(cxt, "additionalItems", schema);
      it.items = true;
      if ((0, util_1.alwaysValidSchema)(it, schema))
        return;
      cxt.ok((0, code_1.validateArray)(cxt));
    }
  };
  function validateTuple(cxt, extraItems, schArr = cxt.schema) {
    const { gen, parentSchema, data, keyword, it } = cxt;
    checkStrictTuple(parentSchema);
    if (it.opts.unevaluated && schArr.length && it.items !== true) {
      it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);
    }
    const valid = gen.name("valid");
    const len = gen.const("len", (0, codegen_1._)`${data}.length`);
    schArr.forEach((sch, i) => {
      if ((0, util_1.alwaysValidSchema)(it, sch))
        return;
      gen.if((0, codegen_1._)`${len} > ${i}`, () => cxt.subschema({
        keyword,
        schemaProp: i,
        dataProp: i
      }, valid));
      cxt.ok(valid);
    });
    function checkStrictTuple(sch) {
      const { opts, errSchemaPath } = it;
      const l = schArr.length;
      const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
      if (opts.strictTuples && !fullTuple) {
        const msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
        (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);
      }
    }
  }
  exports.validateTuple = validateTuple;
  exports.default = def;
});

// node_modules/ajv/dist/vocabularies/applicator/prefixItems.js
var require_prefixItems = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var items_1 = require_items();
  var def = {
    keyword: "prefixItems",
    type: "array",
    schemaType: ["array"],
    before: "uniqueItems",
    code: (cxt) => (0, items_1.validateTuple)(cxt, "items")
  };
  exports.default = def;
});

// node_modules/ajv/dist/vocabularies/applicator/items2020.js
var require_items2020 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var util_1 = require_util();
  var code_1 = require_code2();
  var additionalItems_1 = require_additionalItems();
  var error49 = {
    message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
    params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
  };
  var def = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    error: error49,
    code(cxt) {
      const { schema, parentSchema, it } = cxt;
      const { prefixItems } = parentSchema;
      it.items = true;
      if ((0, util_1.alwaysValidSchema)(it, schema))
        return;
      if (prefixItems)
        (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);
      else
        cxt.ok((0, code_1.validateArray)(cxt));
    }
  };
  exports.default = def;
});

// node_modules/ajv/dist/vocabularies/applicator/contains.js
var require_contains = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var util_1 = require_util();
  var error49 = {
    message: ({ params: { min, max } }) => max === undefined ? (0, codegen_1.str)`must contain at least ${min} valid item(s)` : (0, codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
    params: ({ params: { min, max } }) => max === undefined ? (0, codegen_1._)`{minContains: ${min}}` : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`
  };
  var def = {
    keyword: "contains",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    trackErrors: true,
    error: error49,
    code(cxt) {
      const { gen, schema, parentSchema, data, it } = cxt;
      let min;
      let max;
      const { minContains, maxContains } = parentSchema;
      if (it.opts.next) {
        min = minContains === undefined ? 1 : minContains;
        max = maxContains;
      } else {
        min = 1;
      }
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      cxt.setParams({ min, max });
      if (max === undefined && min === 0) {
        (0, util_1.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
        return;
      }
      if (max !== undefined && min > max) {
        (0, util_1.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
        cxt.fail();
        return;
      }
      if ((0, util_1.alwaysValidSchema)(it, schema)) {
        let cond = (0, codegen_1._)`${len} >= ${min}`;
        if (max !== undefined)
          cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`;
        cxt.pass(cond);
        return;
      }
      it.items = true;
      const valid = gen.name("valid");
      if (max === undefined && min === 1) {
        validateItems(valid, () => gen.if(valid, () => gen.break()));
      } else if (min === 0) {
        gen.let(valid, true);
        if (max !== undefined)
          gen.if((0, codegen_1._)`${data}.length > 0`, validateItemsWithCount);
      } else {
        gen.let(valid, false);
        validateItemsWithCount();
      }
      cxt.result(valid, () => cxt.reset());
      function validateItemsWithCount() {
        const schValid = gen.name("_valid");
        const count = gen.let("count", 0);
        validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
      }
      function validateItems(_valid, block) {
        gen.forRange("i", 0, len, (i) => {
          cxt.subschema({
            keyword: "contains",
            dataProp: i,
            dataPropType: util_1.Type.Num,
            compositeRule: true
          }, _valid);
          block();
        });
      }
      function checkLimits(count) {
        gen.code((0, codegen_1._)`${count}++`);
        if (max === undefined) {
          gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true).break());
        } else {
          gen.if((0, codegen_1._)`${count} > ${max}`, () => gen.assign(valid, false).break());
          if (min === 1)
            gen.assign(valid, true);
          else
            gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true));
        }
      }
    }
  };
  exports.default = def;
});

// node_modules/ajv/dist/vocabularies/applicator/dependencies.js
var require_dependencies = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = undefined;
  var codegen_1 = require_codegen();
  var util_1 = require_util();
  var code_1 = require_code2();
  exports.error = {
    message: ({ params: { property, depsCount, deps } }) => {
      const property_ies = depsCount === 1 ? "property" : "properties";
      return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`;
    },
    params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
  };
  var def = {
    keyword: "dependencies",
    type: "object",
    schemaType: "object",
    error: exports.error,
    code(cxt) {
      const [propDeps, schDeps] = splitDependencies(cxt);
      validatePropertyDeps(cxt, propDeps);
      validateSchemaDeps(cxt, schDeps);
    }
  };
  function splitDependencies({ schema }) {
    const propertyDeps = {};
    const schemaDeps = {};
    for (const key in schema) {
      if (key === "__proto__")
        continue;
      const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
      deps[key] = schema[key];
    }
    return [propertyDeps, schemaDeps];
  }
  function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
    const { gen, data, it } = cxt;
    if (Object.keys(propertyDeps).length === 0)
      return;
    const missing = gen.let("missing");
    for (const prop in propertyDeps) {
      const deps = propertyDeps[prop];
      if (deps.length === 0)
        continue;
      const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);
      cxt.setParams({
        property: prop,
        depsCount: deps.length,
        deps: deps.join(", ")
      });
      if (it.allErrors) {
        gen.if(hasProperty, () => {
          for (const depProp of deps) {
            (0, code_1.checkReportMissingProp)(cxt, depProp);
          }
        });
      } else {
        gen.if((0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
        (0, code_1.reportMissingProp)(cxt, missing);
        gen.else();
      }
    }
  }
  exports.validatePropertyDeps = validatePropertyDeps;
  function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
    const { gen, data, keyword, it } = cxt;
    const valid = gen.name("valid");
    for (const prop in schemaDeps) {
      if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))
        continue;
      gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties), () => {
        const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);
        cxt.mergeValidEvaluated(schCxt, valid);
      }, () => gen.var(valid, true));
      cxt.ok(valid);
    }
  }
  exports.validateSchemaDeps = validateSchemaDeps;
  exports.default = def;
});

// node_modules/ajv/dist/vocabularies/applicator/propertyNames.js
var require_propertyNames = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var util_1 = require_util();
  var error49 = {
    message: "property name must be valid",
    params: ({ params }) => (0, codegen_1._)`{propertyName: ${params.propertyName}}`
  };
  var def = {
    keyword: "propertyNames",
    type: "object",
    schemaType: ["object", "boolean"],
    error: error49,
    code(cxt) {
      const { gen, schema, data, it } = cxt;
      if ((0, util_1.alwaysValidSchema)(it, schema))
        return;
      const valid = gen.name("valid");
      gen.forIn("key", data, (key) => {
        cxt.setParams({ propertyName: key });
        cxt.subschema({
          keyword: "propertyNames",
          data: key,
          dataTypes: ["string"],
          propertyName: key,
          compositeRule: true
        }, valid);
        gen.if((0, codegen_1.not)(valid), () => {
          cxt.error(true);
          if (!it.allErrors)
            gen.break();
        });
      });
      cxt.ok(valid);
    }
  };
  exports.default = def;
});

// node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js
var require_additionalProperties = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var code_1 = require_code2();
  var codegen_1 = require_codegen();
  var names_1 = require_names();
  var util_1 = require_util();
  var error49 = {
    message: "must NOT have additional properties",
    params: ({ params }) => (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`
  };
  var def = {
    keyword: "additionalProperties",
    type: ["object"],
    schemaType: ["boolean", "object"],
    allowUndefined: true,
    trackErrors: true,
    error: error49,
    code(cxt) {
      const { gen, schema, parentSchema, data, errsCount, it } = cxt;
      if (!errsCount)
        throw new Error("ajv implementation error");
      const { allErrors, opts } = it;
      it.props = true;
      if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it, schema))
        return;
      const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
      const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
      checkAdditionalProperties();
      cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
      function checkAdditionalProperties() {
        gen.forIn("key", data, (key) => {
          if (!props.length && !patProps.length)
            additionalPropertyCode(key);
          else
            gen.if(isAdditional(key), () => additionalPropertyCode(key));
        });
      }
      function isAdditional(key) {
        let definedProp;
        if (props.length > 8) {
          const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, "properties");
          definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
        } else if (props.length) {
          definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._)`${key} === ${p}`));
        } else {
          definedProp = codegen_1.nil;
        }
        if (patProps.length) {
          definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) => (0, codegen_1._)`${(0, code_1.usePattern)(cxt, p)}.test(${key})`));
        }
        return (0, codegen_1.not)(definedProp);
      }
      function deleteAdditional(key) {
        gen.code((0, codegen_1._)`delete ${data}[${key}]`);
      }
      function additionalPropertyCode(key) {
        if (opts.removeAdditional === "all" || opts.removeAdditional && schema === false) {
          deleteAdditional(key);
          return;
        }
        if (schema === false) {
          cxt.setParams({ additionalProperty: key });
          cxt.error();
          if (!allErrors)
            gen.break();
          return;
        }
        if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
          const valid = gen.name("valid");
          if (opts.removeAdditional === "failing") {
            applyAdditionalSchema(key, valid, false);
            gen.if((0, codegen_1.not)(valid), () => {
              cxt.reset();
              deleteAdditional(key);
            });
          } else {
            applyAdditionalSchema(key, valid);
            if (!allErrors)
              gen.if((0, codegen_1.not)(valid), () => gen.break());
          }
        }
      }
      function applyAdditionalSchema(key, valid, errors5) {
        const subschema = {
          keyword: "additionalProperties",
          dataProp: key,
          dataPropType: util_1.Type.Str
        };
        if (errors5 === false) {
          Object.assign(subschema, {
            compositeRule: true,
            createErrors: false,
            allErrors: false
          });
        }
        cxt.subschema(subschema, valid);
      }
    }
  };
  exports.default = def;
});

// node_modules/ajv/dist/vocabularies/applicator/properties.js
var require_properties = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var validate_1 = require_validate();
  var code_1 = require_code2();
  var util_1 = require_util();
  var additionalProperties_1 = require_additionalProperties();
  var def = {
    keyword: "properties",
    type: "object",
    schemaType: "object",
    code(cxt) {
      const { gen, schema, parentSchema, data, it } = cxt;
      if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === undefined) {
        additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, "additionalProperties"));
      }
      const allProps = (0, code_1.allSchemaProperties)(schema);
      for (const prop of allProps) {
        it.definedProperties.add(prop);
      }
      if (it.opts.unevaluated && allProps.length && it.props !== true) {
        it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);
      }
      const properties = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));
      if (properties.length === 0)
        return;
      const valid = gen.name("valid");
      for (const prop of properties) {
        if (hasDefault(prop)) {
          applyPropertySchema(prop);
        } else {
          gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));
          applyPropertySchema(prop);
          if (!it.allErrors)
            gen.else().var(valid, true);
          gen.endIf();
        }
        cxt.it.definedProperties.add(prop);
        cxt.ok(valid);
      }
      function hasDefault(prop) {
        return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== undefined;
      }
      function applyPropertySchema(prop) {
        cxt.subschema({
          keyword: "properties",
          schemaProp: prop,
          dataProp: prop
        }, valid);
      }
    }
  };
  exports.default = def;
});

// node_modules/ajv/dist/vocabularies/applicator/patternProperties.js
var require_patternProperties = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var code_1 = require_code2();
  var codegen_1 = require_codegen();
  var util_1 = require_util();
  var util_2 = require_util();
  var def = {
    keyword: "patternProperties",
    type: "object",
    schemaType: "object",
    code(cxt) {
      const { gen, schema, data, parentSchema, it } = cxt;
      const { opts } = it;
      const patterns = (0, code_1.allSchemaProperties)(schema);
      const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));
      if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {
        return;
      }
      const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
      const valid = gen.name("valid");
      if (it.props !== true && !(it.props instanceof codegen_1.Name)) {
        it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
      }
      const { props } = it;
      validatePatternProperties();
      function validatePatternProperties() {
        for (const pat of patterns) {
          if (checkProperties)
            checkMatchingProperties(pat);
          if (it.allErrors) {
            validateProperties(pat);
          } else {
            gen.var(valid, true);
            validateProperties(pat);
            gen.if(valid);
          }
        }
      }
      function checkMatchingProperties(pat) {
        for (const prop in checkProperties) {
          if (new RegExp(pat).test(prop)) {
            (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
          }
        }
      }
      function validateProperties(pat) {
        gen.forIn("key", data, (key) => {
          gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
            const alwaysValid = alwaysValidPatterns.includes(pat);
            if (!alwaysValid) {
              cxt.subschema({
                keyword: "patternProperties",
                schemaProp: pat,
                dataProp: key,
                dataPropType: util_2.Type.Str
              }, valid);
            }
            if (it.opts.unevaluated && props !== true) {
              gen.assign((0, codegen_1._)`${props}[${key}]`, true);
            } else if (!alwaysValid && !it.allErrors) {
              gen.if((0, codegen_1.not)(valid), () => gen.break());
            }
          });
        });
      }
    }
  };
  exports.default = def;
});

// node_modules/ajv/dist/vocabularies/applicator/not.js
var require_not = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var util_1 = require_util();
  var def = {
    keyword: "not",
    schemaType: ["object", "boolean"],
    trackErrors: true,
    code(cxt) {
      const { gen, schema, it } = cxt;
      if ((0, util_1.alwaysValidSchema)(it, schema)) {
        cxt.fail();
        return;
      }
      const valid = gen.name("valid");
      cxt.subschema({
        keyword: "not",
        compositeRule: true,
        createErrors: false,
        allErrors: false
      }, valid);
      cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
    },
    error: { message: "must NOT be valid" }
  };
  exports.default = def;
});

// node_modules/ajv/dist/vocabularies/applicator/anyOf.js
var require_anyOf = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var code_1 = require_code2();
  var def = {
    keyword: "anyOf",
    schemaType: "array",
    trackErrors: true,
    code: code_1.validateUnion,
    error: { message: "must match a schema in anyOf" }
  };
  exports.default = def;
});

// node_modules/ajv/dist/vocabularies/applicator/oneOf.js
var require_oneOf = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var util_1 = require_util();
  var error49 = {
    message: "must match exactly one schema in oneOf",
    params: ({ params }) => (0, codegen_1._)`{passingSchemas: ${params.passing}}`
  };
  var def = {
    keyword: "oneOf",
    schemaType: "array",
    trackErrors: true,
    error: error49,
    code(cxt) {
      const { gen, schema, parentSchema, it } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      if (it.opts.discriminator && parentSchema.discriminator)
        return;
      const schArr = schema;
      const valid = gen.let("valid", false);
      const passing = gen.let("passing", null);
      const schValid = gen.name("_valid");
      cxt.setParams({ passing });
      gen.block(validateOneOf);
      cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
      function validateOneOf() {
        schArr.forEach((sch, i) => {
          let schCxt;
          if ((0, util_1.alwaysValidSchema)(it, sch)) {
            gen.var(schValid, true);
          } else {
            schCxt = cxt.subschema({
              keyword: "oneOf",
              schemaProp: i,
              compositeRule: true
            }, schValid);
          }
          if (i > 0) {
            gen.if((0, codegen_1._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1._)`[${passing}, ${i}]`).else();
          }
          gen.if(schValid, () => {
            gen.assign(valid, true);
            gen.assign(passing, i);
            if (schCxt)
              cxt.mergeEvaluated(schCxt, codegen_1.Name);
          });
        });
      }
    }
  };
  exports.default = def;
});

// node_modules/ajv/dist/vocabularies/applicator/allOf.js
var require_allOf = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var util_1 = require_util();
  var def = {
    keyword: "allOf",
    schemaType: "array",
    code(cxt) {
      const { gen, schema, it } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      const valid = gen.name("valid");
      schema.forEach((sch, i) => {
        if ((0, util_1.alwaysValidSchema)(it, sch))
          return;
        const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
        cxt.ok(valid);
        cxt.mergeEvaluated(schCxt);
      });
    }
  };
  exports.default = def;
});

// node_modules/ajv/dist/vocabularies/applicator/if.js
var require_if = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var util_1 = require_util();
  var error49 = {
    message: ({ params }) => (0, codegen_1.str)`must match "${params.ifClause}" schema`,
    params: ({ params }) => (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`
  };
  var def = {
    keyword: "if",
    schemaType: ["object", "boolean"],
    trackErrors: true,
    error: error49,
    code(cxt) {
      const { gen, parentSchema, it } = cxt;
      if (parentSchema.then === undefined && parentSchema.else === undefined) {
        (0, util_1.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
      }
      const hasThen = hasSchema(it, "then");
      const hasElse = hasSchema(it, "else");
      if (!hasThen && !hasElse)
        return;
      const valid = gen.let("valid", true);
      const schValid = gen.name("_valid");
      validateIf();
      cxt.reset();
      if (hasThen && hasElse) {
        const ifClause = gen.let("ifClause");
        cxt.setParams({ ifClause });
        gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
      } else if (hasThen) {
        gen.if(schValid, validateClause("then"));
      } else {
        gen.if((0, codegen_1.not)(schValid), validateClause("else"));
      }
      cxt.pass(valid, () => cxt.error(true));
      function validateIf() {
        const schCxt = cxt.subschema({
          keyword: "if",
          compositeRule: true,
          createErrors: false,
          allErrors: false
        }, schValid);
        cxt.mergeEvaluated(schCxt);
      }
      function validateClause(keyword, ifClause) {
        return () => {
          const schCxt = cxt.subschema({ keyword }, schValid);
          gen.assign(valid, schValid);
          cxt.mergeValidEvaluated(schCxt, valid);
          if (ifClause)
            gen.assign(ifClause, (0, codegen_1._)`${keyword}`);
          else
            cxt.setParams({ ifClause: keyword });
        };
      }
    }
  };
  function hasSchema(it, keyword) {
    const schema = it.schema[keyword];
    return schema !== undefined && !(0, util_1.alwaysValidSchema)(it, schema);
  }
  exports.default = def;
});

// node_modules/ajv/dist/vocabularies/applicator/thenElse.js
var require_thenElse = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var util_1 = require_util();
  var def = {
    keyword: ["then", "else"],
    schemaType: ["object", "boolean"],
    code({ keyword, parentSchema, it }) {
      if (parentSchema.if === undefined)
        (0, util_1.checkStrictMode)(it, `"${keyword}" without "if" is ignored`);
    }
  };
  exports.default = def;
});

// node_modules/ajv/dist/vocabularies/applicator/index.js
var require_applicator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var additionalItems_1 = require_additionalItems();
  var prefixItems_1 = require_prefixItems();
  var items_1 = require_items();
  var items2020_1 = require_items2020();
  var contains_1 = require_contains();
  var dependencies_1 = require_dependencies();
  var propertyNames_1 = require_propertyNames();
  var additionalProperties_1 = require_additionalProperties();
  var properties_1 = require_properties();
  var patternProperties_1 = require_patternProperties();
  var not_1 = require_not();
  var anyOf_1 = require_anyOf();
  var oneOf_1 = require_oneOf();
  var allOf_1 = require_allOf();
  var if_1 = require_if();
  var thenElse_1 = require_thenElse();
  function getApplicator(draft2020 = false) {
    const applicator = [
      not_1.default,
      anyOf_1.default,
      oneOf_1.default,
      allOf_1.default,
      if_1.default,
      thenElse_1.default,
      propertyNames_1.default,
      additionalProperties_1.default,
      dependencies_1.default,
      properties_1.default,
      patternProperties_1.default
    ];
    if (draft2020)
      applicator.push(prefixItems_1.default, items2020_1.default);
    else
      applicator.push(additionalItems_1.default, items_1.default);
    applicator.push(contains_1.default);
    return applicator;
  }
  exports.default = getApplicator;
});

// node_modules/ajv/dist/vocabularies/format/format.js
var require_format = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var error49 = {
    message: ({ schemaCode }) => (0, codegen_1.str)`must match format "${schemaCode}"`,
    params: ({ schemaCode }) => (0, codegen_1._)`{format: ${schemaCode}}`
  };
  var def = {
    keyword: "format",
    type: ["number", "string"],
    schemaType: "string",
    $data: true,
    error: error49,
    code(cxt, ruleType) {
      const { gen, data, $data, schema, schemaCode, it } = cxt;
      const { opts, errSchemaPath, schemaEnv, self: self2 } = it;
      if (!opts.validateFormats)
        return;
      if ($data)
        validate$DataFormat();
      else
        validateFormat();
      function validate$DataFormat() {
        const fmts = gen.scopeValue("formats", {
          ref: self2.formats,
          code: opts.code.formats
        });
        const fDef = gen.const("fDef", (0, codegen_1._)`${fmts}[${schemaCode}]`);
        const fType = gen.let("fType");
        const format = gen.let("format");
        gen.if((0, codegen_1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._)`${fDef}.type || "string"`).assign(format, (0, codegen_1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._)`"string"`).assign(format, fDef));
        cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
        function unknownFmt() {
          if (opts.strictSchema === false)
            return codegen_1.nil;
          return (0, codegen_1._)`${schemaCode} && !${format}`;
        }
        function invalidFmt() {
          const callFormat = schemaEnv.$async ? (0, codegen_1._)`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))` : (0, codegen_1._)`${format}(${data})`;
          const validData = (0, codegen_1._)`(typeof ${format} == "function" ? ${callFormat} : ${format}.test(${data}))`;
          return (0, codegen_1._)`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;
        }
      }
      function validateFormat() {
        const formatDef = self2.formats[schema];
        if (!formatDef) {
          unknownFormat();
          return;
        }
        if (formatDef === true)
          return;
        const [fmtType, format, fmtRef] = getFormat(formatDef);
        if (fmtType === ruleType)
          cxt.pass(validCondition());
        function unknownFormat() {
          if (opts.strictSchema === false) {
            self2.logger.warn(unknownMsg());
            return;
          }
          throw new Error(unknownMsg());
          function unknownMsg() {
            return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
          }
        }
        function getFormat(fmtDef) {
          const code = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(schema)}` : undefined;
          const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code });
          if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
            return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._)`${fmt}.validate`];
          }
          return ["string", fmtDef, fmt];
        }
        function validCondition() {
          if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
            if (!schemaEnv.$async)
              throw new Error("async format in sync schema");
            return (0, codegen_1._)`await ${fmtRef}(${data})`;
          }
          return typeof format == "function" ? (0, codegen_1._)`${fmtRef}(${data})` : (0, codegen_1._)`${fmtRef}.test(${data})`;
        }
      }
    }
  };
  exports.default = def;
});

// node_modules/ajv/dist/vocabularies/format/index.js
var require_format2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var format_1 = require_format();
  var format = [format_1.default];
  exports.default = format;
});

// node_modules/ajv/dist/vocabularies/metadata.js
var require_metadata = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.contentVocabulary = exports.metadataVocabulary = undefined;
  exports.metadataVocabulary = [
    "title",
    "description",
    "default",
    "deprecated",
    "readOnly",
    "writeOnly",
    "examples"
  ];
  exports.contentVocabulary = [
    "contentMediaType",
    "contentEncoding",
    "contentSchema"
  ];
});

// node_modules/ajv/dist/vocabularies/draft7.js
var require_draft7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var core_1 = require_core2();
  var validation_1 = require_validation();
  var applicator_1 = require_applicator();
  var format_1 = require_format2();
  var metadata_1 = require_metadata();
  var draft7Vocabularies = [
    core_1.default,
    validation_1.default,
    (0, applicator_1.default)(),
    format_1.default,
    metadata_1.metadataVocabulary,
    metadata_1.contentVocabulary
  ];
  exports.default = draft7Vocabularies;
});

// node_modules/ajv/dist/vocabularies/discriminator/types.js
var require_types2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DiscrError = undefined;
  var DiscrError;
  (function(DiscrError2) {
    DiscrError2["Tag"] = "tag";
    DiscrError2["Mapping"] = "mapping";
  })(DiscrError || (exports.DiscrError = DiscrError = {}));
});

// node_modules/ajv/dist/vocabularies/discriminator/index.js
var require_discriminator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var types_1 = require_types2();
  var compile_1 = require_compile();
  var ref_error_1 = require_ref_error();
  var util_1 = require_util();
  var error49 = {
    message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
    params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
  };
  var def = {
    keyword: "discriminator",
    type: "object",
    schemaType: "object",
    error: error49,
    code(cxt) {
      const { gen, data, schema, parentSchema, it } = cxt;
      const { oneOf } = parentSchema;
      if (!it.opts.discriminator) {
        throw new Error("discriminator: requires discriminator option");
      }
      const tagName = schema.propertyName;
      if (typeof tagName != "string")
        throw new Error("discriminator: requires propertyName");
      if (schema.mapping)
        throw new Error("discriminator: mapping is not supported");
      if (!oneOf)
        throw new Error("discriminator: requires oneOf keyword");
      const valid = gen.let("valid", false);
      const tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);
      gen.if((0, codegen_1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
      cxt.ok(valid);
      function validateMapping() {
        const mapping = getMapping();
        gen.if(false);
        for (const tagValue in mapping) {
          gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
          gen.assign(valid, applyTagSchema(mapping[tagValue]));
        }
        gen.else();
        cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
        gen.endIf();
      }
      function applyTagSchema(schemaProp) {
        const _valid = gen.name("valid");
        const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
        cxt.mergeEvaluated(schCxt, codegen_1.Name);
        return _valid;
      }
      function getMapping() {
        var _a2;
        const oneOfMapping = {};
        const topRequired = hasRequired(parentSchema);
        let tagRequired = true;
        for (let i = 0;i < oneOf.length; i++) {
          let sch = oneOf[i];
          if ((sch === null || sch === undefined ? undefined : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
            const ref = sch.$ref;
            sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref);
            if (sch instanceof compile_1.SchemaEnv)
              sch = sch.schema;
            if (sch === undefined)
              throw new ref_error_1.default(it.opts.uriResolver, it.baseId, ref);
          }
          const propSch = (_a2 = sch === null || sch === undefined ? undefined : sch.properties) === null || _a2 === undefined ? undefined : _a2[tagName];
          if (typeof propSch != "object") {
            throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
          }
          tagRequired = tagRequired && (topRequired || hasRequired(sch));
          addMappings(propSch, i);
        }
        if (!tagRequired)
          throw new Error(`discriminator: "${tagName}" must be required`);
        return oneOfMapping;
        function hasRequired({ required: required3 }) {
          return Array.isArray(required3) && required3.includes(tagName);
        }
        function addMappings(sch, i) {
          if (sch.const) {
            addMapping(sch.const, i);
          } else if (sch.enum) {
            for (const tagValue of sch.enum) {
              addMapping(tagValue, i);
            }
          } else {
            throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
          }
        }
        function addMapping(tagValue, i) {
          if (typeof tagValue != "string" || tagValue in oneOfMapping) {
            throw new Error(`discriminator: "${tagName}" values must be unique strings`);
          }
          oneOfMapping[tagValue] = i;
        }
      }
    }
  };
  exports.default = def;
});

// node_modules/ajv/dist/refs/json-schema-draft-07.json
var require_json_schema_draft_07 = __commonJS((exports, module) => {
  module.exports = {
    $schema: "http://json-schema.org/draft-07/schema#",
    $id: "http://json-schema.org/draft-07/schema#",
    title: "Core schema meta-schema",
    definitions: {
      schemaArray: {
        type: "array",
        minItems: 1,
        items: { $ref: "#" }
      },
      nonNegativeInteger: {
        type: "integer",
        minimum: 0
      },
      nonNegativeIntegerDefault0: {
        allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }]
      },
      simpleTypes: {
        enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
      },
      stringArray: {
        type: "array",
        items: { type: "string" },
        uniqueItems: true,
        default: []
      }
    },
    type: ["object", "boolean"],
    properties: {
      $id: {
        type: "string",
        format: "uri-reference"
      },
      $schema: {
        type: "string",
        format: "uri"
      },
      $ref: {
        type: "string",
        format: "uri-reference"
      },
      $comment: {
        type: "string"
      },
      title: {
        type: "string"
      },
      description: {
        type: "string"
      },
      default: true,
      readOnly: {
        type: "boolean",
        default: false
      },
      examples: {
        type: "array",
        items: true
      },
      multipleOf: {
        type: "number",
        exclusiveMinimum: 0
      },
      maximum: {
        type: "number"
      },
      exclusiveMaximum: {
        type: "number"
      },
      minimum: {
        type: "number"
      },
      exclusiveMinimum: {
        type: "number"
      },
      maxLength: { $ref: "#/definitions/nonNegativeInteger" },
      minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
      pattern: {
        type: "string",
        format: "regex"
      },
      additionalItems: { $ref: "#" },
      items: {
        anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
        default: true
      },
      maxItems: { $ref: "#/definitions/nonNegativeInteger" },
      minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
      uniqueItems: {
        type: "boolean",
        default: false
      },
      contains: { $ref: "#" },
      maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
      minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
      required: { $ref: "#/definitions/stringArray" },
      additionalProperties: { $ref: "#" },
      definitions: {
        type: "object",
        additionalProperties: { $ref: "#" },
        default: {}
      },
      properties: {
        type: "object",
        additionalProperties: { $ref: "#" },
        default: {}
      },
      patternProperties: {
        type: "object",
        additionalProperties: { $ref: "#" },
        propertyNames: { format: "regex" },
        default: {}
      },
      dependencies: {
        type: "object",
        additionalProperties: {
          anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }]
        }
      },
      propertyNames: { $ref: "#" },
      const: true,
      enum: {
        type: "array",
        items: true,
        minItems: 1,
        uniqueItems: true
      },
      type: {
        anyOf: [
          { $ref: "#/definitions/simpleTypes" },
          {
            type: "array",
            items: { $ref: "#/definitions/simpleTypes" },
            minItems: 1,
            uniqueItems: true
          }
        ]
      },
      format: { type: "string" },
      contentMediaType: { type: "string" },
      contentEncoding: { type: "string" },
      if: { $ref: "#" },
      then: { $ref: "#" },
      else: { $ref: "#" },
      allOf: { $ref: "#/definitions/schemaArray" },
      anyOf: { $ref: "#/definitions/schemaArray" },
      oneOf: { $ref: "#/definitions/schemaArray" },
      not: { $ref: "#" }
    },
    default: true
  };
});

// node_modules/ajv/dist/ajv.js
var require_ajv = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = exports.Ajv = undefined;
  var core_1 = require_core();
  var draft7_1 = require_draft7();
  var discriminator_1 = require_discriminator();
  var draft7MetaSchema = require_json_schema_draft_07();
  var META_SUPPORT_DATA = ["/properties"];
  var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";

  class Ajv extends core_1.default {
    _addVocabularies() {
      super._addVocabularies();
      draft7_1.default.forEach((v) => this.addVocabulary(v));
      if (this.opts.discriminator)
        this.addKeyword(discriminator_1.default);
    }
    _addDefaultMetaSchema() {
      super._addDefaultMetaSchema();
      if (!this.opts.meta)
        return;
      const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
      this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
      this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
    }
    defaultMeta() {
      return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined);
    }
  }
  exports.Ajv = Ajv;
  module.exports = exports = Ajv;
  module.exports.Ajv = Ajv;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = Ajv;
  var validate_1 = require_validate();
  Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
    return validate_1.KeywordCxt;
  } });
  var codegen_1 = require_codegen();
  Object.defineProperty(exports, "_", { enumerable: true, get: function() {
    return codegen_1._;
  } });
  Object.defineProperty(exports, "str", { enumerable: true, get: function() {
    return codegen_1.str;
  } });
  Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
    return codegen_1.stringify;
  } });
  Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
    return codegen_1.nil;
  } });
  Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
    return codegen_1.Name;
  } });
  Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
    return codegen_1.CodeGen;
  } });
  var validation_error_1 = require_validation_error();
  Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function() {
    return validation_error_1.default;
  } });
  var ref_error_1 = require_ref_error();
  Object.defineProperty(exports, "MissingRefError", { enumerable: true, get: function() {
    return ref_error_1.default;
  } });
});

// node_modules/ajv-formats/dist/formats.js
var require_formats = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.formatNames = exports.fastFormats = exports.fullFormats = undefined;
  function fmtDef(validate, compare) {
    return { validate, compare };
  }
  exports.fullFormats = {
    date: fmtDef(date8, compareDate),
    time: fmtDef(getTime(true), compareTime),
    "date-time": fmtDef(getDateTime(true), compareDateTime),
    "iso-time": fmtDef(getTime(), compareIsoTime),
    "iso-date-time": fmtDef(getDateTime(), compareIsoDateTime),
    duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
    uri,
    "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
    "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
    url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
    email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
    hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/,
    ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
    regex,
    uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
    "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
    "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
    "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
    byte,
    int32: { type: "number", validate: validateInt32 },
    int64: { type: "number", validate: validateInt64 },
    float: { type: "number", validate: validateNumber },
    double: { type: "number", validate: validateNumber },
    password: true,
    binary: true
  };
  exports.fastFormats = {
    ...exports.fullFormats,
    date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
    time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareTime),
    "date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
    "iso-time": fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoTime),
    "iso-date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoDateTime),
    uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
    "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
    email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
  };
  exports.formatNames = Object.keys(exports.fullFormats);
  function isLeapYear(year) {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  }
  var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
  var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  function date8(str2) {
    const matches = DATE.exec(str2);
    if (!matches)
      return false;
    const year = +matches[1];
    const month = +matches[2];
    const day = +matches[3];
    return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
  }
  function compareDate(d1, d2) {
    if (!(d1 && d2))
      return;
    if (d1 > d2)
      return 1;
    if (d1 < d2)
      return -1;
    return 0;
  }
  var TIME = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
  function getTime(strictTimeZone) {
    return function time5(str2) {
      const matches = TIME.exec(str2);
      if (!matches)
        return false;
      const hr = +matches[1];
      const min = +matches[2];
      const sec = +matches[3];
      const tz = matches[4];
      const tzSign = matches[5] === "-" ? -1 : 1;
      const tzH = +(matches[6] || 0);
      const tzM = +(matches[7] || 0);
      if (tzH > 23 || tzM > 59 || strictTimeZone && !tz)
        return false;
      if (hr <= 23 && min <= 59 && sec < 60)
        return true;
      const utcMin = min - tzM * tzSign;
      const utcHr = hr - tzH * tzSign - (utcMin < 0 ? 1 : 0);
      return (utcHr === 23 || utcHr === -1) && (utcMin === 59 || utcMin === -1) && sec < 61;
    };
  }
  function compareTime(s1, s2) {
    if (!(s1 && s2))
      return;
    const t1 = new Date("2020-01-01T" + s1).valueOf();
    const t2 = new Date("2020-01-01T" + s2).valueOf();
    if (!(t1 && t2))
      return;
    return t1 - t2;
  }
  function compareIsoTime(t1, t2) {
    if (!(t1 && t2))
      return;
    const a1 = TIME.exec(t1);
    const a2 = TIME.exec(t2);
    if (!(a1 && a2))
      return;
    t1 = a1[1] + a1[2] + a1[3];
    t2 = a2[1] + a2[2] + a2[3];
    if (t1 > t2)
      return 1;
    if (t1 < t2)
      return -1;
    return 0;
  }
  var DATE_TIME_SEPARATOR = /t|\s/i;
  function getDateTime(strictTimeZone) {
    const time5 = getTime(strictTimeZone);
    return function date_time(str2) {
      const dateTime = str2.split(DATE_TIME_SEPARATOR);
      return dateTime.length === 2 && date8(dateTime[0]) && time5(dateTime[1]);
    };
  }
  function compareDateTime(dt1, dt2) {
    if (!(dt1 && dt2))
      return;
    const d1 = new Date(dt1).valueOf();
    const d2 = new Date(dt2).valueOf();
    if (!(d1 && d2))
      return;
    return d1 - d2;
  }
  function compareIsoDateTime(dt1, dt2) {
    if (!(dt1 && dt2))
      return;
    const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);
    const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR);
    const res = compareDate(d1, d2);
    if (res === undefined)
      return;
    return res || compareTime(t1, t2);
  }
  var NOT_URI_FRAGMENT = /\/|:/;
  var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
  function uri(str2) {
    return NOT_URI_FRAGMENT.test(str2) && URI.test(str2);
  }
  var BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
  function byte(str2) {
    BYTE.lastIndex = 0;
    return BYTE.test(str2);
  }
  var MIN_INT32 = -(2 ** 31);
  var MAX_INT32 = 2 ** 31 - 1;
  function validateInt32(value) {
    return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
  }
  function validateInt64(value) {
    return Number.isInteger(value);
  }
  function validateNumber() {
    return true;
  }
  var Z_ANCHOR = /[^\\]\\Z/;
  function regex(str2) {
    if (Z_ANCHOR.test(str2))
      return false;
    try {
      new RegExp(str2);
      return true;
    } catch (e) {
      return false;
    }
  }
});

// node_modules/ajv-formats/dist/limit.js
var require_limit = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.formatLimitDefinition = undefined;
  var ajv_1 = require_ajv();
  var codegen_1 = require_codegen();
  var ops = codegen_1.operators;
  var KWDs = {
    formatMaximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
    formatMinimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
    formatExclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
    formatExclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
  };
  var error49 = {
    message: ({ keyword, schemaCode }) => (0, codegen_1.str)`should be ${KWDs[keyword].okStr} ${schemaCode}`,
    params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
  };
  exports.formatLimitDefinition = {
    keyword: Object.keys(KWDs),
    type: "string",
    schemaType: "string",
    $data: true,
    error: error49,
    code(cxt) {
      const { gen, data, schemaCode, keyword, it } = cxt;
      const { opts, self: self2 } = it;
      if (!opts.validateFormats)
        return;
      const fCxt = new ajv_1.KeywordCxt(it, self2.RULES.all.format.definition, "format");
      if (fCxt.$data)
        validate$DataFormat();
      else
        validateFormat();
      function validate$DataFormat() {
        const fmts = gen.scopeValue("formats", {
          ref: self2.formats,
          code: opts.code.formats
        });
        const fmt = gen.const("fmt", (0, codegen_1._)`${fmts}[${fCxt.schemaCode}]`);
        cxt.fail$data((0, codegen_1.or)((0, codegen_1._)`typeof ${fmt} != "object"`, (0, codegen_1._)`${fmt} instanceof RegExp`, (0, codegen_1._)`typeof ${fmt}.compare != "function"`, compareCode(fmt)));
      }
      function validateFormat() {
        const format = fCxt.schema;
        const fmtDef = self2.formats[format];
        if (!fmtDef || fmtDef === true)
          return;
        if (typeof fmtDef != "object" || fmtDef instanceof RegExp || typeof fmtDef.compare != "function") {
          throw new Error(`"${keyword}": format "${format}" does not define "compare" function`);
        }
        const fmt = gen.scopeValue("formats", {
          key: format,
          ref: fmtDef,
          code: opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(format)}` : undefined
        });
        cxt.fail$data(compareCode(fmt));
      }
      function compareCode(fmt) {
        return (0, codegen_1._)`${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword].fail} 0`;
      }
    },
    dependencies: ["format"]
  };
  var formatLimitPlugin = (ajv) => {
    ajv.addKeyword(exports.formatLimitDefinition);
    return ajv;
  };
  exports.default = formatLimitPlugin;
});

// node_modules/ajv-formats/dist/index.js
var require_dist2 = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var formats_1 = require_formats();
  var limit_1 = require_limit();
  var codegen_1 = require_codegen();
  var fullName = new codegen_1.Name("fullFormats");
  var fastName = new codegen_1.Name("fastFormats");
  var formatsPlugin = (ajv, opts = { keywords: true }) => {
    if (Array.isArray(opts)) {
      addFormats(ajv, opts, formats_1.fullFormats, fullName);
      return ajv;
    }
    const [formats, exportName] = opts.mode === "fast" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName];
    const list = opts.formats || formats_1.formatNames;
    addFormats(ajv, list, formats, exportName);
    if (opts.keywords)
      (0, limit_1.default)(ajv);
    return ajv;
  };
  formatsPlugin.get = (name, mode = "full") => {
    const formats = mode === "fast" ? formats_1.fastFormats : formats_1.fullFormats;
    const f = formats[name];
    if (!f)
      throw new Error(`Unknown format "${name}"`);
    return f;
  };
  function addFormats(ajv, list, fs2, exportName) {
    var _a2;
    var _b;
    (_a2 = (_b = ajv.opts.code).formats) !== null && _a2 !== undefined || (_b.formats = (0, codegen_1._)`require("ajv-formats/dist/formats").${exportName}`);
    for (const f of list)
      ajv.addFormat(f, fs2[f]);
  }
  module.exports = exports = formatsPlugin;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = formatsPlugin;
});

// node_modules/@modelcontextprotocol/sdk/dist/esm/validation/ajv-provider.js
function createDefaultAjvInstance() {
  const ajv = new import_ajv.default({
    strict: false,
    validateFormats: true,
    validateSchema: false,
    allErrors: true
  });
  const addFormats = import_ajv_formats.default;
  addFormats(ajv);
  return ajv;
}

class AjvJsonSchemaValidator {
  constructor(ajv) {
    this._ajv = ajv ?? createDefaultAjvInstance();
  }
  getValidator(schema) {
    const ajvValidator = "$id" in schema && typeof schema.$id === "string" ? this._ajv.getSchema(schema.$id) ?? this._ajv.compile(schema) : this._ajv.compile(schema);
    return (input) => {
      const valid = ajvValidator(input);
      if (valid) {
        return {
          valid: true,
          data: input,
          errorMessage: undefined
        };
      } else {
        return {
          valid: false,
          data: undefined,
          errorMessage: this._ajv.errorsText(ajvValidator.errors)
        };
      }
    };
  }
}
var import_ajv, import_ajv_formats;
var init_ajv_provider = __esm(() => {
  import_ajv = __toESM(require_ajv(), 1);
  import_ajv_formats = __toESM(require_dist2(), 1);
});

// node_modules/@modelcontextprotocol/sdk/dist/esm/experimental/tasks/server.js
class ExperimentalServerTasks {
  constructor(_server) {
    this._server = _server;
  }
  requestStream(request, resultSchema, options2) {
    return this._server.requestStream(request, resultSchema, options2);
  }
  async getTask(taskId, options2) {
    return this._server.getTask({ taskId }, options2);
  }
  async getTaskResult(taskId, resultSchema, options2) {
    return this._server.getTaskResult({ taskId }, resultSchema, options2);
  }
  async listTasks(cursor, options2) {
    return this._server.listTasks(cursor ? { cursor } : undefined, options2);
  }
  async cancelTask(taskId, options2) {
    return this._server.cancelTask({ taskId }, options2);
  }
}

// node_modules/@modelcontextprotocol/sdk/dist/esm/experimental/tasks/helpers.js
function assertToolsCallTaskCapability(requests, method, entityName) {
  if (!requests) {
    throw new Error(`${entityName} does not support task creation (required for ${method})`);
  }
  switch (method) {
    case "tools/call":
      if (!requests.tools?.call) {
        throw new Error(`${entityName} does not support task creation for tools/call (required for ${method})`);
      }
      break;
    default:
      break;
  }
}
function assertClientRequestTaskCapability(requests, method, entityName) {
  if (!requests) {
    throw new Error(`${entityName} does not support task creation (required for ${method})`);
  }
  switch (method) {
    case "sampling/createMessage":
      if (!requests.sampling?.createMessage) {
        throw new Error(`${entityName} does not support task creation for sampling/createMessage (required for ${method})`);
      }
      break;
    case "elicitation/create":
      if (!requests.elicitation?.create) {
        throw new Error(`${entityName} does not support task creation for elicitation/create (required for ${method})`);
      }
      break;
    default:
      break;
  }
}

// node_modules/@modelcontextprotocol/sdk/dist/esm/server/index.js
var exports_server = {};
__export(exports_server, {
  Server: () => Server
});
var Server;
var init_server = __esm(() => {
  init_protocol();
  init_types();
  init_ajv_provider();
  init_zod_compat();
  Server = class Server extends Protocol {
    constructor(_serverInfo, options2) {
      super(options2);
      this._serverInfo = _serverInfo;
      this._loggingLevels = new Map;
      this.LOG_LEVEL_SEVERITY = new Map(LoggingLevelSchema.options.map((level, index) => [level, index]));
      this.isMessageIgnored = (level, sessionId) => {
        const currentLevel = this._loggingLevels.get(sessionId);
        return currentLevel ? this.LOG_LEVEL_SEVERITY.get(level) < this.LOG_LEVEL_SEVERITY.get(currentLevel) : false;
      };
      this._capabilities = options2?.capabilities ?? {};
      this._instructions = options2?.instructions;
      this._jsonSchemaValidator = options2?.jsonSchemaValidator ?? new AjvJsonSchemaValidator;
      this.setRequestHandler(InitializeRequestSchema, (request) => this._oninitialize(request));
      this.setNotificationHandler(InitializedNotificationSchema, () => this.oninitialized?.());
      if (this._capabilities.logging) {
        this.setRequestHandler(SetLevelRequestSchema, async (request, extra) => {
          const transportSessionId = extra.sessionId || extra.requestInfo?.headers["mcp-session-id"] || undefined;
          const { level } = request.params;
          const parseResult = LoggingLevelSchema.safeParse(level);
          if (parseResult.success) {
            this._loggingLevels.set(transportSessionId, parseResult.data);
          }
          return {};
        });
      }
    }
    get experimental() {
      if (!this._experimental) {
        this._experimental = {
          tasks: new ExperimentalServerTasks(this)
        };
      }
      return this._experimental;
    }
    registerCapabilities(capabilities) {
      if (this.transport) {
        throw new Error("Cannot register capabilities after connecting to transport");
      }
      this._capabilities = mergeCapabilities(this._capabilities, capabilities);
    }
    setRequestHandler(requestSchema, handler) {
      const shape = getObjectShape(requestSchema);
      const methodSchema = shape?.method;
      if (!methodSchema) {
        throw new Error("Schema is missing a method literal");
      }
      let methodValue;
      if (isZ4Schema(methodSchema)) {
        const v4Schema = methodSchema;
        const v4Def = v4Schema._zod?.def;
        methodValue = v4Def?.value ?? v4Schema.value;
      } else {
        const v3Schema = methodSchema;
        const legacyDef = v3Schema._def;
        methodValue = legacyDef?.value ?? v3Schema.value;
      }
      if (typeof methodValue !== "string") {
        throw new Error("Schema method literal must be a string");
      }
      const method = methodValue;
      if (method === "tools/call") {
        const wrappedHandler = async (request, extra) => {
          const validatedRequest = safeParse4(CallToolRequestSchema, request);
          if (!validatedRequest.success) {
            const errorMessage = validatedRequest.error instanceof Error ? validatedRequest.error.message : String(validatedRequest.error);
            throw new McpError(ErrorCode.InvalidParams, `Invalid tools/call request: ${errorMessage}`);
          }
          const { params } = validatedRequest.data;
          const result = await Promise.resolve(handler(request, extra));
          if (params.task) {
            const taskValidationResult = safeParse4(CreateTaskResultSchema, result);
            if (!taskValidationResult.success) {
              const errorMessage = taskValidationResult.error instanceof Error ? taskValidationResult.error.message : String(taskValidationResult.error);
              throw new McpError(ErrorCode.InvalidParams, `Invalid task creation result: ${errorMessage}`);
            }
            return taskValidationResult.data;
          }
          const validationResult = safeParse4(CallToolResultSchema, result);
          if (!validationResult.success) {
            const errorMessage = validationResult.error instanceof Error ? validationResult.error.message : String(validationResult.error);
            throw new McpError(ErrorCode.InvalidParams, `Invalid tools/call result: ${errorMessage}`);
          }
          return validationResult.data;
        };
        return super.setRequestHandler(requestSchema, wrappedHandler);
      }
      return super.setRequestHandler(requestSchema, handler);
    }
    assertCapabilityForMethod(method) {
      switch (method) {
        case "sampling/createMessage":
          if (!this._clientCapabilities?.sampling) {
            throw new Error(`Client does not support sampling (required for ${method})`);
          }
          break;
        case "elicitation/create":
          if (!this._clientCapabilities?.elicitation) {
            throw new Error(`Client does not support elicitation (required for ${method})`);
          }
          break;
        case "roots/list":
          if (!this._clientCapabilities?.roots) {
            throw new Error(`Client does not support listing roots (required for ${method})`);
          }
          break;
        case "ping":
          break;
      }
    }
    assertNotificationCapability(method) {
      switch (method) {
        case "notifications/message":
          if (!this._capabilities.logging) {
            throw new Error(`Server does not support logging (required for ${method})`);
          }
          break;
        case "notifications/resources/updated":
        case "notifications/resources/list_changed":
          if (!this._capabilities.resources) {
            throw new Error(`Server does not support notifying about resources (required for ${method})`);
          }
          break;
        case "notifications/tools/list_changed":
          if (!this._capabilities.tools) {
            throw new Error(`Server does not support notifying of tool list changes (required for ${method})`);
          }
          break;
        case "notifications/prompts/list_changed":
          if (!this._capabilities.prompts) {
            throw new Error(`Server does not support notifying of prompt list changes (required for ${method})`);
          }
          break;
        case "notifications/elicitation/complete":
          if (!this._clientCapabilities?.elicitation?.url) {
            throw new Error(`Client does not support URL elicitation (required for ${method})`);
          }
          break;
        case "notifications/cancelled":
          break;
        case "notifications/progress":
          break;
      }
    }
    assertRequestHandlerCapability(method) {
      if (!this._capabilities) {
        return;
      }
      switch (method) {
        case "completion/complete":
          if (!this._capabilities.completions) {
            throw new Error(`Server does not support completions (required for ${method})`);
          }
          break;
        case "logging/setLevel":
          if (!this._capabilities.logging) {
            throw new Error(`Server does not support logging (required for ${method})`);
          }
          break;
        case "prompts/get":
        case "prompts/list":
          if (!this._capabilities.prompts) {
            throw new Error(`Server does not support prompts (required for ${method})`);
          }
          break;
        case "resources/list":
        case "resources/templates/list":
        case "resources/read":
          if (!this._capabilities.resources) {
            throw new Error(`Server does not support resources (required for ${method})`);
          }
          break;
        case "tools/call":
        case "tools/list":
          if (!this._capabilities.tools) {
            throw new Error(`Server does not support tools (required for ${method})`);
          }
          break;
        case "tasks/get":
        case "tasks/list":
        case "tasks/result":
        case "tasks/cancel":
          if (!this._capabilities.tasks) {
            throw new Error(`Server does not support tasks capability (required for ${method})`);
          }
          break;
        case "ping":
        case "initialize":
          break;
      }
    }
    assertTaskCapability(method) {
      assertClientRequestTaskCapability(this._clientCapabilities?.tasks?.requests, method, "Client");
    }
    assertTaskHandlerCapability(method) {
      if (!this._capabilities) {
        return;
      }
      assertToolsCallTaskCapability(this._capabilities.tasks?.requests, method, "Server");
    }
    async _oninitialize(request) {
      const requestedVersion = request.params.protocolVersion;
      this._clientCapabilities = request.params.capabilities;
      this._clientVersion = request.params.clientInfo;
      const protocolVersion = SUPPORTED_PROTOCOL_VERSIONS.includes(requestedVersion) ? requestedVersion : LATEST_PROTOCOL_VERSION;
      return {
        protocolVersion,
        capabilities: this.getCapabilities(),
        serverInfo: this._serverInfo,
        ...this._instructions && { instructions: this._instructions }
      };
    }
    getClientCapabilities() {
      return this._clientCapabilities;
    }
    getClientVersion() {
      return this._clientVersion;
    }
    getCapabilities() {
      return this._capabilities;
    }
    async ping() {
      return this.request({ method: "ping" }, EmptyResultSchema);
    }
    async createMessage(params, options2) {
      if (params.tools || params.toolChoice) {
        if (!this._clientCapabilities?.sampling?.tools) {
          throw new Error("Client does not support sampling tools capability.");
        }
      }
      if (params.messages.length > 0) {
        const lastMessage = params.messages[params.messages.length - 1];
        const lastContent = Array.isArray(lastMessage.content) ? lastMessage.content : [lastMessage.content];
        const hasToolResults = lastContent.some((c) => c.type === "tool_result");
        const previousMessage = params.messages.length > 1 ? params.messages[params.messages.length - 2] : undefined;
        const previousContent = previousMessage ? Array.isArray(previousMessage.content) ? previousMessage.content : [previousMessage.content] : [];
        const hasPreviousToolUse = previousContent.some((c) => c.type === "tool_use");
        if (hasToolResults) {
          if (lastContent.some((c) => c.type !== "tool_result")) {
            throw new Error("The last message must contain only tool_result content if any is present");
          }
          if (!hasPreviousToolUse) {
            throw new Error("tool_result blocks are not matching any tool_use from the previous message");
          }
        }
        if (hasPreviousToolUse) {
          const toolUseIds = new Set(previousContent.filter((c) => c.type === "tool_use").map((c) => c.id));
          const toolResultIds = new Set(lastContent.filter((c) => c.type === "tool_result").map((c) => c.toolUseId));
          if (toolUseIds.size !== toolResultIds.size || ![...toolUseIds].every((id) => toolResultIds.has(id))) {
            throw new Error("ids of tool_result blocks and tool_use blocks from previous message do not match");
          }
        }
      }
      if (params.tools) {
        return this.request({ method: "sampling/createMessage", params }, CreateMessageResultWithToolsSchema, options2);
      }
      return this.request({ method: "sampling/createMessage", params }, CreateMessageResultSchema, options2);
    }
    async elicitInput(params, options2) {
      const mode = params.mode ?? "form";
      switch (mode) {
        case "url": {
          if (!this._clientCapabilities?.elicitation?.url) {
            throw new Error("Client does not support url elicitation.");
          }
          const urlParams = params;
          return this.request({ method: "elicitation/create", params: urlParams }, ElicitResultSchema, options2);
        }
        case "form": {
          if (!this._clientCapabilities?.elicitation?.form) {
            throw new Error("Client does not support form elicitation.");
          }
          const formParams = params.mode === "form" ? params : { ...params, mode: "form" };
          const result = await this.request({ method: "elicitation/create", params: formParams }, ElicitResultSchema, options2);
          if (result.action === "accept" && result.content && formParams.requestedSchema) {
            try {
              const validator = this._jsonSchemaValidator.getValidator(formParams.requestedSchema);
              const validationResult = validator(result.content);
              if (!validationResult.valid) {
                throw new McpError(ErrorCode.InvalidParams, `Elicitation response content does not match requested schema: ${validationResult.errorMessage}`);
              }
            } catch (error49) {
              if (error49 instanceof McpError) {
                throw error49;
              }
              throw new McpError(ErrorCode.InternalError, `Error validating elicitation response: ${error49 instanceof Error ? error49.message : String(error49)}`);
            }
          }
          return result;
        }
      }
    }
    createElicitationCompletionNotifier(elicitationId, options2) {
      if (!this._clientCapabilities?.elicitation?.url) {
        throw new Error("Client does not support URL elicitation (required for notifications/elicitation/complete)");
      }
      return () => this.notification({
        method: "notifications/elicitation/complete",
        params: {
          elicitationId
        }
      }, options2);
    }
    async listRoots(params, options2) {
      return this.request({ method: "roots/list", params }, ListRootsResultSchema, options2);
    }
    async sendLoggingMessage(params, sessionId) {
      if (this._capabilities.logging) {
        if (!this.isMessageIgnored(params.level, sessionId)) {
          return this.notification({ method: "notifications/message", params });
        }
      }
    }
    async sendResourceUpdated(params) {
      return this.notification({
        method: "notifications/resources/updated",
        params
      });
    }
    async sendResourceListChanged() {
      return this.notification({
        method: "notifications/resources/list_changed"
      });
    }
    async sendToolListChanged() {
      return this.notification({ method: "notifications/tools/list_changed" });
    }
    async sendPromptListChanged() {
      return this.notification({ method: "notifications/prompts/list_changed" });
    }
  };
});

// node_modules/pino-std-serializers/lib/err-helpers.js
var require_err_helpers = __commonJS((exports, module) => {
  var isErrorLike = (err) => {
    return err && typeof err.message === "string";
  };
  var getErrorCause = (err) => {
    if (!err)
      return;
    const cause = err.cause;
    if (typeof cause === "function") {
      const causeResult = err.cause();
      return isErrorLike(causeResult) ? causeResult : undefined;
    } else {
      return isErrorLike(cause) ? cause : undefined;
    }
  };
  var _stackWithCauses = (err, seen) => {
    if (!isErrorLike(err))
      return "";
    const stack = err.stack || "";
    if (seen.has(err)) {
      return stack + `
causes have become circular...`;
    }
    const cause = getErrorCause(err);
    if (cause) {
      seen.add(err);
      return stack + `
caused by: ` + _stackWithCauses(cause, seen);
    } else {
      return stack;
    }
  };
  var stackWithCauses = (err) => _stackWithCauses(err, new Set);
  var _messageWithCauses = (err, seen, skip) => {
    if (!isErrorLike(err))
      return "";
    const message = skip ? "" : err.message || "";
    if (seen.has(err)) {
      return message + ": ...";
    }
    const cause = getErrorCause(err);
    if (cause) {
      seen.add(err);
      const skipIfVErrorStyleCause = typeof err.cause === "function";
      return message + (skipIfVErrorStyleCause ? "" : ": ") + _messageWithCauses(cause, seen, skipIfVErrorStyleCause);
    } else {
      return message;
    }
  };
  var messageWithCauses = (err) => _messageWithCauses(err, new Set);
  module.exports = {
    isErrorLike,
    getErrorCause,
    stackWithCauses,
    messageWithCauses
  };
});

// node_modules/pino-std-serializers/lib/err-proto.js
var require_err_proto = __commonJS((exports, module) => {
  var seen = Symbol("circular-ref-tag");
  var rawSymbol = Symbol("pino-raw-err-ref");
  var pinoErrProto = Object.create({}, {
    type: {
      enumerable: true,
      writable: true,
      value: undefined
    },
    message: {
      enumerable: true,
      writable: true,
      value: undefined
    },
    stack: {
      enumerable: true,
      writable: true,
      value: undefined
    },
    aggregateErrors: {
      enumerable: true,
      writable: true,
      value: undefined
    },
    raw: {
      enumerable: false,
      get: function() {
        return this[rawSymbol];
      },
      set: function(val) {
        this[rawSymbol] = val;
      }
    }
  });
  Object.defineProperty(pinoErrProto, rawSymbol, {
    writable: true,
    value: {}
  });
  module.exports = {
    pinoErrProto,
    pinoErrorSymbols: {
      seen,
      rawSymbol
    }
  };
});

// node_modules/pino-std-serializers/lib/err.js
var require_err = __commonJS((exports, module) => {
  module.exports = errSerializer;
  var { messageWithCauses, stackWithCauses, isErrorLike } = require_err_helpers();
  var { pinoErrProto, pinoErrorSymbols } = require_err_proto();
  var { seen } = pinoErrorSymbols;
  var { toString } = Object.prototype;
  function errSerializer(err) {
    if (!isErrorLike(err)) {
      return err;
    }
    err[seen] = undefined;
    const _err = Object.create(pinoErrProto);
    _err.type = toString.call(err.constructor) === "[object Function]" ? err.constructor.name : err.name;
    _err.message = messageWithCauses(err);
    _err.stack = stackWithCauses(err);
    if (Array.isArray(err.errors)) {
      _err.aggregateErrors = err.errors.map((err2) => errSerializer(err2));
    }
    for (const key in err) {
      if (_err[key] === undefined) {
        const val = err[key];
        if (isErrorLike(val)) {
          if (key !== "cause" && !Object.prototype.hasOwnProperty.call(val, seen)) {
            _err[key] = errSerializer(val);
          }
        } else {
          _err[key] = val;
        }
      }
    }
    delete err[seen];
    _err.raw = err;
    return _err;
  }
});

// node_modules/pino-std-serializers/lib/err-with-cause.js
var require_err_with_cause = __commonJS((exports, module) => {
  module.exports = errWithCauseSerializer;
  var { isErrorLike } = require_err_helpers();
  var { pinoErrProto, pinoErrorSymbols } = require_err_proto();
  var { seen } = pinoErrorSymbols;
  var { toString } = Object.prototype;
  function errWithCauseSerializer(err) {
    if (!isErrorLike(err)) {
      return err;
    }
    err[seen] = undefined;
    const _err = Object.create(pinoErrProto);
    _err.type = toString.call(err.constructor) === "[object Function]" ? err.constructor.name : err.name;
    _err.message = err.message;
    _err.stack = err.stack;
    if (Array.isArray(err.errors)) {
      _err.aggregateErrors = err.errors.map((err2) => errWithCauseSerializer(err2));
    }
    if (isErrorLike(err.cause) && !Object.prototype.hasOwnProperty.call(err.cause, seen)) {
      _err.cause = errWithCauseSerializer(err.cause);
    }
    for (const key in err) {
      if (_err[key] === undefined) {
        const val = err[key];
        if (isErrorLike(val)) {
          if (!Object.prototype.hasOwnProperty.call(val, seen)) {
            _err[key] = errWithCauseSerializer(val);
          }
        } else {
          _err[key] = val;
        }
      }
    }
    delete err[seen];
    _err.raw = err;
    return _err;
  }
});

// node_modules/pino-std-serializers/lib/req.js
var require_req = __commonJS((exports, module) => {
  module.exports = {
    mapHttpRequest,
    reqSerializer
  };
  var rawSymbol = Symbol("pino-raw-req-ref");
  var pinoReqProto = Object.create({}, {
    id: {
      enumerable: true,
      writable: true,
      value: ""
    },
    method: {
      enumerable: true,
      writable: true,
      value: ""
    },
    url: {
      enumerable: true,
      writable: true,
      value: ""
    },
    query: {
      enumerable: true,
      writable: true,
      value: ""
    },
    params: {
      enumerable: true,
      writable: true,
      value: ""
    },
    headers: {
      enumerable: true,
      writable: true,
      value: {}
    },
    remoteAddress: {
      enumerable: true,
      writable: true,
      value: ""
    },
    remotePort: {
      enumerable: true,
      writable: true,
      value: ""
    },
    raw: {
      enumerable: false,
      get: function() {
        return this[rawSymbol];
      },
      set: function(val) {
        this[rawSymbol] = val;
      }
    }
  });
  Object.defineProperty(pinoReqProto, rawSymbol, {
    writable: true,
    value: {}
  });
  function reqSerializer(req) {
    const connection = req.info || req.socket;
    const _req = Object.create(pinoReqProto);
    _req.id = typeof req.id === "function" ? req.id() : req.id || (req.info ? req.info.id : undefined);
    _req.method = req.method;
    if (req.originalUrl) {
      _req.url = req.originalUrl;
    } else {
      const path2 = req.path;
      _req.url = typeof path2 === "string" ? path2 : req.url ? req.url.path || req.url : undefined;
    }
    if (req.query) {
      _req.query = req.query;
    }
    if (req.params) {
      _req.params = req.params;
    }
    _req.headers = req.headers;
    _req.remoteAddress = connection && connection.remoteAddress;
    _req.remotePort = connection && connection.remotePort;
    _req.raw = req.raw || req;
    return _req;
  }
  function mapHttpRequest(req) {
    return {
      req: reqSerializer(req)
    };
  }
});

// node_modules/pino-std-serializers/lib/res.js
var require_res = __commonJS((exports, module) => {
  module.exports = {
    mapHttpResponse,
    resSerializer
  };
  var rawSymbol = Symbol("pino-raw-res-ref");
  var pinoResProto = Object.create({}, {
    statusCode: {
      enumerable: true,
      writable: true,
      value: 0
    },
    headers: {
      enumerable: true,
      writable: true,
      value: ""
    },
    raw: {
      enumerable: false,
      get: function() {
        return this[rawSymbol];
      },
      set: function(val) {
        this[rawSymbol] = val;
      }
    }
  });
  Object.defineProperty(pinoResProto, rawSymbol, {
    writable: true,
    value: {}
  });
  function resSerializer(res) {
    const _res = Object.create(pinoResProto);
    _res.statusCode = res.headersSent ? res.statusCode : null;
    _res.headers = res.getHeaders ? res.getHeaders() : res._headers;
    _res.raw = res;
    return _res;
  }
  function mapHttpResponse(res) {
    return {
      res: resSerializer(res)
    };
  }
});

// node_modules/pino-std-serializers/index.js
var require_pino_std_serializers = __commonJS((exports, module) => {
  var errSerializer = require_err();
  var errWithCauseSerializer = require_err_with_cause();
  var reqSerializers = require_req();
  var resSerializers = require_res();
  module.exports = {
    err: errSerializer,
    errWithCause: errWithCauseSerializer,
    mapHttpRequest: reqSerializers.mapHttpRequest,
    mapHttpResponse: resSerializers.mapHttpResponse,
    req: reqSerializers.reqSerializer,
    res: resSerializers.resSerializer,
    wrapErrorSerializer: function wrapErrorSerializer(customSerializer) {
      if (customSerializer === errSerializer)
        return customSerializer;
      return function wrapErrSerializer(err) {
        return customSerializer(errSerializer(err));
      };
    },
    wrapRequestSerializer: function wrapRequestSerializer(customSerializer) {
      if (customSerializer === reqSerializers.reqSerializer)
        return customSerializer;
      return function wrappedReqSerializer(req) {
        return customSerializer(reqSerializers.reqSerializer(req));
      };
    },
    wrapResponseSerializer: function wrapResponseSerializer(customSerializer) {
      if (customSerializer === resSerializers.resSerializer)
        return customSerializer;
      return function wrappedResSerializer(res) {
        return customSerializer(resSerializers.resSerializer(res));
      };
    }
  };
});

// node_modules/pino/lib/caller.js
var require_caller = __commonJS((exports, module) => {
  function noOpPrepareStackTrace(_, stack) {
    return stack;
  }
  module.exports = function getCallers() {
    const originalPrepare = Error.prepareStackTrace;
    Error.prepareStackTrace = noOpPrepareStackTrace;
    const stack = new Error().stack;
    Error.prepareStackTrace = originalPrepare;
    if (!Array.isArray(stack)) {
      return;
    }
    const entries = stack.slice(2);
    const fileNames = [];
    for (const entry of entries) {
      if (!entry) {
        continue;
      }
      fileNames.push(entry.getFileName());
    }
    return fileNames;
  };
});

// node_modules/@pinojs/redact/index.js
var require_redact = __commonJS((exports, module) => {
  function deepClone(obj) {
    if (obj === null || typeof obj !== "object") {
      return obj;
    }
    if (obj instanceof Date) {
      return new Date(obj.getTime());
    }
    if (obj instanceof Array) {
      const cloned = [];
      for (let i = 0;i < obj.length; i++) {
        cloned[i] = deepClone(obj[i]);
      }
      return cloned;
    }
    if (typeof obj === "object") {
      const cloned = Object.create(Object.getPrototypeOf(obj));
      for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          cloned[key] = deepClone(obj[key]);
        }
      }
      return cloned;
    }
    return obj;
  }
  function parsePath(path2) {
    const parts = [];
    let current = "";
    let inBrackets = false;
    let inQuotes = false;
    let quoteChar = "";
    for (let i = 0;i < path2.length; i++) {
      const char = path2[i];
      if (!inBrackets && char === ".") {
        if (current) {
          parts.push(current);
          current = "";
        }
      } else if (char === "[") {
        if (current) {
          parts.push(current);
          current = "";
        }
        inBrackets = true;
      } else if (char === "]" && inBrackets) {
        parts.push(current);
        current = "";
        inBrackets = false;
        inQuotes = false;
      } else if ((char === '"' || char === "'") && inBrackets) {
        if (!inQuotes) {
          inQuotes = true;
          quoteChar = char;
        } else if (char === quoteChar) {
          inQuotes = false;
          quoteChar = "";
        } else {
          current += char;
        }
      } else {
        current += char;
      }
    }
    if (current) {
      parts.push(current);
    }
    return parts;
  }
  function setValue(obj, parts, value) {
    let current = obj;
    for (let i = 0;i < parts.length - 1; i++) {
      const key = parts[i];
      if (typeof current !== "object" || current === null || !(key in current)) {
        return false;
      }
      if (typeof current[key] !== "object" || current[key] === null) {
        return false;
      }
      current = current[key];
    }
    const lastKey = parts[parts.length - 1];
    if (lastKey === "*") {
      if (Array.isArray(current)) {
        for (let i = 0;i < current.length; i++) {
          current[i] = value;
        }
      } else if (typeof current === "object" && current !== null) {
        for (const key in current) {
          if (Object.prototype.hasOwnProperty.call(current, key)) {
            current[key] = value;
          }
        }
      }
    } else {
      if (typeof current === "object" && current !== null && lastKey in current && Object.prototype.hasOwnProperty.call(current, lastKey)) {
        current[lastKey] = value;
      }
    }
    return true;
  }
  function removeKey(obj, parts) {
    let current = obj;
    for (let i = 0;i < parts.length - 1; i++) {
      const key = parts[i];
      if (typeof current !== "object" || current === null || !(key in current)) {
        return false;
      }
      if (typeof current[key] !== "object" || current[key] === null) {
        return false;
      }
      current = current[key];
    }
    const lastKey = parts[parts.length - 1];
    if (lastKey === "*") {
      if (Array.isArray(current)) {
        for (let i = 0;i < current.length; i++) {
          current[i] = undefined;
        }
      } else if (typeof current === "object" && current !== null) {
        for (const key in current) {
          if (Object.prototype.hasOwnProperty.call(current, key)) {
            delete current[key];
          }
        }
      }
    } else {
      if (typeof current === "object" && current !== null && lastKey in current && Object.prototype.hasOwnProperty.call(current, lastKey)) {
        delete current[lastKey];
      }
    }
    return true;
  }
  var PATH_NOT_FOUND = Symbol("PATH_NOT_FOUND");
  function getValueIfExists(obj, parts) {
    let current = obj;
    for (const part of parts) {
      if (current === null || current === undefined) {
        return PATH_NOT_FOUND;
      }
      if (typeof current !== "object" || current === null) {
        return PATH_NOT_FOUND;
      }
      if (!(part in current)) {
        return PATH_NOT_FOUND;
      }
      current = current[part];
    }
    return current;
  }
  function getValue(obj, parts) {
    let current = obj;
    for (const part of parts) {
      if (current === null || current === undefined) {
        return;
      }
      if (typeof current !== "object" || current === null) {
        return;
      }
      current = current[part];
    }
    return current;
  }
  function redactPaths(obj, paths, censor, remove = false) {
    for (const path2 of paths) {
      const parts = parsePath(path2);
      if (parts.includes("*")) {
        redactWildcardPath(obj, parts, censor, path2, remove);
      } else {
        if (remove) {
          removeKey(obj, parts);
        } else {
          const value = getValueIfExists(obj, parts);
          if (value === PATH_NOT_FOUND) {
            continue;
          }
          const actualCensor = typeof censor === "function" ? censor(value, parts) : censor;
          setValue(obj, parts, actualCensor);
        }
      }
    }
  }
  function redactWildcardPath(obj, parts, censor, originalPath, remove = false) {
    const wildcardIndex = parts.indexOf("*");
    if (wildcardIndex === parts.length - 1) {
      const parentParts = parts.slice(0, -1);
      let current = obj;
      for (const part of parentParts) {
        if (current === null || current === undefined)
          return;
        if (typeof current !== "object" || current === null)
          return;
        current = current[part];
      }
      if (Array.isArray(current)) {
        if (remove) {
          for (let i = 0;i < current.length; i++) {
            current[i] = undefined;
          }
        } else {
          for (let i = 0;i < current.length; i++) {
            const indexPath = [...parentParts, i.toString()];
            const actualCensor = typeof censor === "function" ? censor(current[i], indexPath) : censor;
            current[i] = actualCensor;
          }
        }
      } else if (typeof current === "object" && current !== null) {
        if (remove) {
          const keysToDelete = [];
          for (const key in current) {
            if (Object.prototype.hasOwnProperty.call(current, key)) {
              keysToDelete.push(key);
            }
          }
          for (const key of keysToDelete) {
            delete current[key];
          }
        } else {
          for (const key in current) {
            const keyPath = [...parentParts, key];
            const actualCensor = typeof censor === "function" ? censor(current[key], keyPath) : censor;
            current[key] = actualCensor;
          }
        }
      }
    } else {
      redactIntermediateWildcard(obj, parts, censor, wildcardIndex, originalPath, remove);
    }
  }
  function redactIntermediateWildcard(obj, parts, censor, wildcardIndex, originalPath, remove = false) {
    const beforeWildcard = parts.slice(0, wildcardIndex);
    const afterWildcard = parts.slice(wildcardIndex + 1);
    const pathArray = [];
    function traverse(current, pathLength) {
      if (pathLength === beforeWildcard.length) {
        if (Array.isArray(current)) {
          for (let i = 0;i < current.length; i++) {
            pathArray[pathLength] = i.toString();
            traverse(current[i], pathLength + 1);
          }
        } else if (typeof current === "object" && current !== null) {
          for (const key in current) {
            pathArray[pathLength] = key;
            traverse(current[key], pathLength + 1);
          }
        }
      } else if (pathLength < beforeWildcard.length) {
        const nextKey = beforeWildcard[pathLength];
        if (current && typeof current === "object" && current !== null && nextKey in current) {
          pathArray[pathLength] = nextKey;
          traverse(current[nextKey], pathLength + 1);
        }
      } else {
        if (afterWildcard.includes("*")) {
          const wrappedCensor = typeof censor === "function" ? (value, path2) => {
            const fullPath = [...pathArray.slice(0, pathLength), ...path2];
            return censor(value, fullPath);
          } : censor;
          redactWildcardPath(current, afterWildcard, wrappedCensor, originalPath, remove);
        } else {
          if (remove) {
            removeKey(current, afterWildcard);
          } else {
            const actualCensor = typeof censor === "function" ? censor(getValue(current, afterWildcard), [...pathArray.slice(0, pathLength), ...afterWildcard]) : censor;
            setValue(current, afterWildcard, actualCensor);
          }
        }
      }
    }
    if (beforeWildcard.length === 0) {
      traverse(obj, 0);
    } else {
      let current = obj;
      for (let i = 0;i < beforeWildcard.length; i++) {
        const part = beforeWildcard[i];
        if (current === null || current === undefined)
          return;
        if (typeof current !== "object" || current === null)
          return;
        current = current[part];
        pathArray[i] = part;
      }
      if (current !== null && current !== undefined) {
        traverse(current, beforeWildcard.length);
      }
    }
  }
  function buildPathStructure(pathsToClone) {
    if (pathsToClone.length === 0) {
      return null;
    }
    const pathStructure = new Map;
    for (const path2 of pathsToClone) {
      const parts = parsePath(path2);
      let current = pathStructure;
      for (let i = 0;i < parts.length; i++) {
        const part = parts[i];
        if (!current.has(part)) {
          current.set(part, new Map);
        }
        current = current.get(part);
      }
    }
    return pathStructure;
  }
  function selectiveClone(obj, pathStructure) {
    if (!pathStructure) {
      return obj;
    }
    function cloneSelectively(source, pathMap, depth = 0) {
      if (!pathMap || pathMap.size === 0) {
        return source;
      }
      if (source === null || typeof source !== "object") {
        return source;
      }
      if (source instanceof Date) {
        return new Date(source.getTime());
      }
      if (Array.isArray(source)) {
        const cloned2 = [];
        for (let i = 0;i < source.length; i++) {
          const indexStr = i.toString();
          if (pathMap.has(indexStr) || pathMap.has("*")) {
            cloned2[i] = cloneSelectively(source[i], pathMap.get(indexStr) || pathMap.get("*"));
          } else {
            cloned2[i] = source[i];
          }
        }
        return cloned2;
      }
      const cloned = Object.create(Object.getPrototypeOf(source));
      for (const key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          if (pathMap.has(key) || pathMap.has("*")) {
            cloned[key] = cloneSelectively(source[key], pathMap.get(key) || pathMap.get("*"));
          } else {
            cloned[key] = source[key];
          }
        }
      }
      return cloned;
    }
    return cloneSelectively(obj, pathStructure);
  }
  function validatePath(path2) {
    if (typeof path2 !== "string") {
      throw new Error("Paths must be (non-empty) strings");
    }
    if (path2 === "") {
      throw new Error("Invalid redaction path ()");
    }
    if (path2.includes("..")) {
      throw new Error(`Invalid redaction path (${path2})`);
    }
    if (path2.includes(",")) {
      throw new Error(`Invalid redaction path (${path2})`);
    }
    let bracketCount = 0;
    let inQuotes = false;
    let quoteChar = "";
    for (let i = 0;i < path2.length; i++) {
      const char = path2[i];
      if ((char === '"' || char === "'") && bracketCount > 0) {
        if (!inQuotes) {
          inQuotes = true;
          quoteChar = char;
        } else if (char === quoteChar) {
          inQuotes = false;
          quoteChar = "";
        }
      } else if (char === "[" && !inQuotes) {
        bracketCount++;
      } else if (char === "]" && !inQuotes) {
        bracketCount--;
        if (bracketCount < 0) {
          throw new Error(`Invalid redaction path (${path2})`);
        }
      }
    }
    if (bracketCount !== 0) {
      throw new Error(`Invalid redaction path (${path2})`);
    }
  }
  function validatePaths(paths) {
    if (!Array.isArray(paths)) {
      throw new TypeError("paths must be an array");
    }
    for (const path2 of paths) {
      validatePath(path2);
    }
  }
  function slowRedact(options2 = {}) {
    const {
      paths = [],
      censor = "[REDACTED]",
      serialize = JSON.stringify,
      strict = true,
      remove = false
    } = options2;
    validatePaths(paths);
    const pathStructure = buildPathStructure(paths);
    return function redact(obj) {
      if (strict && (obj === null || typeof obj !== "object")) {
        if (obj === null || obj === undefined) {
          return serialize ? serialize(obj) : obj;
        }
        if (typeof obj !== "object") {
          return serialize ? serialize(obj) : obj;
        }
      }
      const cloned = selectiveClone(obj, pathStructure);
      const original = obj;
      let actualCensor = censor;
      if (typeof censor === "function") {
        actualCensor = censor;
      }
      redactPaths(cloned, paths, actualCensor, remove);
      if (serialize === false) {
        cloned.restore = function() {
          return deepClone(original);
        };
        return cloned;
      }
      if (typeof serialize === "function") {
        return serialize(cloned);
      }
      return JSON.stringify(cloned);
    };
  }
  module.exports = slowRedact;
});

// node_modules/pino/lib/symbols.js
var require_symbols = __commonJS((exports, module) => {
  var setLevelSym = Symbol("pino.setLevel");
  var getLevelSym = Symbol("pino.getLevel");
  var levelValSym = Symbol("pino.levelVal");
  var levelCompSym = Symbol("pino.levelComp");
  var useLevelLabelsSym = Symbol("pino.useLevelLabels");
  var useOnlyCustomLevelsSym = Symbol("pino.useOnlyCustomLevels");
  var mixinSym = Symbol("pino.mixin");
  var lsCacheSym = Symbol("pino.lsCache");
  var chindingsSym = Symbol("pino.chindings");
  var asJsonSym = Symbol("pino.asJson");
  var writeSym = Symbol("pino.write");
  var redactFmtSym = Symbol("pino.redactFmt");
  var timeSym = Symbol("pino.time");
  var timeSliceIndexSym = Symbol("pino.timeSliceIndex");
  var streamSym = Symbol("pino.stream");
  var stringifySym = Symbol("pino.stringify");
  var stringifySafeSym = Symbol("pino.stringifySafe");
  var stringifiersSym = Symbol("pino.stringifiers");
  var endSym = Symbol("pino.end");
  var formatOptsSym = Symbol("pino.formatOpts");
  var messageKeySym = Symbol("pino.messageKey");
  var errorKeySym = Symbol("pino.errorKey");
  var nestedKeySym = Symbol("pino.nestedKey");
  var nestedKeyStrSym = Symbol("pino.nestedKeyStr");
  var mixinMergeStrategySym = Symbol("pino.mixinMergeStrategy");
  var msgPrefixSym = Symbol("pino.msgPrefix");
  var wildcardFirstSym = Symbol("pino.wildcardFirst");
  var serializersSym = Symbol.for("pino.serializers");
  var formattersSym = Symbol.for("pino.formatters");
  var hooksSym = Symbol.for("pino.hooks");
  var needsMetadataGsym = Symbol.for("pino.metadata");
  module.exports = {
    setLevelSym,
    getLevelSym,
    levelValSym,
    levelCompSym,
    useLevelLabelsSym,
    mixinSym,
    lsCacheSym,
    chindingsSym,
    asJsonSym,
    writeSym,
    serializersSym,
    redactFmtSym,
    timeSym,
    timeSliceIndexSym,
    streamSym,
    stringifySym,
    stringifySafeSym,
    stringifiersSym,
    endSym,
    formatOptsSym,
    messageKeySym,
    errorKeySym,
    nestedKeySym,
    wildcardFirstSym,
    needsMetadataGsym,
    useOnlyCustomLevelsSym,
    formattersSym,
    hooksSym,
    nestedKeyStrSym,
    mixinMergeStrategySym,
    msgPrefixSym
  };
});

// node_modules/pino/lib/redaction.js
var require_redaction = __commonJS((exports, module) => {
  var Redact = require_redact();
  var { redactFmtSym, wildcardFirstSym } = require_symbols();
  var rx = /[^.[\]]+|\[([^[\]]*?)\]/g;
  var CENSOR = "[Redacted]";
  var strict = false;
  function redaction(opts, serialize) {
    const { paths, censor, remove } = handle(opts);
    const shape = paths.reduce((o, str2) => {
      rx.lastIndex = 0;
      const first = rx.exec(str2);
      const next = rx.exec(str2);
      let ns = first[1] !== undefined ? first[1].replace(/^(?:"|'|`)(.*)(?:"|'|`)$/, "$1") : first[0];
      if (ns === "*") {
        ns = wildcardFirstSym;
      }
      if (next === null) {
        o[ns] = null;
        return o;
      }
      if (o[ns] === null) {
        return o;
      }
      const { index } = next;
      const nextPath = `${str2.substr(index, str2.length - 1)}`;
      o[ns] = o[ns] || [];
      if (ns !== wildcardFirstSym && o[ns].length === 0) {
        o[ns].push(...o[wildcardFirstSym] || []);
      }
      if (ns === wildcardFirstSym) {
        Object.keys(o).forEach(function(k) {
          if (o[k]) {
            o[k].push(nextPath);
          }
        });
      }
      o[ns].push(nextPath);
      return o;
    }, {});
    const result = {
      [redactFmtSym]: Redact({ paths, censor, serialize, strict, remove })
    };
    const topCensor = (...args) => {
      return typeof censor === "function" ? serialize(censor(...args)) : serialize(censor);
    };
    return [...Object.keys(shape), ...Object.getOwnPropertySymbols(shape)].reduce((o, k) => {
      if (shape[k] === null) {
        o[k] = (value) => topCensor(value, [k]);
      } else {
        const wrappedCensor = typeof censor === "function" ? (value, path2) => {
          return censor(value, [k, ...path2]);
        } : censor;
        o[k] = Redact({
          paths: shape[k],
          censor: wrappedCensor,
          serialize,
          strict,
          remove
        });
      }
      return o;
    }, result);
  }
  function handle(opts) {
    if (Array.isArray(opts)) {
      opts = { paths: opts, censor: CENSOR };
      return opts;
    }
    let { paths, censor = CENSOR, remove } = opts;
    if (Array.isArray(paths) === false) {
      throw Error("pino \u2013 redact must contain an array of strings");
    }
    if (remove === true)
      censor = undefined;
    return { paths, censor, remove };
  }
  module.exports = redaction;
});

// node_modules/pino/lib/time.js
var require_time = __commonJS((exports, module) => {
  var nullTime = () => "";
  var epochTime = () => `,"time":${Date.now()}`;
  var unixTime = () => `,"time":${Math.round(Date.now() / 1000)}`;
  var isoTime = () => `,"time":"${new Date(Date.now()).toISOString()}"`;
  var NS_PER_MS = 1000000n;
  var NS_PER_SEC = 1000000000n;
  var startWallTimeNs = BigInt(Date.now()) * NS_PER_MS;
  var startHrTime = process.hrtime.bigint();
  var isoTimeNano = () => {
    const elapsedNs = process.hrtime.bigint() - startHrTime;
    const currentTimeNs = startWallTimeNs + elapsedNs;
    const secondsSinceEpoch = currentTimeNs / NS_PER_SEC;
    const nanosWithinSecond = currentTimeNs % NS_PER_SEC;
    const msSinceEpoch = Number(secondsSinceEpoch * 1000n + nanosWithinSecond / 1000000n);
    const date8 = new Date(msSinceEpoch);
    const year = date8.getUTCFullYear();
    const month = (date8.getUTCMonth() + 1).toString().padStart(2, "0");
    const day = date8.getUTCDate().toString().padStart(2, "0");
    const hours = date8.getUTCHours().toString().padStart(2, "0");
    const minutes = date8.getUTCMinutes().toString().padStart(2, "0");
    const seconds = date8.getUTCSeconds().toString().padStart(2, "0");
    return `,"time":"${year}-${month}-${day}T${hours}:${minutes}:${seconds}.${nanosWithinSecond.toString().padStart(9, "0")}Z"`;
  };
  module.exports = { nullTime, epochTime, unixTime, isoTime, isoTimeNano };
});

// node_modules/quick-format-unescaped/index.js
var require_quick_format_unescaped = __commonJS((exports, module) => {
  function tryStringify(o) {
    try {
      return JSON.stringify(o);
    } catch (e) {
      return '"[Circular]"';
    }
  }
  module.exports = format;
  function format(f, args, opts) {
    var ss = opts && opts.stringify || tryStringify;
    var offset = 1;
    if (typeof f === "object" && f !== null) {
      var len = args.length + offset;
      if (len === 1)
        return f;
      var objects = new Array(len);
      objects[0] = ss(f);
      for (var index = 1;index < len; index++) {
        objects[index] = ss(args[index]);
      }
      return objects.join(" ");
    }
    if (typeof f !== "string") {
      return f;
    }
    var argLen = args.length;
    if (argLen === 0)
      return f;
    var str2 = "";
    var a = 1 - offset;
    var lastPos = -1;
    var flen = f && f.length || 0;
    for (var i = 0;i < flen; ) {
      if (f.charCodeAt(i) === 37 && i + 1 < flen) {
        lastPos = lastPos > -1 ? lastPos : 0;
        switch (f.charCodeAt(i + 1)) {
          case 100:
          case 102:
            if (a >= argLen)
              break;
            if (args[a] == null)
              break;
            if (lastPos < i)
              str2 += f.slice(lastPos, i);
            str2 += Number(args[a]);
            lastPos = i + 2;
            i++;
            break;
          case 105:
            if (a >= argLen)
              break;
            if (args[a] == null)
              break;
            if (lastPos < i)
              str2 += f.slice(lastPos, i);
            str2 += Math.floor(Number(args[a]));
            lastPos = i + 2;
            i++;
            break;
          case 79:
          case 111:
          case 106:
            if (a >= argLen)
              break;
            if (args[a] === undefined)
              break;
            if (lastPos < i)
              str2 += f.slice(lastPos, i);
            var type = typeof args[a];
            if (type === "string") {
              str2 += "'" + args[a] + "'";
              lastPos = i + 2;
              i++;
              break;
            }
            if (type === "function") {
              str2 += args[a].name || "<anonymous>";
              lastPos = i + 2;
              i++;
              break;
            }
            str2 += ss(args[a]);
            lastPos = i + 2;
            i++;
            break;
          case 115:
            if (a >= argLen)
              break;
            if (lastPos < i)
              str2 += f.slice(lastPos, i);
            str2 += String(args[a]);
            lastPos = i + 2;
            i++;
            break;
          case 37:
            if (lastPos < i)
              str2 += f.slice(lastPos, i);
            str2 += "%";
            lastPos = i + 2;
            i++;
            a--;
            break;
        }
        ++a;
      }
      ++i;
    }
    if (lastPos === -1)
      return f;
    else if (lastPos < flen) {
      str2 += f.slice(lastPos);
    }
    return str2;
  }
});

// node_modules/atomic-sleep/index.js
var require_atomic_sleep = __commonJS((exports, module) => {
  if (typeof SharedArrayBuffer !== "undefined" && typeof Atomics !== "undefined") {
    let sleep = function(ms) {
      const valid = ms > 0 && ms < Infinity;
      if (valid === false) {
        if (typeof ms !== "number" && typeof ms !== "bigint") {
          throw TypeError("sleep: ms must be a number");
        }
        throw RangeError("sleep: ms must be a number that is greater than 0 but less than Infinity");
      }
      Atomics.wait(nil, 0, 0, Number(ms));
    };
    const nil = new Int32Array(new SharedArrayBuffer(4));
    module.exports = sleep;
  } else {
    let sleep = function(ms) {
      const valid = ms > 0 && ms < Infinity;
      if (valid === false) {
        if (typeof ms !== "number" && typeof ms !== "bigint") {
          throw TypeError("sleep: ms must be a number");
        }
        throw RangeError("sleep: ms must be a number that is greater than 0 but less than Infinity");
      }
      const target = Date.now() + Number(ms);
      while (target > Date.now()) {}
    };
    module.exports = sleep;
  }
});

// node_modules/sonic-boom/index.js
var require_sonic_boom = __commonJS((exports, module) => {
  var fs2 = __require("fs");
  var EventEmitter = __require("events");
  var inherits = __require("util").inherits;
  var path2 = __require("path");
  var sleep = require_atomic_sleep();
  var assert3 = __require("assert");
  var BUSY_WRITE_TIMEOUT = 100;
  var kEmptyBuffer = Buffer.allocUnsafe(0);
  var MAX_WRITE = 16 * 1024;
  var kContentModeBuffer = "buffer";
  var kContentModeUtf8 = "utf8";
  var [major, minor] = (process.versions.node || "0.0").split(".").map(Number);
  var kCopyBuffer = major >= 22 && minor >= 7;
  function openFile(file2, sonic) {
    sonic._opening = true;
    sonic._writing = true;
    sonic._asyncDrainScheduled = false;
    function fileOpened(err, fd) {
      if (err) {
        sonic._reopening = false;
        sonic._writing = false;
        sonic._opening = false;
        if (sonic.sync) {
          process.nextTick(() => {
            if (sonic.listenerCount("error") > 0) {
              sonic.emit("error", err);
            }
          });
        } else {
          sonic.emit("error", err);
        }
        return;
      }
      const reopening = sonic._reopening;
      sonic.fd = fd;
      sonic.file = file2;
      sonic._reopening = false;
      sonic._opening = false;
      sonic._writing = false;
      if (sonic.sync) {
        process.nextTick(() => sonic.emit("ready"));
      } else {
        sonic.emit("ready");
      }
      if (sonic.destroyed) {
        return;
      }
      if (!sonic._writing && sonic._len > sonic.minLength || sonic._flushPending) {
        sonic._actualWrite();
      } else if (reopening) {
        process.nextTick(() => sonic.emit("drain"));
      }
    }
    const flags = sonic.append ? "a" : "w";
    const mode = sonic.mode;
    if (sonic.sync) {
      try {
        if (sonic.mkdir)
          fs2.mkdirSync(path2.dirname(file2), { recursive: true });
        const fd = fs2.openSync(file2, flags, mode);
        fileOpened(null, fd);
      } catch (err) {
        fileOpened(err);
        throw err;
      }
    } else if (sonic.mkdir) {
      fs2.mkdir(path2.dirname(file2), { recursive: true }, (err) => {
        if (err)
          return fileOpened(err);
        fs2.open(file2, flags, mode, fileOpened);
      });
    } else {
      fs2.open(file2, flags, mode, fileOpened);
    }
  }
  function SonicBoom(opts) {
    if (!(this instanceof SonicBoom)) {
      return new SonicBoom(opts);
    }
    let { fd, dest, minLength, maxLength, maxWrite, periodicFlush, sync, append = true, mkdir, retryEAGAIN, fsync, contentMode, mode } = opts || {};
    fd = fd || dest;
    this._len = 0;
    this.fd = -1;
    this._bufs = [];
    this._lens = [];
    this._writing = false;
    this._ending = false;
    this._reopening = false;
    this._asyncDrainScheduled = false;
    this._flushPending = false;
    this._hwm = Math.max(minLength || 0, 16387);
    this.file = null;
    this.destroyed = false;
    this.minLength = minLength || 0;
    this.maxLength = maxLength || 0;
    this.maxWrite = maxWrite || MAX_WRITE;
    this._periodicFlush = periodicFlush || 0;
    this._periodicFlushTimer = undefined;
    this.sync = sync || false;
    this.writable = true;
    this._fsync = fsync || false;
    this.append = append || false;
    this.mode = mode;
    this.retryEAGAIN = retryEAGAIN || (() => true);
    this.mkdir = mkdir || false;
    let fsWriteSync;
    let fsWrite;
    if (contentMode === kContentModeBuffer) {
      this._writingBuf = kEmptyBuffer;
      this.write = writeBuffer;
      this.flush = flushBuffer;
      this.flushSync = flushBufferSync;
      this._actualWrite = actualWriteBuffer;
      fsWriteSync = () => fs2.writeSync(this.fd, this._writingBuf);
      fsWrite = () => fs2.write(this.fd, this._writingBuf, this.release);
    } else if (contentMode === undefined || contentMode === kContentModeUtf8) {
      this._writingBuf = "";
      this.write = write;
      this.flush = flush;
      this.flushSync = flushSync;
      this._actualWrite = actualWrite;
      fsWriteSync = () => fs2.writeSync(this.fd, this._writingBuf, "utf8");
      fsWrite = () => fs2.write(this.fd, this._writingBuf, "utf8", this.release);
    } else {
      throw new Error(`SonicBoom supports "${kContentModeUtf8}" and "${kContentModeBuffer}", but passed ${contentMode}`);
    }
    if (typeof fd === "number") {
      this.fd = fd;
      process.nextTick(() => this.emit("ready"));
    } else if (typeof fd === "string") {
      openFile(fd, this);
    } else {
      throw new Error("SonicBoom supports only file descriptors and files");
    }
    if (this.minLength >= this.maxWrite) {
      throw new Error(`minLength should be smaller than maxWrite (${this.maxWrite})`);
    }
    this.release = (err, n) => {
      if (err) {
        if ((err.code === "EAGAIN" || err.code === "EBUSY") && this.retryEAGAIN(err, this._writingBuf.length, this._len - this._writingBuf.length)) {
          if (this.sync) {
            try {
              sleep(BUSY_WRITE_TIMEOUT);
              this.release(undefined, 0);
            } catch (err2) {
              this.release(err2);
            }
          } else {
            setTimeout(fsWrite, BUSY_WRITE_TIMEOUT);
          }
        } else {
          this._writing = false;
          this.emit("error", err);
        }
        return;
      }
      this.emit("write", n);
      const releasedBufObj = releaseWritingBuf(this._writingBuf, this._len, n);
      this._len = releasedBufObj.len;
      this._writingBuf = releasedBufObj.writingBuf;
      if (this._writingBuf.length) {
        if (!this.sync) {
          fsWrite();
          return;
        }
        try {
          do {
            const n2 = fsWriteSync();
            const releasedBufObj2 = releaseWritingBuf(this._writingBuf, this._len, n2);
            this._len = releasedBufObj2.len;
            this._writingBuf = releasedBufObj2.writingBuf;
          } while (this._writingBuf.length);
        } catch (err2) {
          this.release(err2);
          return;
        }
      }
      if (this._fsync) {
        fs2.fsyncSync(this.fd);
      }
      const len = this._len;
      if (this._reopening) {
        this._writing = false;
        this._reopening = false;
        this.reopen();
      } else if (len > this.minLength) {
        this._actualWrite();
      } else if (this._ending) {
        if (len > 0) {
          this._actualWrite();
        } else {
          this._writing = false;
          actualClose(this);
        }
      } else {
        this._writing = false;
        if (this.sync) {
          if (!this._asyncDrainScheduled) {
            this._asyncDrainScheduled = true;
            process.nextTick(emitDrain, this);
          }
        } else {
          this.emit("drain");
        }
      }
    };
    this.on("newListener", function(name) {
      if (name === "drain") {
        this._asyncDrainScheduled = false;
      }
    });
    if (this._periodicFlush !== 0) {
      this._periodicFlushTimer = setInterval(() => this.flush(null), this._periodicFlush);
      this._periodicFlushTimer.unref();
    }
  }
  function releaseWritingBuf(writingBuf, len, n) {
    if (typeof writingBuf === "string" && Buffer.byteLength(writingBuf) !== n) {
      n = Buffer.from(writingBuf).subarray(0, n).toString().length;
    }
    len = Math.max(len - n, 0);
    writingBuf = writingBuf.slice(n);
    return { writingBuf, len };
  }
  function emitDrain(sonic) {
    const hasListeners = sonic.listenerCount("drain") > 0;
    if (!hasListeners)
      return;
    sonic._asyncDrainScheduled = false;
    sonic.emit("drain");
  }
  inherits(SonicBoom, EventEmitter);
  function mergeBuf(bufs, len) {
    if (bufs.length === 0) {
      return kEmptyBuffer;
    }
    if (bufs.length === 1) {
      return bufs[0];
    }
    return Buffer.concat(bufs, len);
  }
  function write(data) {
    if (this.destroyed) {
      throw new Error("SonicBoom destroyed");
    }
    const len = this._len + data.length;
    const bufs = this._bufs;
    if (this.maxLength && len > this.maxLength) {
      this.emit("drop", data);
      return this._len < this._hwm;
    }
    if (bufs.length === 0 || bufs[bufs.length - 1].length + data.length > this.maxWrite) {
      bufs.push("" + data);
    } else {
      bufs[bufs.length - 1] += data;
    }
    this._len = len;
    if (!this._writing && this._len >= this.minLength) {
      this._actualWrite();
    }
    return this._len < this._hwm;
  }
  function writeBuffer(data) {
    if (this.destroyed) {
      throw new Error("SonicBoom destroyed");
    }
    const len = this._len + data.length;
    const bufs = this._bufs;
    const lens = this._lens;
    if (this.maxLength && len > this.maxLength) {
      this.emit("drop", data);
      return this._len < this._hwm;
    }
    if (bufs.length === 0 || lens[lens.length - 1] + data.length > this.maxWrite) {
      bufs.push([data]);
      lens.push(data.length);
    } else {
      bufs[bufs.length - 1].push(data);
      lens[lens.length - 1] += data.length;
    }
    this._len = len;
    if (!this._writing && this._len >= this.minLength) {
      this._actualWrite();
    }
    return this._len < this._hwm;
  }
  function callFlushCallbackOnDrain(cb) {
    this._flushPending = true;
    const onDrain = () => {
      if (!this._fsync) {
        try {
          fs2.fsync(this.fd, (err) => {
            this._flushPending = false;
            cb(err);
          });
        } catch (err) {
          cb(err);
        }
      } else {
        this._flushPending = false;
        cb();
      }
      this.off("error", onError);
    };
    const onError = (err) => {
      this._flushPending = false;
      cb(err);
      this.off("drain", onDrain);
    };
    this.once("drain", onDrain);
    this.once("error", onError);
  }
  function flush(cb) {
    if (cb != null && typeof cb !== "function") {
      throw new Error("flush cb must be a function");
    }
    if (this.destroyed) {
      const error49 = new Error("SonicBoom destroyed");
      if (cb) {
        cb(error49);
        return;
      }
      throw error49;
    }
    if (this.minLength <= 0) {
      cb?.();
      return;
    }
    if (cb) {
      callFlushCallbackOnDrain.call(this, cb);
    }
    if (this._writing) {
      return;
    }
    if (this._bufs.length === 0) {
      this._bufs.push("");
    }
    this._actualWrite();
  }
  function flushBuffer(cb) {
    if (cb != null && typeof cb !== "function") {
      throw new Error("flush cb must be a function");
    }
    if (this.destroyed) {
      const error49 = new Error("SonicBoom destroyed");
      if (cb) {
        cb(error49);
        return;
      }
      throw error49;
    }
    if (this.minLength <= 0) {
      cb?.();
      return;
    }
    if (cb) {
      callFlushCallbackOnDrain.call(this, cb);
    }
    if (this._writing) {
      return;
    }
    if (this._bufs.length === 0) {
      this._bufs.push([]);
      this._lens.push(0);
    }
    this._actualWrite();
  }
  SonicBoom.prototype.reopen = function(file2) {
    if (this.destroyed) {
      throw new Error("SonicBoom destroyed");
    }
    if (this._opening) {
      this.once("ready", () => {
        this.reopen(file2);
      });
      return;
    }
    if (this._ending) {
      return;
    }
    if (!this.file) {
      throw new Error("Unable to reopen a file descriptor, you must pass a file to SonicBoom");
    }
    if (file2) {
      this.file = file2;
    }
    this._reopening = true;
    if (this._writing) {
      return;
    }
    const fd = this.fd;
    this.once("ready", () => {
      if (fd !== this.fd) {
        fs2.close(fd, (err) => {
          if (err) {
            return this.emit("error", err);
          }
        });
      }
    });
    openFile(this.file, this);
  };
  SonicBoom.prototype.end = function() {
    if (this.destroyed) {
      throw new Error("SonicBoom destroyed");
    }
    if (this._opening) {
      this.once("ready", () => {
        this.end();
      });
      return;
    }
    if (this._ending) {
      return;
    }
    this._ending = true;
    if (this._writing) {
      return;
    }
    if (this._len > 0 && this.fd >= 0) {
      this._actualWrite();
    } else {
      actualClose(this);
    }
  };
  function flushSync() {
    if (this.destroyed) {
      throw new Error("SonicBoom destroyed");
    }
    if (this.fd < 0) {
      throw new Error("sonic boom is not ready yet");
    }
    if (!this._writing && this._writingBuf.length > 0) {
      this._bufs.unshift(this._writingBuf);
      this._writingBuf = "";
    }
    let buf = "";
    while (this._bufs.length || buf) {
      if (buf.length <= 0) {
        buf = this._bufs[0];
      }
      try {
        const n = fs2.writeSync(this.fd, buf, "utf8");
        const releasedBufObj = releaseWritingBuf(buf, this._len, n);
        buf = releasedBufObj.writingBuf;
        this._len = releasedBufObj.len;
        if (buf.length <= 0) {
          this._bufs.shift();
        }
      } catch (err) {
        const shouldRetry = err.code === "EAGAIN" || err.code === "EBUSY";
        if (shouldRetry && !this.retryEAGAIN(err, buf.length, this._len - buf.length)) {
          throw err;
        }
        sleep(BUSY_WRITE_TIMEOUT);
      }
    }
    try {
      fs2.fsyncSync(this.fd);
    } catch {}
  }
  function flushBufferSync() {
    if (this.destroyed) {
      throw new Error("SonicBoom destroyed");
    }
    if (this.fd < 0) {
      throw new Error("sonic boom is not ready yet");
    }
    if (!this._writing && this._writingBuf.length > 0) {
      this._bufs.unshift([this._writingBuf]);
      this._writingBuf = kEmptyBuffer;
    }
    let buf = kEmptyBuffer;
    while (this._bufs.length || buf.length) {
      if (buf.length <= 0) {
        buf = mergeBuf(this._bufs[0], this._lens[0]);
      }
      try {
        const n = fs2.writeSync(this.fd, buf);
        buf = buf.subarray(n);
        this._len = Math.max(this._len - n, 0);
        if (buf.length <= 0) {
          this._bufs.shift();
          this._lens.shift();
        }
      } catch (err) {
        const shouldRetry = err.code === "EAGAIN" || err.code === "EBUSY";
        if (shouldRetry && !this.retryEAGAIN(err, buf.length, this._len - buf.length)) {
          throw err;
        }
        sleep(BUSY_WRITE_TIMEOUT);
      }
    }
  }
  SonicBoom.prototype.destroy = function() {
    if (this.destroyed) {
      return;
    }
    actualClose(this);
  };
  function actualWrite() {
    const release = this.release;
    this._writing = true;
    this._writingBuf = this._writingBuf || this._bufs.shift() || "";
    if (this.sync) {
      try {
        const written = fs2.writeSync(this.fd, this._writingBuf, "utf8");
        release(null, written);
      } catch (err) {
        release(err);
      }
    } else {
      fs2.write(this.fd, this._writingBuf, "utf8", release);
    }
  }
  function actualWriteBuffer() {
    const release = this.release;
    this._writing = true;
    this._writingBuf = this._writingBuf.length ? this._writingBuf : mergeBuf(this._bufs.shift(), this._lens.shift());
    if (this.sync) {
      try {
        const written = fs2.writeSync(this.fd, this._writingBuf);
        release(null, written);
      } catch (err) {
        release(err);
      }
    } else {
      if (kCopyBuffer) {
        this._writingBuf = Buffer.from(this._writingBuf);
      }
      fs2.write(this.fd, this._writingBuf, release);
    }
  }
  function actualClose(sonic) {
    if (sonic.fd === -1) {
      sonic.once("ready", actualClose.bind(null, sonic));
      return;
    }
    if (sonic._periodicFlushTimer !== undefined) {
      clearInterval(sonic._periodicFlushTimer);
    }
    sonic.destroyed = true;
    sonic._bufs = [];
    sonic._lens = [];
    assert3(typeof sonic.fd === "number", `sonic.fd must be a number, got ${typeof sonic.fd}`);
    try {
      fs2.fsync(sonic.fd, closeWrapped);
    } catch {}
    function closeWrapped() {
      if (sonic.fd !== 1 && sonic.fd !== 2) {
        fs2.close(sonic.fd, done);
      } else {
        done();
      }
    }
    function done(err) {
      if (err) {
        sonic.emit("error", err);
        return;
      }
      if (sonic._ending && !sonic._writing) {
        sonic.emit("finish");
      }
      sonic.emit("close");
    }
  }
  SonicBoom.SonicBoom = SonicBoom;
  SonicBoom.default = SonicBoom;
  module.exports = SonicBoom;
});

// node_modules/on-exit-leak-free/index.js
var require_on_exit_leak_free = __commonJS((exports, module) => {
  var refs = {
    exit: [],
    beforeExit: []
  };
  var functions = {
    exit: onExit,
    beforeExit: onBeforeExit
  };
  var registry3;
  function ensureRegistry() {
    if (registry3 === undefined) {
      registry3 = new FinalizationRegistry(clear);
    }
  }
  function install(event) {
    if (refs[event].length > 0) {
      return;
    }
    process.on(event, functions[event]);
  }
  function uninstall(event) {
    if (refs[event].length > 0) {
      return;
    }
    process.removeListener(event, functions[event]);
    if (refs.exit.length === 0 && refs.beforeExit.length === 0) {
      registry3 = undefined;
    }
  }
  function onExit() {
    callRefs("exit");
  }
  function onBeforeExit() {
    callRefs("beforeExit");
  }
  function callRefs(event) {
    for (const ref of refs[event]) {
      const obj = ref.deref();
      const fn = ref.fn;
      if (obj !== undefined) {
        fn(obj, event);
      }
    }
    refs[event] = [];
  }
  function clear(ref) {
    for (const event of ["exit", "beforeExit"]) {
      const index = refs[event].indexOf(ref);
      refs[event].splice(index, index + 1);
      uninstall(event);
    }
  }
  function _register(event, obj, fn) {
    if (obj === undefined) {
      throw new Error("the object can't be undefined");
    }
    install(event);
    const ref = new WeakRef(obj);
    ref.fn = fn;
    ensureRegistry();
    registry3.register(obj, ref);
    refs[event].push(ref);
  }
  function register(obj, fn) {
    _register("exit", obj, fn);
  }
  function registerBeforeExit(obj, fn) {
    _register("beforeExit", obj, fn);
  }
  function unregister(obj) {
    if (registry3 === undefined) {
      return;
    }
    registry3.unregister(obj);
    for (const event of ["exit", "beforeExit"]) {
      refs[event] = refs[event].filter((ref) => {
        const _obj = ref.deref();
        return _obj && _obj !== obj;
      });
      uninstall(event);
    }
  }
  module.exports = {
    register,
    registerBeforeExit,
    unregister
  };
});

// node_modules/thread-stream/package.json
var require_package = __commonJS((exports, module) => {
  module.exports = {
    name: "thread-stream",
    version: "3.1.0",
    description: "A streaming way to send data to a Node.js Worker Thread",
    main: "index.js",
    types: "index.d.ts",
    dependencies: {
      "real-require": "^0.2.0"
    },
    devDependencies: {
      "@types/node": "^20.1.0",
      "@types/tap": "^15.0.0",
      "@yao-pkg/pkg": "^5.11.5",
      desm: "^1.3.0",
      fastbench: "^1.0.1",
      husky: "^9.0.6",
      "pino-elasticsearch": "^8.0.0",
      "sonic-boom": "^4.0.1",
      standard: "^17.0.0",
      tap: "^16.2.0",
      "ts-node": "^10.8.0",
      typescript: "^5.3.2",
      "why-is-node-running": "^2.2.2"
    },
    scripts: {
      build: "tsc --noEmit",
      test: 'standard && npm run build && npm run transpile && tap "test/**/*.test.*js" && tap --ts test/*.test.*ts',
      "test:ci": "standard && npm run transpile && npm run test:ci:js && npm run test:ci:ts",
      "test:ci:js": 'tap --no-check-coverage --timeout=120 --coverage-report=lcovonly "test/**/*.test.*js"',
      "test:ci:ts": 'tap --ts --no-check-coverage --coverage-report=lcovonly "test/**/*.test.*ts"',
      "test:yarn": 'npm run transpile && tap "test/**/*.test.js" --no-check-coverage',
      transpile: "sh ./test/ts/transpile.sh",
      prepare: "husky install"
    },
    standard: {
      ignore: [
        "test/ts/**/*",
        "test/syntax-error.mjs"
      ]
    },
    repository: {
      type: "git",
      url: "git+https://github.com/mcollina/thread-stream.git"
    },
    keywords: [
      "worker",
      "thread",
      "threads",
      "stream"
    ],
    author: "Matteo Collina <hello@matteocollina.com>",
    license: "MIT",
    bugs: {
      url: "https://github.com/mcollina/thread-stream/issues"
    },
    homepage: "https://github.com/mcollina/thread-stream#readme"
  };
});

// node_modules/thread-stream/lib/wait.js
var require_wait = __commonJS((exports, module) => {
  var MAX_TIMEOUT = 1000;
  function wait(state, index, expected, timeout, done) {
    const max = Date.now() + timeout;
    let current = Atomics.load(state, index);
    if (current === expected) {
      done(null, "ok");
      return;
    }
    let prior = current;
    const check3 = (backoff) => {
      if (Date.now() > max) {
        done(null, "timed-out");
      } else {
        setTimeout(() => {
          prior = current;
          current = Atomics.load(state, index);
          if (current === prior) {
            check3(backoff >= MAX_TIMEOUT ? MAX_TIMEOUT : backoff * 2);
          } else {
            if (current === expected)
              done(null, "ok");
            else
              done(null, "not-equal");
          }
        }, backoff);
      }
    };
    check3(1);
  }
  function waitDiff(state, index, expected, timeout, done) {
    const max = Date.now() + timeout;
    let current = Atomics.load(state, index);
    if (current !== expected) {
      done(null, "ok");
      return;
    }
    const check3 = (backoff) => {
      if (Date.now() > max) {
        done(null, "timed-out");
      } else {
        setTimeout(() => {
          current = Atomics.load(state, index);
          if (current !== expected) {
            done(null, "ok");
          } else {
            check3(backoff >= MAX_TIMEOUT ? MAX_TIMEOUT : backoff * 2);
          }
        }, backoff);
      }
    };
    check3(1);
  }
  module.exports = { wait, waitDiff };
});

// node_modules/thread-stream/lib/indexes.js
var require_indexes = __commonJS((exports, module) => {
  var WRITE_INDEX = 4;
  var READ_INDEX = 8;
  module.exports = {
    WRITE_INDEX,
    READ_INDEX
  };
});

// node_modules/thread-stream/index.js
var require_thread_stream = __commonJS((exports, module) => {
  var __dirname = "/Users/petersmith/Dev/GitHub/amalfa/node_modules/thread-stream";
  var { version: version3 } = require_package();
  var { EventEmitter } = __require("events");
  var { Worker } = __require("worker_threads");
  var { join: join6 } = __require("path");
  var { pathToFileURL } = __require("url");
  var { wait } = require_wait();
  var {
    WRITE_INDEX,
    READ_INDEX
  } = require_indexes();
  var buffer = __require("buffer");
  var assert3 = __require("assert");
  var kImpl = Symbol("kImpl");
  var MAX_STRING = buffer.constants.MAX_STRING_LENGTH;

  class FakeWeakRef {
    constructor(value) {
      this._value = value;
    }
    deref() {
      return this._value;
    }
  }

  class FakeFinalizationRegistry {
    register() {}
    unregister() {}
  }
  var FinalizationRegistry2 = process.env.NODE_V8_COVERAGE ? FakeFinalizationRegistry : global.FinalizationRegistry || FakeFinalizationRegistry;
  var WeakRef2 = process.env.NODE_V8_COVERAGE ? FakeWeakRef : global.WeakRef || FakeWeakRef;
  var registry3 = new FinalizationRegistry2((worker) => {
    if (worker.exited) {
      return;
    }
    worker.terminate();
  });
  function createWorker(stream, opts) {
    const { filename, workerData } = opts;
    const bundlerOverrides = "__bundlerPathsOverrides" in globalThis ? globalThis.__bundlerPathsOverrides : {};
    const toExecute = bundlerOverrides["thread-stream-worker"] || join6(__dirname, "lib", "worker.js");
    const worker = new Worker(toExecute, {
      ...opts.workerOpts,
      trackUnmanagedFds: false,
      workerData: {
        filename: filename.indexOf("file://") === 0 ? filename : pathToFileURL(filename).href,
        dataBuf: stream[kImpl].dataBuf,
        stateBuf: stream[kImpl].stateBuf,
        workerData: {
          $context: {
            threadStreamVersion: version3
          },
          ...workerData
        }
      }
    });
    worker.stream = new FakeWeakRef(stream);
    worker.on("message", onWorkerMessage);
    worker.on("exit", onWorkerExit);
    registry3.register(stream, worker);
    return worker;
  }
  function drain(stream) {
    assert3(!stream[kImpl].sync);
    if (stream[kImpl].needDrain) {
      stream[kImpl].needDrain = false;
      stream.emit("drain");
    }
  }
  function nextFlush(stream) {
    const writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX);
    let leftover = stream[kImpl].data.length - writeIndex;
    if (leftover > 0) {
      if (stream[kImpl].buf.length === 0) {
        stream[kImpl].flushing = false;
        if (stream[kImpl].ending) {
          end(stream);
        } else if (stream[kImpl].needDrain) {
          process.nextTick(drain, stream);
        }
        return;
      }
      let toWrite = stream[kImpl].buf.slice(0, leftover);
      let toWriteBytes = Buffer.byteLength(toWrite);
      if (toWriteBytes <= leftover) {
        stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
        write(stream, toWrite, nextFlush.bind(null, stream));
      } else {
        stream.flush(() => {
          if (stream.destroyed) {
            return;
          }
          Atomics.store(stream[kImpl].state, READ_INDEX, 0);
          Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
          while (toWriteBytes > stream[kImpl].data.length) {
            leftover = leftover / 2;
            toWrite = stream[kImpl].buf.slice(0, leftover);
            toWriteBytes = Buffer.byteLength(toWrite);
          }
          stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
          write(stream, toWrite, nextFlush.bind(null, stream));
        });
      }
    } else if (leftover === 0) {
      if (writeIndex === 0 && stream[kImpl].buf.length === 0) {
        return;
      }
      stream.flush(() => {
        Atomics.store(stream[kImpl].state, READ_INDEX, 0);
        Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
        nextFlush(stream);
      });
    } else {
      destroy(stream, new Error("overwritten"));
    }
  }
  function onWorkerMessage(msg) {
    const stream = this.stream.deref();
    if (stream === undefined) {
      this.exited = true;
      this.terminate();
      return;
    }
    switch (msg.code) {
      case "READY":
        this.stream = new WeakRef2(stream);
        stream.flush(() => {
          stream[kImpl].ready = true;
          stream.emit("ready");
        });
        break;
      case "ERROR":
        destroy(stream, msg.err);
        break;
      case "EVENT":
        if (Array.isArray(msg.args)) {
          stream.emit(msg.name, ...msg.args);
        } else {
          stream.emit(msg.name, msg.args);
        }
        break;
      case "WARNING":
        process.emitWarning(msg.err);
        break;
      default:
        destroy(stream, new Error("this should not happen: " + msg.code));
    }
  }
  function onWorkerExit(code) {
    const stream = this.stream.deref();
    if (stream === undefined) {
      return;
    }
    registry3.unregister(stream);
    stream.worker.exited = true;
    stream.worker.off("exit", onWorkerExit);
    destroy(stream, code !== 0 ? new Error("the worker thread exited") : null);
  }

  class ThreadStream extends EventEmitter {
    constructor(opts = {}) {
      super();
      if (opts.bufferSize < 4) {
        throw new Error("bufferSize must at least fit a 4-byte utf-8 char");
      }
      this[kImpl] = {};
      this[kImpl].stateBuf = new SharedArrayBuffer(128);
      this[kImpl].state = new Int32Array(this[kImpl].stateBuf);
      this[kImpl].dataBuf = new SharedArrayBuffer(opts.bufferSize || 4 * 1024 * 1024);
      this[kImpl].data = Buffer.from(this[kImpl].dataBuf);
      this[kImpl].sync = opts.sync || false;
      this[kImpl].ending = false;
      this[kImpl].ended = false;
      this[kImpl].needDrain = false;
      this[kImpl].destroyed = false;
      this[kImpl].flushing = false;
      this[kImpl].ready = false;
      this[kImpl].finished = false;
      this[kImpl].errored = null;
      this[kImpl].closed = false;
      this[kImpl].buf = "";
      this.worker = createWorker(this, opts);
      this.on("message", (message, transferList) => {
        this.worker.postMessage(message, transferList);
      });
    }
    write(data) {
      if (this[kImpl].destroyed) {
        error49(this, new Error("the worker has exited"));
        return false;
      }
      if (this[kImpl].ending) {
        error49(this, new Error("the worker is ending"));
        return false;
      }
      if (this[kImpl].flushing && this[kImpl].buf.length + data.length >= MAX_STRING) {
        try {
          writeSync(this);
          this[kImpl].flushing = true;
        } catch (err) {
          destroy(this, err);
          return false;
        }
      }
      this[kImpl].buf += data;
      if (this[kImpl].sync) {
        try {
          writeSync(this);
          return true;
        } catch (err) {
          destroy(this, err);
          return false;
        }
      }
      if (!this[kImpl].flushing) {
        this[kImpl].flushing = true;
        setImmediate(nextFlush, this);
      }
      this[kImpl].needDrain = this[kImpl].data.length - this[kImpl].buf.length - Atomics.load(this[kImpl].state, WRITE_INDEX) <= 0;
      return !this[kImpl].needDrain;
    }
    end() {
      if (this[kImpl].destroyed) {
        return;
      }
      this[kImpl].ending = true;
      end(this);
    }
    flush(cb) {
      if (this[kImpl].destroyed) {
        if (typeof cb === "function") {
          process.nextTick(cb, new Error("the worker has exited"));
        }
        return;
      }
      const writeIndex = Atomics.load(this[kImpl].state, WRITE_INDEX);
      wait(this[kImpl].state, READ_INDEX, writeIndex, Infinity, (err, res) => {
        if (err) {
          destroy(this, err);
          process.nextTick(cb, err);
          return;
        }
        if (res === "not-equal") {
          this.flush(cb);
          return;
        }
        process.nextTick(cb);
      });
    }
    flushSync() {
      if (this[kImpl].destroyed) {
        return;
      }
      writeSync(this);
      flushSync(this);
    }
    unref() {
      this.worker.unref();
    }
    ref() {
      this.worker.ref();
    }
    get ready() {
      return this[kImpl].ready;
    }
    get destroyed() {
      return this[kImpl].destroyed;
    }
    get closed() {
      return this[kImpl].closed;
    }
    get writable() {
      return !this[kImpl].destroyed && !this[kImpl].ending;
    }
    get writableEnded() {
      return this[kImpl].ending;
    }
    get writableFinished() {
      return this[kImpl].finished;
    }
    get writableNeedDrain() {
      return this[kImpl].needDrain;
    }
    get writableObjectMode() {
      return false;
    }
    get writableErrored() {
      return this[kImpl].errored;
    }
  }
  function error49(stream, err) {
    setImmediate(() => {
      stream.emit("error", err);
    });
  }
  function destroy(stream, err) {
    if (stream[kImpl].destroyed) {
      return;
    }
    stream[kImpl].destroyed = true;
    if (err) {
      stream[kImpl].errored = err;
      error49(stream, err);
    }
    if (!stream.worker.exited) {
      stream.worker.terminate().catch(() => {}).then(() => {
        stream[kImpl].closed = true;
        stream.emit("close");
      });
    } else {
      setImmediate(() => {
        stream[kImpl].closed = true;
        stream.emit("close");
      });
    }
  }
  function write(stream, data, cb) {
    const current = Atomics.load(stream[kImpl].state, WRITE_INDEX);
    const length = Buffer.byteLength(data);
    stream[kImpl].data.write(data, current);
    Atomics.store(stream[kImpl].state, WRITE_INDEX, current + length);
    Atomics.notify(stream[kImpl].state, WRITE_INDEX);
    cb();
    return true;
  }
  function end(stream) {
    if (stream[kImpl].ended || !stream[kImpl].ending || stream[kImpl].flushing) {
      return;
    }
    stream[kImpl].ended = true;
    try {
      stream.flushSync();
      let readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);
      Atomics.store(stream[kImpl].state, WRITE_INDEX, -1);
      Atomics.notify(stream[kImpl].state, WRITE_INDEX);
      let spins = 0;
      while (readIndex !== -1) {
        Atomics.wait(stream[kImpl].state, READ_INDEX, readIndex, 1000);
        readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);
        if (readIndex === -2) {
          destroy(stream, new Error("end() failed"));
          return;
        }
        if (++spins === 10) {
          destroy(stream, new Error("end() took too long (10s)"));
          return;
        }
      }
      process.nextTick(() => {
        stream[kImpl].finished = true;
        stream.emit("finish");
      });
    } catch (err) {
      destroy(stream, err);
    }
  }
  function writeSync(stream) {
    const cb = () => {
      if (stream[kImpl].ending) {
        end(stream);
      } else if (stream[kImpl].needDrain) {
        process.nextTick(drain, stream);
      }
    };
    stream[kImpl].flushing = false;
    while (stream[kImpl].buf.length !== 0) {
      const writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX);
      let leftover = stream[kImpl].data.length - writeIndex;
      if (leftover === 0) {
        flushSync(stream);
        Atomics.store(stream[kImpl].state, READ_INDEX, 0);
        Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
        continue;
      } else if (leftover < 0) {
        throw new Error("overwritten");
      }
      let toWrite = stream[kImpl].buf.slice(0, leftover);
      let toWriteBytes = Buffer.byteLength(toWrite);
      if (toWriteBytes <= leftover) {
        stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
        write(stream, toWrite, cb);
      } else {
        flushSync(stream);
        Atomics.store(stream[kImpl].state, READ_INDEX, 0);
        Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
        while (toWriteBytes > stream[kImpl].buf.length) {
          leftover = leftover / 2;
          toWrite = stream[kImpl].buf.slice(0, leftover);
          toWriteBytes = Buffer.byteLength(toWrite);
        }
        stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
        write(stream, toWrite, cb);
      }
    }
  }
  function flushSync(stream) {
    if (stream[kImpl].flushing) {
      throw new Error("unable to flush while flushing");
    }
    const writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX);
    let spins = 0;
    while (true) {
      const readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);
      if (readIndex === -2) {
        throw Error("_flushSync failed");
      }
      if (readIndex !== writeIndex) {
        Atomics.wait(stream[kImpl].state, READ_INDEX, readIndex, 1000);
      } else {
        break;
      }
      if (++spins === 10) {
        throw new Error("_flushSync took too long (10s)");
      }
    }
  }
  module.exports = ThreadStream;
});

// node_modules/pino/lib/transport.js
var require_transport = __commonJS((exports, module) => {
  var __dirname = "/Users/petersmith/Dev/GitHub/amalfa/node_modules/pino/lib";
  var { createRequire } = __require("module");
  var getCallers = require_caller();
  var { join: join6, isAbsolute, sep } = __require("path");
  var sleep = require_atomic_sleep();
  var onExit = require_on_exit_leak_free();
  var ThreadStream = require_thread_stream();
  function setupOnExit(stream) {
    onExit.register(stream, autoEnd);
    onExit.registerBeforeExit(stream, flush);
    stream.on("close", function() {
      onExit.unregister(stream);
    });
  }
  function buildStream(filename, workerData, workerOpts, sync) {
    const stream = new ThreadStream({
      filename,
      workerData,
      workerOpts,
      sync
    });
    stream.on("ready", onReady);
    stream.on("close", function() {
      process.removeListener("exit", onExit2);
    });
    process.on("exit", onExit2);
    function onReady() {
      process.removeListener("exit", onExit2);
      stream.unref();
      if (workerOpts.autoEnd !== false) {
        setupOnExit(stream);
      }
    }
    function onExit2() {
      if (stream.closed) {
        return;
      }
      stream.flushSync();
      sleep(100);
      stream.end();
    }
    return stream;
  }
  function autoEnd(stream) {
    stream.ref();
    stream.flushSync();
    stream.end();
    stream.once("close", function() {
      stream.unref();
    });
  }
  function flush(stream) {
    stream.flushSync();
  }
  function transport(fullOptions) {
    const { pipeline: pipeline2, targets, levels, dedupe, worker = {}, caller = getCallers(), sync = false } = fullOptions;
    const options2 = {
      ...fullOptions.options
    };
    const callers = typeof caller === "string" ? [caller] : caller;
    const bundlerOverrides = "__bundlerPathsOverrides" in globalThis ? globalThis.__bundlerPathsOverrides : {};
    let target = fullOptions.target;
    if (target && targets) {
      throw new Error("only one of target or targets can be specified");
    }
    if (targets) {
      target = bundlerOverrides["pino-worker"] || join6(__dirname, "worker.js");
      options2.targets = targets.filter((dest) => dest.target).map((dest) => {
        return {
          ...dest,
          target: fixTarget(dest.target)
        };
      });
      options2.pipelines = targets.filter((dest) => dest.pipeline).map((dest) => {
        return dest.pipeline.map((t) => {
          return {
            ...t,
            level: dest.level,
            target: fixTarget(t.target)
          };
        });
      });
    } else if (pipeline2) {
      target = bundlerOverrides["pino-worker"] || join6(__dirname, "worker.js");
      options2.pipelines = [pipeline2.map((dest) => {
        return {
          ...dest,
          target: fixTarget(dest.target)
        };
      })];
    }
    if (levels) {
      options2.levels = levels;
    }
    if (dedupe) {
      options2.dedupe = dedupe;
    }
    options2.pinoWillSendConfig = true;
    return buildStream(fixTarget(target), options2, worker, sync);
    function fixTarget(origin) {
      origin = bundlerOverrides[origin] || origin;
      if (isAbsolute(origin) || origin.indexOf("file://") === 0) {
        return origin;
      }
      if (origin === "pino/file") {
        return join6(__dirname, "..", "file.js");
      }
      let fixTarget2;
      for (const filePath of callers) {
        try {
          const context = filePath === "node:repl" ? process.cwd() + sep : filePath;
          fixTarget2 = createRequire(context).resolve(origin);
          break;
        } catch (err) {
          continue;
        }
      }
      if (!fixTarget2) {
        throw new Error(`unable to determine transport target for "${origin}"`);
      }
      return fixTarget2;
    }
  }
  module.exports = transport;
});

// node_modules/pino/lib/tools.js
var require_tools = __commonJS((exports, module) => {
  var diagChan = __require("diagnostics_channel");
  var format = require_quick_format_unescaped();
  var { mapHttpRequest, mapHttpResponse } = require_pino_std_serializers();
  var SonicBoom = require_sonic_boom();
  var onExit = require_on_exit_leak_free();
  var {
    lsCacheSym,
    chindingsSym,
    writeSym,
    serializersSym,
    formatOptsSym,
    endSym,
    stringifiersSym,
    stringifySym,
    stringifySafeSym,
    wildcardFirstSym,
    nestedKeySym,
    formattersSym,
    messageKeySym,
    errorKeySym,
    nestedKeyStrSym,
    msgPrefixSym
  } = require_symbols();
  var { isMainThread } = __require("worker_threads");
  var transport = require_transport();
  var asJsonChan = diagChan.tracingChannel("pino_asJson");
  function noop() {}
  function genLog(level, hook) {
    if (!hook)
      return LOG;
    return function hookWrappedLog(...args) {
      hook.call(this, args, LOG, level);
    };
    function LOG(o, ...n) {
      if (typeof o === "object") {
        let msg = o;
        if (o !== null) {
          if (o.method && o.headers && o.socket) {
            o = mapHttpRequest(o);
          } else if (typeof o.setHeader === "function") {
            o = mapHttpResponse(o);
          }
        }
        let formatParams;
        if (msg === null && n.length === 0) {
          formatParams = [null];
        } else {
          msg = n.shift();
          formatParams = n;
        }
        if (typeof this[msgPrefixSym] === "string" && msg !== undefined && msg !== null) {
          msg = this[msgPrefixSym] + msg;
        }
        this[writeSym](o, format(msg, formatParams, this[formatOptsSym]), level);
      } else {
        let msg = o === undefined ? n.shift() : o;
        if (typeof this[msgPrefixSym] === "string" && msg !== undefined && msg !== null) {
          msg = this[msgPrefixSym] + msg;
        }
        this[writeSym](null, format(msg, n, this[formatOptsSym]), level);
      }
    }
  }
  function asString(str2) {
    let result = "";
    let last = 0;
    let found = false;
    let point = 255;
    const l = str2.length;
    if (l > 100) {
      return JSON.stringify(str2);
    }
    for (var i = 0;i < l && point >= 32; i++) {
      point = str2.charCodeAt(i);
      if (point === 34 || point === 92) {
        result += str2.slice(last, i) + "\\";
        last = i;
        found = true;
      }
    }
    if (!found) {
      result = str2;
    } else {
      result += str2.slice(last);
    }
    return point < 32 ? JSON.stringify(str2) : '"' + result + '"';
  }
  function asJson(obj, msg, num, time5) {
    if (asJsonChan.hasSubscribers === false) {
      return _asJson.call(this, obj, msg, num, time5);
    }
    const store = { instance: this, arguments };
    return asJsonChan.traceSync(_asJson, store, this, obj, msg, num, time5);
  }
  function _asJson(obj, msg, num, time5) {
    const stringify2 = this[stringifySym];
    const stringifySafe = this[stringifySafeSym];
    const stringifiers = this[stringifiersSym];
    const end = this[endSym];
    const chindings = this[chindingsSym];
    const serializers = this[serializersSym];
    const formatters = this[formattersSym];
    const messageKey = this[messageKeySym];
    const errorKey = this[errorKeySym];
    let data = this[lsCacheSym][num] + time5;
    data = data + chindings;
    let value;
    if (formatters.log) {
      obj = formatters.log(obj);
    }
    const wildcardStringifier = stringifiers[wildcardFirstSym];
    let propStr = "";
    for (const key in obj) {
      value = obj[key];
      if (Object.prototype.hasOwnProperty.call(obj, key) && value !== undefined) {
        if (serializers[key]) {
          value = serializers[key](value);
        } else if (key === errorKey && serializers.err) {
          value = serializers.err(value);
        }
        const stringifier = stringifiers[key] || wildcardStringifier;
        switch (typeof value) {
          case "undefined":
          case "function":
            continue;
          case "number":
            if (Number.isFinite(value) === false) {
              value = null;
            }
          case "boolean":
            if (stringifier)
              value = stringifier(value);
            break;
          case "string":
            value = (stringifier || asString)(value);
            break;
          default:
            value = (stringifier || stringify2)(value, stringifySafe);
        }
        if (value === undefined)
          continue;
        const strKey = asString(key);
        propStr += "," + strKey + ":" + value;
      }
    }
    let msgStr = "";
    if (msg !== undefined) {
      value = serializers[messageKey] ? serializers[messageKey](msg) : msg;
      const stringifier = stringifiers[messageKey] || wildcardStringifier;
      switch (typeof value) {
        case "function":
          break;
        case "number":
          if (Number.isFinite(value) === false) {
            value = null;
          }
        case "boolean":
          if (stringifier)
            value = stringifier(value);
          msgStr = ',"' + messageKey + '":' + value;
          break;
        case "string":
          value = (stringifier || asString)(value);
          msgStr = ',"' + messageKey + '":' + value;
          break;
        default:
          value = (stringifier || stringify2)(value, stringifySafe);
          msgStr = ',"' + messageKey + '":' + value;
      }
    }
    if (this[nestedKeySym] && propStr) {
      return data + this[nestedKeyStrSym] + propStr.slice(1) + "}" + msgStr + end;
    } else {
      return data + propStr + msgStr + end;
    }
  }
  function asChindings(instance, bindings) {
    let value;
    let data = instance[chindingsSym];
    const stringify2 = instance[stringifySym];
    const stringifySafe = instance[stringifySafeSym];
    const stringifiers = instance[stringifiersSym];
    const wildcardStringifier = stringifiers[wildcardFirstSym];
    const serializers = instance[serializersSym];
    const formatter = instance[formattersSym].bindings;
    bindings = formatter(bindings);
    for (const key in bindings) {
      value = bindings[key];
      const valid = (key.length < 5 || key !== "level" && key !== "serializers" && key !== "formatters" && key !== "customLevels") && bindings.hasOwnProperty(key) && value !== undefined;
      if (valid === true) {
        value = serializers[key] ? serializers[key](value) : value;
        value = (stringifiers[key] || wildcardStringifier || stringify2)(value, stringifySafe);
        if (value === undefined)
          continue;
        data += ',"' + key + '":' + value;
      }
    }
    return data;
  }
  function hasBeenTampered(stream) {
    return stream.write !== stream.constructor.prototype.write;
  }
  function buildSafeSonicBoom(opts) {
    const stream = new SonicBoom(opts);
    stream.on("error", filterBrokenPipe);
    if (!opts.sync && isMainThread) {
      onExit.register(stream, autoEnd);
      stream.on("close", function() {
        onExit.unregister(stream);
      });
    }
    return stream;
    function filterBrokenPipe(err) {
      if (err.code === "EPIPE") {
        stream.write = noop;
        stream.end = noop;
        stream.flushSync = noop;
        stream.destroy = noop;
        return;
      }
      stream.removeListener("error", filterBrokenPipe);
      stream.emit("error", err);
    }
  }
  function autoEnd(stream, eventName) {
    if (stream.destroyed) {
      return;
    }
    if (eventName === "beforeExit") {
      stream.flush();
      stream.on("drain", function() {
        stream.end();
      });
    } else {
      stream.flushSync();
    }
  }
  function createArgsNormalizer(defaultOptions) {
    return function normalizeArgs(instance, caller, opts = {}, stream) {
      if (typeof opts === "string") {
        stream = buildSafeSonicBoom({ dest: opts });
        opts = {};
      } else if (typeof stream === "string") {
        if (opts && opts.transport) {
          throw Error("only one of option.transport or stream can be specified");
        }
        stream = buildSafeSonicBoom({ dest: stream });
      } else if (opts instanceof SonicBoom || opts.writable || opts._writableState) {
        stream = opts;
        opts = {};
      } else if (opts.transport) {
        if (opts.transport instanceof SonicBoom || opts.transport.writable || opts.transport._writableState) {
          throw Error("option.transport do not allow stream, please pass to option directly. e.g. pino(transport)");
        }
        if (opts.transport.targets && opts.transport.targets.length && opts.formatters && typeof opts.formatters.level === "function") {
          throw Error("option.transport.targets do not allow custom level formatters");
        }
        let customLevels;
        if (opts.customLevels) {
          customLevels = opts.useOnlyCustomLevels ? opts.customLevels : Object.assign({}, opts.levels, opts.customLevels);
        }
        stream = transport({ caller, ...opts.transport, levels: customLevels });
      }
      opts = Object.assign({}, defaultOptions, opts);
      opts.serializers = Object.assign({}, defaultOptions.serializers, opts.serializers);
      opts.formatters = Object.assign({}, defaultOptions.formatters, opts.formatters);
      if (opts.prettyPrint) {
        throw new Error("prettyPrint option is no longer supported, see the pino-pretty package (https://github.com/pinojs/pino-pretty)");
      }
      const { enabled, onChild } = opts;
      if (enabled === false)
        opts.level = "silent";
      if (!onChild)
        opts.onChild = noop;
      if (!stream) {
        if (!hasBeenTampered(process.stdout)) {
          stream = buildSafeSonicBoom({ fd: process.stdout.fd || 1 });
        } else {
          stream = process.stdout;
        }
      }
      return { opts, stream };
    };
  }
  function stringify(obj, stringifySafeFn) {
    try {
      return JSON.stringify(obj);
    } catch (_) {
      try {
        const stringify2 = stringifySafeFn || this[stringifySafeSym];
        return stringify2(obj);
      } catch (_2) {
        return '"[unable to serialize, circular reference is too complex to analyze]"';
      }
    }
  }
  function buildFormatters(level, bindings, log) {
    return {
      level,
      bindings,
      log
    };
  }
  function normalizeDestFileDescriptor(destination) {
    const fd = Number(destination);
    if (typeof destination === "string" && Number.isFinite(fd)) {
      return fd;
    }
    if (destination === undefined) {
      return 1;
    }
    return destination;
  }
  module.exports = {
    noop,
    buildSafeSonicBoom,
    asChindings,
    asJson,
    genLog,
    createArgsNormalizer,
    stringify,
    buildFormatters,
    normalizeDestFileDescriptor
  };
});

// node_modules/pino/lib/constants.js
var require_constants2 = __commonJS((exports, module) => {
  var DEFAULT_LEVELS = {
    trace: 10,
    debug: 20,
    info: 30,
    warn: 40,
    error: 50,
    fatal: 60
  };
  var SORTING_ORDER = {
    ASC: "ASC",
    DESC: "DESC"
  };
  module.exports = {
    DEFAULT_LEVELS,
    SORTING_ORDER
  };
});

// node_modules/pino/lib/levels.js
var require_levels = __commonJS((exports, module) => {
  var {
    lsCacheSym,
    levelValSym,
    useOnlyCustomLevelsSym,
    streamSym,
    formattersSym,
    hooksSym,
    levelCompSym
  } = require_symbols();
  var { noop, genLog } = require_tools();
  var { DEFAULT_LEVELS, SORTING_ORDER } = require_constants2();
  var levelMethods = {
    fatal: (hook) => {
      const logFatal = genLog(DEFAULT_LEVELS.fatal, hook);
      return function(...args) {
        const stream = this[streamSym];
        logFatal.call(this, ...args);
        if (typeof stream.flushSync === "function") {
          try {
            stream.flushSync();
          } catch (e) {}
        }
      };
    },
    error: (hook) => genLog(DEFAULT_LEVELS.error, hook),
    warn: (hook) => genLog(DEFAULT_LEVELS.warn, hook),
    info: (hook) => genLog(DEFAULT_LEVELS.info, hook),
    debug: (hook) => genLog(DEFAULT_LEVELS.debug, hook),
    trace: (hook) => genLog(DEFAULT_LEVELS.trace, hook)
  };
  var nums = Object.keys(DEFAULT_LEVELS).reduce((o, k) => {
    o[DEFAULT_LEVELS[k]] = k;
    return o;
  }, {});
  var initialLsCache = Object.keys(nums).reduce((o, k) => {
    o[k] = '{"level":' + Number(k);
    return o;
  }, {});
  function genLsCache(instance) {
    const formatter = instance[formattersSym].level;
    const { labels } = instance.levels;
    const cache = {};
    for (const label in labels) {
      const level = formatter(labels[label], Number(label));
      cache[label] = JSON.stringify(level).slice(0, -1);
    }
    instance[lsCacheSym] = cache;
    return instance;
  }
  function isStandardLevel(level, useOnlyCustomLevels) {
    if (useOnlyCustomLevels) {
      return false;
    }
    switch (level) {
      case "fatal":
      case "error":
      case "warn":
      case "info":
      case "debug":
      case "trace":
        return true;
      default:
        return false;
    }
  }
  function setLevel(level) {
    const { labels, values } = this.levels;
    if (typeof level === "number") {
      if (labels[level] === undefined)
        throw Error("unknown level value" + level);
      level = labels[level];
    }
    if (values[level] === undefined)
      throw Error("unknown level " + level);
    const preLevelVal = this[levelValSym];
    const levelVal = this[levelValSym] = values[level];
    const useOnlyCustomLevelsVal = this[useOnlyCustomLevelsSym];
    const levelComparison = this[levelCompSym];
    const hook = this[hooksSym].logMethod;
    for (const key in values) {
      if (levelComparison(values[key], levelVal) === false) {
        this[key] = noop;
        continue;
      }
      this[key] = isStandardLevel(key, useOnlyCustomLevelsVal) ? levelMethods[key](hook) : genLog(values[key], hook);
    }
    this.emit("level-change", level, levelVal, labels[preLevelVal], preLevelVal, this);
  }
  function getLevel(level) {
    const { levels, levelVal } = this;
    return levels && levels.labels ? levels.labels[levelVal] : "";
  }
  function isLevelEnabled(logLevel) {
    const { values } = this.levels;
    const logLevelVal = values[logLevel];
    return logLevelVal !== undefined && this[levelCompSym](logLevelVal, this[levelValSym]);
  }
  function compareLevel(direction, current, expected) {
    if (direction === SORTING_ORDER.DESC) {
      return current <= expected;
    }
    return current >= expected;
  }
  function genLevelComparison(levelComparison) {
    if (typeof levelComparison === "string") {
      return compareLevel.bind(null, levelComparison);
    }
    return levelComparison;
  }
  function mappings(customLevels = null, useOnlyCustomLevels = false) {
    const customNums = customLevels ? Object.keys(customLevels).reduce((o, k) => {
      o[customLevels[k]] = k;
      return o;
    }, {}) : null;
    const labels = Object.assign(Object.create(Object.prototype, { Infinity: { value: "silent" } }), useOnlyCustomLevels ? null : nums, customNums);
    const values = Object.assign(Object.create(Object.prototype, { silent: { value: Infinity } }), useOnlyCustomLevels ? null : DEFAULT_LEVELS, customLevels);
    return { labels, values };
  }
  function assertDefaultLevelFound(defaultLevel, customLevels, useOnlyCustomLevels) {
    if (typeof defaultLevel === "number") {
      const values = [].concat(Object.keys(customLevels || {}).map((key) => customLevels[key]), useOnlyCustomLevels ? [] : Object.keys(nums).map((level) => +level), Infinity);
      if (!values.includes(defaultLevel)) {
        throw Error(`default level:${defaultLevel} must be included in custom levels`);
      }
      return;
    }
    const labels = Object.assign(Object.create(Object.prototype, { silent: { value: Infinity } }), useOnlyCustomLevels ? null : DEFAULT_LEVELS, customLevels);
    if (!(defaultLevel in labels)) {
      throw Error(`default level:${defaultLevel} must be included in custom levels`);
    }
  }
  function assertNoLevelCollisions(levels, customLevels) {
    const { labels, values } = levels;
    for (const k in customLevels) {
      if (k in values) {
        throw Error("levels cannot be overridden");
      }
      if (customLevels[k] in labels) {
        throw Error("pre-existing level values cannot be used for new levels");
      }
    }
  }
  function assertLevelComparison(levelComparison) {
    if (typeof levelComparison === "function") {
      return;
    }
    if (typeof levelComparison === "string" && Object.values(SORTING_ORDER).includes(levelComparison)) {
      return;
    }
    throw new Error('Levels comparison should be one of "ASC", "DESC" or "function" type');
  }
  module.exports = {
    initialLsCache,
    genLsCache,
    levelMethods,
    getLevel,
    setLevel,
    isLevelEnabled,
    mappings,
    assertNoLevelCollisions,
    assertDefaultLevelFound,
    genLevelComparison,
    assertLevelComparison
  };
});

// node_modules/pino/lib/meta.js
var require_meta = __commonJS((exports, module) => {
  module.exports = { version: "10.1.0" };
});

// node_modules/pino/lib/proto.js
var require_proto = __commonJS((exports, module) => {
  var { EventEmitter } = __require("events");
  var {
    lsCacheSym,
    levelValSym,
    setLevelSym,
    getLevelSym,
    chindingsSym,
    mixinSym,
    asJsonSym,
    writeSym,
    mixinMergeStrategySym,
    timeSym,
    timeSliceIndexSym,
    streamSym,
    serializersSym,
    formattersSym,
    errorKeySym,
    messageKeySym,
    useOnlyCustomLevelsSym,
    needsMetadataGsym,
    redactFmtSym,
    stringifySym,
    formatOptsSym,
    stringifiersSym,
    msgPrefixSym,
    hooksSym
  } = require_symbols();
  var {
    getLevel,
    setLevel,
    isLevelEnabled,
    mappings,
    initialLsCache,
    genLsCache,
    assertNoLevelCollisions
  } = require_levels();
  var {
    asChindings,
    asJson,
    buildFormatters,
    stringify,
    noop
  } = require_tools();
  var {
    version: version3
  } = require_meta();
  var redaction = require_redaction();
  var constructor = class Pino {
  };
  var prototype = {
    constructor,
    child,
    bindings,
    setBindings,
    flush,
    isLevelEnabled,
    version: version3,
    get level() {
      return this[getLevelSym]();
    },
    set level(lvl) {
      this[setLevelSym](lvl);
    },
    get levelVal() {
      return this[levelValSym];
    },
    set levelVal(n) {
      throw Error("levelVal is read-only");
    },
    get msgPrefix() {
      return this[msgPrefixSym];
    },
    get [Symbol.toStringTag]() {
      return "Pino";
    },
    [lsCacheSym]: initialLsCache,
    [writeSym]: write,
    [asJsonSym]: asJson,
    [getLevelSym]: getLevel,
    [setLevelSym]: setLevel
  };
  Object.setPrototypeOf(prototype, EventEmitter.prototype);
  module.exports = function() {
    return Object.create(prototype);
  };
  var resetChildingsFormatter = (bindings2) => bindings2;
  function child(bindings2, options2) {
    if (!bindings2) {
      throw Error("missing bindings for child Pino");
    }
    const serializers = this[serializersSym];
    const formatters = this[formattersSym];
    const instance = Object.create(this);
    if (options2 == null) {
      if (instance[formattersSym].bindings !== resetChildingsFormatter) {
        instance[formattersSym] = buildFormatters(formatters.level, resetChildingsFormatter, formatters.log);
      }
      instance[chindingsSym] = asChindings(instance, bindings2);
      if (this.onChild !== noop) {
        this.onChild(instance);
      }
      return instance;
    }
    if (options2.hasOwnProperty("serializers") === true) {
      instance[serializersSym] = Object.create(null);
      for (const k in serializers) {
        instance[serializersSym][k] = serializers[k];
      }
      const parentSymbols = Object.getOwnPropertySymbols(serializers);
      for (var i = 0;i < parentSymbols.length; i++) {
        const ks = parentSymbols[i];
        instance[serializersSym][ks] = serializers[ks];
      }
      for (const bk in options2.serializers) {
        instance[serializersSym][bk] = options2.serializers[bk];
      }
      const bindingsSymbols = Object.getOwnPropertySymbols(options2.serializers);
      for (var bi = 0;bi < bindingsSymbols.length; bi++) {
        const bks = bindingsSymbols[bi];
        instance[serializersSym][bks] = options2.serializers[bks];
      }
    } else
      instance[serializersSym] = serializers;
    if (options2.hasOwnProperty("formatters")) {
      const { level, bindings: chindings, log } = options2.formatters;
      instance[formattersSym] = buildFormatters(level || formatters.level, chindings || resetChildingsFormatter, log || formatters.log);
    } else {
      instance[formattersSym] = buildFormatters(formatters.level, resetChildingsFormatter, formatters.log);
    }
    if (options2.hasOwnProperty("customLevels") === true) {
      assertNoLevelCollisions(this.levels, options2.customLevels);
      instance.levels = mappings(options2.customLevels, instance[useOnlyCustomLevelsSym]);
      genLsCache(instance);
    }
    if (typeof options2.redact === "object" && options2.redact !== null || Array.isArray(options2.redact)) {
      instance.redact = options2.redact;
      const stringifiers = redaction(instance.redact, stringify);
      const formatOpts = { stringify: stringifiers[redactFmtSym] };
      instance[stringifySym] = stringify;
      instance[stringifiersSym] = stringifiers;
      instance[formatOptsSym] = formatOpts;
    }
    if (typeof options2.msgPrefix === "string") {
      instance[msgPrefixSym] = (this[msgPrefixSym] || "") + options2.msgPrefix;
    }
    instance[chindingsSym] = asChindings(instance, bindings2);
    if (options2.level !== undefined && options2.level !== this.level || options2.hasOwnProperty("customLevels")) {
      const childLevel = options2.level || this.level;
      instance[setLevelSym](childLevel);
    }
    this.onChild(instance);
    return instance;
  }
  function bindings() {
    const chindings = this[chindingsSym];
    const chindingsJson = `{${chindings.substr(1)}}`;
    const bindingsFromJson = JSON.parse(chindingsJson);
    delete bindingsFromJson.pid;
    delete bindingsFromJson.hostname;
    return bindingsFromJson;
  }
  function setBindings(newBindings) {
    const chindings = asChindings(this, newBindings);
    this[chindingsSym] = chindings;
  }
  function defaultMixinMergeStrategy(mergeObject, mixinObject) {
    return Object.assign(mixinObject, mergeObject);
  }
  function write(_obj, msg, num) {
    const t = this[timeSym]();
    const mixin = this[mixinSym];
    const errorKey = this[errorKeySym];
    const messageKey = this[messageKeySym];
    const mixinMergeStrategy = this[mixinMergeStrategySym] || defaultMixinMergeStrategy;
    let obj;
    const streamWriteHook = this[hooksSym].streamWrite;
    if (_obj === undefined || _obj === null) {
      obj = {};
    } else if (_obj instanceof Error) {
      obj = { [errorKey]: _obj };
      if (msg === undefined) {
        msg = _obj.message;
      }
    } else {
      obj = _obj;
      if (msg === undefined && _obj[messageKey] === undefined && _obj[errorKey]) {
        msg = _obj[errorKey].message;
      }
    }
    if (mixin) {
      obj = mixinMergeStrategy(obj, mixin(obj, num, this));
    }
    const s = this[asJsonSym](obj, msg, num, t);
    const stream = this[streamSym];
    if (stream[needsMetadataGsym] === true) {
      stream.lastLevel = num;
      stream.lastObj = obj;
      stream.lastMsg = msg;
      stream.lastTime = t.slice(this[timeSliceIndexSym]);
      stream.lastLogger = this;
    }
    stream.write(streamWriteHook ? streamWriteHook(s) : s);
  }
  function flush(cb) {
    if (cb != null && typeof cb !== "function") {
      throw Error("callback must be a function");
    }
    const stream = this[streamSym];
    if (typeof stream.flush === "function") {
      stream.flush(cb || noop);
    } else if (cb)
      cb();
  }
});

// node_modules/safe-stable-stringify/index.js
var require_safe_stable_stringify = __commonJS((exports, module) => {
  var { hasOwnProperty } = Object.prototype;
  var stringify = configure();
  stringify.configure = configure;
  stringify.stringify = stringify;
  stringify.default = stringify;
  exports.stringify = stringify;
  exports.configure = configure;
  module.exports = stringify;
  var strEscapeSequencesRegExp = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]/;
  function strEscape(str2) {
    if (str2.length < 5000 && !strEscapeSequencesRegExp.test(str2)) {
      return `"${str2}"`;
    }
    return JSON.stringify(str2);
  }
  function sort(array4, comparator) {
    if (array4.length > 200 || comparator) {
      return array4.sort(comparator);
    }
    for (let i = 1;i < array4.length; i++) {
      const currentValue = array4[i];
      let position = i;
      while (position !== 0 && array4[position - 1] > currentValue) {
        array4[position] = array4[position - 1];
        position--;
      }
      array4[position] = currentValue;
    }
    return array4;
  }
  var typedArrayPrototypeGetSymbolToStringTag = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Object.getPrototypeOf(new Int8Array)), Symbol.toStringTag).get;
  function isTypedArrayWithEntries(value) {
    return typedArrayPrototypeGetSymbolToStringTag.call(value) !== undefined && value.length !== 0;
  }
  function stringifyTypedArray(array4, separator, maximumBreadth) {
    if (array4.length < maximumBreadth) {
      maximumBreadth = array4.length;
    }
    const whitespace = separator === "," ? "" : " ";
    let res = `"0":${whitespace}${array4[0]}`;
    for (let i = 1;i < maximumBreadth; i++) {
      res += `${separator}"${i}":${whitespace}${array4[i]}`;
    }
    return res;
  }
  function getCircularValueOption(options2) {
    if (hasOwnProperty.call(options2, "circularValue")) {
      const circularValue = options2.circularValue;
      if (typeof circularValue === "string") {
        return `"${circularValue}"`;
      }
      if (circularValue == null) {
        return circularValue;
      }
      if (circularValue === Error || circularValue === TypeError) {
        return {
          toString() {
            throw new TypeError("Converting circular structure to JSON");
          }
        };
      }
      throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined');
    }
    return '"[Circular]"';
  }
  function getDeterministicOption(options2) {
    let value;
    if (hasOwnProperty.call(options2, "deterministic")) {
      value = options2.deterministic;
      if (typeof value !== "boolean" && typeof value !== "function") {
        throw new TypeError('The "deterministic" argument must be of type boolean or comparator function');
      }
    }
    return value === undefined ? true : value;
  }
  function getBooleanOption(options2, key) {
    let value;
    if (hasOwnProperty.call(options2, key)) {
      value = options2[key];
      if (typeof value !== "boolean") {
        throw new TypeError(`The "${key}" argument must be of type boolean`);
      }
    }
    return value === undefined ? true : value;
  }
  function getPositiveIntegerOption(options2, key) {
    let value;
    if (hasOwnProperty.call(options2, key)) {
      value = options2[key];
      if (typeof value !== "number") {
        throw new TypeError(`The "${key}" argument must be of type number`);
      }
      if (!Number.isInteger(value)) {
        throw new TypeError(`The "${key}" argument must be an integer`);
      }
      if (value < 1) {
        throw new RangeError(`The "${key}" argument must be >= 1`);
      }
    }
    return value === undefined ? Infinity : value;
  }
  function getItemCount(number7) {
    if (number7 === 1) {
      return "1 item";
    }
    return `${number7} items`;
  }
  function getUniqueReplacerSet(replacerArray) {
    const replacerSet = new Set;
    for (const value of replacerArray) {
      if (typeof value === "string" || typeof value === "number") {
        replacerSet.add(String(value));
      }
    }
    return replacerSet;
  }
  function getStrictOption(options2) {
    if (hasOwnProperty.call(options2, "strict")) {
      const value = options2.strict;
      if (typeof value !== "boolean") {
        throw new TypeError('The "strict" argument must be of type boolean');
      }
      if (value) {
        return (value2) => {
          let message = `Object can not safely be stringified. Received type ${typeof value2}`;
          if (typeof value2 !== "function")
            message += ` (${value2.toString()})`;
          throw new Error(message);
        };
      }
    }
  }
  function configure(options2) {
    options2 = { ...options2 };
    const fail = getStrictOption(options2);
    if (fail) {
      if (options2.bigint === undefined) {
        options2.bigint = false;
      }
      if (!("circularValue" in options2)) {
        options2.circularValue = Error;
      }
    }
    const circularValue = getCircularValueOption(options2);
    const bigint6 = getBooleanOption(options2, "bigint");
    const deterministic = getDeterministicOption(options2);
    const comparator = typeof deterministic === "function" ? deterministic : undefined;
    const maximumDepth = getPositiveIntegerOption(options2, "maximumDepth");
    const maximumBreadth = getPositiveIntegerOption(options2, "maximumBreadth");
    function stringifyFnReplacer(key, parent, stack, replacer, spacer, indentation) {
      let value = parent[key];
      if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
        value = value.toJSON(key);
      }
      value = replacer.call(parent, key, value);
      switch (typeof value) {
        case "string":
          return strEscape(value);
        case "object": {
          if (value === null) {
            return "null";
          }
          if (stack.indexOf(value) !== -1) {
            return circularValue;
          }
          let res = "";
          let join6 = ",";
          const originalIndentation = indentation;
          if (Array.isArray(value)) {
            if (value.length === 0) {
              return "[]";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Array]"';
            }
            stack.push(value);
            if (spacer !== "") {
              indentation += spacer;
              res += `
${indentation}`;
              join6 = `,
${indentation}`;
            }
            const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
            let i = 0;
            for (;i < maximumValuesToStringify - 1; i++) {
              const tmp2 = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
              res += tmp2 !== undefined ? tmp2 : "null";
              res += join6;
            }
            const tmp = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
            res += tmp !== undefined ? tmp : "null";
            if (value.length - 1 > maximumBreadth) {
              const removedKeys = value.length - maximumBreadth - 1;
              res += `${join6}"... ${getItemCount(removedKeys)} not stringified"`;
            }
            if (spacer !== "") {
              res += `
${originalIndentation}`;
            }
            stack.pop();
            return `[${res}]`;
          }
          let keys = Object.keys(value);
          const keyLength = keys.length;
          if (keyLength === 0) {
            return "{}";
          }
          if (maximumDepth < stack.length + 1) {
            return '"[Object]"';
          }
          let whitespace = "";
          let separator = "";
          if (spacer !== "") {
            indentation += spacer;
            join6 = `,
${indentation}`;
            whitespace = " ";
          }
          const maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
          if (deterministic && !isTypedArrayWithEntries(value)) {
            keys = sort(keys, comparator);
          }
          stack.push(value);
          for (let i = 0;i < maximumPropertiesToStringify; i++) {
            const key2 = keys[i];
            const tmp = stringifyFnReplacer(key2, value, stack, replacer, spacer, indentation);
            if (tmp !== undefined) {
              res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
              separator = join6;
            }
          }
          if (keyLength > maximumBreadth) {
            const removedKeys = keyLength - maximumBreadth;
            res += `${separator}"...":${whitespace}"${getItemCount(removedKeys)} not stringified"`;
            separator = join6;
          }
          if (spacer !== "" && separator.length > 1) {
            res = `
${indentation}${res}
${originalIndentation}`;
          }
          stack.pop();
          return `{${res}}`;
        }
        case "number":
          return isFinite(value) ? String(value) : fail ? fail(value) : "null";
        case "boolean":
          return value === true ? "true" : "false";
        case "undefined":
          return;
        case "bigint":
          if (bigint6) {
            return String(value);
          }
        default:
          return fail ? fail(value) : undefined;
      }
    }
    function stringifyArrayReplacer(key, value, stack, replacer, spacer, indentation) {
      if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
        value = value.toJSON(key);
      }
      switch (typeof value) {
        case "string":
          return strEscape(value);
        case "object": {
          if (value === null) {
            return "null";
          }
          if (stack.indexOf(value) !== -1) {
            return circularValue;
          }
          const originalIndentation = indentation;
          let res = "";
          let join6 = ",";
          if (Array.isArray(value)) {
            if (value.length === 0) {
              return "[]";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Array]"';
            }
            stack.push(value);
            if (spacer !== "") {
              indentation += spacer;
              res += `
${indentation}`;
              join6 = `,
${indentation}`;
            }
            const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
            let i = 0;
            for (;i < maximumValuesToStringify - 1; i++) {
              const tmp2 = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
              res += tmp2 !== undefined ? tmp2 : "null";
              res += join6;
            }
            const tmp = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
            res += tmp !== undefined ? tmp : "null";
            if (value.length - 1 > maximumBreadth) {
              const removedKeys = value.length - maximumBreadth - 1;
              res += `${join6}"... ${getItemCount(removedKeys)} not stringified"`;
            }
            if (spacer !== "") {
              res += `
${originalIndentation}`;
            }
            stack.pop();
            return `[${res}]`;
          }
          stack.push(value);
          let whitespace = "";
          if (spacer !== "") {
            indentation += spacer;
            join6 = `,
${indentation}`;
            whitespace = " ";
          }
          let separator = "";
          for (const key2 of replacer) {
            const tmp = stringifyArrayReplacer(key2, value[key2], stack, replacer, spacer, indentation);
            if (tmp !== undefined) {
              res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
              separator = join6;
            }
          }
          if (spacer !== "" && separator.length > 1) {
            res = `
${indentation}${res}
${originalIndentation}`;
          }
          stack.pop();
          return `{${res}}`;
        }
        case "number":
          return isFinite(value) ? String(value) : fail ? fail(value) : "null";
        case "boolean":
          return value === true ? "true" : "false";
        case "undefined":
          return;
        case "bigint":
          if (bigint6) {
            return String(value);
          }
        default:
          return fail ? fail(value) : undefined;
      }
    }
    function stringifyIndent(key, value, stack, spacer, indentation) {
      switch (typeof value) {
        case "string":
          return strEscape(value);
        case "object": {
          if (value === null) {
            return "null";
          }
          if (typeof value.toJSON === "function") {
            value = value.toJSON(key);
            if (typeof value !== "object") {
              return stringifyIndent(key, value, stack, spacer, indentation);
            }
            if (value === null) {
              return "null";
            }
          }
          if (stack.indexOf(value) !== -1) {
            return circularValue;
          }
          const originalIndentation = indentation;
          if (Array.isArray(value)) {
            if (value.length === 0) {
              return "[]";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Array]"';
            }
            stack.push(value);
            indentation += spacer;
            let res2 = `
${indentation}`;
            const join7 = `,
${indentation}`;
            const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
            let i = 0;
            for (;i < maximumValuesToStringify - 1; i++) {
              const tmp2 = stringifyIndent(String(i), value[i], stack, spacer, indentation);
              res2 += tmp2 !== undefined ? tmp2 : "null";
              res2 += join7;
            }
            const tmp = stringifyIndent(String(i), value[i], stack, spacer, indentation);
            res2 += tmp !== undefined ? tmp : "null";
            if (value.length - 1 > maximumBreadth) {
              const removedKeys = value.length - maximumBreadth - 1;
              res2 += `${join7}"... ${getItemCount(removedKeys)} not stringified"`;
            }
            res2 += `
${originalIndentation}`;
            stack.pop();
            return `[${res2}]`;
          }
          let keys = Object.keys(value);
          const keyLength = keys.length;
          if (keyLength === 0) {
            return "{}";
          }
          if (maximumDepth < stack.length + 1) {
            return '"[Object]"';
          }
          indentation += spacer;
          const join6 = `,
${indentation}`;
          let res = "";
          let separator = "";
          let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
          if (isTypedArrayWithEntries(value)) {
            res += stringifyTypedArray(value, join6, maximumBreadth);
            keys = keys.slice(value.length);
            maximumPropertiesToStringify -= value.length;
            separator = join6;
          }
          if (deterministic) {
            keys = sort(keys, comparator);
          }
          stack.push(value);
          for (let i = 0;i < maximumPropertiesToStringify; i++) {
            const key2 = keys[i];
            const tmp = stringifyIndent(key2, value[key2], stack, spacer, indentation);
            if (tmp !== undefined) {
              res += `${separator}${strEscape(key2)}: ${tmp}`;
              separator = join6;
            }
          }
          if (keyLength > maximumBreadth) {
            const removedKeys = keyLength - maximumBreadth;
            res += `${separator}"...": "${getItemCount(removedKeys)} not stringified"`;
            separator = join6;
          }
          if (separator !== "") {
            res = `
${indentation}${res}
${originalIndentation}`;
          }
          stack.pop();
          return `{${res}}`;
        }
        case "number":
          return isFinite(value) ? String(value) : fail ? fail(value) : "null";
        case "boolean":
          return value === true ? "true" : "false";
        case "undefined":
          return;
        case "bigint":
          if (bigint6) {
            return String(value);
          }
        default:
          return fail ? fail(value) : undefined;
      }
    }
    function stringifySimple(key, value, stack) {
      switch (typeof value) {
        case "string":
          return strEscape(value);
        case "object": {
          if (value === null) {
            return "null";
          }
          if (typeof value.toJSON === "function") {
            value = value.toJSON(key);
            if (typeof value !== "object") {
              return stringifySimple(key, value, stack);
            }
            if (value === null) {
              return "null";
            }
          }
          if (stack.indexOf(value) !== -1) {
            return circularValue;
          }
          let res = "";
          const hasLength = value.length !== undefined;
          if (hasLength && Array.isArray(value)) {
            if (value.length === 0) {
              return "[]";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Array]"';
            }
            stack.push(value);
            const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
            let i = 0;
            for (;i < maximumValuesToStringify - 1; i++) {
              const tmp2 = stringifySimple(String(i), value[i], stack);
              res += tmp2 !== undefined ? tmp2 : "null";
              res += ",";
            }
            const tmp = stringifySimple(String(i), value[i], stack);
            res += tmp !== undefined ? tmp : "null";
            if (value.length - 1 > maximumBreadth) {
              const removedKeys = value.length - maximumBreadth - 1;
              res += `,"... ${getItemCount(removedKeys)} not stringified"`;
            }
            stack.pop();
            return `[${res}]`;
          }
          let keys = Object.keys(value);
          const keyLength = keys.length;
          if (keyLength === 0) {
            return "{}";
          }
          if (maximumDepth < stack.length + 1) {
            return '"[Object]"';
          }
          let separator = "";
          let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
          if (hasLength && isTypedArrayWithEntries(value)) {
            res += stringifyTypedArray(value, ",", maximumBreadth);
            keys = keys.slice(value.length);
            maximumPropertiesToStringify -= value.length;
            separator = ",";
          }
          if (deterministic) {
            keys = sort(keys, comparator);
          }
          stack.push(value);
          for (let i = 0;i < maximumPropertiesToStringify; i++) {
            const key2 = keys[i];
            const tmp = stringifySimple(key2, value[key2], stack);
            if (tmp !== undefined) {
              res += `${separator}${strEscape(key2)}:${tmp}`;
              separator = ",";
            }
          }
          if (keyLength > maximumBreadth) {
            const removedKeys = keyLength - maximumBreadth;
            res += `${separator}"...":"${getItemCount(removedKeys)} not stringified"`;
          }
          stack.pop();
          return `{${res}}`;
        }
        case "number":
          return isFinite(value) ? String(value) : fail ? fail(value) : "null";
        case "boolean":
          return value === true ? "true" : "false";
        case "undefined":
          return;
        case "bigint":
          if (bigint6) {
            return String(value);
          }
        default:
          return fail ? fail(value) : undefined;
      }
    }
    function stringify2(value, replacer, space) {
      if (arguments.length > 1) {
        let spacer = "";
        if (typeof space === "number") {
          spacer = " ".repeat(Math.min(space, 10));
        } else if (typeof space === "string") {
          spacer = space.slice(0, 10);
        }
        if (replacer != null) {
          if (typeof replacer === "function") {
            return stringifyFnReplacer("", { "": value }, [], replacer, spacer, "");
          }
          if (Array.isArray(replacer)) {
            return stringifyArrayReplacer("", value, [], getUniqueReplacerSet(replacer), spacer, "");
          }
        }
        if (spacer.length !== 0) {
          return stringifyIndent("", value, [], spacer, "");
        }
      }
      return stringifySimple("", value, []);
    }
    return stringify2;
  }
});

// node_modules/pino/lib/multistream.js
var require_multistream = __commonJS((exports, module) => {
  var metadata = Symbol.for("pino.metadata");
  var { DEFAULT_LEVELS } = require_constants2();
  var DEFAULT_INFO_LEVEL = DEFAULT_LEVELS.info;
  function multistream(streamsArray, opts) {
    streamsArray = streamsArray || [];
    opts = opts || { dedupe: false };
    const streamLevels = Object.create(DEFAULT_LEVELS);
    streamLevels.silent = Infinity;
    if (opts.levels && typeof opts.levels === "object") {
      Object.keys(opts.levels).forEach((i) => {
        streamLevels[i] = opts.levels[i];
      });
    }
    const res = {
      write,
      add,
      remove,
      emit,
      flushSync,
      end,
      minLevel: 0,
      lastId: 0,
      streams: [],
      clone: clone3,
      [metadata]: true,
      streamLevels
    };
    if (Array.isArray(streamsArray)) {
      streamsArray.forEach(add, res);
    } else {
      add.call(res, streamsArray);
    }
    streamsArray = null;
    return res;
    function write(data) {
      let dest;
      const level = this.lastLevel;
      const { streams } = this;
      let recordedLevel = 0;
      let stream;
      for (let i = initLoopVar(streams.length, opts.dedupe);checkLoopVar(i, streams.length, opts.dedupe); i = adjustLoopVar(i, opts.dedupe)) {
        dest = streams[i];
        if (dest.level <= level) {
          if (recordedLevel !== 0 && recordedLevel !== dest.level) {
            break;
          }
          stream = dest.stream;
          if (stream[metadata]) {
            const { lastTime, lastMsg, lastObj, lastLogger } = this;
            stream.lastLevel = level;
            stream.lastTime = lastTime;
            stream.lastMsg = lastMsg;
            stream.lastObj = lastObj;
            stream.lastLogger = lastLogger;
          }
          stream.write(data);
          if (opts.dedupe) {
            recordedLevel = dest.level;
          }
        } else if (!opts.dedupe) {
          break;
        }
      }
    }
    function emit(...args) {
      for (const { stream } of this.streams) {
        if (typeof stream.emit === "function") {
          stream.emit(...args);
        }
      }
    }
    function flushSync() {
      for (const { stream } of this.streams) {
        if (typeof stream.flushSync === "function") {
          stream.flushSync();
        }
      }
    }
    function add(dest) {
      if (!dest) {
        return res;
      }
      const isStream = typeof dest.write === "function" || dest.stream;
      const stream_ = dest.write ? dest : dest.stream;
      if (!isStream) {
        throw Error("stream object needs to implement either StreamEntry or DestinationStream interface");
      }
      const { streams, streamLevels: streamLevels2 } = this;
      let level;
      if (typeof dest.levelVal === "number") {
        level = dest.levelVal;
      } else if (typeof dest.level === "string") {
        level = streamLevels2[dest.level];
      } else if (typeof dest.level === "number") {
        level = dest.level;
      } else {
        level = DEFAULT_INFO_LEVEL;
      }
      const dest_ = {
        stream: stream_,
        level,
        levelVal: undefined,
        id: ++res.lastId
      };
      streams.unshift(dest_);
      streams.sort(compareByLevel);
      this.minLevel = streams[0].level;
      return res;
    }
    function remove(id) {
      const { streams } = this;
      const index = streams.findIndex((s) => s.id === id);
      if (index >= 0) {
        streams.splice(index, 1);
        streams.sort(compareByLevel);
        this.minLevel = streams.length > 0 ? streams[0].level : -1;
      }
      return res;
    }
    function end() {
      for (const { stream } of this.streams) {
        if (typeof stream.flushSync === "function") {
          stream.flushSync();
        }
        stream.end();
      }
    }
    function clone3(level) {
      const streams = new Array(this.streams.length);
      for (let i = 0;i < streams.length; i++) {
        streams[i] = {
          level,
          stream: this.streams[i].stream
        };
      }
      return {
        write,
        add,
        remove,
        minLevel: level,
        streams,
        clone: clone3,
        emit,
        flushSync,
        [metadata]: true
      };
    }
  }
  function compareByLevel(a, b) {
    return a.level - b.level;
  }
  function initLoopVar(length, dedupe) {
    return dedupe ? length - 1 : 0;
  }
  function adjustLoopVar(i, dedupe) {
    return dedupe ? i - 1 : i + 1;
  }
  function checkLoopVar(i, length, dedupe) {
    return dedupe ? i >= 0 : i < length;
  }
  module.exports = multistream;
});

// node_modules/pino/pino.js
var require_pino = __commonJS((exports, module) => {
  var os = __require("os");
  var stdSerializers = require_pino_std_serializers();
  var caller = require_caller();
  var redaction = require_redaction();
  var time5 = require_time();
  var proto = require_proto();
  var symbols = require_symbols();
  var { configure } = require_safe_stable_stringify();
  var { assertDefaultLevelFound, mappings, genLsCache, genLevelComparison, assertLevelComparison } = require_levels();
  var { DEFAULT_LEVELS, SORTING_ORDER } = require_constants2();
  var {
    createArgsNormalizer,
    asChindings,
    buildSafeSonicBoom,
    buildFormatters,
    stringify,
    normalizeDestFileDescriptor,
    noop
  } = require_tools();
  var { version: version3 } = require_meta();
  var {
    chindingsSym,
    redactFmtSym,
    serializersSym,
    timeSym,
    timeSliceIndexSym,
    streamSym,
    stringifySym,
    stringifySafeSym,
    stringifiersSym,
    setLevelSym,
    endSym,
    formatOptsSym,
    messageKeySym,
    errorKeySym,
    nestedKeySym,
    mixinSym,
    levelCompSym,
    useOnlyCustomLevelsSym,
    formattersSym,
    hooksSym,
    nestedKeyStrSym,
    mixinMergeStrategySym,
    msgPrefixSym
  } = symbols;
  var { epochTime, nullTime } = time5;
  var { pid } = process;
  var hostname4 = os.hostname();
  var defaultErrorSerializer = stdSerializers.err;
  var defaultOptions = {
    level: "info",
    levelComparison: SORTING_ORDER.ASC,
    levels: DEFAULT_LEVELS,
    messageKey: "msg",
    errorKey: "err",
    nestedKey: null,
    enabled: true,
    base: { pid, hostname: hostname4 },
    serializers: Object.assign(Object.create(null), {
      err: defaultErrorSerializer
    }),
    formatters: Object.assign(Object.create(null), {
      bindings(bindings) {
        return bindings;
      },
      level(label, number7) {
        return { level: number7 };
      }
    }),
    hooks: {
      logMethod: undefined,
      streamWrite: undefined
    },
    timestamp: epochTime,
    name: undefined,
    redact: null,
    customLevels: null,
    useOnlyCustomLevels: false,
    depthLimit: 5,
    edgeLimit: 100
  };
  var normalize2 = createArgsNormalizer(defaultOptions);
  var serializers = Object.assign(Object.create(null), stdSerializers);
  function pino(...args) {
    const instance = {};
    const { opts, stream } = normalize2(instance, caller(), ...args);
    if (opts.level && typeof opts.level === "string" && DEFAULT_LEVELS[opts.level.toLowerCase()] !== undefined)
      opts.level = opts.level.toLowerCase();
    const {
      redact,
      crlf,
      serializers: serializers2,
      timestamp,
      messageKey,
      errorKey,
      nestedKey,
      base,
      name,
      level,
      customLevels,
      levelComparison,
      mixin,
      mixinMergeStrategy,
      useOnlyCustomLevels,
      formatters,
      hooks,
      depthLimit,
      edgeLimit,
      onChild,
      msgPrefix
    } = opts;
    const stringifySafe = configure({
      maximumDepth: depthLimit,
      maximumBreadth: edgeLimit
    });
    const allFormatters = buildFormatters(formatters.level, formatters.bindings, formatters.log);
    const stringifyFn = stringify.bind({
      [stringifySafeSym]: stringifySafe
    });
    const stringifiers = redact ? redaction(redact, stringifyFn) : {};
    const formatOpts = redact ? { stringify: stringifiers[redactFmtSym] } : { stringify: stringifyFn };
    const end = "}" + (crlf ? `\r
` : `
`);
    const coreChindings = asChindings.bind(null, {
      [chindingsSym]: "",
      [serializersSym]: serializers2,
      [stringifiersSym]: stringifiers,
      [stringifySym]: stringify,
      [stringifySafeSym]: stringifySafe,
      [formattersSym]: allFormatters
    });
    let chindings = "";
    if (base !== null) {
      if (name === undefined) {
        chindings = coreChindings(base);
      } else {
        chindings = coreChindings(Object.assign({}, base, { name }));
      }
    }
    const time6 = timestamp instanceof Function ? timestamp : timestamp ? epochTime : nullTime;
    const timeSliceIndex = time6().indexOf(":") + 1;
    if (useOnlyCustomLevels && !customLevels)
      throw Error("customLevels is required if useOnlyCustomLevels is set true");
    if (mixin && typeof mixin !== "function")
      throw Error(`Unknown mixin type "${typeof mixin}" - expected "function"`);
    if (msgPrefix && typeof msgPrefix !== "string")
      throw Error(`Unknown msgPrefix type "${typeof msgPrefix}" - expected "string"`);
    assertDefaultLevelFound(level, customLevels, useOnlyCustomLevels);
    const levels = mappings(customLevels, useOnlyCustomLevels);
    if (typeof stream.emit === "function") {
      stream.emit("message", { code: "PINO_CONFIG", config: { levels, messageKey, errorKey } });
    }
    assertLevelComparison(levelComparison);
    const levelCompFunc = genLevelComparison(levelComparison);
    Object.assign(instance, {
      levels,
      [levelCompSym]: levelCompFunc,
      [useOnlyCustomLevelsSym]: useOnlyCustomLevels,
      [streamSym]: stream,
      [timeSym]: time6,
      [timeSliceIndexSym]: timeSliceIndex,
      [stringifySym]: stringify,
      [stringifySafeSym]: stringifySafe,
      [stringifiersSym]: stringifiers,
      [endSym]: end,
      [formatOptsSym]: formatOpts,
      [messageKeySym]: messageKey,
      [errorKeySym]: errorKey,
      [nestedKeySym]: nestedKey,
      [nestedKeyStrSym]: nestedKey ? `,${JSON.stringify(nestedKey)}:{` : "",
      [serializersSym]: serializers2,
      [mixinSym]: mixin,
      [mixinMergeStrategySym]: mixinMergeStrategy,
      [chindingsSym]: chindings,
      [formattersSym]: allFormatters,
      [hooksSym]: hooks,
      silent: noop,
      onChild,
      [msgPrefixSym]: msgPrefix
    });
    Object.setPrototypeOf(instance, proto());
    genLsCache(instance);
    instance[setLevelSym](level);
    return instance;
  }
  module.exports = pino;
  module.exports.destination = (dest = process.stdout.fd) => {
    if (typeof dest === "object") {
      dest.dest = normalizeDestFileDescriptor(dest.dest || process.stdout.fd);
      return buildSafeSonicBoom(dest);
    } else {
      return buildSafeSonicBoom({ dest: normalizeDestFileDescriptor(dest), minLength: 0 });
    }
  };
  module.exports.transport = require_transport();
  module.exports.multistream = require_multistream();
  module.exports.levels = mappings();
  module.exports.stdSerializers = serializers;
  module.exports.stdTimeFunctions = Object.assign({}, time5);
  module.exports.symbols = symbols;
  module.exports.version = version3;
  module.exports.default = pino;
  module.exports.pino = pino;
});

// node_modules/isexe/windows.js
var require_windows = __commonJS((exports, module) => {
  module.exports = isexe;
  isexe.sync = sync;
  var fs3 = __require("fs");
  function checkPathExt(path2, options2) {
    var pathext = options2.pathExt !== undefined ? options2.pathExt : process.env.PATHEXT;
    if (!pathext) {
      return true;
    }
    pathext = pathext.split(";");
    if (pathext.indexOf("") !== -1) {
      return true;
    }
    for (var i = 0;i < pathext.length; i++) {
      var p = pathext[i].toLowerCase();
      if (p && path2.substr(-p.length).toLowerCase() === p) {
        return true;
      }
    }
    return false;
  }
  function checkStat(stat, path2, options2) {
    if (!stat.isSymbolicLink() && !stat.isFile()) {
      return false;
    }
    return checkPathExt(path2, options2);
  }
  function isexe(path2, options2, cb) {
    fs3.stat(path2, function(er, stat) {
      cb(er, er ? false : checkStat(stat, path2, options2));
    });
  }
  function sync(path2, options2) {
    return checkStat(fs3.statSync(path2), path2, options2);
  }
});

// node_modules/isexe/mode.js
var require_mode = __commonJS((exports, module) => {
  module.exports = isexe;
  isexe.sync = sync;
  var fs3 = __require("fs");
  function isexe(path2, options2, cb) {
    fs3.stat(path2, function(er, stat) {
      cb(er, er ? false : checkStat(stat, options2));
    });
  }
  function sync(path2, options2) {
    return checkStat(fs3.statSync(path2), options2);
  }
  function checkStat(stat, options2) {
    return stat.isFile() && checkMode(stat, options2);
  }
  function checkMode(stat, options2) {
    var mod = stat.mode;
    var uid = stat.uid;
    var gid = stat.gid;
    var myUid = options2.uid !== undefined ? options2.uid : process.getuid && process.getuid();
    var myGid = options2.gid !== undefined ? options2.gid : process.getgid && process.getgid();
    var u = parseInt("100", 8);
    var g = parseInt("010", 8);
    var o = parseInt("001", 8);
    var ug = u | g;
    var ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
    return ret;
  }
});

// node_modules/isexe/index.js
var require_isexe = __commonJS((exports, module) => {
  var fs3 = __require("fs");
  var core3;
  if (process.platform === "win32" || global.TESTING_WINDOWS) {
    core3 = require_windows();
  } else {
    core3 = require_mode();
  }
  module.exports = isexe;
  isexe.sync = sync;
  function isexe(path2, options2, cb) {
    if (typeof options2 === "function") {
      cb = options2;
      options2 = {};
    }
    if (!cb) {
      if (typeof Promise !== "function") {
        throw new TypeError("callback not provided");
      }
      return new Promise(function(resolve, reject) {
        isexe(path2, options2 || {}, function(er, is2) {
          if (er) {
            reject(er);
          } else {
            resolve(is2);
          }
        });
      });
    }
    core3(path2, options2 || {}, function(er, is2) {
      if (er) {
        if (er.code === "EACCES" || options2 && options2.ignoreErrors) {
          er = null;
          is2 = false;
        }
      }
      cb(er, is2);
    });
  }
  function sync(path2, options2) {
    try {
      return core3.sync(path2, options2 || {});
    } catch (er) {
      if (options2 && options2.ignoreErrors || er.code === "EACCES") {
        return false;
      } else {
        throw er;
      }
    }
  }
});

// node_modules/which/which.js
var require_which = __commonJS((exports, module) => {
  var isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
  var path2 = __require("path");
  var COLON = isWindows ? ";" : ":";
  var isexe = require_isexe();
  var getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), { code: "ENOENT" });
  var getPathInfo = (cmd, opt) => {
    const colon = opt.colon || COLON;
    const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [""] : [
      ...isWindows ? [process.cwd()] : [],
      ...(opt.path || process.env.PATH || "").split(colon)
    ];
    const pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "";
    const pathExt = isWindows ? pathExtExe.split(colon) : [""];
    if (isWindows) {
      if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
        pathExt.unshift("");
    }
    return {
      pathEnv,
      pathExt,
      pathExtExe
    };
  };
  var which = (cmd, opt, cb) => {
    if (typeof opt === "function") {
      cb = opt;
      opt = {};
    }
    if (!opt)
      opt = {};
    const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
    const found = [];
    const step = (i) => new Promise((resolve, reject) => {
      if (i === pathEnv.length)
        return opt.all && found.length ? resolve(found) : reject(getNotFoundError(cmd));
      const ppRaw = pathEnv[i];
      const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
      const pCmd = path2.join(pathPart, cmd);
      const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
      resolve(subStep(p, i, 0));
    });
    const subStep = (p, i, ii) => new Promise((resolve, reject) => {
      if (ii === pathExt.length)
        return resolve(step(i + 1));
      const ext = pathExt[ii];
      isexe(p + ext, { pathExt: pathExtExe }, (er, is2) => {
        if (!er && is2) {
          if (opt.all)
            found.push(p + ext);
          else
            return resolve(p + ext);
        }
        return resolve(subStep(p, i, ii + 1));
      });
    });
    return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
  };
  var whichSync = (cmd, opt) => {
    opt = opt || {};
    const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
    const found = [];
    for (let i = 0;i < pathEnv.length; i++) {
      const ppRaw = pathEnv[i];
      const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
      const pCmd = path2.join(pathPart, cmd);
      const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
      for (let j = 0;j < pathExt.length; j++) {
        const cur = p + pathExt[j];
        try {
          const is2 = isexe.sync(cur, { pathExt: pathExtExe });
          if (is2) {
            if (opt.all)
              found.push(cur);
            else
              return cur;
          }
        } catch (ex) {}
      }
    }
    if (opt.all && found.length)
      return found;
    if (opt.nothrow)
      return null;
    throw getNotFoundError(cmd);
  };
  module.exports = which;
  which.sync = whichSync;
});

// node_modules/path-key/index.js
var require_path_key = __commonJS((exports, module) => {
  var pathKey = (options2 = {}) => {
    const environment = options2.env || process.env;
    const platform2 = options2.platform || process.platform;
    if (platform2 !== "win32") {
      return "PATH";
    }
    return Object.keys(environment).reverse().find((key) => key.toUpperCase() === "PATH") || "Path";
  };
  module.exports = pathKey;
  module.exports.default = pathKey;
});

// node_modules/cross-spawn/lib/util/resolveCommand.js
var require_resolveCommand = __commonJS((exports, module) => {
  var path2 = __require("path");
  var which = require_which();
  var getPathKey = require_path_key();
  function resolveCommandAttempt(parsed, withoutPathExt) {
    const env = parsed.options.env || process.env;
    const cwd = process.cwd();
    const hasCustomCwd = parsed.options.cwd != null;
    const shouldSwitchCwd = hasCustomCwd && process.chdir !== undefined && !process.chdir.disabled;
    if (shouldSwitchCwd) {
      try {
        process.chdir(parsed.options.cwd);
      } catch (err) {}
    }
    let resolved;
    try {
      resolved = which.sync(parsed.command, {
        path: env[getPathKey({ env })],
        pathExt: withoutPathExt ? path2.delimiter : undefined
      });
    } catch (e) {} finally {
      if (shouldSwitchCwd) {
        process.chdir(cwd);
      }
    }
    if (resolved) {
      resolved = path2.resolve(hasCustomCwd ? parsed.options.cwd : "", resolved);
    }
    return resolved;
  }
  function resolveCommand(parsed) {
    return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
  }
  module.exports = resolveCommand;
});

// node_modules/cross-spawn/lib/util/escape.js
var require_escape = __commonJS((exports, module) => {
  var metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
  function escapeCommand(arg) {
    arg = arg.replace(metaCharsRegExp, "^$1");
    return arg;
  }
  function escapeArgument(arg, doubleEscapeMetaChars) {
    arg = `${arg}`;
    arg = arg.replace(/(?=(\\+?)?)\1"/g, "$1$1\\\"");
    arg = arg.replace(/(?=(\\+?)?)\1$/, "$1$1");
    arg = `"${arg}"`;
    arg = arg.replace(metaCharsRegExp, "^$1");
    if (doubleEscapeMetaChars) {
      arg = arg.replace(metaCharsRegExp, "^$1");
    }
    return arg;
  }
  exports.command = escapeCommand;
  exports.argument = escapeArgument;
});

// node_modules/shebang-regex/index.js
var require_shebang_regex = __commonJS((exports, module) => {
  module.exports = /^#!(.*)/;
});

// node_modules/shebang-command/index.js
var require_shebang_command = __commonJS((exports, module) => {
  var shebangRegex = require_shebang_regex();
  module.exports = (string7 = "") => {
    const match = string7.match(shebangRegex);
    if (!match) {
      return null;
    }
    const [path2, argument] = match[0].replace(/#! ?/, "").split(" ");
    const binary = path2.split("/").pop();
    if (binary === "env") {
      return argument;
    }
    return argument ? `${binary} ${argument}` : binary;
  };
});

// node_modules/cross-spawn/lib/util/readShebang.js
var require_readShebang = __commonJS((exports, module) => {
  var fs3 = __require("fs");
  var shebangCommand = require_shebang_command();
  function readShebang(command) {
    const size = 150;
    const buffer = Buffer.alloc(size);
    let fd;
    try {
      fd = fs3.openSync(command, "r");
      fs3.readSync(fd, buffer, 0, size, 0);
      fs3.closeSync(fd);
    } catch (e) {}
    return shebangCommand(buffer.toString());
  }
  module.exports = readShebang;
});

// node_modules/cross-spawn/lib/parse.js
var require_parse2 = __commonJS((exports, module) => {
  var path2 = __require("path");
  var resolveCommand = require_resolveCommand();
  var escape2 = require_escape();
  var readShebang = require_readShebang();
  var isWin = process.platform === "win32";
  var isExecutableRegExp = /\.(?:com|exe)$/i;
  var isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
  function detectShebang(parsed) {
    parsed.file = resolveCommand(parsed);
    const shebang = parsed.file && readShebang(parsed.file);
    if (shebang) {
      parsed.args.unshift(parsed.file);
      parsed.command = shebang;
      return resolveCommand(parsed);
    }
    return parsed.file;
  }
  function parseNonShell(parsed) {
    if (!isWin) {
      return parsed;
    }
    const commandFile = detectShebang(parsed);
    const needsShell = !isExecutableRegExp.test(commandFile);
    if (parsed.options.forceShell || needsShell) {
      const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
      parsed.command = path2.normalize(parsed.command);
      parsed.command = escape2.command(parsed.command);
      parsed.args = parsed.args.map((arg) => escape2.argument(arg, needsDoubleEscapeMetaChars));
      const shellCommand = [parsed.command].concat(parsed.args).join(" ");
      parsed.args = ["/d", "/s", "/c", `"${shellCommand}"`];
      parsed.command = process.env.comspec || "cmd.exe";
      parsed.options.windowsVerbatimArguments = true;
    }
    return parsed;
  }
  function parse11(command, args, options2) {
    if (args && !Array.isArray(args)) {
      options2 = args;
      args = null;
    }
    args = args ? args.slice(0) : [];
    options2 = Object.assign({}, options2);
    const parsed = {
      command,
      args,
      options: options2,
      file: undefined,
      original: {
        command,
        args
      }
    };
    return options2.shell ? parsed : parseNonShell(parsed);
  }
  module.exports = parse11;
});

// node_modules/cross-spawn/lib/enoent.js
var require_enoent = __commonJS((exports, module) => {
  var isWin = process.platform === "win32";
  function notFoundError(original, syscall) {
    return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
      code: "ENOENT",
      errno: "ENOENT",
      syscall: `${syscall} ${original.command}`,
      path: original.command,
      spawnargs: original.args
    });
  }
  function hookChildProcess(cp, parsed) {
    if (!isWin) {
      return;
    }
    const originalEmit = cp.emit;
    cp.emit = function(name, arg1) {
      if (name === "exit") {
        const err = verifyENOENT(arg1, parsed);
        if (err) {
          return originalEmit.call(cp, "error", err);
        }
      }
      return originalEmit.apply(cp, arguments);
    };
  }
  function verifyENOENT(status, parsed) {
    if (isWin && status === 1 && !parsed.file) {
      return notFoundError(parsed.original, "spawn");
    }
    return null;
  }
  function verifyENOENTSync(status, parsed) {
    if (isWin && status === 1 && !parsed.file) {
      return notFoundError(parsed.original, "spawnSync");
    }
    return null;
  }
  module.exports = {
    hookChildProcess,
    verifyENOENT,
    verifyENOENTSync,
    notFoundError
  };
});

// node_modules/cross-spawn/index.js
var require_cross_spawn = __commonJS((exports, module) => {
  var cp = __require("child_process");
  var parse11 = require_parse2();
  var enoent = require_enoent();
  function spawn(command, args, options2) {
    const parsed = parse11(command, args, options2);
    const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
    enoent.hookChildProcess(spawned, parsed);
    return spawned;
  }
  function spawnSync(command, args, options2) {
    const parsed = parse11(command, args, options2);
    const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);
    result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);
    return result;
  }
  module.exports = spawn;
  module.exports.spawn = spawn;
  module.exports.sync = spawnSync;
  module.exports._parse = parse11;
  module.exports._enoent = enoent;
});

// node_modules/kind-of/index.js
var require_kind_of = __commonJS((exports, module) => {
  var toString = Object.prototype.toString;
  module.exports = function kindOf(val) {
    if (val === undefined)
      return "undefined";
    if (val === null)
      return "null";
    var type = typeof val;
    if (type === "boolean")
      return "boolean";
    if (type === "string")
      return "string";
    if (type === "number")
      return "number";
    if (type === "symbol")
      return "symbol";
    if (type === "function") {
      return isGeneratorFn(val) ? "generatorfunction" : "function";
    }
    if (isArray(val))
      return "array";
    if (isBuffer(val))
      return "buffer";
    if (isArguments(val))
      return "arguments";
    if (isDate(val))
      return "date";
    if (isError(val))
      return "error";
    if (isRegexp(val))
      return "regexp";
    switch (ctorName(val)) {
      case "Symbol":
        return "symbol";
      case "Promise":
        return "promise";
      case "WeakMap":
        return "weakmap";
      case "WeakSet":
        return "weakset";
      case "Map":
        return "map";
      case "Set":
        return "set";
      case "Int8Array":
        return "int8array";
      case "Uint8Array":
        return "uint8array";
      case "Uint8ClampedArray":
        return "uint8clampedarray";
      case "Int16Array":
        return "int16array";
      case "Uint16Array":
        return "uint16array";
      case "Int32Array":
        return "int32array";
      case "Uint32Array":
        return "uint32array";
      case "Float32Array":
        return "float32array";
      case "Float64Array":
        return "float64array";
    }
    if (isGeneratorObj(val)) {
      return "generator";
    }
    type = toString.call(val);
    switch (type) {
      case "[object Object]":
        return "object";
      case "[object Map Iterator]":
        return "mapiterator";
      case "[object Set Iterator]":
        return "setiterator";
      case "[object String Iterator]":
        return "stringiterator";
      case "[object Array Iterator]":
        return "arrayiterator";
    }
    return type.slice(8, -1).toLowerCase().replace(/\s/g, "");
  };
  function ctorName(val) {
    return typeof val.constructor === "function" ? val.constructor.name : null;
  }
  function isArray(val) {
    if (Array.isArray)
      return Array.isArray(val);
    return val instanceof Array;
  }
  function isError(val) {
    return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
  }
  function isDate(val) {
    if (val instanceof Date)
      return true;
    return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
  }
  function isRegexp(val) {
    if (val instanceof RegExp)
      return true;
    return typeof val.flags === "string" && typeof val.ignoreCase === "boolean" && typeof val.multiline === "boolean" && typeof val.global === "boolean";
  }
  function isGeneratorFn(name, val) {
    return ctorName(name) === "GeneratorFunction";
  }
  function isGeneratorObj(val) {
    return typeof val.throw === "function" && typeof val.return === "function" && typeof val.next === "function";
  }
  function isArguments(val) {
    try {
      if (typeof val.length === "number" && typeof val.callee === "function") {
        return true;
      }
    } catch (err) {
      if (err.message.indexOf("callee") !== -1) {
        return true;
      }
    }
    return false;
  }
  function isBuffer(val) {
    if (val.constructor && typeof val.constructor.isBuffer === "function") {
      return val.constructor.isBuffer(val);
    }
    return false;
  }
});

// node_modules/is-extendable/index.js
var require_is_extendable = __commonJS((exports, module) => {
  /*!
   * is-extendable <https://github.com/jonschlinkert/is-extendable>
   *
   * Copyright (c) 2015, Jon Schlinkert.
   * Licensed under the MIT License.
   */
  module.exports = function isExtendable(val) {
    return typeof val !== "undefined" && val !== null && (typeof val === "object" || typeof val === "function");
  };
});

// node_modules/extend-shallow/index.js
var require_extend_shallow = __commonJS((exports, module) => {
  var isObject3 = require_is_extendable();
  module.exports = function extend3(o) {
    if (!isObject3(o)) {
      o = {};
    }
    var len = arguments.length;
    for (var i = 1;i < len; i++) {
      var obj = arguments[i];
      if (isObject3(obj)) {
        assign(o, obj);
      }
    }
    return o;
  };
  function assign(a, b) {
    for (var key in b) {
      if (hasOwn(b, key)) {
        a[key] = b[key];
      }
    }
  }
  function hasOwn(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }
});

// node_modules/section-matter/index.js
var require_section_matter = __commonJS((exports, module) => {
  var typeOf = require_kind_of();
  var extend3 = require_extend_shallow();
  module.exports = function(input, options2) {
    if (typeof options2 === "function") {
      options2 = { parse: options2 };
    }
    var file2 = toObject(input);
    var defaults = { section_delimiter: "---", parse: identity };
    var opts = extend3({}, defaults, options2);
    var delim = opts.section_delimiter;
    var lines = file2.content.split(/\r?\n/);
    var sections = null;
    var section = createSection();
    var content = [];
    var stack = [];
    function initSections(val) {
      file2.content = val;
      sections = [];
      content = [];
    }
    function closeSection(val) {
      if (stack.length) {
        section.key = getKey(stack[0], delim);
        section.content = val;
        opts.parse(section, sections);
        sections.push(section);
        section = createSection();
        content = [];
        stack = [];
      }
    }
    for (var i = 0;i < lines.length; i++) {
      var line = lines[i];
      var len = stack.length;
      var ln = line.trim();
      if (isDelimiter(ln, delim)) {
        if (ln.length === 3 && i !== 0) {
          if (len === 0 || len === 2) {
            content.push(line);
            continue;
          }
          stack.push(ln);
          section.data = content.join(`
`);
          content = [];
          continue;
        }
        if (sections === null) {
          initSections(content.join(`
`));
        }
        if (len === 2) {
          closeSection(content.join(`
`));
        }
        stack.push(ln);
        continue;
      }
      content.push(line);
    }
    if (sections === null) {
      initSections(content.join(`
`));
    } else {
      closeSection(content.join(`
`));
    }
    file2.sections = sections;
    return file2;
  };
  function isDelimiter(line, delim) {
    if (line.slice(0, delim.length) !== delim) {
      return false;
    }
    if (line.charAt(delim.length + 1) === delim.slice(-1)) {
      return false;
    }
    return true;
  }
  function toObject(input) {
    if (typeOf(input) !== "object") {
      input = { content: input };
    }
    if (typeof input.content !== "string" && !isBuffer(input.content)) {
      throw new TypeError("expected a buffer or string");
    }
    input.content = input.content.toString();
    input.sections = [];
    return input;
  }
  function getKey(val, delim) {
    return val ? val.slice(delim.length).trim() : "";
  }
  function createSection() {
    return { key: "", data: "", content: "" };
  }
  function identity(val) {
    return val;
  }
  function isBuffer(val) {
    if (val && val.constructor && typeof val.constructor.isBuffer === "function") {
      return val.constructor.isBuffer(val);
    }
    return false;
  }
});

// node_modules/js-yaml/lib/js-yaml/common.js
var require_common = __commonJS((exports, module) => {
  function isNothing(subject) {
    return typeof subject === "undefined" || subject === null;
  }
  function isObject3(subject) {
    return typeof subject === "object" && subject !== null;
  }
  function toArray(sequence) {
    if (Array.isArray(sequence))
      return sequence;
    else if (isNothing(sequence))
      return [];
    return [sequence];
  }
  function extend3(target, source) {
    var index, length, key, sourceKeys;
    if (source) {
      sourceKeys = Object.keys(source);
      for (index = 0, length = sourceKeys.length;index < length; index += 1) {
        key = sourceKeys[index];
        target[key] = source[key];
      }
    }
    return target;
  }
  function repeat(string7, count) {
    var result = "", cycle;
    for (cycle = 0;cycle < count; cycle += 1) {
      result += string7;
    }
    return result;
  }
  function isNegativeZero(number7) {
    return number7 === 0 && Number.NEGATIVE_INFINITY === 1 / number7;
  }
  exports.isNothing = isNothing;
  exports.isObject = isObject3;
  exports.toArray = toArray;
  exports.repeat = repeat;
  exports.isNegativeZero = isNegativeZero;
  exports.extend = extend3;
});

// node_modules/js-yaml/lib/js-yaml/exception.js
var require_exception = __commonJS((exports, module) => {
  function YAMLException(reason, mark) {
    Error.call(this);
    this.name = "YAMLException";
    this.reason = reason;
    this.mark = mark;
    this.message = (this.reason || "(unknown reason)") + (this.mark ? " " + this.mark.toString() : "");
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error().stack || "";
    }
  }
  YAMLException.prototype = Object.create(Error.prototype);
  YAMLException.prototype.constructor = YAMLException;
  YAMLException.prototype.toString = function toString(compact) {
    var result = this.name + ": ";
    result += this.reason || "(unknown reason)";
    if (!compact && this.mark) {
      result += " " + this.mark.toString();
    }
    return result;
  };
  module.exports = YAMLException;
});

// node_modules/js-yaml/lib/js-yaml/mark.js
var require_mark = __commonJS((exports, module) => {
  var common = require_common();
  function Mark(name, buffer, position, line, column) {
    this.name = name;
    this.buffer = buffer;
    this.position = position;
    this.line = line;
    this.column = column;
  }
  Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
    var head, start, tail, end, snippet;
    if (!this.buffer)
      return null;
    indent = indent || 4;
    maxLength = maxLength || 75;
    head = "";
    start = this.position;
    while (start > 0 && `\x00\r
\x85\u2028\u2029`.indexOf(this.buffer.charAt(start - 1)) === -1) {
      start -= 1;
      if (this.position - start > maxLength / 2 - 1) {
        head = " ... ";
        start += 5;
        break;
      }
    }
    tail = "";
    end = this.position;
    while (end < this.buffer.length && `\x00\r
\x85\u2028\u2029`.indexOf(this.buffer.charAt(end)) === -1) {
      end += 1;
      if (end - this.position > maxLength / 2 - 1) {
        tail = " ... ";
        end -= 5;
        break;
      }
    }
    snippet = this.buffer.slice(start, end);
    return common.repeat(" ", indent) + head + snippet + tail + `
` + common.repeat(" ", indent + this.position - start + head.length) + "^";
  };
  Mark.prototype.toString = function toString(compact) {
    var snippet, where = "";
    if (this.name) {
      where += 'in "' + this.name + '" ';
    }
    where += "at line " + (this.line + 1) + ", column " + (this.column + 1);
    if (!compact) {
      snippet = this.getSnippet();
      if (snippet) {
        where += `:
` + snippet;
      }
    }
    return where;
  };
  module.exports = Mark;
});

// node_modules/js-yaml/lib/js-yaml/type.js
var require_type = __commonJS((exports, module) => {
  var YAMLException = require_exception();
  var TYPE_CONSTRUCTOR_OPTIONS = [
    "kind",
    "resolve",
    "construct",
    "instanceOf",
    "predicate",
    "represent",
    "defaultStyle",
    "styleAliases"
  ];
  var YAML_NODE_KINDS = [
    "scalar",
    "sequence",
    "mapping"
  ];
  function compileStyleAliases(map3) {
    var result = {};
    if (map3 !== null) {
      Object.keys(map3).forEach(function(style) {
        map3[style].forEach(function(alias) {
          result[String(alias)] = style;
        });
      });
    }
    return result;
  }
  function Type(tag, options2) {
    options2 = options2 || {};
    Object.keys(options2).forEach(function(name) {
      if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
        throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
      }
    });
    this.tag = tag;
    this.kind = options2["kind"] || null;
    this.resolve = options2["resolve"] || function() {
      return true;
    };
    this.construct = options2["construct"] || function(data) {
      return data;
    };
    this.instanceOf = options2["instanceOf"] || null;
    this.predicate = options2["predicate"] || null;
    this.represent = options2["represent"] || null;
    this.defaultStyle = options2["defaultStyle"] || null;
    this.styleAliases = compileStyleAliases(options2["styleAliases"] || null);
    if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
      throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
    }
  }
  module.exports = Type;
});

// node_modules/js-yaml/lib/js-yaml/schema.js
var require_schema = __commonJS((exports, module) => {
  var common = require_common();
  var YAMLException = require_exception();
  var Type = require_type();
  function compileList(schema, name, result) {
    var exclude = [];
    schema.include.forEach(function(includedSchema) {
      result = compileList(includedSchema, name, result);
    });
    schema[name].forEach(function(currentType) {
      result.forEach(function(previousType, previousIndex) {
        if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {
          exclude.push(previousIndex);
        }
      });
      result.push(currentType);
    });
    return result.filter(function(type, index) {
      return exclude.indexOf(index) === -1;
    });
  }
  function compileMap() {
    var result = {
      scalar: {},
      sequence: {},
      mapping: {},
      fallback: {}
    }, index, length;
    function collectType(type) {
      result[type.kind][type.tag] = result["fallback"][type.tag] = type;
    }
    for (index = 0, length = arguments.length;index < length; index += 1) {
      arguments[index].forEach(collectType);
    }
    return result;
  }
  function Schema2(definition) {
    this.include = definition.include || [];
    this.implicit = definition.implicit || [];
    this.explicit = definition.explicit || [];
    this.implicit.forEach(function(type) {
      if (type.loadKind && type.loadKind !== "scalar") {
        throw new YAMLException("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
      }
    });
    this.compiledImplicit = compileList(this, "implicit", []);
    this.compiledExplicit = compileList(this, "explicit", []);
    this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);
  }
  Schema2.DEFAULT = null;
  Schema2.create = function createSchema() {
    var schemas6, types;
    switch (arguments.length) {
      case 1:
        schemas6 = Schema2.DEFAULT;
        types = arguments[0];
        break;
      case 2:
        schemas6 = arguments[0];
        types = arguments[1];
        break;
      default:
        throw new YAMLException("Wrong number of arguments for Schema.create function");
    }
    schemas6 = common.toArray(schemas6);
    types = common.toArray(types);
    if (!schemas6.every(function(schema) {
      return schema instanceof Schema2;
    })) {
      throw new YAMLException("Specified list of super schemas (or a single Schema object) contains a non-Schema object.");
    }
    if (!types.every(function(type) {
      return type instanceof Type;
    })) {
      throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
    return new Schema2({
      include: schemas6,
      explicit: types
    });
  };
  module.exports = Schema2;
});

// node_modules/js-yaml/lib/js-yaml/type/str.js
var require_str = __commonJS((exports, module) => {
  var Type = require_type();
  module.exports = new Type("tag:yaml.org,2002:str", {
    kind: "scalar",
    construct: function(data) {
      return data !== null ? data : "";
    }
  });
});

// node_modules/js-yaml/lib/js-yaml/type/seq.js
var require_seq = __commonJS((exports, module) => {
  var Type = require_type();
  module.exports = new Type("tag:yaml.org,2002:seq", {
    kind: "sequence",
    construct: function(data) {
      return data !== null ? data : [];
    }
  });
});

// node_modules/js-yaml/lib/js-yaml/type/map.js
var require_map = __commonJS((exports, module) => {
  var Type = require_type();
  module.exports = new Type("tag:yaml.org,2002:map", {
    kind: "mapping",
    construct: function(data) {
      return data !== null ? data : {};
    }
  });
});

// node_modules/js-yaml/lib/js-yaml/schema/failsafe.js
var require_failsafe = __commonJS((exports, module) => {
  var Schema2 = require_schema();
  module.exports = new Schema2({
    explicit: [
      require_str(),
      require_seq(),
      require_map()
    ]
  });
});

// node_modules/js-yaml/lib/js-yaml/type/null.js
var require_null = __commonJS((exports, module) => {
  var Type = require_type();
  function resolveYamlNull(data) {
    if (data === null)
      return true;
    var max = data.length;
    return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
  }
  function constructYamlNull() {
    return null;
  }
  function isNull2(object5) {
    return object5 === null;
  }
  module.exports = new Type("tag:yaml.org,2002:null", {
    kind: "scalar",
    resolve: resolveYamlNull,
    construct: constructYamlNull,
    predicate: isNull2,
    represent: {
      canonical: function() {
        return "~";
      },
      lowercase: function() {
        return "null";
      },
      uppercase: function() {
        return "NULL";
      },
      camelcase: function() {
        return "Null";
      }
    },
    defaultStyle: "lowercase"
  });
});

// node_modules/js-yaml/lib/js-yaml/type/bool.js
var require_bool = __commonJS((exports, module) => {
  var Type = require_type();
  function resolveYamlBoolean(data) {
    if (data === null)
      return false;
    var max = data.length;
    return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
  }
  function constructYamlBoolean(data) {
    return data === "true" || data === "True" || data === "TRUE";
  }
  function isBoolean(object5) {
    return Object.prototype.toString.call(object5) === "[object Boolean]";
  }
  module.exports = new Type("tag:yaml.org,2002:bool", {
    kind: "scalar",
    resolve: resolveYamlBoolean,
    construct: constructYamlBoolean,
    predicate: isBoolean,
    represent: {
      lowercase: function(object5) {
        return object5 ? "true" : "false";
      },
      uppercase: function(object5) {
        return object5 ? "TRUE" : "FALSE";
      },
      camelcase: function(object5) {
        return object5 ? "True" : "False";
      }
    },
    defaultStyle: "lowercase"
  });
});

// node_modules/js-yaml/lib/js-yaml/type/int.js
var require_int = __commonJS((exports, module) => {
  var common = require_common();
  var Type = require_type();
  function isHexCode(c) {
    return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
  }
  function isOctCode(c) {
    return 48 <= c && c <= 55;
  }
  function isDecCode(c) {
    return 48 <= c && c <= 57;
  }
  function resolveYamlInteger(data) {
    if (data === null)
      return false;
    var max = data.length, index = 0, hasDigits = false, ch;
    if (!max)
      return false;
    ch = data[index];
    if (ch === "-" || ch === "+") {
      ch = data[++index];
    }
    if (ch === "0") {
      if (index + 1 === max)
        return true;
      ch = data[++index];
      if (ch === "b") {
        index++;
        for (;index < max; index++) {
          ch = data[index];
          if (ch === "_")
            continue;
          if (ch !== "0" && ch !== "1")
            return false;
          hasDigits = true;
        }
        return hasDigits && ch !== "_";
      }
      if (ch === "x") {
        index++;
        for (;index < max; index++) {
          ch = data[index];
          if (ch === "_")
            continue;
          if (!isHexCode(data.charCodeAt(index)))
            return false;
          hasDigits = true;
        }
        return hasDigits && ch !== "_";
      }
      for (;index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (!isOctCode(data.charCodeAt(index)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "_")
      return false;
    for (;index < max; index++) {
      ch = data[index];
      if (ch === "_")
        continue;
      if (ch === ":")
        break;
      if (!isDecCode(data.charCodeAt(index))) {
        return false;
      }
      hasDigits = true;
    }
    if (!hasDigits || ch === "_")
      return false;
    if (ch !== ":")
      return true;
    return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
  }
  function constructYamlInteger(data) {
    var value = data, sign = 1, ch, base, digits = [];
    if (value.indexOf("_") !== -1) {
      value = value.replace(/_/g, "");
    }
    ch = value[0];
    if (ch === "-" || ch === "+") {
      if (ch === "-")
        sign = -1;
      value = value.slice(1);
      ch = value[0];
    }
    if (value === "0")
      return 0;
    if (ch === "0") {
      if (value[1] === "b")
        return sign * parseInt(value.slice(2), 2);
      if (value[1] === "x")
        return sign * parseInt(value, 16);
      return sign * parseInt(value, 8);
    }
    if (value.indexOf(":") !== -1) {
      value.split(":").forEach(function(v) {
        digits.unshift(parseInt(v, 10));
      });
      value = 0;
      base = 1;
      digits.forEach(function(d) {
        value += d * base;
        base *= 60;
      });
      return sign * value;
    }
    return sign * parseInt(value, 10);
  }
  function isInteger(object5) {
    return Object.prototype.toString.call(object5) === "[object Number]" && (object5 % 1 === 0 && !common.isNegativeZero(object5));
  }
  module.exports = new Type("tag:yaml.org,2002:int", {
    kind: "scalar",
    resolve: resolveYamlInteger,
    construct: constructYamlInteger,
    predicate: isInteger,
    represent: {
      binary: function(obj) {
        return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
      },
      octal: function(obj) {
        return obj >= 0 ? "0" + obj.toString(8) : "-0" + obj.toString(8).slice(1);
      },
      decimal: function(obj) {
        return obj.toString(10);
      },
      hexadecimal: function(obj) {
        return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
      }
    },
    defaultStyle: "decimal",
    styleAliases: {
      binary: [2, "bin"],
      octal: [8, "oct"],
      decimal: [10, "dec"],
      hexadecimal: [16, "hex"]
    }
  });
});

// node_modules/js-yaml/lib/js-yaml/type/float.js
var require_float = __commonJS((exports, module) => {
  var common = require_common();
  var Type = require_type();
  var YAML_FLOAT_PATTERN = new RegExp("^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?" + "|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?" + "|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*" + "|[-+]?\\.(?:inf|Inf|INF)" + "|\\.(?:nan|NaN|NAN))$");
  function resolveYamlFloat(data) {
    if (data === null)
      return false;
    if (!YAML_FLOAT_PATTERN.test(data) || data[data.length - 1] === "_") {
      return false;
    }
    return true;
  }
  function constructYamlFloat(data) {
    var value, sign, base, digits;
    value = data.replace(/_/g, "").toLowerCase();
    sign = value[0] === "-" ? -1 : 1;
    digits = [];
    if ("+-".indexOf(value[0]) >= 0) {
      value = value.slice(1);
    }
    if (value === ".inf") {
      return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
    } else if (value === ".nan") {
      return NaN;
    } else if (value.indexOf(":") >= 0) {
      value.split(":").forEach(function(v) {
        digits.unshift(parseFloat(v, 10));
      });
      value = 0;
      base = 1;
      digits.forEach(function(d) {
        value += d * base;
        base *= 60;
      });
      return sign * value;
    }
    return sign * parseFloat(value, 10);
  }
  var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
  function representYamlFloat(object5, style) {
    var res;
    if (isNaN(object5)) {
      switch (style) {
        case "lowercase":
          return ".nan";
        case "uppercase":
          return ".NAN";
        case "camelcase":
          return ".NaN";
      }
    } else if (Number.POSITIVE_INFINITY === object5) {
      switch (style) {
        case "lowercase":
          return ".inf";
        case "uppercase":
          return ".INF";
        case "camelcase":
          return ".Inf";
      }
    } else if (Number.NEGATIVE_INFINITY === object5) {
      switch (style) {
        case "lowercase":
          return "-.inf";
        case "uppercase":
          return "-.INF";
        case "camelcase":
          return "-.Inf";
      }
    } else if (common.isNegativeZero(object5)) {
      return "-0.0";
    }
    res = object5.toString(10);
    return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
  }
  function isFloat(object5) {
    return Object.prototype.toString.call(object5) === "[object Number]" && (object5 % 1 !== 0 || common.isNegativeZero(object5));
  }
  module.exports = new Type("tag:yaml.org,2002:float", {
    kind: "scalar",
    resolve: resolveYamlFloat,
    construct: constructYamlFloat,
    predicate: isFloat,
    represent: representYamlFloat,
    defaultStyle: "lowercase"
  });
});

// node_modules/js-yaml/lib/js-yaml/schema/json.js
var require_json = __commonJS((exports, module) => {
  var Schema2 = require_schema();
  module.exports = new Schema2({
    include: [
      require_failsafe()
    ],
    implicit: [
      require_null(),
      require_bool(),
      require_int(),
      require_float()
    ]
  });
});

// node_modules/js-yaml/lib/js-yaml/schema/core.js
var require_core3 = __commonJS((exports, module) => {
  var Schema2 = require_schema();
  module.exports = new Schema2({
    include: [
      require_json()
    ]
  });
});

// node_modules/js-yaml/lib/js-yaml/type/timestamp.js
var require_timestamp = __commonJS((exports, module) => {
  var Type = require_type();
  var YAML_DATE_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])" + "-([0-9][0-9])" + "-([0-9][0-9])$");
  var YAML_TIMESTAMP_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])" + "-([0-9][0-9]?)" + "-([0-9][0-9]?)" + "(?:[Tt]|[ \\t]+)" + "([0-9][0-9]?)" + ":([0-9][0-9])" + ":([0-9][0-9])" + "(?:\\.([0-9]*))?" + "(?:[ \\t]*(Z|([-+])([0-9][0-9]?)" + "(?::([0-9][0-9]))?))?$");
  function resolveYamlTimestamp(data) {
    if (data === null)
      return false;
    if (YAML_DATE_REGEXP.exec(data) !== null)
      return true;
    if (YAML_TIMESTAMP_REGEXP.exec(data) !== null)
      return true;
    return false;
  }
  function constructYamlTimestamp(data) {
    var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date8;
    match = YAML_DATE_REGEXP.exec(data);
    if (match === null)
      match = YAML_TIMESTAMP_REGEXP.exec(data);
    if (match === null)
      throw new Error("Date resolve error");
    year = +match[1];
    month = +match[2] - 1;
    day = +match[3];
    if (!match[4]) {
      return new Date(Date.UTC(year, month, day));
    }
    hour = +match[4];
    minute = +match[5];
    second = +match[6];
    if (match[7]) {
      fraction = match[7].slice(0, 3);
      while (fraction.length < 3) {
        fraction += "0";
      }
      fraction = +fraction;
    }
    if (match[9]) {
      tz_hour = +match[10];
      tz_minute = +(match[11] || 0);
      delta = (tz_hour * 60 + tz_minute) * 60000;
      if (match[9] === "-")
        delta = -delta;
    }
    date8 = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
    if (delta)
      date8.setTime(date8.getTime() - delta);
    return date8;
  }
  function representYamlTimestamp(object5) {
    return object5.toISOString();
  }
  module.exports = new Type("tag:yaml.org,2002:timestamp", {
    kind: "scalar",
    resolve: resolveYamlTimestamp,
    construct: constructYamlTimestamp,
    instanceOf: Date,
    represent: representYamlTimestamp
  });
});

// node_modules/js-yaml/lib/js-yaml/type/merge.js
var require_merge = __commonJS((exports, module) => {
  var Type = require_type();
  function resolveYamlMerge(data) {
    return data === "<<" || data === null;
  }
  module.exports = new Type("tag:yaml.org,2002:merge", {
    kind: "scalar",
    resolve: resolveYamlMerge
  });
});

// node_modules/js-yaml/lib/js-yaml/type/binary.js
var require_binary = __commonJS((exports, module) => {
  var NodeBuffer;
  try {
    _require = __require;
    NodeBuffer = _require("buffer").Buffer;
  } catch (__) {}
  var _require;
  var Type = require_type();
  var BASE64_MAP = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
  function resolveYamlBinary(data) {
    if (data === null)
      return false;
    var code, idx, bitlen = 0, max = data.length, map3 = BASE64_MAP;
    for (idx = 0;idx < max; idx++) {
      code = map3.indexOf(data.charAt(idx));
      if (code > 64)
        continue;
      if (code < 0)
        return false;
      bitlen += 6;
    }
    return bitlen % 8 === 0;
  }
  function constructYamlBinary(data) {
    var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map3 = BASE64_MAP, bits = 0, result = [];
    for (idx = 0;idx < max; idx++) {
      if (idx % 4 === 0 && idx) {
        result.push(bits >> 16 & 255);
        result.push(bits >> 8 & 255);
        result.push(bits & 255);
      }
      bits = bits << 6 | map3.indexOf(input.charAt(idx));
    }
    tailbits = max % 4 * 6;
    if (tailbits === 0) {
      result.push(bits >> 16 & 255);
      result.push(bits >> 8 & 255);
      result.push(bits & 255);
    } else if (tailbits === 18) {
      result.push(bits >> 10 & 255);
      result.push(bits >> 2 & 255);
    } else if (tailbits === 12) {
      result.push(bits >> 4 & 255);
    }
    if (NodeBuffer) {
      return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);
    }
    return result;
  }
  function representYamlBinary(object5) {
    var result = "", bits = 0, idx, tail, max = object5.length, map3 = BASE64_MAP;
    for (idx = 0;idx < max; idx++) {
      if (idx % 3 === 0 && idx) {
        result += map3[bits >> 18 & 63];
        result += map3[bits >> 12 & 63];
        result += map3[bits >> 6 & 63];
        result += map3[bits & 63];
      }
      bits = (bits << 8) + object5[idx];
    }
    tail = max % 3;
    if (tail === 0) {
      result += map3[bits >> 18 & 63];
      result += map3[bits >> 12 & 63];
      result += map3[bits >> 6 & 63];
      result += map3[bits & 63];
    } else if (tail === 2) {
      result += map3[bits >> 10 & 63];
      result += map3[bits >> 4 & 63];
      result += map3[bits << 2 & 63];
      result += map3[64];
    } else if (tail === 1) {
      result += map3[bits >> 2 & 63];
      result += map3[bits << 4 & 63];
      result += map3[64];
      result += map3[64];
    }
    return result;
  }
  function isBinary(object5) {
    return NodeBuffer && NodeBuffer.isBuffer(object5);
  }
  module.exports = new Type("tag:yaml.org,2002:binary", {
    kind: "scalar",
    resolve: resolveYamlBinary,
    construct: constructYamlBinary,
    predicate: isBinary,
    represent: representYamlBinary
  });
});

// node_modules/js-yaml/lib/js-yaml/type/omap.js
var require_omap = __commonJS((exports, module) => {
  var Type = require_type();
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  var _toString = Object.prototype.toString;
  function resolveYamlOmap(data) {
    if (data === null)
      return true;
    var objectKeys = [], index, length, pair, pairKey, pairHasKey, object5 = data;
    for (index = 0, length = object5.length;index < length; index += 1) {
      pair = object5[index];
      pairHasKey = false;
      if (_toString.call(pair) !== "[object Object]")
        return false;
      for (pairKey in pair) {
        if (_hasOwnProperty.call(pair, pairKey)) {
          if (!pairHasKey)
            pairHasKey = true;
          else
            return false;
        }
      }
      if (!pairHasKey)
        return false;
      if (objectKeys.indexOf(pairKey) === -1)
        objectKeys.push(pairKey);
      else
        return false;
    }
    return true;
  }
  function constructYamlOmap(data) {
    return data !== null ? data : [];
  }
  module.exports = new Type("tag:yaml.org,2002:omap", {
    kind: "sequence",
    resolve: resolveYamlOmap,
    construct: constructYamlOmap
  });
});

// node_modules/js-yaml/lib/js-yaml/type/pairs.js
var require_pairs = __commonJS((exports, module) => {
  var Type = require_type();
  var _toString = Object.prototype.toString;
  function resolveYamlPairs(data) {
    if (data === null)
      return true;
    var index, length, pair, keys, result, object5 = data;
    result = new Array(object5.length);
    for (index = 0, length = object5.length;index < length; index += 1) {
      pair = object5[index];
      if (_toString.call(pair) !== "[object Object]")
        return false;
      keys = Object.keys(pair);
      if (keys.length !== 1)
        return false;
      result[index] = [keys[0], pair[keys[0]]];
    }
    return true;
  }
  function constructYamlPairs(data) {
    if (data === null)
      return [];
    var index, length, pair, keys, result, object5 = data;
    result = new Array(object5.length);
    for (index = 0, length = object5.length;index < length; index += 1) {
      pair = object5[index];
      keys = Object.keys(pair);
      result[index] = [keys[0], pair[keys[0]]];
    }
    return result;
  }
  module.exports = new Type("tag:yaml.org,2002:pairs", {
    kind: "sequence",
    resolve: resolveYamlPairs,
    construct: constructYamlPairs
  });
});

// node_modules/js-yaml/lib/js-yaml/type/set.js
var require_set = __commonJS((exports, module) => {
  var Type = require_type();
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  function resolveYamlSet(data) {
    if (data === null)
      return true;
    var key, object5 = data;
    for (key in object5) {
      if (_hasOwnProperty.call(object5, key)) {
        if (object5[key] !== null)
          return false;
      }
    }
    return true;
  }
  function constructYamlSet(data) {
    return data !== null ? data : {};
  }
  module.exports = new Type("tag:yaml.org,2002:set", {
    kind: "mapping",
    resolve: resolveYamlSet,
    construct: constructYamlSet
  });
});

// node_modules/js-yaml/lib/js-yaml/schema/default_safe.js
var require_default_safe = __commonJS((exports, module) => {
  var Schema2 = require_schema();
  module.exports = new Schema2({
    include: [
      require_core3()
    ],
    implicit: [
      require_timestamp(),
      require_merge()
    ],
    explicit: [
      require_binary(),
      require_omap(),
      require_pairs(),
      require_set()
    ]
  });
});

// node_modules/js-yaml/lib/js-yaml/type/js/undefined.js
var require_undefined = __commonJS((exports, module) => {
  var Type = require_type();
  function resolveJavascriptUndefined() {
    return true;
  }
  function constructJavascriptUndefined() {
    return;
  }
  function representJavascriptUndefined() {
    return "";
  }
  function isUndefined(object5) {
    return typeof object5 === "undefined";
  }
  module.exports = new Type("tag:yaml.org,2002:js/undefined", {
    kind: "scalar",
    resolve: resolveJavascriptUndefined,
    construct: constructJavascriptUndefined,
    predicate: isUndefined,
    represent: representJavascriptUndefined
  });
});

// node_modules/js-yaml/lib/js-yaml/type/js/regexp.js
var require_regexp = __commonJS((exports, module) => {
  var Type = require_type();
  function resolveJavascriptRegExp(data) {
    if (data === null)
      return false;
    if (data.length === 0)
      return false;
    var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers = "";
    if (regexp[0] === "/") {
      if (tail)
        modifiers = tail[1];
      if (modifiers.length > 3)
        return false;
      if (regexp[regexp.length - modifiers.length - 1] !== "/")
        return false;
    }
    return true;
  }
  function constructJavascriptRegExp(data) {
    var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers = "";
    if (regexp[0] === "/") {
      if (tail)
        modifiers = tail[1];
      regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
    }
    return new RegExp(regexp, modifiers);
  }
  function representJavascriptRegExp(object5) {
    var result = "/" + object5.source + "/";
    if (object5.global)
      result += "g";
    if (object5.multiline)
      result += "m";
    if (object5.ignoreCase)
      result += "i";
    return result;
  }
  function isRegExp(object5) {
    return Object.prototype.toString.call(object5) === "[object RegExp]";
  }
  module.exports = new Type("tag:yaml.org,2002:js/regexp", {
    kind: "scalar",
    resolve: resolveJavascriptRegExp,
    construct: constructJavascriptRegExp,
    predicate: isRegExp,
    represent: representJavascriptRegExp
  });
});

// node_modules/js-yaml/lib/js-yaml/type/js/function.js
var require_function = __commonJS((exports, module) => {
  var esprima;
  try {
    _require = __require;
    esprima = _require("esprima");
  } catch (_) {
    if (typeof window !== "undefined")
      esprima = window.esprima;
  }
  var _require;
  var Type = require_type();
  function resolveJavascriptFunction(data) {
    if (data === null)
      return false;
    try {
      var source = "(" + data + ")", ast = esprima.parse(source, { range: true });
      if (ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression") {
        return false;
      }
      return true;
    } catch (err) {
      return false;
    }
  }
  function constructJavascriptFunction(data) {
    var source = "(" + data + ")", ast = esprima.parse(source, { range: true }), params = [], body;
    if (ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression") {
      throw new Error("Failed to resolve function");
    }
    ast.body[0].expression.params.forEach(function(param) {
      params.push(param.name);
    });
    body = ast.body[0].expression.body.range;
    if (ast.body[0].expression.body.type === "BlockStatement") {
      return new Function(params, source.slice(body[0] + 1, body[1] - 1));
    }
    return new Function(params, "return " + source.slice(body[0], body[1]));
  }
  function representJavascriptFunction(object5) {
    return object5.toString();
  }
  function isFunction(object5) {
    return Object.prototype.toString.call(object5) === "[object Function]";
  }
  module.exports = new Type("tag:yaml.org,2002:js/function", {
    kind: "scalar",
    resolve: resolveJavascriptFunction,
    construct: constructJavascriptFunction,
    predicate: isFunction,
    represent: representJavascriptFunction
  });
});

// node_modules/js-yaml/lib/js-yaml/schema/default_full.js
var require_default_full = __commonJS((exports, module) => {
  var Schema2 = require_schema();
  module.exports = Schema2.DEFAULT = new Schema2({
    include: [
      require_default_safe()
    ],
    explicit: [
      require_undefined(),
      require_regexp(),
      require_function()
    ]
  });
});

// node_modules/js-yaml/lib/js-yaml/loader.js
var require_loader = __commonJS((exports, module) => {
  var common = require_common();
  var YAMLException = require_exception();
  var Mark = require_mark();
  var DEFAULT_SAFE_SCHEMA = require_default_safe();
  var DEFAULT_FULL_SCHEMA = require_default_full();
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  var CONTEXT_FLOW_IN = 1;
  var CONTEXT_FLOW_OUT = 2;
  var CONTEXT_BLOCK_IN = 3;
  var CONTEXT_BLOCK_OUT = 4;
  var CHOMPING_CLIP = 1;
  var CHOMPING_STRIP = 2;
  var CHOMPING_KEEP = 3;
  var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
  var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
  var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
  var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
  var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
  function _class(obj) {
    return Object.prototype.toString.call(obj);
  }
  function is_EOL(c) {
    return c === 10 || c === 13;
  }
  function is_WHITE_SPACE(c) {
    return c === 9 || c === 32;
  }
  function is_WS_OR_EOL(c) {
    return c === 9 || c === 32 || c === 10 || c === 13;
  }
  function is_FLOW_INDICATOR(c) {
    return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
  }
  function fromHexCode(c) {
    var lc;
    if (48 <= c && c <= 57) {
      return c - 48;
    }
    lc = c | 32;
    if (97 <= lc && lc <= 102) {
      return lc - 97 + 10;
    }
    return -1;
  }
  function escapedHexLen(c) {
    if (c === 120) {
      return 2;
    }
    if (c === 117) {
      return 4;
    }
    if (c === 85) {
      return 8;
    }
    return 0;
  }
  function fromDecimalCode(c) {
    if (48 <= c && c <= 57) {
      return c - 48;
    }
    return -1;
  }
  function simpleEscapeSequence(c) {
    return c === 48 ? "\x00" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "\t" : c === 9 ? "\t" : c === 110 ? `
` : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "\x85" : c === 95 ? "\xA0" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
  }
  function charFromCodepoint(c) {
    if (c <= 65535) {
      return String.fromCharCode(c);
    }
    return String.fromCharCode((c - 65536 >> 10) + 55296, (c - 65536 & 1023) + 56320);
  }
  function setProperty(object5, key, value) {
    if (key === "__proto__") {
      Object.defineProperty(object5, key, {
        configurable: true,
        enumerable: true,
        writable: true,
        value
      });
    } else {
      object5[key] = value;
    }
  }
  var simpleEscapeCheck = new Array(256);
  var simpleEscapeMap = new Array(256);
  for (i = 0;i < 256; i++) {
    simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
    simpleEscapeMap[i] = simpleEscapeSequence(i);
  }
  var i;
  function State(input, options2) {
    this.input = input;
    this.filename = options2["filename"] || null;
    this.schema = options2["schema"] || DEFAULT_FULL_SCHEMA;
    this.onWarning = options2["onWarning"] || null;
    this.legacy = options2["legacy"] || false;
    this.json = options2["json"] || false;
    this.listener = options2["listener"] || null;
    this.implicitTypes = this.schema.compiledImplicit;
    this.typeMap = this.schema.compiledTypeMap;
    this.length = input.length;
    this.position = 0;
    this.line = 0;
    this.lineStart = 0;
    this.lineIndent = 0;
    this.documents = [];
  }
  function generateError(state, message) {
    return new YAMLException(message, new Mark(state.filename, state.input, state.position, state.line, state.position - state.lineStart));
  }
  function throwError(state, message) {
    throw generateError(state, message);
  }
  function throwWarning(state, message) {
    if (state.onWarning) {
      state.onWarning.call(null, generateError(state, message));
    }
  }
  var directiveHandlers = {
    YAML: function handleYamlDirective(state, name, args) {
      var match, major, minor;
      if (state.version !== null) {
        throwError(state, "duplication of %YAML directive");
      }
      if (args.length !== 1) {
        throwError(state, "YAML directive accepts exactly one argument");
      }
      match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
      if (match === null) {
        throwError(state, "ill-formed argument of the YAML directive");
      }
      major = parseInt(match[1], 10);
      minor = parseInt(match[2], 10);
      if (major !== 1) {
        throwError(state, "unacceptable YAML version of the document");
      }
      state.version = args[0];
      state.checkLineBreaks = minor < 2;
      if (minor !== 1 && minor !== 2) {
        throwWarning(state, "unsupported YAML version of the document");
      }
    },
    TAG: function handleTagDirective(state, name, args) {
      var handle, prefix;
      if (args.length !== 2) {
        throwError(state, "TAG directive accepts exactly two arguments");
      }
      handle = args[0];
      prefix = args[1];
      if (!PATTERN_TAG_HANDLE.test(handle)) {
        throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
      }
      if (_hasOwnProperty.call(state.tagMap, handle)) {
        throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
      }
      if (!PATTERN_TAG_URI.test(prefix)) {
        throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
      }
      state.tagMap[handle] = prefix;
    }
  };
  function captureSegment(state, start, end, checkJson) {
    var _position, _length3, _character, _result;
    if (start < end) {
      _result = state.input.slice(start, end);
      if (checkJson) {
        for (_position = 0, _length3 = _result.length;_position < _length3; _position += 1) {
          _character = _result.charCodeAt(_position);
          if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
            throwError(state, "expected valid JSON character");
          }
        }
      } else if (PATTERN_NON_PRINTABLE.test(_result)) {
        throwError(state, "the stream contains non-printable characters");
      }
      state.result += _result;
    }
  }
  function mergeMappings(state, destination, source, overridableKeys) {
    var sourceKeys, key, index, quantity;
    if (!common.isObject(source)) {
      throwError(state, "cannot merge mappings; the provided source object is unacceptable");
    }
    sourceKeys = Object.keys(source);
    for (index = 0, quantity = sourceKeys.length;index < quantity; index += 1) {
      key = sourceKeys[index];
      if (!_hasOwnProperty.call(destination, key)) {
        setProperty(destination, key, source[key]);
        overridableKeys[key] = true;
      }
    }
  }
  function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
    var index, quantity;
    if (Array.isArray(keyNode)) {
      keyNode = Array.prototype.slice.call(keyNode);
      for (index = 0, quantity = keyNode.length;index < quantity; index += 1) {
        if (Array.isArray(keyNode[index])) {
          throwError(state, "nested arrays are not supported inside keys");
        }
        if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
          keyNode[index] = "[object Object]";
        }
      }
    }
    if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
      keyNode = "[object Object]";
    }
    keyNode = String(keyNode);
    if (_result === null) {
      _result = {};
    }
    if (keyTag === "tag:yaml.org,2002:merge") {
      if (Array.isArray(valueNode)) {
        for (index = 0, quantity = valueNode.length;index < quantity; index += 1) {
          mergeMappings(state, _result, valueNode[index], overridableKeys);
        }
      } else {
        mergeMappings(state, _result, valueNode, overridableKeys);
      }
    } else {
      if (!state.json && !_hasOwnProperty.call(overridableKeys, keyNode) && _hasOwnProperty.call(_result, keyNode)) {
        state.line = startLine || state.line;
        state.position = startPos || state.position;
        throwError(state, "duplicated mapping key");
      }
      setProperty(_result, keyNode, valueNode);
      delete overridableKeys[keyNode];
    }
    return _result;
  }
  function readLineBreak(state) {
    var ch;
    ch = state.input.charCodeAt(state.position);
    if (ch === 10) {
      state.position++;
    } else if (ch === 13) {
      state.position++;
      if (state.input.charCodeAt(state.position) === 10) {
        state.position++;
      }
    } else {
      throwError(state, "a line break is expected");
    }
    state.line += 1;
    state.lineStart = state.position;
  }
  function skipSeparationSpace(state, allowComments, checkIndent) {
    var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (allowComments && ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 10 && ch !== 13 && ch !== 0);
      }
      if (is_EOL(ch)) {
        readLineBreak(state);
        ch = state.input.charCodeAt(state.position);
        lineBreaks++;
        state.lineIndent = 0;
        while (ch === 32) {
          state.lineIndent++;
          ch = state.input.charCodeAt(++state.position);
        }
      } else {
        break;
      }
    }
    if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
      throwWarning(state, "deficient indentation");
    }
    return lineBreaks;
  }
  function testDocumentSeparator(state) {
    var _position = state.position, ch;
    ch = state.input.charCodeAt(_position);
    if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
      _position += 3;
      ch = state.input.charCodeAt(_position);
      if (ch === 0 || is_WS_OR_EOL(ch)) {
        return true;
      }
    }
    return false;
  }
  function writeFoldedLines(state, count) {
    if (count === 1) {
      state.result += " ";
    } else if (count > 1) {
      state.result += common.repeat(`
`, count - 1);
    }
  }
  function readPlainScalar(state, nodeIndent, withinFlowCollection) {
    var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
    ch = state.input.charCodeAt(state.position);
    if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
      return false;
    }
    if (ch === 63 || ch === 45) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        return false;
      }
    }
    state.kind = "scalar";
    state.result = "";
    captureStart = captureEnd = state.position;
    hasPendingContent = false;
    while (ch !== 0) {
      if (ch === 58) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
          break;
        }
      } else if (ch === 35) {
        preceding = state.input.charCodeAt(state.position - 1);
        if (is_WS_OR_EOL(preceding)) {
          break;
        }
      } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
        break;
      } else if (is_EOL(ch)) {
        _line = state.line;
        _lineStart = state.lineStart;
        _lineIndent = state.lineIndent;
        skipSeparationSpace(state, false, -1);
        if (state.lineIndent >= nodeIndent) {
          hasPendingContent = true;
          ch = state.input.charCodeAt(state.position);
          continue;
        } else {
          state.position = captureEnd;
          state.line = _line;
          state.lineStart = _lineStart;
          state.lineIndent = _lineIndent;
          break;
        }
      }
      if (hasPendingContent) {
        captureSegment(state, captureStart, captureEnd, false);
        writeFoldedLines(state, state.line - _line);
        captureStart = captureEnd = state.position;
        hasPendingContent = false;
      }
      if (!is_WHITE_SPACE(ch)) {
        captureEnd = state.position + 1;
      }
      ch = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, captureEnd, false);
    if (state.result) {
      return true;
    }
    state.kind = _kind;
    state.result = _result;
    return false;
  }
  function readSingleQuotedScalar(state, nodeIndent) {
    var ch, captureStart, captureEnd;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 39) {
      return false;
    }
    state.kind = "scalar";
    state.result = "";
    state.position++;
    captureStart = captureEnd = state.position;
    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      if (ch === 39) {
        captureSegment(state, captureStart, state.position, true);
        ch = state.input.charCodeAt(++state.position);
        if (ch === 39) {
          captureStart = state.position;
          state.position++;
          captureEnd = state.position;
        } else {
          return true;
        }
      } else if (is_EOL(ch)) {
        captureSegment(state, captureStart, captureEnd, true);
        writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
        captureStart = captureEnd = state.position;
      } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
        throwError(state, "unexpected end of the document within a single quoted scalar");
      } else {
        state.position++;
        captureEnd = state.position;
      }
    }
    throwError(state, "unexpected end of the stream within a single quoted scalar");
  }
  function readDoubleQuotedScalar(state, nodeIndent) {
    var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 34) {
      return false;
    }
    state.kind = "scalar";
    state.result = "";
    state.position++;
    captureStart = captureEnd = state.position;
    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      if (ch === 34) {
        captureSegment(state, captureStart, state.position, true);
        state.position++;
        return true;
      } else if (ch === 92) {
        captureSegment(state, captureStart, state.position, true);
        ch = state.input.charCodeAt(++state.position);
        if (is_EOL(ch)) {
          skipSeparationSpace(state, false, nodeIndent);
        } else if (ch < 256 && simpleEscapeCheck[ch]) {
          state.result += simpleEscapeMap[ch];
          state.position++;
        } else if ((tmp = escapedHexLen(ch)) > 0) {
          hexLength = tmp;
          hexResult = 0;
          for (;hexLength > 0; hexLength--) {
            ch = state.input.charCodeAt(++state.position);
            if ((tmp = fromHexCode(ch)) >= 0) {
              hexResult = (hexResult << 4) + tmp;
            } else {
              throwError(state, "expected hexadecimal character");
            }
          }
          state.result += charFromCodepoint(hexResult);
          state.position++;
        } else {
          throwError(state, "unknown escape sequence");
        }
        captureStart = captureEnd = state.position;
      } else if (is_EOL(ch)) {
        captureSegment(state, captureStart, captureEnd, true);
        writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
        captureStart = captureEnd = state.position;
      } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
        throwError(state, "unexpected end of the document within a double quoted scalar");
      } else {
        state.position++;
        captureEnd = state.position;
      }
    }
    throwError(state, "unexpected end of the stream within a double quoted scalar");
  }
  function readFlowCollection(state, nodeIndent) {
    var readNext = true, _line, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = {}, keyNode, keyTag, valueNode, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch === 91) {
      terminator = 93;
      isMapping = false;
      _result = [];
    } else if (ch === 123) {
      terminator = 125;
      isMapping = true;
      _result = {};
    } else {
      return false;
    }
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }
    ch = state.input.charCodeAt(++state.position);
    while (ch !== 0) {
      skipSeparationSpace(state, true, nodeIndent);
      ch = state.input.charCodeAt(state.position);
      if (ch === terminator) {
        state.position++;
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = isMapping ? "mapping" : "sequence";
        state.result = _result;
        return true;
      } else if (!readNext) {
        throwError(state, "missed comma between flow collection entries");
      }
      keyTag = keyNode = valueNode = null;
      isPair = isExplicitPair = false;
      if (ch === 63) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL(following)) {
          isPair = isExplicitPair = true;
          state.position++;
          skipSeparationSpace(state, true, nodeIndent);
        }
      }
      _line = state.line;
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      keyTag = state.tag;
      keyNode = state.result;
      skipSeparationSpace(state, true, nodeIndent);
      ch = state.input.charCodeAt(state.position);
      if ((isExplicitPair || state.line === _line) && ch === 58) {
        isPair = true;
        ch = state.input.charCodeAt(++state.position);
        skipSeparationSpace(state, true, nodeIndent);
        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
        valueNode = state.result;
      }
      if (isMapping) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
      } else if (isPair) {
        _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
      } else {
        _result.push(keyNode);
      }
      skipSeparationSpace(state, true, nodeIndent);
      ch = state.input.charCodeAt(state.position);
      if (ch === 44) {
        readNext = true;
        ch = state.input.charCodeAt(++state.position);
      } else {
        readNext = false;
      }
    }
    throwError(state, "unexpected end of the stream within a flow collection");
  }
  function readBlockScalar(state, nodeIndent) {
    var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch === 124) {
      folding = false;
    } else if (ch === 62) {
      folding = true;
    } else {
      return false;
    }
    state.kind = "scalar";
    state.result = "";
    while (ch !== 0) {
      ch = state.input.charCodeAt(++state.position);
      if (ch === 43 || ch === 45) {
        if (CHOMPING_CLIP === chomping) {
          chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
        } else {
          throwError(state, "repeat of a chomping mode identifier");
        }
      } else if ((tmp = fromDecimalCode(ch)) >= 0) {
        if (tmp === 0) {
          throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
        } else if (!detectedIndent) {
          textIndent = nodeIndent + tmp - 1;
          detectedIndent = true;
        } else {
          throwError(state, "repeat of an indentation width identifier");
        }
      } else {
        break;
      }
    }
    if (is_WHITE_SPACE(ch)) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (is_WHITE_SPACE(ch));
      if (ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (!is_EOL(ch) && ch !== 0);
      }
    }
    while (ch !== 0) {
      readLineBreak(state);
      state.lineIndent = 0;
      ch = state.input.charCodeAt(state.position);
      while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
      if (!detectedIndent && state.lineIndent > textIndent) {
        textIndent = state.lineIndent;
      }
      if (is_EOL(ch)) {
        emptyLines++;
        continue;
      }
      if (state.lineIndent < textIndent) {
        if (chomping === CHOMPING_KEEP) {
          state.result += common.repeat(`
`, didReadContent ? 1 + emptyLines : emptyLines);
        } else if (chomping === CHOMPING_CLIP) {
          if (didReadContent) {
            state.result += `
`;
          }
        }
        break;
      }
      if (folding) {
        if (is_WHITE_SPACE(ch)) {
          atMoreIndented = true;
          state.result += common.repeat(`
`, didReadContent ? 1 + emptyLines : emptyLines);
        } else if (atMoreIndented) {
          atMoreIndented = false;
          state.result += common.repeat(`
`, emptyLines + 1);
        } else if (emptyLines === 0) {
          if (didReadContent) {
            state.result += " ";
          }
        } else {
          state.result += common.repeat(`
`, emptyLines);
        }
      } else {
        state.result += common.repeat(`
`, didReadContent ? 1 + emptyLines : emptyLines);
      }
      didReadContent = true;
      detectedIndent = true;
      emptyLines = 0;
      captureStart = state.position;
      while (!is_EOL(ch) && ch !== 0) {
        ch = state.input.charCodeAt(++state.position);
      }
      captureSegment(state, captureStart, state.position, false);
    }
    return true;
  }
  function readBlockSequence(state, nodeIndent) {
    var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }
    ch = state.input.charCodeAt(state.position);
    while (ch !== 0) {
      if (ch !== 45) {
        break;
      }
      following = state.input.charCodeAt(state.position + 1);
      if (!is_WS_OR_EOL(following)) {
        break;
      }
      detected = true;
      state.position++;
      if (skipSeparationSpace(state, true, -1)) {
        if (state.lineIndent <= nodeIndent) {
          _result.push(null);
          ch = state.input.charCodeAt(state.position);
          continue;
        }
      }
      _line = state.line;
      composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
      _result.push(state.result);
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
      if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
        throwError(state, "bad indentation of a sequence entry");
      } else if (state.lineIndent < nodeIndent) {
        break;
      }
    }
    if (detected) {
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = "sequence";
      state.result = _result;
      return true;
    }
    return false;
  }
  function readBlockMapping(state, nodeIndent, flowIndent) {
    var following, allowCompact, _line, _pos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = {}, keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }
    ch = state.input.charCodeAt(state.position);
    while (ch !== 0) {
      following = state.input.charCodeAt(state.position + 1);
      _line = state.line;
      _pos = state.position;
      if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
        if (ch === 63) {
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = true;
          allowCompact = true;
        } else if (atExplicitKey) {
          atExplicitKey = false;
          allowCompact = true;
        } else {
          throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
        }
        state.position += 1;
        ch = following;
      } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
        if (state.line === _line) {
          ch = state.input.charCodeAt(state.position);
          while (is_WHITE_SPACE(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          if (ch === 58) {
            ch = state.input.charCodeAt(++state.position);
            if (!is_WS_OR_EOL(ch)) {
              throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
            }
            if (atExplicitKey) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
              keyTag = keyNode = valueNode = null;
            }
            detected = true;
            atExplicitKey = false;
            allowCompact = false;
            keyTag = state.tag;
            keyNode = state.result;
          } else if (detected) {
            throwError(state, "can not read an implicit mapping pair; a colon is missed");
          } else {
            state.tag = _tag;
            state.anchor = _anchor;
            return true;
          }
        } else if (detected) {
          throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true;
        }
      } else {
        break;
      }
      if (state.line === _line || state.lineIndent > nodeIndent) {
        if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
          if (atExplicitKey) {
            keyNode = state.result;
          } else {
            valueNode = state.result;
          }
        }
        if (!atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
          keyTag = keyNode = valueNode = null;
        }
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
      }
      if (state.lineIndent > nodeIndent && ch !== 0) {
        throwError(state, "bad indentation of a mapping entry");
      } else if (state.lineIndent < nodeIndent) {
        break;
      }
    }
    if (atExplicitKey) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
    }
    if (detected) {
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = "mapping";
      state.result = _result;
    }
    return detected;
  }
  function readTagProperty(state) {
    var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 33)
      return false;
    if (state.tag !== null) {
      throwError(state, "duplication of a tag property");
    }
    ch = state.input.charCodeAt(++state.position);
    if (ch === 60) {
      isVerbatim = true;
      ch = state.input.charCodeAt(++state.position);
    } else if (ch === 33) {
      isNamed = true;
      tagHandle = "!!";
      ch = state.input.charCodeAt(++state.position);
    } else {
      tagHandle = "!";
    }
    _position = state.position;
    if (isVerbatim) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 0 && ch !== 62);
      if (state.position < state.length) {
        tagName = state.input.slice(_position, state.position);
        ch = state.input.charCodeAt(++state.position);
      } else {
        throwError(state, "unexpected end of the stream within a verbatim tag");
      }
    } else {
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        if (ch === 33) {
          if (!isNamed) {
            tagHandle = state.input.slice(_position - 1, state.position + 1);
            if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
              throwError(state, "named tag handle cannot contain such characters");
            }
            isNamed = true;
            _position = state.position + 1;
          } else {
            throwError(state, "tag suffix cannot contain exclamation marks");
          }
        }
        ch = state.input.charCodeAt(++state.position);
      }
      tagName = state.input.slice(_position, state.position);
      if (PATTERN_FLOW_INDICATORS.test(tagName)) {
        throwError(state, "tag suffix cannot contain flow indicator characters");
      }
    }
    if (tagName && !PATTERN_TAG_URI.test(tagName)) {
      throwError(state, "tag name cannot contain such characters: " + tagName);
    }
    if (isVerbatim) {
      state.tag = tagName;
    } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
      state.tag = state.tagMap[tagHandle] + tagName;
    } else if (tagHandle === "!") {
      state.tag = "!" + tagName;
    } else if (tagHandle === "!!") {
      state.tag = "tag:yaml.org,2002:" + tagName;
    } else {
      throwError(state, 'undeclared tag handle "' + tagHandle + '"');
    }
    return true;
  }
  function readAnchorProperty(state) {
    var _position, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 38)
      return false;
    if (state.anchor !== null) {
      throwError(state, "duplication of an anchor property");
    }
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    if (state.position === _position) {
      throwError(state, "name of an anchor node must contain at least one character");
    }
    state.anchor = state.input.slice(_position, state.position);
    return true;
  }
  function readAlias(state) {
    var _position, alias, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 42)
      return false;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    if (state.position === _position) {
      throwError(state, "name of an alias node must contain at least one character");
    }
    alias = state.input.slice(_position, state.position);
    if (!_hasOwnProperty.call(state.anchorMap, alias)) {
      throwError(state, 'unidentified alias "' + alias + '"');
    }
    state.result = state.anchorMap[alias];
    skipSeparationSpace(state, true, -1);
    return true;
  }
  function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
    var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, type, flowIndent, blockIndent;
    if (state.listener !== null) {
      state.listener("open", state);
    }
    state.tag = null;
    state.anchor = null;
    state.kind = null;
    state.result = null;
    allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
    if (allowToSeek) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      }
    }
    if (indentStatus === 1) {
      while (readTagProperty(state) || readAnchorProperty(state)) {
        if (skipSeparationSpace(state, true, -1)) {
          atNewLine = true;
          allowBlockCollections = allowBlockStyles;
          if (state.lineIndent > parentIndent) {
            indentStatus = 1;
          } else if (state.lineIndent === parentIndent) {
            indentStatus = 0;
          } else if (state.lineIndent < parentIndent) {
            indentStatus = -1;
          }
        } else {
          allowBlockCollections = false;
        }
      }
    }
    if (allowBlockCollections) {
      allowBlockCollections = atNewLine || allowCompact;
    }
    if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
      if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
        flowIndent = parentIndent;
      } else {
        flowIndent = parentIndent + 1;
      }
      blockIndent = state.position - state.lineStart;
      if (indentStatus === 1) {
        if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
          hasContent = true;
        } else {
          if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
            hasContent = true;
          } else if (readAlias(state)) {
            hasContent = true;
            if (state.tag !== null || state.anchor !== null) {
              throwError(state, "alias node should not have any properties");
            }
          } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
            hasContent = true;
            if (state.tag === null) {
              state.tag = "?";
            }
          }
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
        }
      } else if (indentStatus === 0) {
        hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
      }
    }
    if (state.tag !== null && state.tag !== "!") {
      if (state.tag === "?") {
        if (state.result !== null && state.kind !== "scalar") {
          throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
        }
        for (typeIndex = 0, typeQuantity = state.implicitTypes.length;typeIndex < typeQuantity; typeIndex += 1) {
          type = state.implicitTypes[typeIndex];
          if (type.resolve(state.result)) {
            state.result = type.construct(state.result);
            state.tag = type.tag;
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = state.result;
            }
            break;
          }
        }
      } else if (_hasOwnProperty.call(state.typeMap[state.kind || "fallback"], state.tag)) {
        type = state.typeMap[state.kind || "fallback"][state.tag];
        if (state.result !== null && type.kind !== state.kind) {
          throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
        }
        if (!type.resolve(state.result)) {
          throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
        } else {
          state.result = type.construct(state.result);
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
        }
      } else {
        throwError(state, "unknown tag !<" + state.tag + ">");
      }
    }
    if (state.listener !== null) {
      state.listener("close", state);
    }
    return state.tag !== null || state.anchor !== null || hasContent;
  }
  function readDocument(state) {
    var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
    state.version = null;
    state.checkLineBreaks = state.legacy;
    state.tagMap = {};
    state.anchorMap = {};
    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
      if (state.lineIndent > 0 || ch !== 37) {
        break;
      }
      hasDirectives = true;
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      directiveName = state.input.slice(_position, state.position);
      directiveArgs = [];
      if (directiveName.length < 1) {
        throwError(state, "directive name must not be less than one character in length");
      }
      while (ch !== 0) {
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (ch === 35) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (ch !== 0 && !is_EOL(ch));
          break;
        }
        if (is_EOL(ch))
          break;
        _position = state.position;
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        directiveArgs.push(state.input.slice(_position, state.position));
      }
      if (ch !== 0)
        readLineBreak(state);
      if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
        directiveHandlers[directiveName](state, directiveName, directiveArgs);
      } else {
        throwWarning(state, 'unknown document directive "' + directiveName + '"');
      }
    }
    skipSeparationSpace(state, true, -1);
    if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    } else if (hasDirectives) {
      throwError(state, "directives end mark is expected");
    }
    composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
    skipSeparationSpace(state, true, -1);
    if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
      throwWarning(state, "non-ASCII line breaks are interpreted as content");
    }
    state.documents.push(state.result);
    if (state.position === state.lineStart && testDocumentSeparator(state)) {
      if (state.input.charCodeAt(state.position) === 46) {
        state.position += 3;
        skipSeparationSpace(state, true, -1);
      }
      return;
    }
    if (state.position < state.length - 1) {
      throwError(state, "end of the stream or a document separator is expected");
    } else {
      return;
    }
  }
  function loadDocuments(input, options2) {
    input = String(input);
    options2 = options2 || {};
    if (input.length !== 0) {
      if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
        input += `
`;
      }
      if (input.charCodeAt(0) === 65279) {
        input = input.slice(1);
      }
    }
    var state = new State(input, options2);
    var nullpos = input.indexOf("\x00");
    if (nullpos !== -1) {
      state.position = nullpos;
      throwError(state, "null byte is not allowed in input");
    }
    state.input += "\x00";
    while (state.input.charCodeAt(state.position) === 32) {
      state.lineIndent += 1;
      state.position += 1;
    }
    while (state.position < state.length - 1) {
      readDocument(state);
    }
    return state.documents;
  }
  function loadAll(input, iterator, options2) {
    if (iterator !== null && typeof iterator === "object" && typeof options2 === "undefined") {
      options2 = iterator;
      iterator = null;
    }
    var documents = loadDocuments(input, options2);
    if (typeof iterator !== "function") {
      return documents;
    }
    for (var index = 0, length = documents.length;index < length; index += 1) {
      iterator(documents[index]);
    }
  }
  function load(input, options2) {
    var documents = loadDocuments(input, options2);
    if (documents.length === 0) {
      return;
    } else if (documents.length === 1) {
      return documents[0];
    }
    throw new YAMLException("expected a single document in the stream, but found more");
  }
  function safeLoadAll(input, iterator, options2) {
    if (typeof iterator === "object" && iterator !== null && typeof options2 === "undefined") {
      options2 = iterator;
      iterator = null;
    }
    return loadAll(input, iterator, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options2));
  }
  function safeLoad(input, options2) {
    return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options2));
  }
  exports.loadAll = loadAll;
  exports.load = load;
  exports.safeLoadAll = safeLoadAll;
  exports.safeLoad = safeLoad;
});

// node_modules/js-yaml/lib/js-yaml/dumper.js
var require_dumper = __commonJS((exports, module) => {
  var common = require_common();
  var YAMLException = require_exception();
  var DEFAULT_FULL_SCHEMA = require_default_full();
  var DEFAULT_SAFE_SCHEMA = require_default_safe();
  var _toString = Object.prototype.toString;
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  var CHAR_TAB = 9;
  var CHAR_LINE_FEED = 10;
  var CHAR_CARRIAGE_RETURN = 13;
  var CHAR_SPACE = 32;
  var CHAR_EXCLAMATION = 33;
  var CHAR_DOUBLE_QUOTE = 34;
  var CHAR_SHARP = 35;
  var CHAR_PERCENT = 37;
  var CHAR_AMPERSAND = 38;
  var CHAR_SINGLE_QUOTE = 39;
  var CHAR_ASTERISK = 42;
  var CHAR_COMMA = 44;
  var CHAR_MINUS = 45;
  var CHAR_COLON = 58;
  var CHAR_EQUALS = 61;
  var CHAR_GREATER_THAN = 62;
  var CHAR_QUESTION = 63;
  var CHAR_COMMERCIAL_AT = 64;
  var CHAR_LEFT_SQUARE_BRACKET = 91;
  var CHAR_RIGHT_SQUARE_BRACKET = 93;
  var CHAR_GRAVE_ACCENT = 96;
  var CHAR_LEFT_CURLY_BRACKET = 123;
  var CHAR_VERTICAL_LINE = 124;
  var CHAR_RIGHT_CURLY_BRACKET = 125;
  var ESCAPE_SEQUENCES = {};
  ESCAPE_SEQUENCES[0] = "\\0";
  ESCAPE_SEQUENCES[7] = "\\a";
  ESCAPE_SEQUENCES[8] = "\\b";
  ESCAPE_SEQUENCES[9] = "\\t";
  ESCAPE_SEQUENCES[10] = "\\n";
  ESCAPE_SEQUENCES[11] = "\\v";
  ESCAPE_SEQUENCES[12] = "\\f";
  ESCAPE_SEQUENCES[13] = "\\r";
  ESCAPE_SEQUENCES[27] = "\\e";
  ESCAPE_SEQUENCES[34] = "\\\"";
  ESCAPE_SEQUENCES[92] = "\\\\";
  ESCAPE_SEQUENCES[133] = "\\N";
  ESCAPE_SEQUENCES[160] = "\\_";
  ESCAPE_SEQUENCES[8232] = "\\L";
  ESCAPE_SEQUENCES[8233] = "\\P";
  var DEPRECATED_BOOLEANS_SYNTAX = [
    "y",
    "Y",
    "yes",
    "Yes",
    "YES",
    "on",
    "On",
    "ON",
    "n",
    "N",
    "no",
    "No",
    "NO",
    "off",
    "Off",
    "OFF"
  ];
  function compileStyleMap(schema, map3) {
    var result, keys, index, length, tag, style, type;
    if (map3 === null)
      return {};
    result = {};
    keys = Object.keys(map3);
    for (index = 0, length = keys.length;index < length; index += 1) {
      tag = keys[index];
      style = String(map3[tag]);
      if (tag.slice(0, 2) === "!!") {
        tag = "tag:yaml.org,2002:" + tag.slice(2);
      }
      type = schema.compiledTypeMap["fallback"][tag];
      if (type && _hasOwnProperty.call(type.styleAliases, style)) {
        style = type.styleAliases[style];
      }
      result[tag] = style;
    }
    return result;
  }
  function encodeHex(character) {
    var string7, handle, length;
    string7 = character.toString(16).toUpperCase();
    if (character <= 255) {
      handle = "x";
      length = 2;
    } else if (character <= 65535) {
      handle = "u";
      length = 4;
    } else if (character <= 4294967295) {
      handle = "U";
      length = 8;
    } else {
      throw new YAMLException("code point within a string may not be greater than 0xFFFFFFFF");
    }
    return "\\" + handle + common.repeat("0", length - string7.length) + string7;
  }
  function State(options2) {
    this.schema = options2["schema"] || DEFAULT_FULL_SCHEMA;
    this.indent = Math.max(1, options2["indent"] || 2);
    this.noArrayIndent = options2["noArrayIndent"] || false;
    this.skipInvalid = options2["skipInvalid"] || false;
    this.flowLevel = common.isNothing(options2["flowLevel"]) ? -1 : options2["flowLevel"];
    this.styleMap = compileStyleMap(this.schema, options2["styles"] || null);
    this.sortKeys = options2["sortKeys"] || false;
    this.lineWidth = options2["lineWidth"] || 80;
    this.noRefs = options2["noRefs"] || false;
    this.noCompatMode = options2["noCompatMode"] || false;
    this.condenseFlow = options2["condenseFlow"] || false;
    this.implicitTypes = this.schema.compiledImplicit;
    this.explicitTypes = this.schema.compiledExplicit;
    this.tag = null;
    this.result = "";
    this.duplicates = [];
    this.usedDuplicates = null;
  }
  function indentString(string7, spaces) {
    var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string7.length;
    while (position < length) {
      next = string7.indexOf(`
`, position);
      if (next === -1) {
        line = string7.slice(position);
        position = length;
      } else {
        line = string7.slice(position, next + 1);
        position = next + 1;
      }
      if (line.length && line !== `
`)
        result += ind;
      result += line;
    }
    return result;
  }
  function generateNextLine(state, level) {
    return `
` + common.repeat(" ", state.indent * level);
  }
  function testImplicitResolving(state, str2) {
    var index, length, type;
    for (index = 0, length = state.implicitTypes.length;index < length; index += 1) {
      type = state.implicitTypes[index];
      if (type.resolve(str2)) {
        return true;
      }
    }
    return false;
  }
  function isWhitespace(c) {
    return c === CHAR_SPACE || c === CHAR_TAB;
  }
  function isPrintable(c) {
    return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== 65279 || 65536 <= c && c <= 1114111;
  }
  function isNsChar(c) {
    return isPrintable(c) && !isWhitespace(c) && c !== 65279 && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
  }
  function isPlainSafe(c, prev) {
    return isPrintable(c) && c !== 65279 && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_COLON && (c !== CHAR_SHARP || prev && isNsChar(prev));
  }
  function isPlainSafeFirst(c) {
    return isPrintable(c) && c !== 65279 && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
  }
  function needIndentIndicator(string7) {
    var leadingSpaceRe = /^\n* /;
    return leadingSpaceRe.test(string7);
  }
  var STYLE_PLAIN = 1;
  var STYLE_SINGLE = 2;
  var STYLE_LITERAL = 3;
  var STYLE_FOLDED = 4;
  var STYLE_DOUBLE = 5;
  function chooseScalarStyle(string7, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
    var i;
    var char, prev_char;
    var hasLineBreak = false;
    var hasFoldableLine = false;
    var shouldTrackWidth = lineWidth !== -1;
    var previousLineBreak = -1;
    var plain = isPlainSafeFirst(string7.charCodeAt(0)) && !isWhitespace(string7.charCodeAt(string7.length - 1));
    if (singleLineOnly) {
      for (i = 0;i < string7.length; i++) {
        char = string7.charCodeAt(i);
        if (!isPrintable(char)) {
          return STYLE_DOUBLE;
        }
        prev_char = i > 0 ? string7.charCodeAt(i - 1) : null;
        plain = plain && isPlainSafe(char, prev_char);
      }
    } else {
      for (i = 0;i < string7.length; i++) {
        char = string7.charCodeAt(i);
        if (char === CHAR_LINE_FEED) {
          hasLineBreak = true;
          if (shouldTrackWidth) {
            hasFoldableLine = hasFoldableLine || i - previousLineBreak - 1 > lineWidth && string7[previousLineBreak + 1] !== " ";
            previousLineBreak = i;
          }
        } else if (!isPrintable(char)) {
          return STYLE_DOUBLE;
        }
        prev_char = i > 0 ? string7.charCodeAt(i - 1) : null;
        plain = plain && isPlainSafe(char, prev_char);
      }
      hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string7[previousLineBreak + 1] !== " ");
    }
    if (!hasLineBreak && !hasFoldableLine) {
      return plain && !testAmbiguousType(string7) ? STYLE_PLAIN : STYLE_SINGLE;
    }
    if (indentPerLevel > 9 && needIndentIndicator(string7)) {
      return STYLE_DOUBLE;
    }
    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }
  function writeScalar(state, string7, level, iskey) {
    state.dump = function() {
      if (string7.length === 0) {
        return "''";
      }
      if (!state.noCompatMode && DEPRECATED_BOOLEANS_SYNTAX.indexOf(string7) !== -1) {
        return "'" + string7 + "'";
      }
      var indent = state.indent * Math.max(1, level);
      var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
      var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
      function testAmbiguity(string8) {
        return testImplicitResolving(state, string8);
      }
      switch (chooseScalarStyle(string7, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
        case STYLE_PLAIN:
          return string7;
        case STYLE_SINGLE:
          return "'" + string7.replace(/'/g, "''") + "'";
        case STYLE_LITERAL:
          return "|" + blockHeader(string7, state.indent) + dropEndingNewline(indentString(string7, indent));
        case STYLE_FOLDED:
          return ">" + blockHeader(string7, state.indent) + dropEndingNewline(indentString(foldString(string7, lineWidth), indent));
        case STYLE_DOUBLE:
          return '"' + escapeString(string7, lineWidth) + '"';
        default:
          throw new YAMLException("impossible error: invalid scalar style");
      }
    }();
  }
  function blockHeader(string7, indentPerLevel) {
    var indentIndicator = needIndentIndicator(string7) ? String(indentPerLevel) : "";
    var clip = string7[string7.length - 1] === `
`;
    var keep = clip && (string7[string7.length - 2] === `
` || string7 === `
`);
    var chomp = keep ? "+" : clip ? "" : "-";
    return indentIndicator + chomp + `
`;
  }
  function dropEndingNewline(string7) {
    return string7[string7.length - 1] === `
` ? string7.slice(0, -1) : string7;
  }
  function foldString(string7, width) {
    var lineRe = /(\n+)([^\n]*)/g;
    var result = function() {
      var nextLF = string7.indexOf(`
`);
      nextLF = nextLF !== -1 ? nextLF : string7.length;
      lineRe.lastIndex = nextLF;
      return foldLine(string7.slice(0, nextLF), width);
    }();
    var prevMoreIndented = string7[0] === `
` || string7[0] === " ";
    var moreIndented;
    var match;
    while (match = lineRe.exec(string7)) {
      var prefix = match[1], line = match[2];
      moreIndented = line[0] === " ";
      result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? `
` : "") + foldLine(line, width);
      prevMoreIndented = moreIndented;
    }
    return result;
  }
  function foldLine(line, width) {
    if (line === "" || line[0] === " ")
      return line;
    var breakRe = / [^ ]/g;
    var match;
    var start = 0, end, curr = 0, next = 0;
    var result = "";
    while (match = breakRe.exec(line)) {
      next = match.index;
      if (next - start > width) {
        end = curr > start ? curr : next;
        result += `
` + line.slice(start, end);
        start = end + 1;
      }
      curr = next;
    }
    result += `
`;
    if (line.length - start > width && curr > start) {
      result += line.slice(start, curr) + `
` + line.slice(curr + 1);
    } else {
      result += line.slice(start);
    }
    return result.slice(1);
  }
  function escapeString(string7) {
    var result = "";
    var char, nextChar;
    var escapeSeq;
    for (var i = 0;i < string7.length; i++) {
      char = string7.charCodeAt(i);
      if (char >= 55296 && char <= 56319) {
        nextChar = string7.charCodeAt(i + 1);
        if (nextChar >= 56320 && nextChar <= 57343) {
          result += encodeHex((char - 55296) * 1024 + nextChar - 56320 + 65536);
          i++;
          continue;
        }
      }
      escapeSeq = ESCAPE_SEQUENCES[char];
      result += !escapeSeq && isPrintable(char) ? string7[i] : escapeSeq || encodeHex(char);
    }
    return result;
  }
  function writeFlowSequence(state, level, object5) {
    var _result = "", _tag = state.tag, index, length;
    for (index = 0, length = object5.length;index < length; index += 1) {
      if (writeNode(state, level, object5[index], false, false)) {
        if (index !== 0)
          _result += "," + (!state.condenseFlow ? " " : "");
        _result += state.dump;
      }
    }
    state.tag = _tag;
    state.dump = "[" + _result + "]";
  }
  function writeBlockSequence(state, level, object5, compact) {
    var _result = "", _tag = state.tag, index, length;
    for (index = 0, length = object5.length;index < length; index += 1) {
      if (writeNode(state, level + 1, object5[index], true, true)) {
        if (!compact || index !== 0) {
          _result += generateNextLine(state, level);
        }
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          _result += "-";
        } else {
          _result += "- ";
        }
        _result += state.dump;
      }
    }
    state.tag = _tag;
    state.dump = _result || "[]";
  }
  function writeFlowMapping(state, level, object5) {
    var _result = "", _tag = state.tag, objectKeyList = Object.keys(object5), index, length, objectKey, objectValue, pairBuffer;
    for (index = 0, length = objectKeyList.length;index < length; index += 1) {
      pairBuffer = "";
      if (index !== 0)
        pairBuffer += ", ";
      if (state.condenseFlow)
        pairBuffer += '"';
      objectKey = objectKeyList[index];
      objectValue = object5[objectKey];
      if (!writeNode(state, level, objectKey, false, false)) {
        continue;
      }
      if (state.dump.length > 1024)
        pairBuffer += "? ";
      pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
      if (!writeNode(state, level, objectValue, false, false)) {
        continue;
      }
      pairBuffer += state.dump;
      _result += pairBuffer;
    }
    state.tag = _tag;
    state.dump = "{" + _result + "}";
  }
  function writeBlockMapping(state, level, object5, compact) {
    var _result = "", _tag = state.tag, objectKeyList = Object.keys(object5), index, length, objectKey, objectValue, explicitPair, pairBuffer;
    if (state.sortKeys === true) {
      objectKeyList.sort();
    } else if (typeof state.sortKeys === "function") {
      objectKeyList.sort(state.sortKeys);
    } else if (state.sortKeys) {
      throw new YAMLException("sortKeys must be a boolean or a function");
    }
    for (index = 0, length = objectKeyList.length;index < length; index += 1) {
      pairBuffer = "";
      if (!compact || index !== 0) {
        pairBuffer += generateNextLine(state, level);
      }
      objectKey = objectKeyList[index];
      objectValue = object5[objectKey];
      if (!writeNode(state, level + 1, objectKey, true, true, true)) {
        continue;
      }
      explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
      if (explicitPair) {
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          pairBuffer += "?";
        } else {
          pairBuffer += "? ";
        }
      }
      pairBuffer += state.dump;
      if (explicitPair) {
        pairBuffer += generateNextLine(state, level);
      }
      if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
        continue;
      }
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += ":";
      } else {
        pairBuffer += ": ";
      }
      pairBuffer += state.dump;
      _result += pairBuffer;
    }
    state.tag = _tag;
    state.dump = _result || "{}";
  }
  function detectType(state, object5, explicit) {
    var _result, typeList, index, length, type, style;
    typeList = explicit ? state.explicitTypes : state.implicitTypes;
    for (index = 0, length = typeList.length;index < length; index += 1) {
      type = typeList[index];
      if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object5 === "object" && object5 instanceof type.instanceOf) && (!type.predicate || type.predicate(object5))) {
        state.tag = explicit ? type.tag : "?";
        if (type.represent) {
          style = state.styleMap[type.tag] || type.defaultStyle;
          if (_toString.call(type.represent) === "[object Function]") {
            _result = type.represent(object5, style);
          } else if (_hasOwnProperty.call(type.represent, style)) {
            _result = type.represent[style](object5, style);
          } else {
            throw new YAMLException("!<" + type.tag + '> tag resolver accepts not "' + style + '" style');
          }
          state.dump = _result;
        }
        return true;
      }
    }
    return false;
  }
  function writeNode(state, level, object5, block, compact, iskey) {
    state.tag = null;
    state.dump = object5;
    if (!detectType(state, object5, false)) {
      detectType(state, object5, true);
    }
    var type = _toString.call(state.dump);
    if (block) {
      block = state.flowLevel < 0 || state.flowLevel > level;
    }
    var objectOrArray = type === "[object Object]" || type === "[object Array]", duplicateIndex, duplicate;
    if (objectOrArray) {
      duplicateIndex = state.duplicates.indexOf(object5);
      duplicate = duplicateIndex !== -1;
    }
    if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
      compact = false;
    }
    if (duplicate && state.usedDuplicates[duplicateIndex]) {
      state.dump = "*ref_" + duplicateIndex;
    } else {
      if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
        state.usedDuplicates[duplicateIndex] = true;
      }
      if (type === "[object Object]") {
        if (block && Object.keys(state.dump).length !== 0) {
          writeBlockMapping(state, level, state.dump, compact);
          if (duplicate) {
            state.dump = "&ref_" + duplicateIndex + state.dump;
          }
        } else {
          writeFlowMapping(state, level, state.dump);
          if (duplicate) {
            state.dump = "&ref_" + duplicateIndex + " " + state.dump;
          }
        }
      } else if (type === "[object Array]") {
        var arrayLevel = state.noArrayIndent && level > 0 ? level - 1 : level;
        if (block && state.dump.length !== 0) {
          writeBlockSequence(state, arrayLevel, state.dump, compact);
          if (duplicate) {
            state.dump = "&ref_" + duplicateIndex + state.dump;
          }
        } else {
          writeFlowSequence(state, arrayLevel, state.dump);
          if (duplicate) {
            state.dump = "&ref_" + duplicateIndex + " " + state.dump;
          }
        }
      } else if (type === "[object String]") {
        if (state.tag !== "?") {
          writeScalar(state, state.dump, level, iskey);
        }
      } else {
        if (state.skipInvalid)
          return false;
        throw new YAMLException("unacceptable kind of an object to dump " + type);
      }
      if (state.tag !== null && state.tag !== "?") {
        state.dump = "!<" + state.tag + "> " + state.dump;
      }
    }
    return true;
  }
  function getDuplicateReferences(object5, state) {
    var objects = [], duplicatesIndexes = [], index, length;
    inspectNode(object5, objects, duplicatesIndexes);
    for (index = 0, length = duplicatesIndexes.length;index < length; index += 1) {
      state.duplicates.push(objects[duplicatesIndexes[index]]);
    }
    state.usedDuplicates = new Array(length);
  }
  function inspectNode(object5, objects, duplicatesIndexes) {
    var objectKeyList, index, length;
    if (object5 !== null && typeof object5 === "object") {
      index = objects.indexOf(object5);
      if (index !== -1) {
        if (duplicatesIndexes.indexOf(index) === -1) {
          duplicatesIndexes.push(index);
        }
      } else {
        objects.push(object5);
        if (Array.isArray(object5)) {
          for (index = 0, length = object5.length;index < length; index += 1) {
            inspectNode(object5[index], objects, duplicatesIndexes);
          }
        } else {
          objectKeyList = Object.keys(object5);
          for (index = 0, length = objectKeyList.length;index < length; index += 1) {
            inspectNode(object5[objectKeyList[index]], objects, duplicatesIndexes);
          }
        }
      }
    }
  }
  function dump(input, options2) {
    options2 = options2 || {};
    var state = new State(options2);
    if (!state.noRefs)
      getDuplicateReferences(input, state);
    if (writeNode(state, 0, input, true, true))
      return state.dump + `
`;
    return "";
  }
  function safeDump(input, options2) {
    return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options2));
  }
  exports.dump = dump;
  exports.safeDump = safeDump;
});

// node_modules/js-yaml/lib/js-yaml.js
var require_js_yaml = __commonJS((exports, module) => {
  var loader = require_loader();
  var dumper = require_dumper();
  function deprecated(name) {
    return function() {
      throw new Error("Function " + name + " is deprecated and cannot be used.");
    };
  }
  exports.Type = require_type();
  exports.Schema = require_schema();
  exports.FAILSAFE_SCHEMA = require_failsafe();
  exports.JSON_SCHEMA = require_json();
  exports.CORE_SCHEMA = require_core3();
  exports.DEFAULT_SAFE_SCHEMA = require_default_safe();
  exports.DEFAULT_FULL_SCHEMA = require_default_full();
  exports.load = loader.load;
  exports.loadAll = loader.loadAll;
  exports.safeLoad = loader.safeLoad;
  exports.safeLoadAll = loader.safeLoadAll;
  exports.dump = dumper.dump;
  exports.safeDump = dumper.safeDump;
  exports.YAMLException = require_exception();
  exports.MINIMAL_SCHEMA = require_failsafe();
  exports.SAFE_SCHEMA = require_default_safe();
  exports.DEFAULT_SCHEMA = require_default_full();
  exports.scan = deprecated("scan");
  exports.parse = deprecated("parse");
  exports.compose = deprecated("compose");
  exports.addConstructor = deprecated("addConstructor");
});

// node_modules/js-yaml/index.js
var require_js_yaml2 = __commonJS((exports, module) => {
  var yaml = require_js_yaml();
  module.exports = yaml;
});

// node_modules/gray-matter/lib/engines.js
var require_engines = __commonJS((exports, module) => {
  var yaml = require_js_yaml2();
  var engines = exports = module.exports;
  engines.yaml = {
    parse: yaml.safeLoad.bind(yaml),
    stringify: yaml.safeDump.bind(yaml)
  };
  engines.json = {
    parse: JSON.parse.bind(JSON),
    stringify: function(obj, options2) {
      const opts = Object.assign({ replacer: null, space: 2 }, options2);
      return JSON.stringify(obj, opts.replacer, opts.space);
    }
  };
  engines.javascript = {
    parse: function parse(str, options, wrap) {
      try {
        if (wrap !== false) {
          str = `(function() {
return ` + str.trim() + `;
}());`;
        }
        return eval(str) || {};
      } catch (err) {
        if (wrap !== false && /(unexpected|identifier)/i.test(err.message)) {
          return parse(str, options, false);
        }
        throw new SyntaxError(err);
      }
    },
    stringify: function() {
      throw new Error("stringifying JavaScript is not supported");
    }
  };
});

// node_modules/strip-bom-string/index.js
var require_strip_bom_string = __commonJS((exports, module) => {
  /*!
   * strip-bom-string <https://github.com/jonschlinkert/strip-bom-string>
   *
   * Copyright (c) 2015, 2017, Jon Schlinkert.
   * Released under the MIT License.
   */
  module.exports = function(str2) {
    if (typeof str2 === "string" && str2.charAt(0) === "\uFEFF") {
      return str2.slice(1);
    }
    return str2;
  };
});

// node_modules/gray-matter/lib/utils.js
var require_utils2 = __commonJS((exports) => {
  var stripBom = require_strip_bom_string();
  var typeOf = require_kind_of();
  exports.define = function(obj, key, val) {
    Reflect.defineProperty(obj, key, {
      enumerable: false,
      configurable: true,
      writable: true,
      value: val
    });
  };
  exports.isBuffer = function(val) {
    return typeOf(val) === "buffer";
  };
  exports.isObject = function(val) {
    return typeOf(val) === "object";
  };
  exports.toBuffer = function(input) {
    return typeof input === "string" ? Buffer.from(input) : input;
  };
  exports.toString = function(input) {
    if (exports.isBuffer(input))
      return stripBom(String(input));
    if (typeof input !== "string") {
      throw new TypeError("expected input to be a string or buffer");
    }
    return stripBom(input);
  };
  exports.arrayify = function(val) {
    return val ? Array.isArray(val) ? val : [val] : [];
  };
  exports.startsWith = function(str2, substr, len) {
    if (typeof len !== "number")
      len = substr.length;
    return str2.slice(0, len) === substr;
  };
});

// node_modules/gray-matter/lib/defaults.js
var require_defaults2 = __commonJS((exports, module) => {
  var engines = require_engines();
  var utils = require_utils2();
  module.exports = function(options2) {
    const opts = Object.assign({}, options2);
    opts.delimiters = utils.arrayify(opts.delims || opts.delimiters || "---");
    if (opts.delimiters.length === 1) {
      opts.delimiters.push(opts.delimiters[0]);
    }
    opts.language = (opts.language || opts.lang || "yaml").toLowerCase();
    opts.engines = Object.assign({}, engines, opts.parsers, opts.engines);
    return opts;
  };
});

// node_modules/gray-matter/lib/engine.js
var require_engine = __commonJS((exports, module) => {
  module.exports = function(name, options2) {
    let engine = options2.engines[name] || options2.engines[aliase(name)];
    if (typeof engine === "undefined") {
      throw new Error('gray-matter engine "' + name + '" is not registered');
    }
    if (typeof engine === "function") {
      engine = { parse: engine };
    }
    return engine;
  };
  function aliase(name) {
    switch (name.toLowerCase()) {
      case "js":
      case "javascript":
        return "javascript";
      case "coffee":
      case "coffeescript":
      case "cson":
        return "coffee";
      case "yaml":
      case "yml":
        return "yaml";
      default: {
        return name;
      }
    }
  }
});

// node_modules/gray-matter/lib/stringify.js
var require_stringify = __commonJS((exports, module) => {
  var typeOf = require_kind_of();
  var getEngine = require_engine();
  var defaults = require_defaults2();
  module.exports = function(file2, data, options2) {
    if (data == null && options2 == null) {
      switch (typeOf(file2)) {
        case "object":
          data = file2.data;
          options2 = {};
          break;
        case "string":
          return file2;
        default: {
          throw new TypeError("expected file to be a string or object");
        }
      }
    }
    const str2 = file2.content;
    const opts = defaults(options2);
    if (data == null) {
      if (!opts.data)
        return file2;
      data = opts.data;
    }
    const language = file2.language || opts.language;
    const engine = getEngine(language, opts);
    if (typeof engine.stringify !== "function") {
      throw new TypeError('expected "' + language + '.stringify" to be a function');
    }
    data = Object.assign({}, file2.data, data);
    const open = opts.delimiters[0];
    const close = opts.delimiters[1];
    const matter = engine.stringify(data, options2).trim();
    let buf = "";
    if (matter !== "{}") {
      buf = newline(open) + newline(matter) + newline(close);
    }
    if (typeof file2.excerpt === "string" && file2.excerpt !== "") {
      if (str2.indexOf(file2.excerpt.trim()) === -1) {
        buf += newline(file2.excerpt) + newline(close);
      }
    }
    return buf + newline(str2);
  };
  function newline(str2) {
    return str2.slice(-1) !== `
` ? str2 + `
` : str2;
  }
});

// node_modules/gray-matter/lib/excerpt.js
var require_excerpt = __commonJS((exports, module) => {
  var defaults = require_defaults2();
  module.exports = function(file2, options2) {
    const opts = defaults(options2);
    if (file2.data == null) {
      file2.data = {};
    }
    if (typeof opts.excerpt === "function") {
      return opts.excerpt(file2, opts);
    }
    const sep = file2.data.excerpt_separator || opts.excerpt_separator;
    if (sep == null && (opts.excerpt === false || opts.excerpt == null)) {
      return file2;
    }
    const delimiter = typeof opts.excerpt === "string" ? opts.excerpt : sep || opts.delimiters[0];
    const idx = file2.content.indexOf(delimiter);
    if (idx !== -1) {
      file2.excerpt = file2.content.slice(0, idx);
    }
    return file2;
  };
});

// node_modules/gray-matter/lib/to-file.js
var require_to_file = __commonJS((exports, module) => {
  var typeOf = require_kind_of();
  var stringify = require_stringify();
  var utils = require_utils2();
  module.exports = function(file2) {
    if (typeOf(file2) !== "object") {
      file2 = { content: file2 };
    }
    if (typeOf(file2.data) !== "object") {
      file2.data = {};
    }
    if (file2.contents && file2.content == null) {
      file2.content = file2.contents;
    }
    utils.define(file2, "orig", utils.toBuffer(file2.content));
    utils.define(file2, "language", file2.language || "");
    utils.define(file2, "matter", file2.matter || "");
    utils.define(file2, "stringify", function(data, options2) {
      if (options2 && options2.language) {
        file2.language = options2.language;
      }
      return stringify(file2, data, options2);
    });
    file2.content = utils.toString(file2.content);
    file2.isEmpty = false;
    file2.excerpt = "";
    return file2;
  };
});

// node_modules/gray-matter/lib/parse.js
var require_parse3 = __commonJS((exports, module) => {
  var getEngine = require_engine();
  var defaults = require_defaults2();
  module.exports = function(language, str2, options2) {
    const opts = defaults(options2);
    const engine = getEngine(language, opts);
    if (typeof engine.parse !== "function") {
      throw new TypeError('expected "' + language + '.parse" to be a function');
    }
    return engine.parse(str2, opts);
  };
});

// node_modules/gray-matter/index.js
var require_gray_matter = __commonJS((exports, module) => {
  var fs3 = __require("fs");
  var sections = require_section_matter();
  var defaults = require_defaults2();
  var stringify = require_stringify();
  var excerpt = require_excerpt();
  var engines = require_engines();
  var toFile = require_to_file();
  var parse11 = require_parse3();
  var utils = require_utils2();
  function matter(input, options2) {
    if (input === "") {
      return { data: {}, content: input, excerpt: "", orig: input };
    }
    let file2 = toFile(input);
    const cached3 = matter.cache[file2.content];
    if (!options2) {
      if (cached3) {
        file2 = Object.assign({}, cached3);
        file2.orig = cached3.orig;
        return file2;
      }
      matter.cache[file2.content] = file2;
    }
    return parseMatter(file2, options2);
  }
  function parseMatter(file2, options2) {
    const opts = defaults(options2);
    const open = opts.delimiters[0];
    const close = `
` + opts.delimiters[1];
    let str2 = file2.content;
    if (opts.language) {
      file2.language = opts.language;
    }
    const openLen = open.length;
    if (!utils.startsWith(str2, open, openLen)) {
      excerpt(file2, opts);
      return file2;
    }
    if (str2.charAt(openLen) === open.slice(-1)) {
      return file2;
    }
    str2 = str2.slice(openLen);
    const len = str2.length;
    const language = matter.language(str2, opts);
    if (language.name) {
      file2.language = language.name;
      str2 = str2.slice(language.raw.length);
    }
    let closeIndex = str2.indexOf(close);
    if (closeIndex === -1) {
      closeIndex = len;
    }
    file2.matter = str2.slice(0, closeIndex);
    const block = file2.matter.replace(/^\s*#[^\n]+/gm, "").trim();
    if (block === "") {
      file2.isEmpty = true;
      file2.empty = file2.content;
      file2.data = {};
    } else {
      file2.data = parse11(file2.language, file2.matter, opts);
    }
    if (closeIndex === len) {
      file2.content = "";
    } else {
      file2.content = str2.slice(closeIndex + close.length);
      if (file2.content[0] === "\r") {
        file2.content = file2.content.slice(1);
      }
      if (file2.content[0] === `
`) {
        file2.content = file2.content.slice(1);
      }
    }
    excerpt(file2, opts);
    if (opts.sections === true || typeof opts.section === "function") {
      sections(file2, opts.section);
    }
    return file2;
  }
  matter.engines = engines;
  matter.stringify = function(file2, data, options2) {
    if (typeof file2 === "string")
      file2 = matter(file2, options2);
    return stringify(file2, data, options2);
  };
  matter.read = function(filepath, options2) {
    const str2 = fs3.readFileSync(filepath, "utf8");
    const file2 = matter(str2, options2);
    file2.path = filepath;
    return file2;
  };
  matter.test = function(str2, options2) {
    return utils.startsWith(str2, defaults(options2).delimiters[0]);
  };
  matter.language = function(str2, options2) {
    const opts = defaults(options2);
    const open = opts.delimiters[0];
    if (matter.test(str2)) {
      str2 = str2.slice(open.length);
    }
    const language = str2.slice(0, str2.search(/\r?\n/));
    return {
      raw: language,
      name: language ? language.trim() : ""
    };
  };
  matter.cache = {};
  matter.clearCache = function() {
    matter.cache = {};
  };
  module.exports = matter;
});

// node_modules/graphology-utils/defaults.js
var require_defaults3 = __commonJS((exports, module) => {
  function isLeaf(o) {
    return !o || typeof o !== "object" || typeof o === "function" || Array.isArray(o) || o instanceof Set || o instanceof Map || o instanceof RegExp || o instanceof Date;
  }
  function resolveDefaults(target, defaults) {
    target = target || {};
    var output = {};
    for (var k in defaults) {
      var existing = target[k];
      var def = defaults[k];
      if (!isLeaf(def)) {
        output[k] = resolveDefaults(existing, def);
        continue;
      }
      if (existing === undefined) {
        output[k] = def;
      } else {
        output[k] = existing;
      }
    }
    return output;
  }
  module.exports = resolveDefaults;
});

// node_modules/graphology-utils/is-graph.js
var require_is_graph = __commonJS((exports, module) => {
  module.exports = function isGraph(value) {
    return value !== null && typeof value === "object" && typeof value.addUndirectedEdgeWithKey === "function" && typeof value.dropNode === "function" && typeof value.multi === "boolean";
  };
});

// node_modules/graphology-utils/infer-type.js
var require_infer_type = __commonJS((exports, module) => {
  var isGraph = require_is_graph();
  module.exports = function inferType(graph) {
    if (!isGraph(graph))
      throw new Error("graphology-utils/infer-type: expecting a valid graphology instance.");
    var declaredType = graph.type;
    if (declaredType !== "mixed")
      return declaredType;
    if (graph.directedSize === 0 && graph.undirectedSize === 0 || graph.directedSize > 0 && graph.undirectedSize > 0)
      return "mixed";
    if (graph.directedSize > 0)
      return "directed";
    return "undirected";
  };
});

// node_modules/obliterator/iterator.js
var require_iterator2 = __commonJS((exports, module) => {
  function Iterator(next) {
    if (typeof next !== "function")
      throw new Error("obliterator/iterator: expecting a function!");
    this.next = next;
  }
  if (typeof Symbol !== "undefined")
    Iterator.prototype[Symbol.iterator] = function() {
      return this;
    };
  Iterator.of = function() {
    var args = arguments, l = args.length, i = 0;
    return new Iterator(function() {
      if (i >= l)
        return { done: true };
      return { done: false, value: args[i++] };
    });
  };
  Iterator.empty = function() {
    var iterator = new Iterator(function() {
      return { done: true };
    });
    return iterator;
  };
  Iterator.fromSequence = function(sequence) {
    var i = 0, l = sequence.length;
    return new Iterator(function() {
      if (i >= l)
        return { done: true };
      return { done: false, value: sequence[i++] };
    });
  };
  Iterator.is = function(value) {
    if (value instanceof Iterator)
      return true;
    return typeof value === "object" && value !== null && typeof value.next === "function";
  };
  module.exports = Iterator;
});

// node_modules/mnemonist/utils/typed-arrays.js
var require_typed_arrays = __commonJS((exports) => {
  var MAX_8BIT_INTEGER = Math.pow(2, 8) - 1;
  var MAX_16BIT_INTEGER = Math.pow(2, 16) - 1;
  var MAX_32BIT_INTEGER = Math.pow(2, 32) - 1;
  var MAX_SIGNED_8BIT_INTEGER = Math.pow(2, 7) - 1;
  var MAX_SIGNED_16BIT_INTEGER = Math.pow(2, 15) - 1;
  var MAX_SIGNED_32BIT_INTEGER = Math.pow(2, 31) - 1;
  exports.getPointerArray = function(size) {
    var maxIndex = size - 1;
    if (maxIndex <= MAX_8BIT_INTEGER)
      return Uint8Array;
    if (maxIndex <= MAX_16BIT_INTEGER)
      return Uint16Array;
    if (maxIndex <= MAX_32BIT_INTEGER)
      return Uint32Array;
    throw new Error("mnemonist: Pointer Array of size > 4294967295 is not supported.");
  };
  exports.getSignedPointerArray = function(size) {
    var maxIndex = size - 1;
    if (maxIndex <= MAX_SIGNED_8BIT_INTEGER)
      return Int8Array;
    if (maxIndex <= MAX_SIGNED_16BIT_INTEGER)
      return Int16Array;
    if (maxIndex <= MAX_SIGNED_32BIT_INTEGER)
      return Int32Array;
    return Float64Array;
  };
  exports.getNumberType = function(value) {
    if (value === (value | 0)) {
      if (Math.sign(value) === -1) {
        if (value <= 127 && value >= -128)
          return Int8Array;
        if (value <= 32767 && value >= -32768)
          return Int16Array;
        return Int32Array;
      } else {
        if (value <= 255)
          return Uint8Array;
        if (value <= 65535)
          return Uint16Array;
        return Uint32Array;
      }
    }
    return Float64Array;
  };
  var TYPE_PRIORITY = {
    Uint8Array: 1,
    Int8Array: 2,
    Uint16Array: 3,
    Int16Array: 4,
    Uint32Array: 5,
    Int32Array: 6,
    Float32Array: 7,
    Float64Array: 8
  };
  exports.getMinimalRepresentation = function(array4, getter) {
    var maxType = null, maxPriority = 0, p, t, v, i, l;
    for (i = 0, l = array4.length;i < l; i++) {
      v = getter ? getter(array4[i]) : array4[i];
      t = exports.getNumberType(v);
      p = TYPE_PRIORITY[t.name];
      if (p > maxPriority) {
        maxPriority = p;
        maxType = t;
      }
    }
    return maxType;
  };
  exports.isTypedArray = function(value) {
    return typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView(value);
  };
  exports.concat = function() {
    var length = 0, i, o, l;
    for (i = 0, l = arguments.length;i < l; i++)
      length += arguments[i].length;
    var array4 = new arguments[0].constructor(length);
    for (i = 0, o = 0;i < l; i++) {
      array4.set(arguments[i], o);
      o += arguments[i].length;
    }
    return array4;
  };
  exports.indices = function(length) {
    var PointerArray = exports.getPointerArray(length);
    var array4 = new PointerArray(length);
    for (var i = 0;i < length; i++)
      array4[i] = i;
    return array4;
  };
});

// node_modules/mnemonist/sparse-map.js
var require_sparse_map = __commonJS((exports, module) => {
  var Iterator = require_iterator2();
  var getPointerArray = require_typed_arrays().getPointerArray;
  function SparseMap(Values, length) {
    if (arguments.length < 2) {
      length = Values;
      Values = Array;
    }
    var ByteArray = getPointerArray(length);
    this.size = 0;
    this.length = length;
    this.dense = new ByteArray(length);
    this.sparse = new ByteArray(length);
    this.vals = new Values(length);
  }
  SparseMap.prototype.clear = function() {
    this.size = 0;
  };
  SparseMap.prototype.has = function(member) {
    var index = this.sparse[member];
    return index < this.size && this.dense[index] === member;
  };
  SparseMap.prototype.get = function(member) {
    var index = this.sparse[member];
    if (index < this.size && this.dense[index] === member)
      return this.vals[index];
    return;
  };
  SparseMap.prototype.set = function(member, value) {
    var index = this.sparse[member];
    if (index < this.size && this.dense[index] === member) {
      this.vals[index] = value;
      return this;
    }
    this.dense[this.size] = member;
    this.sparse[member] = this.size;
    this.vals[this.size] = value;
    this.size++;
    return this;
  };
  SparseMap.prototype.delete = function(member) {
    var index = this.sparse[member];
    if (index >= this.size || this.dense[index] !== member)
      return false;
    index = this.dense[this.size - 1];
    this.dense[this.sparse[member]] = index;
    this.sparse[index] = this.sparse[member];
    this.size--;
    return true;
  };
  SparseMap.prototype.forEach = function(callback, scope) {
    scope = arguments.length > 1 ? scope : this;
    for (var i = 0;i < this.size; i++)
      callback.call(scope, this.vals[i], this.dense[i]);
  };
  SparseMap.prototype.keys = function() {
    var size = this.size, dense = this.dense, i = 0;
    return new Iterator(function() {
      if (i < size) {
        var item = dense[i];
        i++;
        return {
          value: item
        };
      }
      return {
        done: true
      };
    });
  };
  SparseMap.prototype.values = function() {
    var size = this.size, values = this.vals, i = 0;
    return new Iterator(function() {
      if (i < size) {
        var item = values[i];
        i++;
        return {
          value: item
        };
      }
      return {
        done: true
      };
    });
  };
  SparseMap.prototype.entries = function() {
    var size = this.size, dense = this.dense, values = this.vals, i = 0;
    return new Iterator(function() {
      if (i < size) {
        var item = [dense[i], values[i]];
        i++;
        return {
          value: item
        };
      }
      return {
        done: true
      };
    });
  };
  if (typeof Symbol !== "undefined")
    SparseMap.prototype[Symbol.iterator] = SparseMap.prototype.entries;
  SparseMap.prototype.inspect = function() {
    var proxy = new Map;
    for (var i = 0;i < this.size; i++)
      proxy.set(this.dense[i], this.vals[i]);
    Object.defineProperty(proxy, "constructor", {
      value: SparseMap,
      enumerable: false
    });
    proxy.length = this.length;
    if (this.vals.constructor !== Array)
      proxy.type = this.vals.constructor.name;
    return proxy;
  };
  if (typeof Symbol !== "undefined")
    SparseMap.prototype[Symbol.for("nodejs.util.inspect.custom")] = SparseMap.prototype.inspect;
  module.exports = SparseMap;
});

// node_modules/mnemonist/sparse-queue-set.js
var require_sparse_queue_set = __commonJS((exports, module) => {
  var Iterator = require_iterator2();
  var getPointerArray = require_typed_arrays().getPointerArray;
  function SparseQueueSet(capacity) {
    var ByteArray = getPointerArray(capacity);
    this.start = 0;
    this.size = 0;
    this.capacity = capacity;
    this.dense = new ByteArray(capacity);
    this.sparse = new ByteArray(capacity);
  }
  SparseQueueSet.prototype.clear = function() {
    this.start = 0;
    this.size = 0;
  };
  SparseQueueSet.prototype.has = function(member) {
    if (this.size === 0)
      return false;
    var index = this.sparse[member];
    var inBounds = index < this.capacity && (index >= this.start && index < this.start + this.size) || index < (this.start + this.size) % this.capacity;
    return inBounds && this.dense[index] === member;
  };
  SparseQueueSet.prototype.enqueue = function(member) {
    var index = this.sparse[member];
    if (this.size !== 0) {
      var inBounds = index < this.capacity && (index >= this.start && index < this.start + this.size) || index < (this.start + this.size) % this.capacity;
      if (inBounds && this.dense[index] === member)
        return this;
    }
    index = (this.start + this.size) % this.capacity;
    this.dense[index] = member;
    this.sparse[member] = index;
    this.size++;
    return this;
  };
  SparseQueueSet.prototype.dequeue = function() {
    if (this.size === 0)
      return;
    var index = this.start;
    this.size--;
    this.start++;
    if (this.start === this.capacity)
      this.start = 0;
    var member = this.dense[index];
    this.sparse[member] = this.capacity;
    return member;
  };
  SparseQueueSet.prototype.forEach = function(callback, scope) {
    scope = arguments.length > 1 ? scope : this;
    var c = this.capacity, l = this.size, i = this.start, j = 0;
    while (j < l) {
      callback.call(scope, this.dense[i], j, this);
      i++;
      j++;
      if (i === c)
        i = 0;
    }
  };
  SparseQueueSet.prototype.values = function() {
    var dense = this.dense, c = this.capacity, l = this.size, i = this.start, j = 0;
    return new Iterator(function() {
      if (j >= l)
        return {
          done: true
        };
      var value = dense[i];
      i++;
      j++;
      if (i === c)
        i = 0;
      return {
        value,
        done: false
      };
    });
  };
  if (typeof Symbol !== "undefined")
    SparseQueueSet.prototype[Symbol.iterator] = SparseQueueSet.prototype.values;
  SparseQueueSet.prototype.inspect = function() {
    var proxy = [];
    this.forEach(function(member) {
      proxy.push(member);
    });
    Object.defineProperty(proxy, "constructor", {
      value: SparseQueueSet,
      enumerable: false
    });
    proxy.capacity = this.capacity;
    return proxy;
  };
  if (typeof Symbol !== "undefined")
    SparseQueueSet.prototype[Symbol.for("nodejs.util.inspect.custom")] = SparseQueueSet.prototype.inspect;
  module.exports = SparseQueueSet;
});

// node_modules/pandemonium/random-index.js
var require_random_index = __commonJS((exports, module) => {
  function createRandomIndex(rng) {
    return function(length) {
      if (typeof length !== "number")
        length = length.length;
      return Math.floor(rng() * length);
    };
  }
  var randomIndex = createRandomIndex(Math.random);
  randomIndex.createRandomIndex = createRandomIndex;
  module.exports = randomIndex;
});

// node_modules/graphology-utils/getters.js
var require_getters = __commonJS((exports) => {
  function coerceWeight(value) {
    if (typeof value !== "number" || isNaN(value))
      return 1;
    return value;
  }
  function createNodeValueGetter(nameOrFunction, defaultValue) {
    var getter = {};
    var coerceToDefault = function(v) {
      if (typeof v === "undefined")
        return defaultValue;
      return v;
    };
    if (typeof defaultValue === "function")
      coerceToDefault = defaultValue;
    var get = function(attributes) {
      return coerceToDefault(attributes[nameOrFunction]);
    };
    var returnDefault = function() {
      return coerceToDefault(undefined);
    };
    if (typeof nameOrFunction === "string") {
      getter.fromAttributes = get;
      getter.fromGraph = function(graph, node) {
        return get(graph.getNodeAttributes(node));
      };
      getter.fromEntry = function(node, attributes) {
        return get(attributes);
      };
    } else if (typeof nameOrFunction === "function") {
      getter.fromAttributes = function() {
        throw new Error("graphology-utils/getters/createNodeValueGetter: irrelevant usage.");
      };
      getter.fromGraph = function(graph, node) {
        return coerceToDefault(nameOrFunction(node, graph.getNodeAttributes(node)));
      };
      getter.fromEntry = function(node, attributes) {
        return coerceToDefault(nameOrFunction(node, attributes));
      };
    } else {
      getter.fromAttributes = returnDefault;
      getter.fromGraph = returnDefault;
      getter.fromEntry = returnDefault;
    }
    return getter;
  }
  function createEdgeValueGetter(nameOrFunction, defaultValue) {
    var getter = {};
    var coerceToDefault = function(v) {
      if (typeof v === "undefined")
        return defaultValue;
      return v;
    };
    if (typeof defaultValue === "function")
      coerceToDefault = defaultValue;
    var get = function(attributes) {
      return coerceToDefault(attributes[nameOrFunction]);
    };
    var returnDefault = function() {
      return coerceToDefault(undefined);
    };
    if (typeof nameOrFunction === "string") {
      getter.fromAttributes = get;
      getter.fromGraph = function(graph, edge) {
        return get(graph.getEdgeAttributes(edge));
      };
      getter.fromEntry = function(edge, attributes) {
        return get(attributes);
      };
      getter.fromPartialEntry = getter.fromEntry;
      getter.fromMinimalEntry = getter.fromEntry;
    } else if (typeof nameOrFunction === "function") {
      getter.fromAttributes = function() {
        throw new Error("graphology-utils/getters/createEdgeValueGetter: irrelevant usage.");
      };
      getter.fromGraph = function(graph, edge) {
        var extremities = graph.extremities(edge);
        return coerceToDefault(nameOrFunction(edge, graph.getEdgeAttributes(edge), extremities[0], extremities[1], graph.getNodeAttributes(extremities[0]), graph.getNodeAttributes(extremities[1]), graph.isUndirected(edge)));
      };
      getter.fromEntry = function(e, a, s, t, sa, ta, u) {
        return coerceToDefault(nameOrFunction(e, a, s, t, sa, ta, u));
      };
      getter.fromPartialEntry = function(e, a, s, t) {
        return coerceToDefault(nameOrFunction(e, a, s, t));
      };
      getter.fromMinimalEntry = function(e, a) {
        return coerceToDefault(nameOrFunction(e, a));
      };
    } else {
      getter.fromAttributes = returnDefault;
      getter.fromGraph = returnDefault;
      getter.fromEntry = returnDefault;
      getter.fromMinimalEntry = returnDefault;
    }
    return getter;
  }
  exports.createNodeValueGetter = createNodeValueGetter;
  exports.createEdgeValueGetter = createEdgeValueGetter;
  exports.createEdgeWeightGetter = function(name) {
    return createEdgeValueGetter(name, coerceWeight);
  };
});

// node_modules/graphology-indices/louvain.js
var require_louvain = __commonJS((exports) => {
  var typed = require_typed_arrays();
  var resolveDefaults = require_defaults3();
  var createEdgeWeightGetter = require_getters().createEdgeWeightGetter;
  var INSPECT = Symbol.for("nodejs.util.inspect.custom");
  var DEFAULTS2 = {
    getEdgeWeight: "weight",
    keepDendrogram: false,
    resolution: 1
  };
  function UndirectedLouvainIndex(graph, options2) {
    options2 = resolveDefaults(options2, DEFAULTS2);
    var resolution = options2.resolution;
    var getEdgeWeight = createEdgeWeightGetter(options2.getEdgeWeight).fromEntry;
    var size = (graph.size - graph.selfLoopCount) * 2;
    var NeighborhoodPointerArray = typed.getPointerArray(size);
    var NodesPointerArray = typed.getPointerArray(graph.order + 1);
    var WeightsArray = options2.getEdgeWeight ? Float64Array : typed.getPointerArray(graph.size * 2);
    this.C = graph.order;
    this.M = 0;
    this.E = size;
    this.U = 0;
    this.resolution = resolution;
    this.level = 0;
    this.graph = graph;
    this.nodes = new Array(graph.order);
    this.keepDendrogram = options2.keepDendrogram;
    this.neighborhood = new NodesPointerArray(size);
    this.weights = new WeightsArray(size);
    this.loops = new WeightsArray(graph.order);
    this.starts = new NeighborhoodPointerArray(graph.order + 1);
    this.belongings = new NodesPointerArray(graph.order);
    this.dendrogram = [];
    this.mapping = null;
    this.counts = new NodesPointerArray(graph.order);
    this.unused = new NodesPointerArray(graph.order);
    this.totalWeights = new WeightsArray(graph.order);
    var ids = {};
    var weight;
    var i = 0, n = 0;
    var self2 = this;
    graph.forEachNode(function(node) {
      self2.nodes[i] = node;
      ids[node] = i;
      n += graph.undirectedDegreeWithoutSelfLoops(node);
      self2.starts[i] = n;
      self2.belongings[i] = i;
      self2.counts[i] = 1;
      i++;
    });
    graph.forEachEdge(function(edge, attr, source, target, sa, ta, u) {
      weight = getEdgeWeight(edge, attr, source, target, sa, ta, u);
      source = ids[source];
      target = ids[target];
      self2.M += weight;
      if (source === target) {
        self2.totalWeights[source] += weight * 2;
        self2.loops[source] = weight * 2;
      } else {
        self2.totalWeights[source] += weight;
        self2.totalWeights[target] += weight;
        var startSource = --self2.starts[source], startTarget = --self2.starts[target];
        self2.neighborhood[startSource] = target;
        self2.neighborhood[startTarget] = source;
        self2.weights[startSource] = weight;
        self2.weights[startTarget] = weight;
      }
    });
    this.starts[i] = this.E;
    if (this.keepDendrogram)
      this.dendrogram.push(this.belongings.slice());
    else
      this.mapping = this.belongings.slice();
  }
  UndirectedLouvainIndex.prototype.isolate = function(i, degree) {
    var currentCommunity = this.belongings[i];
    if (this.counts[currentCommunity] === 1)
      return currentCommunity;
    var newCommunity = this.unused[--this.U];
    var loops = this.loops[i];
    this.totalWeights[currentCommunity] -= degree + loops;
    this.totalWeights[newCommunity] += degree + loops;
    this.belongings[i] = newCommunity;
    this.counts[currentCommunity]--;
    this.counts[newCommunity]++;
    return newCommunity;
  };
  UndirectedLouvainIndex.prototype.move = function(i, degree, targetCommunity) {
    var currentCommunity = this.belongings[i], loops = this.loops[i];
    this.totalWeights[currentCommunity] -= degree + loops;
    this.totalWeights[targetCommunity] += degree + loops;
    this.belongings[i] = targetCommunity;
    var nowEmpty = this.counts[currentCommunity]-- === 1;
    this.counts[targetCommunity]++;
    if (nowEmpty)
      this.unused[this.U++] = currentCommunity;
  };
  UndirectedLouvainIndex.prototype.computeNodeDegree = function(i) {
    var o, l, weight;
    var degree = 0;
    for (o = this.starts[i], l = this.starts[i + 1];o < l; o++) {
      weight = this.weights[o];
      degree += weight;
    }
    return degree;
  };
  UndirectedLouvainIndex.prototype.expensiveIsolate = function(i) {
    var degree = this.computeNodeDegree(i);
    return this.isolate(i, degree);
  };
  UndirectedLouvainIndex.prototype.expensiveMove = function(i, ci) {
    var degree = this.computeNodeDegree(i);
    this.move(i, degree, ci);
  };
  UndirectedLouvainIndex.prototype.zoomOut = function() {
    var inducedGraph = new Array(this.C - this.U), newLabels = {};
    var N = this.nodes.length;
    var C = 0, E = 0;
    var i, j, l, m, n, ci, cj, data, adj;
    for (i = 0, l = this.C;i < l; i++) {
      ci = this.belongings[i];
      if (!(ci in newLabels)) {
        newLabels[ci] = C;
        inducedGraph[C] = {
          adj: {},
          totalWeights: this.totalWeights[ci],
          internalWeights: 0
        };
        C++;
      }
      this.belongings[i] = newLabels[ci];
    }
    var currentLevel, nextLevel;
    if (this.keepDendrogram) {
      currentLevel = this.dendrogram[this.level];
      nextLevel = new (typed.getPointerArray(C))(N);
      for (i = 0;i < N; i++)
        nextLevel[i] = this.belongings[currentLevel[i]];
      this.dendrogram.push(nextLevel);
    } else {
      for (i = 0;i < N; i++)
        this.mapping[i] = this.belongings[this.mapping[i]];
    }
    for (i = 0, l = this.C;i < l; i++) {
      ci = this.belongings[i];
      data = inducedGraph[ci];
      adj = data.adj;
      data.internalWeights += this.loops[i];
      for (j = this.starts[i], m = this.starts[i + 1];j < m; j++) {
        n = this.neighborhood[j];
        cj = this.belongings[n];
        if (ci === cj) {
          data.internalWeights += this.weights[j];
          continue;
        }
        if (!(cj in adj))
          adj[cj] = 0;
        adj[cj] += this.weights[j];
      }
    }
    this.C = C;
    n = 0;
    for (ci = 0;ci < C; ci++) {
      data = inducedGraph[ci];
      adj = data.adj;
      ci = +ci;
      this.totalWeights[ci] = data.totalWeights;
      this.loops[ci] = data.internalWeights;
      this.counts[ci] = 1;
      this.starts[ci] = n;
      this.belongings[ci] = ci;
      for (cj in adj) {
        this.neighborhood[n] = +cj;
        this.weights[n] = adj[cj];
        E++;
        n++;
      }
    }
    this.starts[C] = E;
    this.E = E;
    this.U = 0;
    this.level++;
    return newLabels;
  };
  UndirectedLouvainIndex.prototype.modularity = function() {
    var ci, cj, i, j, m;
    var Q = 0;
    var M2 = this.M * 2;
    var internalWeights = new Float64Array(this.C);
    for (i = 0;i < this.C; i++) {
      ci = this.belongings[i];
      internalWeights[ci] += this.loops[i];
      for (j = this.starts[i], m = this.starts[i + 1];j < m; j++) {
        cj = this.belongings[this.neighborhood[j]];
        if (ci !== cj)
          continue;
        internalWeights[ci] += this.weights[j];
      }
    }
    for (i = 0;i < this.C; i++) {
      Q += internalWeights[i] / M2 - Math.pow(this.totalWeights[i] / M2, 2) * this.resolution;
    }
    return Q;
  };
  UndirectedLouvainIndex.prototype.delta = function(i, degree, targetCommunityDegree, targetCommunity) {
    var M = this.M;
    var targetCommunityTotalWeight = this.totalWeights[targetCommunity];
    degree += this.loops[i];
    return targetCommunityDegree / M - targetCommunityTotalWeight * degree * this.resolution / (2 * M * M);
  };
  UndirectedLouvainIndex.prototype.deltaWithOwnCommunity = function(i, degree, targetCommunityDegree, targetCommunity) {
    var M = this.M;
    var targetCommunityTotalWeight = this.totalWeights[targetCommunity];
    degree += this.loops[i];
    return targetCommunityDegree / M - (targetCommunityTotalWeight - degree) * degree * this.resolution / (2 * M * M);
  };
  UndirectedLouvainIndex.prototype.fastDelta = function(i, degree, targetCommunityDegree, targetCommunity) {
    var M = this.M;
    var targetCommunityTotalWeight = this.totalWeights[targetCommunity];
    degree += this.loops[i];
    return targetCommunityDegree - degree * targetCommunityTotalWeight * this.resolution / (2 * M);
  };
  UndirectedLouvainIndex.prototype.fastDeltaWithOwnCommunity = function(i, degree, targetCommunityDegree, targetCommunity) {
    var M = this.M;
    var targetCommunityTotalWeight = this.totalWeights[targetCommunity];
    degree += this.loops[i];
    return targetCommunityDegree - degree * (targetCommunityTotalWeight - degree) * this.resolution / (2 * M);
  };
  UndirectedLouvainIndex.prototype.bounds = function(i) {
    return [this.starts[i], this.starts[i + 1]];
  };
  UndirectedLouvainIndex.prototype.project = function() {
    var self2 = this;
    var projection = {};
    self2.nodes.slice(0, this.C).forEach(function(node, i) {
      projection[node] = Array.from(self2.neighborhood.slice(self2.starts[i], self2.starts[i + 1])).map(function(j) {
        return self2.nodes[j];
      });
    });
    return projection;
  };
  UndirectedLouvainIndex.prototype.collect = function(level) {
    if (arguments.length < 1)
      level = this.level;
    var o = {};
    var mapping = this.keepDendrogram ? this.dendrogram[level] : this.mapping;
    var i, l;
    for (i = 0, l = mapping.length;i < l; i++)
      o[this.nodes[i]] = mapping[i];
    return o;
  };
  UndirectedLouvainIndex.prototype.assign = function(prop, level) {
    if (arguments.length < 2)
      level = this.level;
    var mapping = this.keepDendrogram ? this.dendrogram[level] : this.mapping;
    var i, l;
    for (i = 0, l = mapping.length;i < l; i++)
      this.graph.setNodeAttribute(this.nodes[i], prop, mapping[i]);
  };
  UndirectedLouvainIndex.prototype[INSPECT] = function() {
    var proxy = {};
    Object.defineProperty(proxy, "constructor", {
      value: UndirectedLouvainIndex,
      enumerable: false
    });
    proxy.C = this.C;
    proxy.M = this.M;
    proxy.E = this.E;
    proxy.U = this.U;
    proxy.resolution = this.resolution;
    proxy.level = this.level;
    proxy.nodes = this.nodes;
    proxy.starts = this.starts.slice(0, proxy.C + 1);
    var eTruncated = ["neighborhood", "weights"];
    var cTruncated = ["counts", "loops", "belongings", "totalWeights"];
    var self2 = this;
    eTruncated.forEach(function(key) {
      proxy[key] = self2[key].slice(0, proxy.E);
    });
    cTruncated.forEach(function(key) {
      proxy[key] = self2[key].slice(0, proxy.C);
    });
    proxy.unused = this.unused.slice(0, this.U);
    if (this.keepDendrogram)
      proxy.dendrogram = this.dendrogram;
    else
      proxy.mapping = this.mapping;
    return proxy;
  };
  function DirectedLouvainIndex(graph, options2) {
    options2 = resolveDefaults(options2, DEFAULTS2);
    var resolution = options2.resolution;
    var getEdgeWeight = createEdgeWeightGetter(options2.getEdgeWeight).fromEntry;
    var size = (graph.size - graph.selfLoopCount) * 2;
    var NeighborhoodPointerArray = typed.getPointerArray(size);
    var NodesPointerArray = typed.getPointerArray(graph.order + 1);
    var WeightsArray = options2.getEdgeWeight ? Float64Array : typed.getPointerArray(graph.size * 2);
    this.C = graph.order;
    this.M = 0;
    this.E = size;
    this.U = 0;
    this.resolution = resolution;
    this.level = 0;
    this.graph = graph;
    this.nodes = new Array(graph.order);
    this.keepDendrogram = options2.keepDendrogram;
    this.neighborhood = new NodesPointerArray(size);
    this.weights = new WeightsArray(size);
    this.loops = new WeightsArray(graph.order);
    this.starts = new NeighborhoodPointerArray(graph.order + 1);
    this.offsets = new NeighborhoodPointerArray(graph.order);
    this.belongings = new NodesPointerArray(graph.order);
    this.dendrogram = [];
    this.counts = new NodesPointerArray(graph.order);
    this.unused = new NodesPointerArray(graph.order);
    this.totalInWeights = new WeightsArray(graph.order);
    this.totalOutWeights = new WeightsArray(graph.order);
    var ids = {};
    var weight;
    var i = 0, n = 0;
    var self2 = this;
    graph.forEachNode(function(node) {
      self2.nodes[i] = node;
      ids[node] = i;
      n += graph.outDegreeWithoutSelfLoops(node);
      self2.starts[i] = n;
      n += graph.inDegreeWithoutSelfLoops(node);
      self2.offsets[i] = n;
      self2.belongings[i] = i;
      self2.counts[i] = 1;
      i++;
    });
    graph.forEachEdge(function(edge, attr, source, target, sa, ta, u) {
      weight = getEdgeWeight(edge, attr, source, target, sa, ta, u);
      source = ids[source];
      target = ids[target];
      self2.M += weight;
      if (source === target) {
        self2.loops[source] += weight;
        self2.totalInWeights[source] += weight;
        self2.totalOutWeights[source] += weight;
      } else {
        self2.totalOutWeights[source] += weight;
        self2.totalInWeights[target] += weight;
        var startSource = --self2.starts[source], startTarget = --self2.offsets[target];
        self2.neighborhood[startSource] = target;
        self2.neighborhood[startTarget] = source;
        self2.weights[startSource] = weight;
        self2.weights[startTarget] = weight;
      }
    });
    this.starts[i] = this.E;
    if (this.keepDendrogram)
      this.dendrogram.push(this.belongings.slice());
    else
      this.mapping = this.belongings.slice();
  }
  DirectedLouvainIndex.prototype.bounds = UndirectedLouvainIndex.prototype.bounds;
  DirectedLouvainIndex.prototype.inBounds = function(i) {
    return [this.offsets[i], this.starts[i + 1]];
  };
  DirectedLouvainIndex.prototype.outBounds = function(i) {
    return [this.starts[i], this.offsets[i]];
  };
  DirectedLouvainIndex.prototype.project = UndirectedLouvainIndex.prototype.project;
  DirectedLouvainIndex.prototype.projectIn = function() {
    var self2 = this;
    var projection = {};
    self2.nodes.slice(0, this.C).forEach(function(node, i) {
      projection[node] = Array.from(self2.neighborhood.slice(self2.offsets[i], self2.starts[i + 1])).map(function(j) {
        return self2.nodes[j];
      });
    });
    return projection;
  };
  DirectedLouvainIndex.prototype.projectOut = function() {
    var self2 = this;
    var projection = {};
    self2.nodes.slice(0, this.C).forEach(function(node, i) {
      projection[node] = Array.from(self2.neighborhood.slice(self2.starts[i], self2.offsets[i])).map(function(j) {
        return self2.nodes[j];
      });
    });
    return projection;
  };
  DirectedLouvainIndex.prototype.isolate = function(i, inDegree, outDegree) {
    var currentCommunity = this.belongings[i];
    if (this.counts[currentCommunity] === 1)
      return currentCommunity;
    var newCommunity = this.unused[--this.U];
    var loops = this.loops[i];
    this.totalInWeights[currentCommunity] -= inDegree + loops;
    this.totalInWeights[newCommunity] += inDegree + loops;
    this.totalOutWeights[currentCommunity] -= outDegree + loops;
    this.totalOutWeights[newCommunity] += outDegree + loops;
    this.belongings[i] = newCommunity;
    this.counts[currentCommunity]--;
    this.counts[newCommunity]++;
    return newCommunity;
  };
  DirectedLouvainIndex.prototype.move = function(i, inDegree, outDegree, targetCommunity) {
    var currentCommunity = this.belongings[i], loops = this.loops[i];
    this.totalInWeights[currentCommunity] -= inDegree + loops;
    this.totalInWeights[targetCommunity] += inDegree + loops;
    this.totalOutWeights[currentCommunity] -= outDegree + loops;
    this.totalOutWeights[targetCommunity] += outDegree + loops;
    this.belongings[i] = targetCommunity;
    var nowEmpty = this.counts[currentCommunity]-- === 1;
    this.counts[targetCommunity]++;
    if (nowEmpty)
      this.unused[this.U++] = currentCommunity;
  };
  DirectedLouvainIndex.prototype.computeNodeInDegree = function(i) {
    var o, l, weight;
    var inDegree = 0;
    for (o = this.offsets[i], l = this.starts[i + 1];o < l; o++) {
      weight = this.weights[o];
      inDegree += weight;
    }
    return inDegree;
  };
  DirectedLouvainIndex.prototype.computeNodeOutDegree = function(i) {
    var o, l, weight;
    var outDegree = 0;
    for (o = this.starts[i], l = this.offsets[i];o < l; o++) {
      weight = this.weights[o];
      outDegree += weight;
    }
    return outDegree;
  };
  DirectedLouvainIndex.prototype.expensiveMove = function(i, ci) {
    var inDegree = this.computeNodeInDegree(i), outDegree = this.computeNodeOutDegree(i);
    this.move(i, inDegree, outDegree, ci);
  };
  DirectedLouvainIndex.prototype.zoomOut = function() {
    var inducedGraph = new Array(this.C - this.U), newLabels = {};
    var N = this.nodes.length;
    var C = 0, E = 0;
    var i, j, l, m, n, ci, cj, data, offset, out, adj, inAdj, outAdj;
    for (i = 0, l = this.C;i < l; i++) {
      ci = this.belongings[i];
      if (!(ci in newLabels)) {
        newLabels[ci] = C;
        inducedGraph[C] = {
          inAdj: {},
          outAdj: {},
          totalInWeights: this.totalInWeights[ci],
          totalOutWeights: this.totalOutWeights[ci],
          internalWeights: 0
        };
        C++;
      }
      this.belongings[i] = newLabels[ci];
    }
    var currentLevel, nextLevel;
    if (this.keepDendrogram) {
      currentLevel = this.dendrogram[this.level];
      nextLevel = new (typed.getPointerArray(C))(N);
      for (i = 0;i < N; i++)
        nextLevel[i] = this.belongings[currentLevel[i]];
      this.dendrogram.push(nextLevel);
    } else {
      for (i = 0;i < N; i++)
        this.mapping[i] = this.belongings[this.mapping[i]];
    }
    for (i = 0, l = this.C;i < l; i++) {
      ci = this.belongings[i];
      offset = this.offsets[i];
      data = inducedGraph[ci];
      inAdj = data.inAdj;
      outAdj = data.outAdj;
      data.internalWeights += this.loops[i];
      for (j = this.starts[i], m = this.starts[i + 1];j < m; j++) {
        n = this.neighborhood[j];
        cj = this.belongings[n];
        out = j < offset;
        adj = out ? outAdj : inAdj;
        if (ci === cj) {
          if (out)
            data.internalWeights += this.weights[j];
          continue;
        }
        if (!(cj in adj))
          adj[cj] = 0;
        adj[cj] += this.weights[j];
      }
    }
    this.C = C;
    n = 0;
    for (ci = 0;ci < C; ci++) {
      data = inducedGraph[ci];
      inAdj = data.inAdj;
      outAdj = data.outAdj;
      ci = +ci;
      this.totalInWeights[ci] = data.totalInWeights;
      this.totalOutWeights[ci] = data.totalOutWeights;
      this.loops[ci] = data.internalWeights;
      this.counts[ci] = 1;
      this.starts[ci] = n;
      this.belongings[ci] = ci;
      for (cj in outAdj) {
        this.neighborhood[n] = +cj;
        this.weights[n] = outAdj[cj];
        E++;
        n++;
      }
      this.offsets[ci] = n;
      for (cj in inAdj) {
        this.neighborhood[n] = +cj;
        this.weights[n] = inAdj[cj];
        E++;
        n++;
      }
    }
    this.starts[C] = E;
    this.E = E;
    this.U = 0;
    this.level++;
    return newLabels;
  };
  DirectedLouvainIndex.prototype.modularity = function() {
    var ci, cj, i, j, m;
    var Q = 0;
    var M = this.M;
    var internalWeights = new Float64Array(this.C);
    for (i = 0;i < this.C; i++) {
      ci = this.belongings[i];
      internalWeights[ci] += this.loops[i];
      for (j = this.starts[i], m = this.offsets[i];j < m; j++) {
        cj = this.belongings[this.neighborhood[j]];
        if (ci !== cj)
          continue;
        internalWeights[ci] += this.weights[j];
      }
    }
    for (i = 0;i < this.C; i++)
      Q += internalWeights[i] / M - this.totalInWeights[i] * this.totalOutWeights[i] / Math.pow(M, 2) * this.resolution;
    return Q;
  };
  DirectedLouvainIndex.prototype.delta = function(i, inDegree, outDegree, targetCommunityDegree, targetCommunity) {
    var M = this.M;
    var targetCommunityTotalInWeight = this.totalInWeights[targetCommunity], targetCommunityTotalOutWeight = this.totalOutWeights[targetCommunity];
    var loops = this.loops[i];
    inDegree += loops;
    outDegree += loops;
    return targetCommunityDegree / M - (outDegree * targetCommunityTotalInWeight + inDegree * targetCommunityTotalOutWeight) * this.resolution / (M * M);
  };
  DirectedLouvainIndex.prototype.deltaWithOwnCommunity = function(i, inDegree, outDegree, targetCommunityDegree, targetCommunity) {
    var M = this.M;
    var targetCommunityTotalInWeight = this.totalInWeights[targetCommunity], targetCommunityTotalOutWeight = this.totalOutWeights[targetCommunity];
    var loops = this.loops[i];
    inDegree += loops;
    outDegree += loops;
    return targetCommunityDegree / M - (outDegree * (targetCommunityTotalInWeight - inDegree) + inDegree * (targetCommunityTotalOutWeight - outDegree)) * this.resolution / (M * M);
  };
  DirectedLouvainIndex.prototype.collect = UndirectedLouvainIndex.prototype.collect;
  DirectedLouvainIndex.prototype.assign = UndirectedLouvainIndex.prototype.assign;
  DirectedLouvainIndex.prototype[INSPECT] = function() {
    var proxy = {};
    Object.defineProperty(proxy, "constructor", {
      value: DirectedLouvainIndex,
      enumerable: false
    });
    proxy.C = this.C;
    proxy.M = this.M;
    proxy.E = this.E;
    proxy.U = this.U;
    proxy.resolution = this.resolution;
    proxy.level = this.level;
    proxy.nodes = this.nodes;
    proxy.starts = this.starts.slice(0, proxy.C + 1);
    var eTruncated = ["neighborhood", "weights"];
    var cTruncated = [
      "counts",
      "offsets",
      "loops",
      "belongings",
      "totalInWeights",
      "totalOutWeights"
    ];
    var self2 = this;
    eTruncated.forEach(function(key) {
      proxy[key] = self2[key].slice(0, proxy.E);
    });
    cTruncated.forEach(function(key) {
      proxy[key] = self2[key].slice(0, proxy.C);
    });
    proxy.unused = this.unused.slice(0, this.U);
    if (this.keepDendrogram)
      proxy.dendrogram = this.dendrogram;
    else
      proxy.mapping = this.mapping;
    return proxy;
  };
  exports.UndirectedLouvainIndex = UndirectedLouvainIndex;
  exports.DirectedLouvainIndex = DirectedLouvainIndex;
});

// node_modules/graphology-communities-louvain/index.js
var require_graphology_communities_louvain = __commonJS((exports, module) => {
  var resolveDefaults = require_defaults3();
  var isGraph = require_is_graph();
  var inferType = require_infer_type();
  var SparseMap = require_sparse_map();
  var SparseQueueSet = require_sparse_queue_set();
  var createRandomIndex = require_random_index().createRandomIndex;
  var indices = require_louvain();
  var UndirectedLouvainIndex = indices.UndirectedLouvainIndex;
  var DirectedLouvainIndex = indices.DirectedLouvainIndex;
  var DEFAULTS2 = {
    nodeCommunityAttribute: "community",
    getEdgeWeight: "weight",
    fastLocalMoves: true,
    randomWalk: true,
    resolution: 1,
    rng: Math.random
  };
  function addWeightToCommunity(map3, community, weight) {
    var currentWeight = map3.get(community);
    if (typeof currentWeight === "undefined")
      currentWeight = 0;
    currentWeight += weight;
    map3.set(community, currentWeight);
  }
  var EPSILON = 0.0000000001;
  function tieBreaker(bestCommunity, currentCommunity, targetCommunity, delta, bestDelta) {
    if (Math.abs(delta - bestDelta) < EPSILON) {
      if (bestCommunity === currentCommunity) {
        return false;
      } else {
        return targetCommunity > bestCommunity;
      }
    } else if (delta > bestDelta) {
      return true;
    }
    return false;
  }
  function undirectedLouvain(detailed, graph, options2) {
    var index = new UndirectedLouvainIndex(graph, {
      getEdgeWeight: options2.getEdgeWeight,
      keepDendrogram: detailed,
      resolution: options2.resolution
    });
    var randomIndex = createRandomIndex(options2.rng);
    var moveWasMade = true, localMoveWasMade = true;
    var currentCommunity, targetCommunity;
    var communities = new SparseMap(Float64Array, index.C);
    var queue, start, end, weight, ci, ri, s, i, j, l;
    var degree, targetCommunityDegree;
    var bestCommunity, bestDelta, deltaIsBetter, delta;
    var deltaComputations = 0, nodesVisited = 0, moves = [], localMoves, currentMoves;
    if (options2.fastLocalMoves)
      queue = new SparseQueueSet(index.C);
    while (moveWasMade) {
      l = index.C;
      moveWasMade = false;
      localMoveWasMade = true;
      if (options2.fastLocalMoves) {
        currentMoves = 0;
        ri = options2.randomWalk ? randomIndex(l) : 0;
        for (s = 0;s < l; s++, ri++) {
          i = ri % l;
          queue.enqueue(i);
        }
        while (queue.size !== 0) {
          i = queue.dequeue();
          nodesVisited++;
          degree = 0;
          communities.clear();
          currentCommunity = index.belongings[i];
          start = index.starts[i];
          end = index.starts[i + 1];
          for (;start < end; start++) {
            j = index.neighborhood[start];
            weight = index.weights[start];
            targetCommunity = index.belongings[j];
            degree += weight;
            addWeightToCommunity(communities, targetCommunity, weight);
          }
          bestDelta = index.fastDeltaWithOwnCommunity(i, degree, communities.get(currentCommunity) || 0, currentCommunity);
          bestCommunity = currentCommunity;
          for (ci = 0;ci < communities.size; ci++) {
            targetCommunity = communities.dense[ci];
            if (targetCommunity === currentCommunity)
              continue;
            targetCommunityDegree = communities.vals[ci];
            deltaComputations++;
            delta = index.fastDelta(i, degree, targetCommunityDegree, targetCommunity);
            deltaIsBetter = tieBreaker(bestCommunity, currentCommunity, targetCommunity, delta, bestDelta);
            if (deltaIsBetter) {
              bestDelta = delta;
              bestCommunity = targetCommunity;
            }
          }
          if (bestDelta < 0) {
            bestCommunity = index.isolate(i, degree);
            if (bestCommunity === currentCommunity)
              continue;
          } else {
            if (bestCommunity === currentCommunity) {
              continue;
            } else {
              index.move(i, degree, bestCommunity);
            }
          }
          moveWasMade = true;
          currentMoves++;
          start = index.starts[i];
          end = index.starts[i + 1];
          for (;start < end; start++) {
            j = index.neighborhood[start];
            targetCommunity = index.belongings[j];
            if (targetCommunity !== bestCommunity)
              queue.enqueue(j);
          }
        }
        moves.push(currentMoves);
      } else {
        localMoves = [];
        moves.push(localMoves);
        while (localMoveWasMade) {
          localMoveWasMade = false;
          currentMoves = 0;
          ri = options2.randomWalk ? randomIndex(l) : 0;
          for (s = 0;s < l; s++, ri++) {
            i = ri % l;
            nodesVisited++;
            degree = 0;
            communities.clear();
            currentCommunity = index.belongings[i];
            start = index.starts[i];
            end = index.starts[i + 1];
            for (;start < end; start++) {
              j = index.neighborhood[start];
              weight = index.weights[start];
              targetCommunity = index.belongings[j];
              degree += weight;
              addWeightToCommunity(communities, targetCommunity, weight);
            }
            bestDelta = index.fastDeltaWithOwnCommunity(i, degree, communities.get(currentCommunity) || 0, currentCommunity);
            bestCommunity = currentCommunity;
            for (ci = 0;ci < communities.size; ci++) {
              targetCommunity = communities.dense[ci];
              if (targetCommunity === currentCommunity)
                continue;
              targetCommunityDegree = communities.vals[ci];
              deltaComputations++;
              delta = index.fastDelta(i, degree, targetCommunityDegree, targetCommunity);
              deltaIsBetter = tieBreaker(bestCommunity, currentCommunity, targetCommunity, delta, bestDelta);
              if (deltaIsBetter) {
                bestDelta = delta;
                bestCommunity = targetCommunity;
              }
            }
            if (bestDelta < 0) {
              bestCommunity = index.isolate(i, degree);
              if (bestCommunity === currentCommunity)
                continue;
            } else {
              if (bestCommunity === currentCommunity) {
                continue;
              } else {
                index.move(i, degree, bestCommunity);
              }
            }
            localMoveWasMade = true;
            currentMoves++;
          }
          localMoves.push(currentMoves);
          moveWasMade = localMoveWasMade || moveWasMade;
        }
      }
      if (moveWasMade)
        index.zoomOut();
    }
    var results = {
      index,
      deltaComputations,
      nodesVisited,
      moves
    };
    return results;
  }
  function directedLouvain(detailed, graph, options2) {
    var index = new DirectedLouvainIndex(graph, {
      getEdgeWeight: options2.getEdgeWeight,
      keepDendrogram: detailed,
      resolution: options2.resolution
    });
    var randomIndex = createRandomIndex(options2.rng);
    var moveWasMade = true, localMoveWasMade = true;
    var currentCommunity, targetCommunity;
    var communities = new SparseMap(Float64Array, index.C);
    var queue, start, end, offset, out, weight, ci, ri, s, i, j, l;
    var inDegree, outDegree, targetCommunityDegree;
    var bestCommunity, bestDelta, deltaIsBetter, delta;
    var deltaComputations = 0, nodesVisited = 0, moves = [], localMoves, currentMoves;
    if (options2.fastLocalMoves)
      queue = new SparseQueueSet(index.C);
    while (moveWasMade) {
      l = index.C;
      moveWasMade = false;
      localMoveWasMade = true;
      if (options2.fastLocalMoves) {
        currentMoves = 0;
        ri = options2.randomWalk ? randomIndex(l) : 0;
        for (s = 0;s < l; s++, ri++) {
          i = ri % l;
          queue.enqueue(i);
        }
        while (queue.size !== 0) {
          i = queue.dequeue();
          nodesVisited++;
          inDegree = 0;
          outDegree = 0;
          communities.clear();
          currentCommunity = index.belongings[i];
          start = index.starts[i];
          end = index.starts[i + 1];
          offset = index.offsets[i];
          for (;start < end; start++) {
            out = start < offset;
            j = index.neighborhood[start];
            weight = index.weights[start];
            targetCommunity = index.belongings[j];
            if (out)
              outDegree += weight;
            else
              inDegree += weight;
            addWeightToCommunity(communities, targetCommunity, weight);
          }
          bestDelta = index.deltaWithOwnCommunity(i, inDegree, outDegree, communities.get(currentCommunity) || 0, currentCommunity);
          bestCommunity = currentCommunity;
          for (ci = 0;ci < communities.size; ci++) {
            targetCommunity = communities.dense[ci];
            if (targetCommunity === currentCommunity)
              continue;
            targetCommunityDegree = communities.vals[ci];
            deltaComputations++;
            delta = index.delta(i, inDegree, outDegree, targetCommunityDegree, targetCommunity);
            deltaIsBetter = tieBreaker(bestCommunity, currentCommunity, targetCommunity, delta, bestDelta);
            if (deltaIsBetter) {
              bestDelta = delta;
              bestCommunity = targetCommunity;
            }
          }
          if (bestDelta < 0) {
            bestCommunity = index.isolate(i, inDegree, outDegree);
            if (bestCommunity === currentCommunity)
              continue;
          } else {
            if (bestCommunity === currentCommunity) {
              continue;
            } else {
              index.move(i, inDegree, outDegree, bestCommunity);
            }
          }
          moveWasMade = true;
          currentMoves++;
          start = index.starts[i];
          end = index.starts[i + 1];
          for (;start < end; start++) {
            j = index.neighborhood[start];
            targetCommunity = index.belongings[j];
            if (targetCommunity !== bestCommunity)
              queue.enqueue(j);
          }
        }
        moves.push(currentMoves);
      } else {
        localMoves = [];
        moves.push(localMoves);
        while (localMoveWasMade) {
          localMoveWasMade = false;
          currentMoves = 0;
          ri = options2.randomWalk ? randomIndex(l) : 0;
          for (s = 0;s < l; s++, ri++) {
            i = ri % l;
            nodesVisited++;
            inDegree = 0;
            outDegree = 0;
            communities.clear();
            currentCommunity = index.belongings[i];
            start = index.starts[i];
            end = index.starts[i + 1];
            offset = index.offsets[i];
            for (;start < end; start++) {
              out = start < offset;
              j = index.neighborhood[start];
              weight = index.weights[start];
              targetCommunity = index.belongings[j];
              if (out)
                outDegree += weight;
              else
                inDegree += weight;
              addWeightToCommunity(communities, targetCommunity, weight);
            }
            bestDelta = index.deltaWithOwnCommunity(i, inDegree, outDegree, communities.get(currentCommunity) || 0, currentCommunity);
            bestCommunity = currentCommunity;
            for (ci = 0;ci < communities.size; ci++) {
              targetCommunity = communities.dense[ci];
              if (targetCommunity === currentCommunity)
                continue;
              targetCommunityDegree = communities.vals[ci];
              deltaComputations++;
              delta = index.delta(i, inDegree, outDegree, targetCommunityDegree, targetCommunity);
              deltaIsBetter = tieBreaker(bestCommunity, currentCommunity, targetCommunity, delta, bestDelta);
              if (deltaIsBetter) {
                bestDelta = delta;
                bestCommunity = targetCommunity;
              }
            }
            if (bestDelta < 0) {
              bestCommunity = index.isolate(i, inDegree, outDegree);
              if (bestCommunity === currentCommunity)
                continue;
            } else {
              if (bestCommunity === currentCommunity) {
                continue;
              } else {
                index.move(i, inDegree, outDegree, bestCommunity);
              }
            }
            localMoveWasMade = true;
            currentMoves++;
          }
          localMoves.push(currentMoves);
          moveWasMade = localMoveWasMade || moveWasMade;
        }
      }
      if (moveWasMade)
        index.zoomOut();
    }
    var results = {
      index,
      deltaComputations,
      nodesVisited,
      moves
    };
    return results;
  }
  function louvain(assign2, detailed, graph, options2) {
    if (!isGraph(graph))
      throw new Error("graphology-communities-louvain: the given graph is not a valid graphology instance.");
    var type = inferType(graph);
    if (type === "mixed")
      throw new Error("graphology-communities-louvain: cannot run the algorithm on a true mixed graph.");
    options2 = resolveDefaults(options2, DEFAULTS2);
    var c = 0;
    if (graph.size === 0) {
      if (assign2) {
        graph.forEachNode(function(node) {
          graph.setNodeAttribute(node, options2.nodeCommunityAttribute, c++);
        });
        return;
      }
      var communities = {};
      graph.forEachNode(function(node) {
        communities[node] = c++;
      });
      if (!detailed)
        return communities;
      return {
        communities,
        count: graph.order,
        deltaComputations: 0,
        dendrogram: null,
        level: 0,
        modularity: NaN,
        moves: null,
        nodesVisited: 0,
        resolution: options2.resolution
      };
    }
    var fn2 = type === "undirected" ? undirectedLouvain : directedLouvain;
    var results = fn2(detailed, graph, options2);
    var index = results.index;
    if (!detailed) {
      if (assign2) {
        index.assign(options2.nodeCommunityAttribute);
        return;
      }
      return index.collect();
    }
    var output = {
      count: index.C,
      deltaComputations: results.deltaComputations,
      dendrogram: index.dendrogram,
      level: index.level,
      modularity: index.modularity(),
      moves: results.moves,
      nodesVisited: results.nodesVisited,
      resolution: options2.resolution
    };
    if (assign2) {
      index.assign(options2.nodeCommunityAttribute);
      return output;
    }
    output.communities = index.collect();
    return output;
  }
  var fn = louvain.bind(null, false, false);
  fn.assign = louvain.bind(null, true, false);
  fn.detailed = louvain.bind(null, false, true);
  fn.defaults = DEFAULTS2;
  module.exports = fn;
});

// node_modules/graphology-utils/add-node.js
var require_add_node = __commonJS((exports) => {
  exports.copyNode = function(graph, key, attributes) {
    attributes = Object.assign({}, attributes);
    return graph.addNode(key, attributes);
  };
});

// node_modules/graphology-utils/add-edge.js
var require_add_edge = __commonJS((exports) => {
  exports.addEdge = function addEdge2(graph, undirected, key, source, target, attributes) {
    if (undirected) {
      if (key === null || key === undefined)
        return graph.addUndirectedEdge(source, target, attributes);
      else
        return graph.addUndirectedEdgeWithKey(key, source, target, attributes);
    } else {
      if (key === null || key === undefined)
        return graph.addDirectedEdge(source, target, attributes);
      else
        return graph.addDirectedEdgeWithKey(key, source, target, attributes);
    }
  };
  exports.copyEdge = function copyEdge(graph, undirected, key, source, target, attributes) {
    attributes = Object.assign({}, attributes);
    if (undirected) {
      if (key === null || key === undefined)
        return graph.addUndirectedEdge(source, target, attributes);
      else
        return graph.addUndirectedEdgeWithKey(key, source, target, attributes);
    } else {
      if (key === null || key === undefined)
        return graph.addDirectedEdge(source, target, attributes);
      else
        return graph.addDirectedEdgeWithKey(key, source, target, attributes);
    }
  };
  exports.mergeEdge = function mergeEdge2(graph, undirected, key, source, target, attributes) {
    if (undirected) {
      if (key === null || key === undefined)
        return graph.mergeUndirectedEdge(source, target, attributes);
      else
        return graph.mergeUndirectedEdgeWithKey(key, source, target, attributes);
    } else {
      if (key === null || key === undefined)
        return graph.mergeDirectedEdge(source, target, attributes);
      else
        return graph.mergeDirectedEdgeWithKey(key, source, target, attributes);
    }
  };
  exports.updateEdge = function updateEdge(graph, undirected, key, source, target, updater) {
    if (undirected) {
      if (key === null || key === undefined)
        return graph.updateUndirectedEdge(source, target, updater);
      else
        return graph.updateUndirectedEdgeWithKey(key, source, target, updater);
    } else {
      if (key === null || key === undefined)
        return graph.updateDirectedEdge(source, target, updater);
      else
        return graph.updateDirectedEdgeWithKey(key, source, target, updater);
    }
  };
});

// node_modules/graphology-indices/dfs-stack.js
var require_dfs_stack = __commonJS((exports, module) => {
  function DFSStack(graph) {
    this.graph = graph;
    this.stack = new Array(graph.order);
    this.seen = new Set;
    this.size = 0;
  }
  DFSStack.prototype.hasAlreadySeenEverything = function() {
    return this.seen.size === this.graph.order;
  };
  DFSStack.prototype.countUnseenNodes = function() {
    return this.graph.order - this.seen.size;
  };
  DFSStack.prototype.forEachNodeYetUnseen = function(callback) {
    var seen = this.seen;
    var graph = this.graph;
    graph.someNode(function(node, attr) {
      if (seen.size === graph.order)
        return true;
      if (seen.has(node))
        return false;
      var shouldBreak = callback(node, attr);
      if (shouldBreak)
        return true;
      return false;
    });
  };
  DFSStack.prototype.has = function(node) {
    return this.seen.has(node);
  };
  DFSStack.prototype.push = function(node) {
    var seenSizeBefore = this.seen.size;
    this.seen.add(node);
    if (seenSizeBefore === this.seen.size)
      return false;
    this.stack[this.size++] = node;
    return true;
  };
  DFSStack.prototype.pushWith = function(node, item) {
    var seenSizeBefore = this.seen.size;
    this.seen.add(node);
    if (seenSizeBefore === this.seen.size)
      return false;
    this.stack[this.size++] = item;
    return true;
  };
  DFSStack.prototype.pop = function() {
    if (this.size === 0)
      return;
    return this.stack[--this.size];
  };
  module.exports = DFSStack;
});

// node_modules/obliterator/support.js
var require_support = __commonJS((exports) => {
  exports.ARRAY_BUFFER_SUPPORT = typeof ArrayBuffer !== "undefined";
  exports.SYMBOL_SUPPORT = typeof Symbol !== "undefined";
});

// node_modules/obliterator/foreach.js
var require_foreach = __commonJS((exports, module) => {
  var support = require_support();
  var ARRAY_BUFFER_SUPPORT = support.ARRAY_BUFFER_SUPPORT;
  var SYMBOL_SUPPORT = support.SYMBOL_SUPPORT;
  module.exports = function forEach(iterable, callback) {
    var iterator, k, i, l, s;
    if (!iterable)
      throw new Error("obliterator/forEach: invalid iterable.");
    if (typeof callback !== "function")
      throw new Error("obliterator/forEach: expecting a callback.");
    if (Array.isArray(iterable) || ARRAY_BUFFER_SUPPORT && ArrayBuffer.isView(iterable) || typeof iterable === "string" || iterable.toString() === "[object Arguments]") {
      for (i = 0, l = iterable.length;i < l; i++)
        callback(iterable[i], i);
      return;
    }
    if (typeof iterable.forEach === "function") {
      iterable.forEach(callback);
      return;
    }
    if (SYMBOL_SUPPORT && Symbol.iterator in iterable && typeof iterable.next !== "function") {
      iterable = iterable[Symbol.iterator]();
    }
    if (typeof iterable.next === "function") {
      iterator = iterable;
      i = 0;
      while (s = iterator.next(), s.done !== true) {
        callback(s.value, i);
        i++;
      }
      return;
    }
    for (k in iterable) {
      if (iterable.hasOwnProperty(k)) {
        callback(iterable[k], k);
      }
    }
    return;
  };
});

// node_modules/mnemonist/utils/iterables.js
var require_iterables = __commonJS((exports) => {
  var forEach = require_foreach();
  var typed = require_typed_arrays();
  function isArrayLike(target) {
    return Array.isArray(target) || typed.isTypedArray(target);
  }
  function guessLength(target) {
    if (typeof target.length === "number")
      return target.length;
    if (typeof target.size === "number")
      return target.size;
    return;
  }
  function toArray(target) {
    var l = guessLength(target);
    var array4 = typeof l === "number" ? new Array(l) : [];
    var i = 0;
    forEach(target, function(value) {
      array4[i++] = value;
    });
    return array4;
  }
  function toArrayWithIndices(target) {
    var l = guessLength(target);
    var IndexArray = typeof l === "number" ? typed.getPointerArray(l) : Array;
    var array4 = typeof l === "number" ? new Array(l) : [];
    var indices = typeof l === "number" ? new IndexArray(l) : [];
    var i = 0;
    forEach(target, function(value) {
      array4[i] = value;
      indices[i] = i++;
    });
    return [array4, indices];
  }
  exports.isArrayLike = isArrayLike;
  exports.guessLength = guessLength;
  exports.toArray = toArray;
  exports.toArrayWithIndices = toArrayWithIndices;
});

// node_modules/mnemonist/fixed-deque.js
var require_fixed_deque = __commonJS((exports, module) => {
  var iterables = require_iterables();
  var Iterator = require_iterator2();
  function FixedDeque(ArrayClass, capacity) {
    if (arguments.length < 2)
      throw new Error("mnemonist/fixed-deque: expecting an Array class and a capacity.");
    if (typeof capacity !== "number" || capacity <= 0)
      throw new Error("mnemonist/fixed-deque: `capacity` should be a positive number.");
    this.ArrayClass = ArrayClass;
    this.capacity = capacity;
    this.items = new ArrayClass(this.capacity);
    this.clear();
  }
  FixedDeque.prototype.clear = function() {
    this.start = 0;
    this.size = 0;
  };
  FixedDeque.prototype.push = function(item) {
    if (this.size === this.capacity)
      throw new Error("mnemonist/fixed-deque.push: deque capacity (" + this.capacity + ") exceeded!");
    var index = this.start + this.size;
    if (index >= this.capacity)
      index -= this.capacity;
    this.items[index] = item;
    return ++this.size;
  };
  FixedDeque.prototype.unshift = function(item) {
    if (this.size === this.capacity)
      throw new Error("mnemonist/fixed-deque.unshift: deque capacity (" + this.capacity + ") exceeded!");
    var index = this.start - 1;
    if (this.start === 0)
      index = this.capacity - 1;
    this.items[index] = item;
    this.start = index;
    return ++this.size;
  };
  FixedDeque.prototype.pop = function() {
    if (this.size === 0)
      return;
    this.size--;
    var index = this.start + this.size;
    if (index >= this.capacity)
      index -= this.capacity;
    return this.items[index];
  };
  FixedDeque.prototype.shift = function() {
    if (this.size === 0)
      return;
    var index = this.start;
    this.size--;
    this.start++;
    if (this.start === this.capacity)
      this.start = 0;
    return this.items[index];
  };
  FixedDeque.prototype.peekFirst = function() {
    if (this.size === 0)
      return;
    return this.items[this.start];
  };
  FixedDeque.prototype.peekLast = function() {
    if (this.size === 0)
      return;
    var index = this.start + this.size - 1;
    if (index >= this.capacity)
      index -= this.capacity;
    return this.items[index];
  };
  FixedDeque.prototype.get = function(index) {
    if (this.size === 0 || index >= this.capacity)
      return;
    index = this.start + index;
    if (index >= this.capacity)
      index -= this.capacity;
    return this.items[index];
  };
  FixedDeque.prototype.forEach = function(callback, scope) {
    scope = arguments.length > 1 ? scope : this;
    var c = this.capacity, l = this.size, i = this.start, j = 0;
    while (j < l) {
      callback.call(scope, this.items[i], j, this);
      i++;
      j++;
      if (i === c)
        i = 0;
    }
  };
  FixedDeque.prototype.toArray = function() {
    var offset = this.start + this.size;
    if (offset < this.capacity)
      return this.items.slice(this.start, offset);
    var array4 = new this.ArrayClass(this.size), c = this.capacity, l = this.size, i = this.start, j = 0;
    while (j < l) {
      array4[j] = this.items[i];
      i++;
      j++;
      if (i === c)
        i = 0;
    }
    return array4;
  };
  FixedDeque.prototype.values = function() {
    var items = this.items, c = this.capacity, l = this.size, i = this.start, j = 0;
    return new Iterator(function() {
      if (j >= l)
        return {
          done: true
        };
      var value = items[i];
      i++;
      j++;
      if (i === c)
        i = 0;
      return {
        value,
        done: false
      };
    });
  };
  FixedDeque.prototype.entries = function() {
    var items = this.items, c = this.capacity, l = this.size, i = this.start, j = 0;
    return new Iterator(function() {
      if (j >= l)
        return {
          done: true
        };
      var value = items[i];
      i++;
      if (i === c)
        i = 0;
      return {
        value: [j++, value],
        done: false
      };
    });
  };
  if (typeof Symbol !== "undefined")
    FixedDeque.prototype[Symbol.iterator] = FixedDeque.prototype.values;
  FixedDeque.prototype.inspect = function() {
    var array4 = this.toArray();
    array4.type = this.ArrayClass.name;
    array4.capacity = this.capacity;
    Object.defineProperty(array4, "constructor", {
      value: FixedDeque,
      enumerable: false
    });
    return array4;
  };
  if (typeof Symbol !== "undefined")
    FixedDeque.prototype[Symbol.for("nodejs.util.inspect.custom")] = FixedDeque.prototype.inspect;
  FixedDeque.from = function(iterable, ArrayClass, capacity) {
    if (arguments.length < 3) {
      capacity = iterables.guessLength(iterable);
      if (typeof capacity !== "number")
        throw new Error("mnemonist/fixed-deque.from: could not guess iterable length. Please provide desired capacity as last argument.");
    }
    var deque = new FixedDeque(ArrayClass, capacity);
    if (iterables.isArrayLike(iterable)) {
      var i, l;
      for (i = 0, l = iterable.length;i < l; i++)
        deque.items[i] = iterable[i];
      deque.size = l;
      return deque;
    }
    iterables.forEach(iterable, function(value) {
      deque.push(value);
    });
    return deque;
  };
  module.exports = FixedDeque;
});

// node_modules/mnemonist/fixed-stack.js
var require_fixed_stack = __commonJS((exports, module) => {
  var Iterator = require_iterator2();
  var iterables = require_iterables();
  function FixedStack(ArrayClass, capacity) {
    if (arguments.length < 2)
      throw new Error("mnemonist/fixed-stack: expecting an Array class and a capacity.");
    if (typeof capacity !== "number" || capacity <= 0)
      throw new Error("mnemonist/fixed-stack: `capacity` should be a positive number.");
    this.capacity = capacity;
    this.ArrayClass = ArrayClass;
    this.items = new this.ArrayClass(this.capacity);
    this.clear();
  }
  FixedStack.prototype.clear = function() {
    this.size = 0;
  };
  FixedStack.prototype.push = function(item) {
    if (this.size === this.capacity)
      throw new Error("mnemonist/fixed-stack.push: stack capacity (" + this.capacity + ") exceeded!");
    this.items[this.size++] = item;
    return this.size;
  };
  FixedStack.prototype.pop = function() {
    if (this.size === 0)
      return;
    return this.items[--this.size];
  };
  FixedStack.prototype.peek = function() {
    return this.items[this.size - 1];
  };
  FixedStack.prototype.forEach = function(callback, scope) {
    scope = arguments.length > 1 ? scope : this;
    for (var i = 0, l = this.items.length;i < l; i++)
      callback.call(scope, this.items[l - i - 1], i, this);
  };
  FixedStack.prototype.toArray = function() {
    var array4 = new this.ArrayClass(this.size), l = this.size - 1, i = this.size;
    while (i--)
      array4[i] = this.items[l - i];
    return array4;
  };
  FixedStack.prototype.values = function() {
    var items = this.items, l = this.size, i = 0;
    return new Iterator(function() {
      if (i >= l)
        return {
          done: true
        };
      var value = items[l - i - 1];
      i++;
      return {
        value,
        done: false
      };
    });
  };
  FixedStack.prototype.entries = function() {
    var items = this.items, l = this.size, i = 0;
    return new Iterator(function() {
      if (i >= l)
        return {
          done: true
        };
      var value = items[l - i - 1];
      return {
        value: [i++, value],
        done: false
      };
    });
  };
  if (typeof Symbol !== "undefined")
    FixedStack.prototype[Symbol.iterator] = FixedStack.prototype.values;
  FixedStack.prototype.toString = function() {
    return this.toArray().join(",");
  };
  FixedStack.prototype.toJSON = function() {
    return this.toArray();
  };
  FixedStack.prototype.inspect = function() {
    var array4 = this.toArray();
    array4.type = this.ArrayClass.name;
    array4.capacity = this.capacity;
    Object.defineProperty(array4, "constructor", {
      value: FixedStack,
      enumerable: false
    });
    return array4;
  };
  if (typeof Symbol !== "undefined")
    FixedStack.prototype[Symbol.for("nodejs.util.inspect.custom")] = FixedStack.prototype.inspect;
  FixedStack.from = function(iterable, ArrayClass, capacity) {
    if (arguments.length < 3) {
      capacity = iterables.guessLength(iterable);
      if (typeof capacity !== "number")
        throw new Error("mnemonist/fixed-stack.from: could not guess iterable length. Please provide desired capacity as last argument.");
    }
    var stack = new FixedStack(ArrayClass, capacity);
    if (iterables.isArrayLike(iterable)) {
      var i, l;
      for (i = 0, l = iterable.length;i < l; i++)
        stack.items[i] = iterable[i];
      stack.size = l;
      return stack;
    }
    iterables.forEach(iterable, function(value) {
      stack.push(value);
    });
    return stack;
  };
  module.exports = FixedStack;
});

// node_modules/mnemonist/utils/comparators.js
var require_comparators = __commonJS((exports) => {
  var DEFAULT_COMPARATOR = function(a, b) {
    if (a < b)
      return -1;
    if (a > b)
      return 1;
    return 0;
  };
  var DEFAULT_REVERSE_COMPARATOR = function(a, b) {
    if (a < b)
      return 1;
    if (a > b)
      return -1;
    return 0;
  };
  function reverseComparator(comparator) {
    return function(a, b) {
      return comparator(b, a);
    };
  }
  function createTupleComparator(size) {
    if (size === 2) {
      return function(a, b) {
        if (a[0] < b[0])
          return -1;
        if (a[0] > b[0])
          return 1;
        if (a[1] < b[1])
          return -1;
        if (a[1] > b[1])
          return 1;
        return 0;
      };
    }
    return function(a, b) {
      var i = 0;
      while (i < size) {
        if (a[i] < b[i])
          return -1;
        if (a[i] > b[i])
          return 1;
        i++;
      }
      return 0;
    };
  }
  exports.DEFAULT_COMPARATOR = DEFAULT_COMPARATOR;
  exports.DEFAULT_REVERSE_COMPARATOR = DEFAULT_REVERSE_COMPARATOR;
  exports.reverseComparator = reverseComparator;
  exports.createTupleComparator = createTupleComparator;
});

// node_modules/mnemonist/heap.js
var require_heap = __commonJS((exports, module) => {
  var forEach = require_foreach();
  var comparators = require_comparators();
  var iterables = require_iterables();
  var DEFAULT_COMPARATOR = comparators.DEFAULT_COMPARATOR;
  var reverseComparator = comparators.reverseComparator;
  function siftDown(compare, heap, startIndex, i) {
    var item = heap[i], parentIndex, parent;
    while (i > startIndex) {
      parentIndex = i - 1 >> 1;
      parent = heap[parentIndex];
      if (compare(item, parent) < 0) {
        heap[i] = parent;
        i = parentIndex;
        continue;
      }
      break;
    }
    heap[i] = item;
  }
  function siftUp(compare, heap, i) {
    var endIndex = heap.length, startIndex = i, item = heap[i], childIndex = 2 * i + 1, rightIndex;
    while (childIndex < endIndex) {
      rightIndex = childIndex + 1;
      if (rightIndex < endIndex && compare(heap[childIndex], heap[rightIndex]) >= 0) {
        childIndex = rightIndex;
      }
      heap[i] = heap[childIndex];
      i = childIndex;
      childIndex = 2 * i + 1;
    }
    heap[i] = item;
    siftDown(compare, heap, startIndex, i);
  }
  function push(compare, heap, item) {
    heap.push(item);
    siftDown(compare, heap, 0, heap.length - 1);
  }
  function pop(compare, heap) {
    var lastItem = heap.pop();
    if (heap.length !== 0) {
      var item = heap[0];
      heap[0] = lastItem;
      siftUp(compare, heap, 0);
      return item;
    }
    return lastItem;
  }
  function replace2(compare, heap, item) {
    if (heap.length === 0)
      throw new Error("mnemonist/heap.replace: cannot pop an empty heap.");
    var popped = heap[0];
    heap[0] = item;
    siftUp(compare, heap, 0);
    return popped;
  }
  function pushpop(compare, heap, item) {
    var tmp;
    if (heap.length !== 0 && compare(heap[0], item) < 0) {
      tmp = heap[0];
      heap[0] = item;
      item = tmp;
      siftUp(compare, heap, 0);
    }
    return item;
  }
  function heapify(compare, array4) {
    var n = array4.length, l = n >> 1, i = l;
    while (--i >= 0)
      siftUp(compare, array4, i);
  }
  function consume(compare, heap) {
    var l = heap.length, i = 0;
    var array4 = new Array(l);
    while (i < l)
      array4[i++] = pop(compare, heap);
    return array4;
  }
  function nsmallest(compare, n, iterable) {
    if (arguments.length === 2) {
      iterable = n;
      n = compare;
      compare = DEFAULT_COMPARATOR;
    }
    var reverseCompare = reverseComparator(compare);
    var i, l, v;
    var min = Infinity;
    var result;
    if (n === 1) {
      if (iterables.isArrayLike(iterable)) {
        for (i = 0, l = iterable.length;i < l; i++) {
          v = iterable[i];
          if (min === Infinity || compare(v, min) < 0)
            min = v;
        }
        result = new iterable.constructor(1);
        result[0] = min;
        return result;
      }
      forEach(iterable, function(value) {
        if (min === Infinity || compare(value, min) < 0)
          min = value;
      });
      return [min];
    }
    if (iterables.isArrayLike(iterable)) {
      if (n >= iterable.length)
        return iterable.slice().sort(compare);
      result = iterable.slice(0, n);
      heapify(reverseCompare, result);
      for (i = n, l = iterable.length;i < l; i++)
        if (reverseCompare(iterable[i], result[0]) > 0)
          replace2(reverseCompare, result, iterable[i]);
      return result.sort(compare);
    }
    var size = iterables.guessLength(iterable);
    if (size !== null && size < n)
      n = size;
    result = new Array(n);
    i = 0;
    forEach(iterable, function(value) {
      if (i < n) {
        result[i] = value;
      } else {
        if (i === n)
          heapify(reverseCompare, result);
        if (reverseCompare(value, result[0]) > 0)
          replace2(reverseCompare, result, value);
      }
      i++;
    });
    if (result.length > i)
      result.length = i;
    return result.sort(compare);
  }
  function nlargest(compare, n, iterable) {
    if (arguments.length === 2) {
      iterable = n;
      n = compare;
      compare = DEFAULT_COMPARATOR;
    }
    var reverseCompare = reverseComparator(compare);
    var i, l, v;
    var max = -Infinity;
    var result;
    if (n === 1) {
      if (iterables.isArrayLike(iterable)) {
        for (i = 0, l = iterable.length;i < l; i++) {
          v = iterable[i];
          if (max === -Infinity || compare(v, max) > 0)
            max = v;
        }
        result = new iterable.constructor(1);
        result[0] = max;
        return result;
      }
      forEach(iterable, function(value) {
        if (max === -Infinity || compare(value, max) > 0)
          max = value;
      });
      return [max];
    }
    if (iterables.isArrayLike(iterable)) {
      if (n >= iterable.length)
        return iterable.slice().sort(reverseCompare);
      result = iterable.slice(0, n);
      heapify(compare, result);
      for (i = n, l = iterable.length;i < l; i++)
        if (compare(iterable[i], result[0]) > 0)
          replace2(compare, result, iterable[i]);
      return result.sort(reverseCompare);
    }
    var size = iterables.guessLength(iterable);
    if (size !== null && size < n)
      n = size;
    result = new Array(n);
    i = 0;
    forEach(iterable, function(value) {
      if (i < n) {
        result[i] = value;
      } else {
        if (i === n)
          heapify(compare, result);
        if (compare(value, result[0]) > 0)
          replace2(compare, result, value);
      }
      i++;
    });
    if (result.length > i)
      result.length = i;
    return result.sort(reverseCompare);
  }
  function Heap(comparator) {
    this.clear();
    this.comparator = comparator || DEFAULT_COMPARATOR;
    if (typeof this.comparator !== "function")
      throw new Error("mnemonist/Heap.constructor: given comparator should be a function.");
  }
  Heap.prototype.clear = function() {
    this.items = [];
    this.size = 0;
  };
  Heap.prototype.push = function(item) {
    push(this.comparator, this.items, item);
    return ++this.size;
  };
  Heap.prototype.peek = function() {
    return this.items[0];
  };
  Heap.prototype.pop = function() {
    if (this.size !== 0)
      this.size--;
    return pop(this.comparator, this.items);
  };
  Heap.prototype.replace = function(item) {
    return replace2(this.comparator, this.items, item);
  };
  Heap.prototype.pushpop = function(item) {
    return pushpop(this.comparator, this.items, item);
  };
  Heap.prototype.consume = function() {
    this.size = 0;
    return consume(this.comparator, this.items);
  };
  Heap.prototype.toArray = function() {
    return consume(this.comparator, this.items.slice());
  };
  Heap.prototype.inspect = function() {
    var proxy = this.toArray();
    Object.defineProperty(proxy, "constructor", {
      value: Heap,
      enumerable: false
    });
    return proxy;
  };
  if (typeof Symbol !== "undefined")
    Heap.prototype[Symbol.for("nodejs.util.inspect.custom")] = Heap.prototype.inspect;
  function MaxHeap(comparator) {
    this.clear();
    this.comparator = comparator || DEFAULT_COMPARATOR;
    if (typeof this.comparator !== "function")
      throw new Error("mnemonist/MaxHeap.constructor: given comparator should be a function.");
    this.comparator = reverseComparator(this.comparator);
  }
  MaxHeap.prototype = Heap.prototype;
  Heap.from = function(iterable, comparator) {
    var heap = new Heap(comparator);
    var items;
    if (iterables.isArrayLike(iterable))
      items = iterable.slice();
    else
      items = iterables.toArray(iterable);
    heapify(heap.comparator, items);
    heap.items = items;
    heap.size = items.length;
    return heap;
  };
  MaxHeap.from = function(iterable, comparator) {
    var heap = new MaxHeap(comparator);
    var items;
    if (iterables.isArrayLike(iterable))
      items = iterable.slice();
    else
      items = iterables.toArray(iterable);
    heapify(heap.comparator, items);
    heap.items = items;
    heap.size = items.length;
    return heap;
  };
  Heap.siftUp = siftUp;
  Heap.siftDown = siftDown;
  Heap.push = push;
  Heap.pop = pop;
  Heap.replace = replace2;
  Heap.pushpop = pushpop;
  Heap.heapify = heapify;
  Heap.consume = consume;
  Heap.nsmallest = nsmallest;
  Heap.nlargest = nlargest;
  Heap.MinHeap = Heap;
  Heap.MaxHeap = MaxHeap;
  module.exports = Heap;
});

// node_modules/graphology-indices/neighborhood.js
var require_neighborhood = __commonJS((exports) => {
  var typed = require_typed_arrays();
  var createEdgeWeightGetter = require_getters().createEdgeWeightGetter;
  function upperBoundPerMethod(method, graph) {
    if (method === "outbound" || method === "inbound")
      return graph.directedSize + graph.undirectedSize * 2;
    if (method === "in" || method === "out" || method === "directed")
      return graph.directedSize;
    return graph.undirectedSize * 2;
  }
  function NeighborhoodIndex(graph, method) {
    method = method || "outbound";
    var getNeighbors = graph[method + "Neighbors"].bind(graph);
    var upperBound = upperBoundPerMethod(method, graph);
    var NeighborhoodPointerArray = typed.getPointerArray(upperBound);
    var NodesPointerArray = typed.getPointerArray(graph.order);
    this.graph = graph;
    this.neighborhood = new NodesPointerArray(upperBound);
    this.starts = new NeighborhoodPointerArray(graph.order + 1);
    this.nodes = graph.nodes();
    var ids = {};
    var i, l, j, m, node, neighbors;
    var n = 0;
    for (i = 0, l = graph.order;i < l; i++)
      ids[this.nodes[i]] = i;
    for (i = 0, l = graph.order;i < l; i++) {
      node = this.nodes[i];
      neighbors = getNeighbors(node);
      this.starts[i] = n;
      for (j = 0, m = neighbors.length;j < m; j++)
        this.neighborhood[n++] = ids[neighbors[j]];
    }
    this.starts[i] = upperBound;
  }
  NeighborhoodIndex.prototype.bounds = function(i) {
    return [this.starts[i], this.starts[i + 1]];
  };
  NeighborhoodIndex.prototype.project = function() {
    var self2 = this;
    var projection = {};
    self2.nodes.forEach(function(node, i) {
      projection[node] = Array.from(self2.neighborhood.slice(self2.starts[i], self2.starts[i + 1])).map(function(j) {
        return self2.nodes[j];
      });
    });
    return projection;
  };
  NeighborhoodIndex.prototype.collect = function(results) {
    var i, l;
    var o = {};
    for (i = 0, l = results.length;i < l; i++)
      o[this.nodes[i]] = results[i];
    return o;
  };
  NeighborhoodIndex.prototype.assign = function(prop, results) {
    var i = 0;
    this.graph.updateEachNodeAttributes(function(_, attr) {
      attr[prop] = results[i++];
      return attr;
    }, { attributes: [prop] });
  };
  exports.NeighborhoodIndex = NeighborhoodIndex;
  function WeightedNeighborhoodIndex(graph, getEdgeWeight, method) {
    method = method || "outbound";
    var getEdges = graph[method + "Edges"].bind(graph);
    var upperBound = upperBoundPerMethod(method, graph);
    var NeighborhoodPointerArray = typed.getPointerArray(upperBound);
    var NodesPointerArray = typed.getPointerArray(graph.order);
    var weightGetter = createEdgeWeightGetter(getEdgeWeight).fromMinimalEntry;
    this.graph = graph;
    this.neighborhood = new NodesPointerArray(upperBound);
    this.weights = new Float64Array(upperBound);
    this.outDegrees = new Float64Array(graph.order);
    this.starts = new NeighborhoodPointerArray(graph.order + 1);
    this.nodes = graph.nodes();
    var ids = {};
    var i, l, j, m, node, neighbor, edges, edge, weight;
    var n = 0;
    for (i = 0, l = graph.order;i < l; i++)
      ids[this.nodes[i]] = i;
    for (i = 0, l = graph.order;i < l; i++) {
      node = this.nodes[i];
      edges = getEdges(node);
      this.starts[i] = n;
      for (j = 0, m = edges.length;j < m; j++) {
        edge = edges[j];
        neighbor = graph.opposite(node, edge);
        weight = weightGetter(edge, graph.getEdgeAttributes(edge));
        this.neighborhood[n] = ids[neighbor];
        this.weights[n++] = weight;
        this.outDegrees[i] += weight;
      }
    }
    this.starts[i] = upperBound;
  }
  WeightedNeighborhoodIndex.prototype.bounds = NeighborhoodIndex.prototype.bounds;
  WeightedNeighborhoodIndex.prototype.project = NeighborhoodIndex.prototype.project;
  WeightedNeighborhoodIndex.prototype.collect = NeighborhoodIndex.prototype.collect;
  WeightedNeighborhoodIndex.prototype.assign = NeighborhoodIndex.prototype.assign;
  exports.WeightedNeighborhoodIndex = WeightedNeighborhoodIndex;
});

// node_modules/graphology-shortest-path/indexed-brandes.js
var require_indexed_brandes = __commonJS((exports) => {
  var FixedDeque = require_fixed_deque();
  var FixedStack = require_fixed_stack();
  var Heap = require_heap();
  var typed = require_typed_arrays();
  var neighborhoodIndices = require_neighborhood();
  var NeighborhoodIndex = neighborhoodIndices.NeighborhoodIndex;
  var WeightedNeighborhoodIndex = neighborhoodIndices.WeightedNeighborhoodIndex;
  exports.createUnweightedIndexedBrandes = function createUnweightedIndexedBrandes(graph) {
    var neighborhoodIndex = new NeighborhoodIndex(graph);
    var { neighborhood, starts } = neighborhoodIndex;
    var order = graph.order;
    var S = new FixedStack(typed.getPointerArray(order), order), sigma = new Uint32Array(order), P = new Array(order), D = new Int32Array(order);
    var Q = new FixedDeque(Uint32Array, order);
    var brandes = function(sourceIndex) {
      var Dv, sigmav, start, stop, j, v, w;
      for (v = 0;v < order; v++) {
        P[v] = [];
        sigma[v] = 0;
        D[v] = -1;
      }
      sigma[sourceIndex] = 1;
      D[sourceIndex] = 0;
      Q.push(sourceIndex);
      while (Q.size !== 0) {
        v = Q.shift();
        S.push(v);
        Dv = D[v];
        sigmav = sigma[v];
        start = starts[v];
        stop = starts[v + 1];
        for (j = start;j < stop; j++) {
          w = neighborhood[j];
          if (D[w] === -1) {
            Q.push(w);
            D[w] = Dv + 1;
          }
          if (D[w] === Dv + 1) {
            sigma[w] += sigmav;
            P[w].push(v);
          }
        }
      }
      return [S, P, sigma];
    };
    brandes.index = neighborhoodIndex;
    return brandes;
  };
  function BRANDES_DIJKSTRA_HEAP_COMPARATOR(a, b) {
    if (a[0] > b[0])
      return 1;
    if (a[0] < b[0])
      return -1;
    if (a[1] > b[1])
      return 1;
    if (a[1] < b[1])
      return -1;
    if (a[2] > b[2])
      return 1;
    if (a[2] < b[2])
      return -1;
    if (a[3] > b[3])
      return 1;
    if (a[3] < b[3])
      return -1;
    return 0;
  }
  exports.createDijkstraIndexedBrandes = function createDijkstraIndexedBrandes(graph, getEdgeWeight) {
    var neighborhoodIndex = new WeightedNeighborhoodIndex(graph, getEdgeWeight || "weight");
    var { neighborhood, weights, starts } = neighborhoodIndex;
    var order = graph.order;
    var S = new FixedStack(typed.getPointerArray(order), order), sigma = new Uint32Array(order), P = new Array(order), D = new Float64Array(order), seen = new Float64Array(order);
    var Q = new Heap(BRANDES_DIJKSTRA_HEAP_COMPARATOR);
    var brandes = function(sourceIndex) {
      var start, stop, item, dist, pred, cost, j, v, w;
      var count = 0;
      for (v = 0;v < order; v++) {
        P[v] = [];
        sigma[v] = 0;
        D[v] = -1;
        seen[v] = -1;
      }
      sigma[sourceIndex] = 1;
      seen[sourceIndex] = 0;
      Q.push([0, count++, sourceIndex, sourceIndex]);
      while (Q.size !== 0) {
        item = Q.pop();
        dist = item[0];
        pred = item[2];
        v = item[3];
        if (D[v] !== -1)
          continue;
        S.push(v);
        D[v] = dist;
        sigma[v] += sigma[pred];
        start = starts[v];
        stop = starts[v + 1];
        for (j = start;j < stop; j++) {
          w = neighborhood[j];
          cost = dist + weights[j];
          if (D[w] === -1 && (seen[w] === -1 || cost < seen[w])) {
            seen[w] = cost;
            Q.push([cost, count++, v, w]);
            sigma[w] = 0;
            P[w] = [v];
          } else if (cost === seen[w]) {
            sigma[w] += sigma[v];
            P[w].push(v);
          }
        }
      }
      return [S, P, sigma];
    };
    brandes.index = neighborhoodIndex;
    return brandes;
  };
});

// node_modules/graphology-metrics/centrality/betweenness.js
var require_betweenness = __commonJS((exports, module) => {
  var isGraph2 = require_is_graph();
  var lib = require_indexed_brandes();
  var resolveDefaults = require_defaults3();
  var createUnweightedIndexedBrandes = lib.createUnweightedIndexedBrandes;
  var createDijkstraIndexedBrandes = lib.createDijkstraIndexedBrandes;
  var DEFAULTS2 = {
    nodeCentralityAttribute: "betweennessCentrality",
    getEdgeWeight: "weight",
    normalized: true
  };
  function abstractBetweennessCentrality(assign2, graph, options2) {
    if (!isGraph2(graph))
      throw new Error("graphology-centrality/beetweenness-centrality: the given graph is not a valid graphology instance.");
    options2 = resolveDefaults(options2, DEFAULTS2);
    var outputName = options2.nodeCentralityAttribute;
    var normalized = options2.normalized;
    var brandes = options2.getEdgeWeight ? createDijkstraIndexedBrandes(graph, options2.getEdgeWeight) : createUnweightedIndexedBrandes(graph);
    var N = graph.order;
    var result, S, P, sigma, coefficient, i, j, m, v, w;
    var delta = new Float64Array(N);
    var centralities = new Float64Array(N);
    for (i = 0;i < N; i++) {
      result = brandes(i);
      S = result[0];
      P = result[1];
      sigma = result[2];
      j = S.size;
      while (j--)
        delta[S.items[S.size - j]] = 0;
      while (S.size !== 0) {
        w = S.pop();
        coefficient = (1 + delta[w]) / sigma[w];
        for (j = 0, m = P[w].length;j < m; j++) {
          v = P[w][j];
          delta[v] += sigma[v] * coefficient;
        }
        if (w !== i)
          centralities[w] += delta[w];
      }
    }
    var scale = null;
    if (normalized)
      scale = N <= 2 ? null : 1 / ((N - 1) * (N - 2));
    else
      scale = graph.type === "undirected" ? 0.5 : null;
    if (scale !== null) {
      for (i = 0;i < N; i++)
        centralities[i] *= scale;
    }
    if (assign2)
      return brandes.index.assign(outputName, centralities);
    return brandes.index.collect(centralities);
  }
  var betweennessCentrality = abstractBetweennessCentrality.bind(null, false);
  betweennessCentrality.assign = abstractBetweennessCentrality.bind(null, true);
  module.exports = betweennessCentrality;
});

// node_modules/graphology-metrics/centrality/pagerank.js
var require_pagerank = __commonJS((exports, module) => {
  var isGraph2 = require_is_graph();
  var resolveDefaults = require_defaults3();
  var WeightedNeighborhoodIndex = require_neighborhood().WeightedNeighborhoodIndex;
  var DEFAULTS2 = {
    nodePagerankAttribute: "pagerank",
    getEdgeWeight: "weight",
    alpha: 0.85,
    maxIterations: 100,
    tolerance: 0.000001
  };
  function abstractPagerank(assign2, graph, options2) {
    if (!isGraph2(graph))
      throw new Error("graphology-metrics/centrality/pagerank: the given graph is not a valid graphology instance.");
    options2 = resolveDefaults(options2, DEFAULTS2);
    var alpha = options2.alpha;
    var maxIterations = options2.maxIterations;
    var tolerance = options2.tolerance;
    var pagerankAttribute = options2.nodePagerankAttribute;
    var N = graph.order;
    var p = 1 / N;
    var index = new WeightedNeighborhoodIndex(graph, options2.getEdgeWeight);
    var i, j, l, d;
    var x = new Float64Array(graph.order);
    var normalizedEdgeWeights = new Float64Array(index.weights.length);
    var danglingNodes = [];
    for (i = 0;i < N; i++) {
      x[i] = p;
      l = index.starts[i + 1];
      d = index.outDegrees[i];
      if (d === 0)
        danglingNodes.push(i);
      for (j = index.starts[i];j < l; j++) {
        normalizedEdgeWeights[j] = index.weights[j] / d;
      }
    }
    var iteration = 0;
    var error49 = 0;
    var dangleSum, neighbor, xLast;
    var converged = false;
    while (iteration < maxIterations) {
      xLast = x;
      x = new Float64Array(graph.order);
      dangleSum = 0;
      for (i = 0, l = danglingNodes.length;i < l; i++)
        dangleSum += xLast[danglingNodes[i]];
      dangleSum *= alpha;
      for (i = 0;i < N; i++) {
        l = index.starts[i + 1];
        for (j = index.starts[i];j < l; j++) {
          neighbor = index.neighborhood[j];
          x[neighbor] += alpha * xLast[i] * normalizedEdgeWeights[j];
        }
        x[i] += dangleSum * p + (1 - alpha) * p;
      }
      error49 = 0;
      for (i = 0;i < N; i++) {
        error49 += Math.abs(x[i] - xLast[i]);
      }
      if (error49 < N * tolerance) {
        converged = true;
        break;
      }
      iteration++;
    }
    if (!converged)
      throw Error("graphology-metrics/centrality/pagerank: failed to converge.");
    if (assign2) {
      index.assign(pagerankAttribute, x);
      return;
    }
    return index.collect(x);
  }
  var pagerank = abstractPagerank.bind(null, false);
  pagerank.assign = abstractPagerank.bind(null, true);
  module.exports = pagerank;
});

// node_modules/mnemonist/queue.js
var require_queue = __commonJS((exports, module) => {
  var Iterator = require_iterator2();
  var forEach = require_foreach();
  function Queue() {
    this.clear();
  }
  Queue.prototype.clear = function() {
    this.items = [];
    this.offset = 0;
    this.size = 0;
  };
  Queue.prototype.enqueue = function(item) {
    this.items.push(item);
    return ++this.size;
  };
  Queue.prototype.dequeue = function() {
    if (!this.size)
      return;
    var item = this.items[this.offset];
    if (++this.offset * 2 >= this.items.length) {
      this.items = this.items.slice(this.offset);
      this.offset = 0;
    }
    this.size--;
    return item;
  };
  Queue.prototype.peek = function() {
    if (!this.size)
      return;
    return this.items[this.offset];
  };
  Queue.prototype.forEach = function(callback, scope) {
    scope = arguments.length > 1 ? scope : this;
    for (var i = this.offset, j = 0, l = this.items.length;i < l; i++, j++)
      callback.call(scope, this.items[i], j, this);
  };
  Queue.prototype.toArray = function() {
    return this.items.slice(this.offset);
  };
  Queue.prototype.values = function() {
    var items = this.items, i = this.offset;
    return new Iterator(function() {
      if (i >= items.length)
        return {
          done: true
        };
      var value = items[i];
      i++;
      return {
        value,
        done: false
      };
    });
  };
  Queue.prototype.entries = function() {
    var items = this.items, i = this.offset, j = 0;
    return new Iterator(function() {
      if (i >= items.length)
        return {
          done: true
        };
      var value = items[i];
      i++;
      return {
        value: [j++, value],
        done: false
      };
    });
  };
  if (typeof Symbol !== "undefined")
    Queue.prototype[Symbol.iterator] = Queue.prototype.values;
  Queue.prototype.toString = function() {
    return this.toArray().join(",");
  };
  Queue.prototype.toJSON = function() {
    return this.toArray();
  };
  Queue.prototype.inspect = function() {
    var array4 = this.toArray();
    Object.defineProperty(array4, "constructor", {
      value: Queue,
      enumerable: false
    });
    return array4;
  };
  if (typeof Symbol !== "undefined")
    Queue.prototype[Symbol.for("nodejs.util.inspect.custom")] = Queue.prototype.inspect;
  Queue.from = function(iterable) {
    var queue = new Queue;
    forEach(iterable, function(value) {
      queue.enqueue(value);
    });
    return queue;
  };
  Queue.of = function() {
    return Queue.from(arguments);
  };
  module.exports = Queue;
});

// node_modules/@yomguithereal/helpers/extend.js
var require_extend = __commonJS((exports, module) => {
  module.exports = function extend3(array4, values) {
    var l2 = values.length;
    if (l2 === 0)
      return;
    var l1 = array4.length;
    array4.length += l2;
    for (var i = 0;i < l2; i++)
      array4[l1 + i] = values[i];
  };
});

// node_modules/graphology-indices/bfs-queue.js
var require_bfs_queue = __commonJS((exports, module) => {
  var FixedDeque = require_fixed_deque();
  function BFSQueue(graph) {
    this.graph = graph;
    this.queue = new FixedDeque(Array, graph.order);
    this.seen = new Set;
    this.size = 0;
  }
  BFSQueue.prototype.hasAlreadySeenEverything = function() {
    return this.seen.size === this.graph.order;
  };
  BFSQueue.prototype.countUnseenNodes = function() {
    return this.graph.order - this.seen.size;
  };
  BFSQueue.prototype.forEachNodeYetUnseen = function(callback) {
    var seen = this.seen;
    var graph = this.graph;
    graph.someNode(function(node, attr) {
      if (seen.size === graph.order)
        return true;
      if (seen.has(node))
        return false;
      var shouldBreak = callback(node, attr);
      if (shouldBreak)
        return true;
      return false;
    });
  };
  BFSQueue.prototype.has = function(node) {
    return this.seen.has(node);
  };
  BFSQueue.prototype.push = function(node) {
    var seenSizeBefore = this.seen.size;
    this.seen.add(node);
    if (seenSizeBefore === this.seen.size)
      return false;
    this.queue.push(node);
    this.size++;
    return true;
  };
  BFSQueue.prototype.pushWith = function(node, item) {
    var seenSizeBefore = this.seen.size;
    this.seen.add(node);
    if (seenSizeBefore === this.seen.size)
      return false;
    this.queue.push(item);
    this.size++;
    return true;
  };
  BFSQueue.prototype.shift = function() {
    var item = this.queue.shift();
    this.size = this.queue.size;
    return item;
  };
  module.exports = BFSQueue;
});

// node_modules/graphology-traversal/utils.js
var require_utils3 = __commonJS((exports) => {
  function TraversalRecord(node, attr, depth) {
    this.node = node;
    this.attributes = attr;
    this.depth = depth;
  }
  function capitalize(string7) {
    return string7[0].toUpperCase() + string7.slice(1);
  }
  exports.TraversalRecord = TraversalRecord;
  exports.capitalize = capitalize;
});

// node_modules/graphology-traversal/bfs.js
var require_bfs = __commonJS((exports) => {
  var isGraph3 = require_is_graph();
  var BFSQueue = require_bfs_queue();
  var utils = require_utils3();
  var TraversalRecord = utils.TraversalRecord;
  var capitalize = utils.capitalize;
  function abstractBfs(graph, startingNode, callback, options2) {
    options2 = options2 || {};
    if (!isGraph3(graph))
      throw new Error("graphology-traversal/bfs: expecting a graphology instance.");
    if (typeof callback !== "function")
      throw new Error("graphology-traversal/bfs: given callback is not a function.");
    if (graph.order === 0)
      return;
    var queue = new BFSQueue(graph);
    var forEachNeighbor2 = graph["forEach" + capitalize(options2.mode || "outbound") + "Neighbor"].bind(graph);
    var forEachNode;
    if (startingNode === null) {
      forEachNode = queue.forEachNodeYetUnseen.bind(queue);
    } else {
      forEachNode = function(fn) {
        startingNode = "" + startingNode;
        fn(startingNode, graph.getNodeAttributes(startingNode));
      };
    }
    var record4, stop;
    function visit(neighbor, attr) {
      queue.pushWith(neighbor, new TraversalRecord(neighbor, attr, record4.depth + 1));
    }
    forEachNode(function(node, attr) {
      queue.pushWith(node, new TraversalRecord(node, attr, 0));
      while (queue.size !== 0) {
        record4 = queue.shift();
        stop = callback(record4.node, record4.attributes, record4.depth);
        if (stop === true)
          continue;
        forEachNeighbor2(record4.node, visit);
      }
    });
  }
  exports.bfs = function(graph, callback, options2) {
    return abstractBfs(graph, null, callback, options2);
  };
  exports.bfsFromNode = abstractBfs;
});

// node_modules/graphology-traversal/dfs.js
var require_dfs = __commonJS((exports) => {
  var isGraph3 = require_is_graph();
  var DFSStack2 = require_dfs_stack();
  var utils = require_utils3();
  var TraversalRecord = utils.TraversalRecord;
  var capitalize = utils.capitalize;
  function abstractDfs(graph, startingNode, callback, options2) {
    options2 = options2 || {};
    if (!isGraph3(graph))
      throw new Error("graphology-traversal/dfs: expecting a graphology instance.");
    if (typeof callback !== "function")
      throw new Error("graphology-traversal/dfs: given callback is not a function.");
    if (graph.order === 0)
      return;
    var stack = new DFSStack2(graph);
    var forEachNeighbor2 = graph["forEach" + capitalize(options2.mode || "outbound") + "Neighbor"].bind(graph);
    var forEachNode;
    if (startingNode === null) {
      forEachNode = stack.forEachNodeYetUnseen.bind(stack);
    } else {
      forEachNode = function(fn) {
        startingNode = "" + startingNode;
        fn(startingNode, graph.getNodeAttributes(startingNode));
      };
    }
    var record4, stop;
    function visit(neighbor, attr) {
      stack.pushWith(neighbor, new TraversalRecord(neighbor, attr, record4.depth + 1));
    }
    forEachNode(function(node, attr) {
      stack.pushWith(node, new TraversalRecord(node, attr, 0));
      while (stack.size !== 0) {
        record4 = stack.pop();
        stop = callback(record4.node, record4.attributes, record4.depth);
        if (stop === true)
          continue;
        forEachNeighbor2(record4.node, visit);
      }
    });
  }
  exports.dfs = function(graph, callback, options2) {
    return abstractDfs(graph, null, callback, options2);
  };
  exports.dfsFromNode = abstractDfs;
});

// node_modules/sharp/lib/is.js
var require_is = __commonJS((exports, module) => {
  /*!
    Copyright 2013 Lovell Fuller and others.
    SPDX-License-Identifier: Apache-2.0
  */
  var defined = (val) => typeof val !== "undefined" && val !== null;
  var object5 = (val) => typeof val === "object";
  var plainObject = (val) => Object.prototype.toString.call(val) === "[object Object]";
  var fn = (val) => typeof val === "function";
  var bool = (val) => typeof val === "boolean";
  var buffer = (val) => val instanceof Buffer;
  var typedArray = (val) => {
    if (defined(val)) {
      switch (val.constructor) {
        case Uint8Array:
        case Uint8ClampedArray:
        case Int8Array:
        case Uint16Array:
        case Int16Array:
        case Uint32Array:
        case Int32Array:
        case Float32Array:
        case Float64Array:
          return true;
      }
    }
    return false;
  };
  var arrayBuffer = (val) => val instanceof ArrayBuffer;
  var string7 = (val) => typeof val === "string" && val.length > 0;
  var number7 = (val) => typeof val === "number" && !Number.isNaN(val);
  var integer3 = (val) => Number.isInteger(val);
  var inRange = (val, min, max) => val >= min && val <= max;
  var inArray2 = (val, list) => list.includes(val);
  var invalidParameterError = (name, expected, actual) => new Error(`Expected ${expected} for ${name} but received ${actual} of type ${typeof actual}`);
  var nativeError = (native, context) => {
    context.message = native.message;
    return context;
  };
  module.exports = {
    defined,
    object: object5,
    plainObject,
    fn,
    bool,
    buffer,
    typedArray,
    arrayBuffer,
    string: string7,
    number: number7,
    integer: integer3,
    inRange,
    inArray: inArray2,
    invalidParameterError,
    nativeError
  };
});

// node_modules/detect-libc/lib/process.js
var require_process = __commonJS((exports, module) => {
  var isLinux = () => process.platform === "linux";
  var report = null;
  var getReport = () => {
    if (!report) {
      if (isLinux() && process.report) {
        const orig = process.report.excludeNetwork;
        process.report.excludeNetwork = true;
        report = process.report.getReport();
        process.report.excludeNetwork = orig;
      } else {
        report = {};
      }
    }
    return report;
  };
  module.exports = { isLinux, getReport };
});

// node_modules/detect-libc/lib/filesystem.js
var require_filesystem = __commonJS((exports, module) => {
  var fs3 = __require("fs");
  var LDD_PATH = "/usr/bin/ldd";
  var SELF_PATH = "/proc/self/exe";
  var MAX_LENGTH = 2048;
  var readFileSync6 = (path2) => {
    const fd = fs3.openSync(path2, "r");
    const buffer = Buffer.alloc(MAX_LENGTH);
    const bytesRead = fs3.readSync(fd, buffer, 0, MAX_LENGTH, 0);
    fs3.close(fd, () => {});
    return buffer.subarray(0, bytesRead);
  };
  var readFile = (path2) => new Promise((resolve4, reject) => {
    fs3.open(path2, "r", (err, fd) => {
      if (err) {
        reject(err);
      } else {
        const buffer = Buffer.alloc(MAX_LENGTH);
        fs3.read(fd, buffer, 0, MAX_LENGTH, 0, (_, bytesRead) => {
          resolve4(buffer.subarray(0, bytesRead));
          fs3.close(fd, () => {});
        });
      }
    });
  });
  module.exports = {
    LDD_PATH,
    SELF_PATH,
    readFileSync: readFileSync6,
    readFile
  };
});

// node_modules/detect-libc/lib/elf.js
var require_elf = __commonJS((exports, module) => {
  var interpreterPath = (elf) => {
    if (elf.length < 64) {
      return null;
    }
    if (elf.readUInt32BE(0) !== 2135247942) {
      return null;
    }
    if (elf.readUInt8(4) !== 2) {
      return null;
    }
    if (elf.readUInt8(5) !== 1) {
      return null;
    }
    const offset = elf.readUInt32LE(32);
    const size = elf.readUInt16LE(54);
    const count = elf.readUInt16LE(56);
    for (let i = 0;i < count; i++) {
      const headerOffset = offset + i * size;
      const type = elf.readUInt32LE(headerOffset);
      if (type === 3) {
        const fileOffset = elf.readUInt32LE(headerOffset + 8);
        const fileSize = elf.readUInt32LE(headerOffset + 32);
        return elf.subarray(fileOffset, fileOffset + fileSize).toString().replace(/\0.*$/g, "");
      }
    }
    return null;
  };
  module.exports = {
    interpreterPath
  };
});

// node_modules/detect-libc/lib/detect-libc.js
var require_detect_libc = __commonJS((exports, module) => {
  var childProcess = __require("child_process");
  var { isLinux, getReport } = require_process();
  var { LDD_PATH, SELF_PATH, readFile, readFileSync: readFileSync6 } = require_filesystem();
  var { interpreterPath } = require_elf();
  var cachedFamilyInterpreter;
  var cachedFamilyFilesystem;
  var cachedVersionFilesystem;
  var command = "getconf GNU_LIBC_VERSION 2>&1 || true; ldd --version 2>&1 || true";
  var commandOut = "";
  var safeCommand = () => {
    if (!commandOut) {
      return new Promise((resolve4) => {
        childProcess.exec(command, (err, out) => {
          commandOut = err ? " " : out;
          resolve4(commandOut);
        });
      });
    }
    return commandOut;
  };
  var safeCommandSync = () => {
    if (!commandOut) {
      try {
        commandOut = childProcess.execSync(command, { encoding: "utf8" });
      } catch (_err) {
        commandOut = " ";
      }
    }
    return commandOut;
  };
  var GLIBC = "glibc";
  var RE_GLIBC_VERSION = /LIBC[a-z0-9 \-).]*?(\d+\.\d+)/i;
  var MUSL = "musl";
  var isFileMusl = (f) => f.includes("libc.musl-") || f.includes("ld-musl-");
  var familyFromReport = () => {
    const report = getReport();
    if (report.header && report.header.glibcVersionRuntime) {
      return GLIBC;
    }
    if (Array.isArray(report.sharedObjects)) {
      if (report.sharedObjects.some(isFileMusl)) {
        return MUSL;
      }
    }
    return null;
  };
  var familyFromCommand = (out) => {
    const [getconf, ldd1] = out.split(/[\r\n]+/);
    if (getconf && getconf.includes(GLIBC)) {
      return GLIBC;
    }
    if (ldd1 && ldd1.includes(MUSL)) {
      return MUSL;
    }
    return null;
  };
  var familyFromInterpreterPath = (path2) => {
    if (path2) {
      if (path2.includes("/ld-musl-")) {
        return MUSL;
      } else if (path2.includes("/ld-linux-")) {
        return GLIBC;
      }
    }
    return null;
  };
  var getFamilyFromLddContent = (content) => {
    content = content.toString();
    if (content.includes("musl")) {
      return MUSL;
    }
    if (content.includes("GNU C Library")) {
      return GLIBC;
    }
    return null;
  };
  var familyFromFilesystem = async () => {
    if (cachedFamilyFilesystem !== undefined) {
      return cachedFamilyFilesystem;
    }
    cachedFamilyFilesystem = null;
    try {
      const lddContent = await readFile(LDD_PATH);
      cachedFamilyFilesystem = getFamilyFromLddContent(lddContent);
    } catch (e) {}
    return cachedFamilyFilesystem;
  };
  var familyFromFilesystemSync = () => {
    if (cachedFamilyFilesystem !== undefined) {
      return cachedFamilyFilesystem;
    }
    cachedFamilyFilesystem = null;
    try {
      const lddContent = readFileSync6(LDD_PATH);
      cachedFamilyFilesystem = getFamilyFromLddContent(lddContent);
    } catch (e) {}
    return cachedFamilyFilesystem;
  };
  var familyFromInterpreter = async () => {
    if (cachedFamilyInterpreter !== undefined) {
      return cachedFamilyInterpreter;
    }
    cachedFamilyInterpreter = null;
    try {
      const selfContent = await readFile(SELF_PATH);
      const path2 = interpreterPath(selfContent);
      cachedFamilyInterpreter = familyFromInterpreterPath(path2);
    } catch (e) {}
    return cachedFamilyInterpreter;
  };
  var familyFromInterpreterSync = () => {
    if (cachedFamilyInterpreter !== undefined) {
      return cachedFamilyInterpreter;
    }
    cachedFamilyInterpreter = null;
    try {
      const selfContent = readFileSync6(SELF_PATH);
      const path2 = interpreterPath(selfContent);
      cachedFamilyInterpreter = familyFromInterpreterPath(path2);
    } catch (e) {}
    return cachedFamilyInterpreter;
  };
  var family = async () => {
    let family2 = null;
    if (isLinux()) {
      family2 = await familyFromInterpreter();
      if (!family2) {
        family2 = await familyFromFilesystem();
        if (!family2) {
          family2 = familyFromReport();
        }
        if (!family2) {
          const out = await safeCommand();
          family2 = familyFromCommand(out);
        }
      }
    }
    return family2;
  };
  var familySync = () => {
    let family2 = null;
    if (isLinux()) {
      family2 = familyFromInterpreterSync();
      if (!family2) {
        family2 = familyFromFilesystemSync();
        if (!family2) {
          family2 = familyFromReport();
        }
        if (!family2) {
          const out = safeCommandSync();
          family2 = familyFromCommand(out);
        }
      }
    }
    return family2;
  };
  var isNonGlibcLinux = async () => isLinux() && await family() !== GLIBC;
  var isNonGlibcLinuxSync = () => isLinux() && familySync() !== GLIBC;
  var versionFromFilesystem = async () => {
    if (cachedVersionFilesystem !== undefined) {
      return cachedVersionFilesystem;
    }
    cachedVersionFilesystem = null;
    try {
      const lddContent = await readFile(LDD_PATH);
      const versionMatch = lddContent.match(RE_GLIBC_VERSION);
      if (versionMatch) {
        cachedVersionFilesystem = versionMatch[1];
      }
    } catch (e) {}
    return cachedVersionFilesystem;
  };
  var versionFromFilesystemSync = () => {
    if (cachedVersionFilesystem !== undefined) {
      return cachedVersionFilesystem;
    }
    cachedVersionFilesystem = null;
    try {
      const lddContent = readFileSync6(LDD_PATH);
      const versionMatch = lddContent.match(RE_GLIBC_VERSION);
      if (versionMatch) {
        cachedVersionFilesystem = versionMatch[1];
      }
    } catch (e) {}
    return cachedVersionFilesystem;
  };
  var versionFromReport = () => {
    const report = getReport();
    if (report.header && report.header.glibcVersionRuntime) {
      return report.header.glibcVersionRuntime;
    }
    return null;
  };
  var versionSuffix = (s) => s.trim().split(/\s+/)[1];
  var versionFromCommand = (out) => {
    const [getconf, ldd1, ldd2] = out.split(/[\r\n]+/);
    if (getconf && getconf.includes(GLIBC)) {
      return versionSuffix(getconf);
    }
    if (ldd1 && ldd2 && ldd1.includes(MUSL)) {
      return versionSuffix(ldd2);
    }
    return null;
  };
  var version5 = async () => {
    let version6 = null;
    if (isLinux()) {
      version6 = await versionFromFilesystem();
      if (!version6) {
        version6 = versionFromReport();
      }
      if (!version6) {
        const out = await safeCommand();
        version6 = versionFromCommand(out);
      }
    }
    return version6;
  };
  var versionSync = () => {
    let version6 = null;
    if (isLinux()) {
      version6 = versionFromFilesystemSync();
      if (!version6) {
        version6 = versionFromReport();
      }
      if (!version6) {
        const out = safeCommandSync();
        version6 = versionFromCommand(out);
      }
    }
    return version6;
  };
  module.exports = {
    GLIBC,
    MUSL,
    family,
    familySync,
    isNonGlibcLinux,
    isNonGlibcLinuxSync,
    version: version5,
    versionSync
  };
});

// node_modules/semver/internal/debug.js
var require_debug = __commonJS((exports, module) => {
  var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {};
  module.exports = debug;
});

// node_modules/semver/internal/constants.js
var require_constants3 = __commonJS((exports, module) => {
  var SEMVER_SPEC_VERSION = "2.0.0";
  var MAX_LENGTH = 256;
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MAX_SAFE_COMPONENT_LENGTH = 16;
  var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
  var RELEASE_TYPES = [
    "major",
    "premajor",
    "minor",
    "preminor",
    "patch",
    "prepatch",
    "prerelease"
  ];
  module.exports = {
    MAX_LENGTH,
    MAX_SAFE_COMPONENT_LENGTH,
    MAX_SAFE_BUILD_LENGTH,
    MAX_SAFE_INTEGER,
    RELEASE_TYPES,
    SEMVER_SPEC_VERSION,
    FLAG_INCLUDE_PRERELEASE: 1,
    FLAG_LOOSE: 2
  };
});

// node_modules/semver/internal/re.js
var require_re = __commonJS((exports, module) => {
  var {
    MAX_SAFE_COMPONENT_LENGTH,
    MAX_SAFE_BUILD_LENGTH,
    MAX_LENGTH
  } = require_constants3();
  var debug = require_debug();
  exports = module.exports = {};
  var re = exports.re = [];
  var safeRe = exports.safeRe = [];
  var src = exports.src = [];
  var safeSrc = exports.safeSrc = [];
  var t = exports.t = {};
  var R = 0;
  var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
  var safeRegexReplacements = [
    ["\\s", 1],
    ["\\d", MAX_LENGTH],
    [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
  ];
  var makeSafeRegex = (value) => {
    for (const [token, max] of safeRegexReplacements) {
      value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
    }
    return value;
  };
  var createToken = (name, value, isGlobal) => {
    const safe = makeSafeRegex(value);
    const index = R++;
    debug(name, index, value);
    t[name] = index;
    src[index] = value;
    safeSrc[index] = safe;
    re[index] = new RegExp(value, isGlobal ? "g" : undefined);
    safeRe[index] = new RegExp(safe, isGlobal ? "g" : undefined);
  };
  createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
  createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
  createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.` + `(${src[t.NUMERICIDENTIFIER]})\\.` + `(${src[t.NUMERICIDENTIFIER]})`);
  createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIER]})`);
  createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
  createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
  createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
  createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
  createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
  createToken("FULL", `^${src[t.FULLPLAIN]}$`);
  createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
  createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
  createToken("GTLT", "((?:<|>)?=?)");
  createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
  createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
  createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t.XRANGEIDENTIFIER]})` + `(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?` + `)?)?`);
  createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?` + `)?)?`);
  createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
  createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
  createToken("COERCEPLAIN", `${"(^|[^\\d])" + "(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
  createToken("COERCE", `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
  createToken("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?` + `(?:${src[t.BUILD]})?` + `(?:$|[^\\d])`);
  createToken("COERCERTL", src[t.COERCE], true);
  createToken("COERCERTLFULL", src[t.COERCEFULL], true);
  createToken("LONETILDE", "(?:~>?)");
  createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
  exports.tildeTrimReplace = "$1~";
  createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
  createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
  createToken("LONECARET", "(?:\\^)");
  createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
  exports.caretTrimReplace = "$1^";
  createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
  createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
  createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
  createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
  createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
  exports.comparatorTrimReplace = "$1$2$3";
  createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})` + `\\s+-\\s+` + `(${src[t.XRANGEPLAIN]})` + `\\s*$`);
  createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})` + `\\s+-\\s+` + `(${src[t.XRANGEPLAINLOOSE]})` + `\\s*$`);
  createToken("STAR", "(<|>)?=?\\s*\\*");
  createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
  createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
});

// node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS((exports, module) => {
  var looseOption = Object.freeze({ loose: true });
  var emptyOpts = Object.freeze({});
  var parseOptions = (options2) => {
    if (!options2) {
      return emptyOpts;
    }
    if (typeof options2 !== "object") {
      return looseOption;
    }
    return options2;
  };
  module.exports = parseOptions;
});

// node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS((exports, module) => {
  var numeric = /^[0-9]+$/;
  var compareIdentifiers = (a, b) => {
    if (typeof a === "number" && typeof b === "number") {
      return a === b ? 0 : a < b ? -1 : 1;
    }
    const anum = numeric.test(a);
    const bnum = numeric.test(b);
    if (anum && bnum) {
      a = +a;
      b = +b;
    }
    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
  };
  var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
  module.exports = {
    compareIdentifiers,
    rcompareIdentifiers
  };
});

// node_modules/semver/classes/semver.js
var require_semver = __commonJS((exports, module) => {
  var debug = require_debug();
  var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants3();
  var { safeRe: re, t } = require_re();
  var parseOptions = require_parse_options();
  var { compareIdentifiers } = require_identifiers();

  class SemVer {
    constructor(version5, options2) {
      options2 = parseOptions(options2);
      if (version5 instanceof SemVer) {
        if (version5.loose === !!options2.loose && version5.includePrerelease === !!options2.includePrerelease) {
          return version5;
        } else {
          version5 = version5.version;
        }
      } else if (typeof version5 !== "string") {
        throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version5}".`);
      }
      if (version5.length > MAX_LENGTH) {
        throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
      }
      debug("SemVer", version5, options2);
      this.options = options2;
      this.loose = !!options2.loose;
      this.includePrerelease = !!options2.includePrerelease;
      const m = version5.trim().match(options2.loose ? re[t.LOOSE] : re[t.FULL]);
      if (!m) {
        throw new TypeError(`Invalid Version: ${version5}`);
      }
      this.raw = version5;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split(".").map((id) => {
          if (/^[0-9]+$/.test(id)) {
            const num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m[5] ? m[5].split(".") : [];
      this.format();
    }
    format() {
      this.version = `${this.major}.${this.minor}.${this.patch}`;
      if (this.prerelease.length) {
        this.version += `-${this.prerelease.join(".")}`;
      }
      return this.version;
    }
    toString() {
      return this.version;
    }
    compare(other) {
      debug("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        if (typeof other === "string" && other === this.version) {
          return 0;
        }
        other = new SemVer(other, this.options);
      }
      if (other.version === this.version) {
        return 0;
      }
      return this.compareMain(other) || this.comparePre(other);
    }
    compareMain(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.major < other.major) {
        return -1;
      }
      if (this.major > other.major) {
        return 1;
      }
      if (this.minor < other.minor) {
        return -1;
      }
      if (this.minor > other.minor) {
        return 1;
      }
      if (this.patch < other.patch) {
        return -1;
      }
      if (this.patch > other.patch) {
        return 1;
      }
      return 0;
    }
    comparePre(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      let i = 0;
      do {
        const a = this.prerelease[i];
        const b = other.prerelease[i];
        debug("prerelease compare", i, a, b);
        if (a === undefined && b === undefined) {
          return 0;
        } else if (b === undefined) {
          return 1;
        } else if (a === undefined) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    }
    compareBuild(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      let i = 0;
      do {
        const a = this.build[i];
        const b = other.build[i];
        debug("build compare", i, a, b);
        if (a === undefined && b === undefined) {
          return 0;
        } else if (b === undefined) {
          return 1;
        } else if (a === undefined) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    }
    inc(release, identifier, identifierBase) {
      if (release.startsWith("pre")) {
        if (!identifier && identifierBase === false) {
          throw new Error("invalid increment argument: identifier is empty");
        }
        if (identifier) {
          const match = `-${identifier}`.match(this.options.loose ? re[t.PRERELEASELOOSE] : re[t.PRERELEASE]);
          if (!match || match[1] !== identifier) {
            throw new Error(`invalid identifier: ${identifier}`);
          }
        }
      }
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier, identifierBase);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier, identifierBase);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier, identifierBase);
          this.inc("pre", identifier, identifierBase);
          break;
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier, identifierBase);
          }
          this.inc("pre", identifier, identifierBase);
          break;
        case "release":
          if (this.prerelease.length === 0) {
            throw new Error(`version ${this.raw} is not a prerelease`);
          }
          this.prerelease.length = 0;
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        case "pre": {
          const base = Number(identifierBase) ? 1 : 0;
          if (this.prerelease.length === 0) {
            this.prerelease = [base];
          } else {
            let i = this.prerelease.length;
            while (--i >= 0) {
              if (typeof this.prerelease[i] === "number") {
                this.prerelease[i]++;
                i = -2;
              }
            }
            if (i === -1) {
              if (identifier === this.prerelease.join(".") && identifierBase === false) {
                throw new Error("invalid increment argument: identifier already exists");
              }
              this.prerelease.push(base);
            }
          }
          if (identifier) {
            let prerelease = [identifier, base];
            if (identifierBase === false) {
              prerelease = [identifier];
            }
            if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = prerelease;
              }
            } else {
              this.prerelease = prerelease;
            }
          }
          break;
        }
        default:
          throw new Error(`invalid increment argument: ${release}`);
      }
      this.raw = this.format();
      if (this.build.length) {
        this.raw += `+${this.build.join(".")}`;
      }
      return this;
    }
  }
  module.exports = SemVer;
});

// node_modules/semver/functions/parse.js
var require_parse4 = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var parse11 = (version5, options2, throwErrors = false) => {
    if (version5 instanceof SemVer) {
      return version5;
    }
    try {
      return new SemVer(version5, options2);
    } catch (er) {
      if (!throwErrors) {
        return null;
      }
      throw er;
    }
  };
  module.exports = parse11;
});

// node_modules/semver/functions/coerce.js
var require_coerce = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var parse11 = require_parse4();
  var { safeRe: re, t } = require_re();
  var coerce = (version5, options2) => {
    if (version5 instanceof SemVer) {
      return version5;
    }
    if (typeof version5 === "number") {
      version5 = String(version5);
    }
    if (typeof version5 !== "string") {
      return null;
    }
    options2 = options2 || {};
    let match = null;
    if (!options2.rtl) {
      match = version5.match(options2.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
    } else {
      const coerceRtlRegex = options2.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
      let next;
      while ((next = coerceRtlRegex.exec(version5)) && (!match || match.index + match[0].length !== version5.length)) {
        if (!match || next.index + next[0].length !== match.index + match[0].length) {
          match = next;
        }
        coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
      }
      coerceRtlRegex.lastIndex = -1;
    }
    if (match === null) {
      return null;
    }
    const major = match[2];
    const minor = match[3] || "0";
    const patch = match[4] || "0";
    const prerelease = options2.includePrerelease && match[5] ? `-${match[5]}` : "";
    const build = options2.includePrerelease && match[6] ? `+${match[6]}` : "";
    return parse11(`${major}.${minor}.${patch}${prerelease}${build}`, options2);
  };
  module.exports = coerce;
});

// node_modules/semver/functions/compare.js
var require_compare = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
  module.exports = compare;
});

// node_modules/semver/functions/gte.js
var require_gte = __commonJS((exports, module) => {
  var compare = require_compare();
  var gte2 = (a, b, loose) => compare(a, b, loose) >= 0;
  module.exports = gte2;
});

// node_modules/semver/internal/lrucache.js
var require_lrucache = __commonJS((exports, module) => {
  class LRUCache {
    constructor() {
      this.max = 1000;
      this.map = new Map;
    }
    get(key) {
      const value = this.map.get(key);
      if (value === undefined) {
        return;
      } else {
        this.map.delete(key);
        this.map.set(key, value);
        return value;
      }
    }
    delete(key) {
      return this.map.delete(key);
    }
    set(key, value) {
      const deleted = this.delete(key);
      if (!deleted && value !== undefined) {
        if (this.map.size >= this.max) {
          const firstKey = this.map.keys().next().value;
          this.delete(firstKey);
        }
        this.map.set(key, value);
      }
      return this;
    }
  }
  module.exports = LRUCache;
});

// node_modules/semver/functions/eq.js
var require_eq = __commonJS((exports, module) => {
  var compare = require_compare();
  var eq2 = (a, b, loose) => compare(a, b, loose) === 0;
  module.exports = eq2;
});

// node_modules/semver/functions/neq.js
var require_neq = __commonJS((exports, module) => {
  var compare = require_compare();
  var neq = (a, b, loose) => compare(a, b, loose) !== 0;
  module.exports = neq;
});

// node_modules/semver/functions/gt.js
var require_gt = __commonJS((exports, module) => {
  var compare = require_compare();
  var gt2 = (a, b, loose) => compare(a, b, loose) > 0;
  module.exports = gt2;
});

// node_modules/semver/functions/lt.js
var require_lt = __commonJS((exports, module) => {
  var compare = require_compare();
  var lt2 = (a, b, loose) => compare(a, b, loose) < 0;
  module.exports = lt2;
});

// node_modules/semver/functions/lte.js
var require_lte = __commonJS((exports, module) => {
  var compare = require_compare();
  var lte2 = (a, b, loose) => compare(a, b, loose) <= 0;
  module.exports = lte2;
});

// node_modules/semver/functions/cmp.js
var require_cmp = __commonJS((exports, module) => {
  var eq2 = require_eq();
  var neq = require_neq();
  var gt2 = require_gt();
  var gte2 = require_gte();
  var lt2 = require_lt();
  var lte2 = require_lte();
  var cmp = (a, op, b, loose) => {
    switch (op) {
      case "===":
        if (typeof a === "object") {
          a = a.version;
        }
        if (typeof b === "object") {
          b = b.version;
        }
        return a === b;
      case "!==":
        if (typeof a === "object") {
          a = a.version;
        }
        if (typeof b === "object") {
          b = b.version;
        }
        return a !== b;
      case "":
      case "=":
      case "==":
        return eq2(a, b, loose);
      case "!=":
        return neq(a, b, loose);
      case ">":
        return gt2(a, b, loose);
      case ">=":
        return gte2(a, b, loose);
      case "<":
        return lt2(a, b, loose);
      case "<=":
        return lte2(a, b, loose);
      default:
        throw new TypeError(`Invalid operator: ${op}`);
    }
  };
  module.exports = cmp;
});

// node_modules/semver/classes/comparator.js
var require_comparator = __commonJS((exports, module) => {
  var ANY = Symbol("SemVer ANY");

  class Comparator {
    static get ANY() {
      return ANY;
    }
    constructor(comp, options2) {
      options2 = parseOptions(options2);
      if (comp instanceof Comparator) {
        if (comp.loose === !!options2.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      comp = comp.trim().split(/\s+/).join(" ");
      debug("comparator", comp, options2);
      this.options = options2;
      this.loose = !!options2.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug("comp", this);
    }
    parse(comp) {
      const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
      const m = comp.match(r);
      if (!m) {
        throw new TypeError(`Invalid comparator: ${comp}`);
      }
      this.operator = m[1] !== undefined ? m[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    }
    toString() {
      return this.value;
    }
    test(version5) {
      debug("Comparator.test", version5, this.options.loose);
      if (this.semver === ANY || version5 === ANY) {
        return true;
      }
      if (typeof version5 === "string") {
        try {
          version5 = new SemVer(version5, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp(version5, this.operator, this.semver, this.options);
    }
    intersects(comp, options2) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        return new Range(comp.value, options2).test(this.value);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        return new Range(this.value, options2).test(comp.semver);
      }
      options2 = parseOptions(options2);
      if (options2.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
        return false;
      }
      if (!options2.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
        return false;
      }
      if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
        return true;
      }
      if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
        return true;
      }
      if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
        return true;
      }
      if (cmp(this.semver, "<", comp.semver, options2) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
        return true;
      }
      if (cmp(this.semver, ">", comp.semver, options2) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
        return true;
      }
      return false;
    }
  }
  module.exports = Comparator;
  var parseOptions = require_parse_options();
  var { safeRe: re, t } = require_re();
  var cmp = require_cmp();
  var debug = require_debug();
  var SemVer = require_semver();
  var Range = require_range();
});

// node_modules/semver/classes/range.js
var require_range = __commonJS((exports, module) => {
  var SPACE_CHARACTERS = /\s+/g;

  class Range {
    constructor(range, options2) {
      options2 = parseOptions(options2);
      if (range instanceof Range) {
        if (range.loose === !!options2.loose && range.includePrerelease === !!options2.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options2);
        }
      }
      if (range instanceof Comparator) {
        this.raw = range.value;
        this.set = [[range]];
        this.formatted = undefined;
        return this;
      }
      this.options = options2;
      this.loose = !!options2.loose;
      this.includePrerelease = !!options2.includePrerelease;
      this.raw = range.trim().replace(SPACE_CHARACTERS, " ");
      this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
      if (!this.set.length) {
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      }
      if (this.set.length > 1) {
        const first = this.set[0];
        this.set = this.set.filter((c) => !isNullSet(c[0]));
        if (this.set.length === 0) {
          this.set = [first];
        } else if (this.set.length > 1) {
          for (const c of this.set) {
            if (c.length === 1 && isAny(c[0])) {
              this.set = [c];
              break;
            }
          }
        }
      }
      this.formatted = undefined;
    }
    get range() {
      if (this.formatted === undefined) {
        this.formatted = "";
        for (let i = 0;i < this.set.length; i++) {
          if (i > 0) {
            this.formatted += "||";
          }
          const comps = this.set[i];
          for (let k = 0;k < comps.length; k++) {
            if (k > 0) {
              this.formatted += " ";
            }
            this.formatted += comps[k].toString().trim();
          }
        }
      }
      return this.formatted;
    }
    format() {
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(range) {
      const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
      const memoKey = memoOpts + ":" + range;
      const cached3 = cache.get(memoKey);
      if (cached3) {
        return cached3;
      }
      const loose = this.options.loose;
      const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
      range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
      debug("hyphen replace", range);
      range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
      debug("comparator trim", range);
      range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
      debug("tilde trim", range);
      range = range.replace(re[t.CARETTRIM], caretTrimReplace);
      debug("caret trim", range);
      let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
      if (loose) {
        rangeList = rangeList.filter((comp) => {
          debug("loose invalid filter", comp, this.options);
          return !!comp.match(re[t.COMPARATORLOOSE]);
        });
      }
      debug("range list", rangeList);
      const rangeMap = new Map;
      const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
      for (const comp of comparators) {
        if (isNullSet(comp)) {
          return [comp];
        }
        rangeMap.set(comp.value, comp);
      }
      if (rangeMap.size > 1 && rangeMap.has("")) {
        rangeMap.delete("");
      }
      const result = [...rangeMap.values()];
      cache.set(memoKey, result);
      return result;
    }
    intersects(range, options2) {
      if (!(range instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some((thisComparators) => {
        return isSatisfiable(thisComparators, options2) && range.set.some((rangeComparators) => {
          return isSatisfiable(rangeComparators, options2) && thisComparators.every((thisComparator) => {
            return rangeComparators.every((rangeComparator) => {
              return thisComparator.intersects(rangeComparator, options2);
            });
          });
        });
      });
    }
    test(version5) {
      if (!version5) {
        return false;
      }
      if (typeof version5 === "string") {
        try {
          version5 = new SemVer(version5, this.options);
        } catch (er) {
          return false;
        }
      }
      for (let i = 0;i < this.set.length; i++) {
        if (testSet(this.set[i], version5, this.options)) {
          return true;
        }
      }
      return false;
    }
  }
  module.exports = Range;
  var LRU = require_lrucache();
  var cache = new LRU;
  var parseOptions = require_parse_options();
  var Comparator = require_comparator();
  var debug = require_debug();
  var SemVer = require_semver();
  var {
    safeRe: re,
    t,
    comparatorTrimReplace,
    tildeTrimReplace,
    caretTrimReplace
  } = require_re();
  var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants3();
  var isNullSet = (c) => c.value === "<0.0.0-0";
  var isAny = (c) => c.value === "";
  var isSatisfiable = (comparators, options2) => {
    let result = true;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every((otherComparator) => {
        return testComparator.intersects(otherComparator, options2);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  };
  var parseComparator = (comp, options2) => {
    comp = comp.replace(re[t.BUILD], "");
    debug("comp", comp, options2);
    comp = replaceCarets(comp, options2);
    debug("caret", comp);
    comp = replaceTildes(comp, options2);
    debug("tildes", comp);
    comp = replaceXRanges(comp, options2);
    debug("xrange", comp);
    comp = replaceStars(comp, options2);
    debug("stars", comp);
    return comp;
  };
  var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
  var replaceTildes = (comp, options2) => {
    return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options2)).join(" ");
  };
  var replaceTilde = (comp, options2) => {
    const r = options2.loose ? re[t.TILDELOOSE] : re[t.TILDE];
    return comp.replace(r, (_, M, m, p, pr) => {
      debug("tilde", comp, _, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
      } else if (pr) {
        debug("replaceTilde pr", pr);
        ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
      } else {
        ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
      }
      debug("tilde return", ret);
      return ret;
    });
  };
  var replaceCarets = (comp, options2) => {
    return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options2)).join(" ");
  };
  var replaceCaret = (comp, options2) => {
    debug("caret", comp, options2);
    const r = options2.loose ? re[t.CARETLOOSE] : re[t.CARET];
    const z2 = options2.includePrerelease ? "-0" : "";
    return comp.replace(r, (_, M, m, p, pr) => {
      debug("caret", comp, _, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0${z2} <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        if (M === "0") {
          ret = `>=${M}.${m}.0${z2} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.0${z2} <${+M + 1}.0.0-0`;
        }
      } else if (pr) {
        debug("replaceCaret pr", pr);
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
        }
      } else {
        debug("no pr");
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}${z2} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}${z2} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
        }
      }
      debug("caret return", ret);
      return ret;
    });
  };
  var replaceXRanges = (comp, options2) => {
    debug("replaceXRanges", comp, options2);
    return comp.split(/\s+/).map((c) => replaceXRange(c, options2)).join(" ");
  };
  var replaceXRange = (comp, options2) => {
    comp = comp.trim();
    const r = options2.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
    return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
      debug("xRange", comp, ret, gtlt, M, m, p, pr);
      const xM = isX(M);
      const xm = xM || isX(m);
      const xp = xm || isX(p);
      const anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options2.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }
        if (gtlt === "<") {
          pr = "-0";
        }
        ret = `${gtlt + M}.${m}.${p}${pr}`;
      } else if (xm) {
        ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
      } else if (xp) {
        ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
      }
      debug("xRange return", ret);
      return ret;
    });
  };
  var replaceStars = (comp, options2) => {
    debug("replaceStars", comp, options2);
    return comp.trim().replace(re[t.STAR], "");
  };
  var replaceGTE0 = (comp, options2) => {
    debug("replaceGTE0", comp, options2);
    return comp.trim().replace(re[options2.includePrerelease ? t.GTE0PRE : t.GTE0], "");
  };
  var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
    } else if (isX(fp)) {
      from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
    } else if (fpr) {
      from = `>=${from}`;
    } else {
      from = `>=${from}${incPr ? "-0" : ""}`;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = `<${+tM + 1}.0.0-0`;
    } else if (isX(tp)) {
      to = `<${tM}.${+tm + 1}.0-0`;
    } else if (tpr) {
      to = `<=${tM}.${tm}.${tp}-${tpr}`;
    } else if (incPr) {
      to = `<${tM}.${tm}.${+tp + 1}-0`;
    } else {
      to = `<=${to}`;
    }
    return `${from} ${to}`.trim();
  };
  var testSet = (set3, version5, options2) => {
    for (let i = 0;i < set3.length; i++) {
      if (!set3[i].test(version5)) {
        return false;
      }
    }
    if (version5.prerelease.length && !options2.includePrerelease) {
      for (let i = 0;i < set3.length; i++) {
        debug(set3[i].semver);
        if (set3[i].semver === Comparator.ANY) {
          continue;
        }
        if (set3[i].semver.prerelease.length > 0) {
          const allowed = set3[i].semver;
          if (allowed.major === version5.major && allowed.minor === version5.minor && allowed.patch === version5.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  };
});

// node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS((exports, module) => {
  var Range = require_range();
  var satisfies = (version5, range, options2) => {
    try {
      range = new Range(range, options2);
    } catch (er) {
      return false;
    }
    return range.test(version5);
  };
  module.exports = satisfies;
});

// node_modules/sharp/package.json
var require_package2 = __commonJS((exports, module) => {
  module.exports = {
    name: "sharp",
    description: "High performance Node.js image processing, the fastest module to resize JPEG, PNG, WebP, GIF, AVIF and TIFF images",
    version: "0.34.5",
    author: "Lovell Fuller <npm@lovell.info>",
    homepage: "https://sharp.pixelplumbing.com",
    contributors: [
      "Pierre Inglebert <pierre.inglebert@gmail.com>",
      "Jonathan Ong <jonathanrichardong@gmail.com>",
      "Chanon Sajjamanochai <chanon.s@gmail.com>",
      "Juliano Julio <julianojulio@gmail.com>",
      "Daniel Gasienica <daniel@gasienica.ch>",
      "Julian Walker <julian@fiftythree.com>",
      "Amit Pitaru <pitaru.amit@gmail.com>",
      "Brandon Aaron <hello.brandon@aaron.sh>",
      "Andreas Lind <andreas@one.com>",
      "Maurus Cuelenaere <mcuelenaere@gmail.com>",
      "Linus Unneb\xE4ck <linus@folkdatorn.se>",
      "Victor Mateevitsi <mvictoras@gmail.com>",
      "Alaric Holloway <alaric.holloway@gmail.com>",
      "Bernhard K. Weisshuhn <bkw@codingforce.com>",
      "Chris Riley <criley@primedia.com>",
      "David Carley <dacarley@gmail.com>",
      "John Tobin <john@limelightmobileinc.com>",
      "Kenton Gray <kentongray@gmail.com>",
      "Felix B\xFCnemann <Felix.Buenemann@gmail.com>",
      "Samy Al Zahrani <samyalzahrany@gmail.com>",
      "Chintan Thakkar <lemnisk8@gmail.com>",
      "F. Orlando Galashan <frulo@gmx.de>",
      "Kleis Auke Wolthuizen <info@kleisauke.nl>",
      "Matt Hirsch <mhirsch@media.mit.edu>",
      "Matthias Thoemmes <thoemmes@gmail.com>",
      "Patrick Paskaris <patrick@paskaris.gr>",
      "J\xE9r\xE9my Lal <kapouer@melix.org>",
      "Rahul Nanwani <r.nanwani@gmail.com>",
      "Alice Monday <alice0meta@gmail.com>",
      "Kristo Jorgenson <kristo.jorgenson@gmail.com>",
      "YvesBos <yves_bos@outlook.com>",
      "Guy Maliar <guy@tailorbrands.com>",
      "Nicolas Coden <nicolas@ncoden.fr>",
      "Matt Parrish <matt.r.parrish@gmail.com>",
      "Marcel Bretschneider <marcel.bretschneider@gmail.com>",
      "Matthew McEachen <matthew+github@mceachen.org>",
      "Jarda Kot\u011B\u0161ovec <jarda.kotesovec@gmail.com>",
      "Kenric D'Souza <kenric.dsouza@gmail.com>",
      "Oleh Aleinyk <oleg.aleynik@gmail.com>",
      "Marcel Bretschneider <marcel.bretschneider@gmail.com>",
      "Andrea Bianco <andrea.bianco@unibas.ch>",
      "Rik Heywood <rik@rik.org>",
      "Thomas Parisot <hi@oncletom.io>",
      "Nathan Graves <nathanrgraves+github@gmail.com>",
      "Tom Lokhorst <tom@lokhorst.eu>",
      "Espen Hovlandsdal <espen@hovlandsdal.com>",
      "Sylvain Dumont <sylvain.dumont35@gmail.com>",
      "Alun Davies <alun.owain.davies@googlemail.com>",
      "Aidan Hoolachan <ajhoolachan21@gmail.com>",
      "Axel Eirola <axel.eirola@iki.fi>",
      "Freezy <freezy@xbmc.org>",
      "Daiz <taneli.vatanen@gmail.com>",
      "Julian Aubourg <j@ubourg.net>",
      "Keith Belovay <keith@picthrive.com>",
      "Michael B. Klein <mbklein@gmail.com>",
      "Jordan Prudhomme <jordan@raboland.fr>",
      "Ilya Ovdin <iovdin@gmail.com>",
      "Andargor <andargor@yahoo.com>",
      "Paul Neave <paul.neave@gmail.com>",
      "Brendan Kennedy <brenwken@gmail.com>",
      "Brychan Bennett-Odlum <git@brychan.io>",
      "Edward Silverton <e.silverton@gmail.com>",
      "Roman Malieiev <aromaleev@gmail.com>",
      "Tomas Szabo <tomas.szabo@deftomat.com>",
      "Robert O'Rourke <robert@o-rourke.org>",
      "Guillermo Alfonso Varela Chouci\xF1o <guillevch@gmail.com>",
      "Christian Flintrup <chr@gigahost.dk>",
      "Manan Jadhav <manan@motionden.com>",
      "Leon Radley <leon@radley.se>",
      "alza54 <alza54@thiocod.in>",
      "Jacob Smith <jacob@frende.me>",
      "Michael Nutt <michael@nutt.im>",
      "Brad Parham <baparham@gmail.com>",
      "Taneli Vatanen <taneli.vatanen@gmail.com>",
      "Joris Dugu\xE9 <zaruike10@gmail.com>",
      "Chris Banks <christopher.bradley.banks@gmail.com>",
      "Ompal Singh <ompal.hitm09@gmail.com>",
      "Brodan <christopher.hranj@gmail.com>",
      "Ankur Parihar <ankur.github@gmail.com>",
      "Brahim Ait elhaj <brahima@gmail.com>",
      "Mart Jansink <m.jansink@gmail.com>",
      "Lachlan Newman <lachnewman007@gmail.com>",
      "Dennis Beatty <dennis@dcbeatty.com>",
      "Ingvar Stepanyan <me@rreverser.com>",
      "Don Denton <don@happycollision.com>"
    ],
    scripts: {
      build: "node install/build.js",
      install: "node install/check.js || npm run build",
      clean: "rm -rf src/build/ .nyc_output/ coverage/ test/fixtures/output.*",
      test: "npm run lint && npm run test-unit",
      lint: "npm run lint-cpp && npm run lint-js && npm run lint-types",
      "lint-cpp": "cpplint --quiet src/*.h src/*.cc",
      "lint-js": "biome lint",
      "lint-types": "tsd --files ./test/types/sharp.test-d.ts",
      "test-leak": "./test/leak/leak.sh",
      "test-unit": "node --experimental-test-coverage test/unit.mjs",
      "package-from-local-build": "node npm/from-local-build.js",
      "package-release-notes": "node npm/release-notes.js",
      "docs-build": "node docs/build.mjs",
      "docs-serve": "cd docs && npm start",
      "docs-publish": "cd docs && npm run build && npx firebase-tools deploy --project pixelplumbing --only hosting:pixelplumbing-sharp"
    },
    type: "commonjs",
    main: "lib/index.js",
    types: "lib/index.d.ts",
    files: [
      "install",
      "lib",
      "src/*.{cc,h,gyp}"
    ],
    repository: {
      type: "git",
      url: "git://github.com/lovell/sharp.git"
    },
    keywords: [
      "jpeg",
      "png",
      "webp",
      "avif",
      "tiff",
      "gif",
      "svg",
      "jp2",
      "dzi",
      "image",
      "resize",
      "thumbnail",
      "crop",
      "embed",
      "libvips",
      "vips"
    ],
    dependencies: {
      "@img/colour": "^1.0.0",
      "detect-libc": "^2.1.2",
      semver: "^7.7.3"
    },
    optionalDependencies: {
      "@img/sharp-darwin-arm64": "0.34.5",
      "@img/sharp-darwin-x64": "0.34.5",
      "@img/sharp-libvips-darwin-arm64": "1.2.4",
      "@img/sharp-libvips-darwin-x64": "1.2.4",
      "@img/sharp-libvips-linux-arm": "1.2.4",
      "@img/sharp-libvips-linux-arm64": "1.2.4",
      "@img/sharp-libvips-linux-ppc64": "1.2.4",
      "@img/sharp-libvips-linux-riscv64": "1.2.4",
      "@img/sharp-libvips-linux-s390x": "1.2.4",
      "@img/sharp-libvips-linux-x64": "1.2.4",
      "@img/sharp-libvips-linuxmusl-arm64": "1.2.4",
      "@img/sharp-libvips-linuxmusl-x64": "1.2.4",
      "@img/sharp-linux-arm": "0.34.5",
      "@img/sharp-linux-arm64": "0.34.5",
      "@img/sharp-linux-ppc64": "0.34.5",
      "@img/sharp-linux-riscv64": "0.34.5",
      "@img/sharp-linux-s390x": "0.34.5",
      "@img/sharp-linux-x64": "0.34.5",
      "@img/sharp-linuxmusl-arm64": "0.34.5",
      "@img/sharp-linuxmusl-x64": "0.34.5",
      "@img/sharp-wasm32": "0.34.5",
      "@img/sharp-win32-arm64": "0.34.5",
      "@img/sharp-win32-ia32": "0.34.5",
      "@img/sharp-win32-x64": "0.34.5"
    },
    devDependencies: {
      "@biomejs/biome": "^2.3.4",
      "@cpplint/cli": "^0.1.0",
      "@emnapi/runtime": "^1.7.0",
      "@img/sharp-libvips-dev": "1.2.4",
      "@img/sharp-libvips-dev-wasm32": "1.2.4",
      "@img/sharp-libvips-win32-arm64": "1.2.4",
      "@img/sharp-libvips-win32-ia32": "1.2.4",
      "@img/sharp-libvips-win32-x64": "1.2.4",
      "@types/node": "*",
      emnapi: "^1.7.0",
      "exif-reader": "^2.0.2",
      "extract-zip": "^2.0.1",
      icc: "^3.0.0",
      "jsdoc-to-markdown": "^9.1.3",
      "node-addon-api": "^8.5.0",
      "node-gyp": "^11.5.0",
      "tar-fs": "^3.1.1",
      tsd: "^0.33.0"
    },
    license: "Apache-2.0",
    engines: {
      node: "^18.17.0 || ^20.3.0 || >=21.0.0"
    },
    config: {
      libvips: ">=8.17.3"
    },
    funding: {
      url: "https://opencollective.com/libvips"
    }
  };
});

// node_modules/sharp/lib/libvips.js
var require_libvips = __commonJS((exports, module) => {
  /*!
    Copyright 2013 Lovell Fuller and others.
    SPDX-License-Identifier: Apache-2.0
  */
  var { spawnSync } = __require("child_process");
  var { createHash: createHash2 } = __require("crypto");
  var semverCoerce = require_coerce();
  var semverGreaterThanOrEqualTo = require_gte();
  var semverSatisfies = require_satisfies();
  var detectLibc = require_detect_libc();
  var { config: config3, engines, optionalDependencies } = require_package2();
  var minimumLibvipsVersionLabelled = process.env.npm_package_config_libvips || config3.libvips;
  var minimumLibvipsVersion = semverCoerce(minimumLibvipsVersionLabelled).version;
  var prebuiltPlatforms = [
    "darwin-arm64",
    "darwin-x64",
    "linux-arm",
    "linux-arm64",
    "linux-ppc64",
    "linux-riscv64",
    "linux-s390x",
    "linux-x64",
    "linuxmusl-arm64",
    "linuxmusl-x64",
    "win32-arm64",
    "win32-ia32",
    "win32-x64"
  ];
  var spawnSyncOptions = {
    encoding: "utf8",
    shell: true
  };
  var log10 = (item) => {
    if (item instanceof Error) {
      console.error(`sharp: Installation error: ${item.message}`);
    } else {
      console.log(`sharp: ${item}`);
    }
  };
  var runtimeLibc = () => detectLibc.isNonGlibcLinuxSync() ? detectLibc.familySync() : "";
  var runtimePlatformArch = () => `${process.platform}${runtimeLibc()}-${process.arch}`;
  var buildPlatformArch = () => {
    if (isEmscripten()) {
      return "wasm32";
    }
    const { npm_config_arch, npm_config_platform, npm_config_libc } = process.env;
    const libc = typeof npm_config_libc === "string" ? npm_config_libc : runtimeLibc();
    return `${npm_config_platform || process.platform}${libc}-${npm_config_arch || process.arch}`;
  };
  var buildSharpLibvipsIncludeDir = () => {
    try {
      return __require(`@img/sharp-libvips-dev-${buildPlatformArch()}/include`);
    } catch {
      try {
        return (()=>{throw new Error("Cannot require module "+"@img/sharp-libvips-dev/include");})();
      } catch {}
    }
    return "";
  };
  var buildSharpLibvipsCPlusPlusDir = () => {
    try {
      return (()=>{throw new Error("Cannot require module "+"@img/sharp-libvips-dev/cplusplus");})();
    } catch {}
    return "";
  };
  var buildSharpLibvipsLibDir = () => {
    try {
      return __require(`@img/sharp-libvips-dev-${buildPlatformArch()}/lib`);
    } catch {
      try {
        return __require(`@img/sharp-libvips-${buildPlatformArch()}/lib`);
      } catch {}
    }
    return "";
  };
  var isUnsupportedNodeRuntime = () => {
    if (process.release?.name === "node" && process.versions) {
      if (!semverSatisfies(process.versions.node, engines.node)) {
        return { found: process.versions.node, expected: engines.node };
      }
    }
  };
  var isEmscripten = () => {
    const { CC } = process.env;
    return Boolean(CC?.endsWith("/emcc"));
  };
  var isRosetta = () => {
    if (process.platform === "darwin" && process.arch === "x64") {
      const translated = spawnSync("sysctl sysctl.proc_translated", spawnSyncOptions).stdout;
      return (translated || "").trim() === "sysctl.proc_translated: 1";
    }
    return false;
  };
  var sha512 = (s) => createHash2("sha512").update(s).digest("hex");
  var yarnLocator = () => {
    try {
      const identHash = sha512(`imgsharp-libvips-${buildPlatformArch()}`);
      const npmVersion = semverCoerce(optionalDependencies[`@img/sharp-libvips-${buildPlatformArch()}`], {
        includePrerelease: true
      }).version;
      return sha512(`${identHash}npm:${npmVersion}`).slice(0, 10);
    } catch {}
    return "";
  };
  var spawnRebuild = () => spawnSync(`node-gyp rebuild --directory=src ${isEmscripten() ? "--nodedir=emscripten" : ""}`, {
    ...spawnSyncOptions,
    stdio: "inherit"
  }).status;
  var globalLibvipsVersion = () => {
    if (process.platform !== "win32") {
      const globalLibvipsVersion2 = spawnSync("pkg-config --modversion vips-cpp", {
        ...spawnSyncOptions,
        env: {
          ...process.env,
          PKG_CONFIG_PATH: pkgConfigPath()
        }
      }).stdout;
      return (globalLibvipsVersion2 || "").trim();
    } else {
      return "";
    }
  };
  var pkgConfigPath = () => {
    if (process.platform !== "win32") {
      const brewPkgConfigPath = spawnSync('which brew >/dev/null 2>&1 && brew environment --plain | grep PKG_CONFIG_LIBDIR | cut -d" " -f2', spawnSyncOptions).stdout || "";
      return [
        brewPkgConfigPath.trim(),
        process.env.PKG_CONFIG_PATH,
        "/usr/local/lib/pkgconfig",
        "/usr/lib/pkgconfig",
        "/usr/local/libdata/pkgconfig",
        "/usr/libdata/pkgconfig"
      ].filter(Boolean).join(":");
    } else {
      return "";
    }
  };
  var skipSearch = (status, reason, logger) => {
    if (logger) {
      logger(`Detected ${reason}, skipping search for globally-installed libvips`);
    }
    return status;
  };
  var useGlobalLibvips = (logger) => {
    if (Boolean(process.env.SHARP_IGNORE_GLOBAL_LIBVIPS) === true) {
      return skipSearch(false, "SHARP_IGNORE_GLOBAL_LIBVIPS", logger);
    }
    if (Boolean(process.env.SHARP_FORCE_GLOBAL_LIBVIPS) === true) {
      return skipSearch(true, "SHARP_FORCE_GLOBAL_LIBVIPS", logger);
    }
    if (isRosetta()) {
      return skipSearch(false, "Rosetta", logger);
    }
    const globalVipsVersion = globalLibvipsVersion();
    return !!globalVipsVersion && semverGreaterThanOrEqualTo(globalVipsVersion, minimumLibvipsVersion);
  };
  module.exports = {
    minimumLibvipsVersion,
    prebuiltPlatforms,
    buildPlatformArch,
    buildSharpLibvipsIncludeDir,
    buildSharpLibvipsCPlusPlusDir,
    buildSharpLibvipsLibDir,
    isUnsupportedNodeRuntime,
    runtimePlatformArch,
    log: log10,
    yarnLocator,
    spawnRebuild,
    globalLibvipsVersion,
    pkgConfigPath,
    useGlobalLibvips
  };
});

// node_modules/sharp/lib/sharp.js
var require_sharp = __commonJS((exports, module) => {
  /*!
    Copyright 2013 Lovell Fuller and others.
    SPDX-License-Identifier: Apache-2.0
  */
  var { familySync, versionSync } = require_detect_libc();
  var { runtimePlatformArch, isUnsupportedNodeRuntime, prebuiltPlatforms, minimumLibvipsVersion } = require_libvips();
  var runtimePlatform = runtimePlatformArch();
  var paths = [
    `../src/build/Release/sharp-${runtimePlatform}.node`,
    "../src/build/Release/sharp-wasm32.node",
    `@img/sharp-${runtimePlatform}/sharp.node`,
    "@img/sharp-wasm32/sharp.node"
  ];
  var path2;
  var sharp;
  var errors5 = [];
  for (path2 of paths) {
    try {
      sharp = __require(path2);
      break;
    } catch (err) {
      errors5.push(err);
    }
  }
  if (sharp && path2.startsWith("@img/sharp-linux-x64") && !sharp._isUsingX64V2()) {
    const err = new Error("Prebuilt binaries for linux-x64 require v2 microarchitecture");
    err.code = "Unsupported CPU";
    errors5.push(err);
    sharp = null;
  }
  if (sharp) {
    module.exports = sharp;
  } else {
    const [isLinux, isMacOs, isWindows] = ["linux", "darwin", "win32"].map((os) => runtimePlatform.startsWith(os));
    const help = [`Could not load the "sharp" module using the ${runtimePlatform} runtime`];
    errors5.forEach((err) => {
      if (err.code !== "MODULE_NOT_FOUND") {
        help.push(`${err.code}: ${err.message}`);
      }
    });
    const messages = errors5.map((err) => err.message).join(" ");
    help.push("Possible solutions:");
    if (isUnsupportedNodeRuntime()) {
      const { found, expected } = isUnsupportedNodeRuntime();
      help.push("- Please upgrade Node.js:", `    Found ${found}`, `    Requires ${expected}`);
    } else if (prebuiltPlatforms.includes(runtimePlatform)) {
      const [os, cpu] = runtimePlatform.split("-");
      const libc = os.endsWith("musl") ? " --libc=musl" : "";
      help.push("- Ensure optional dependencies can be installed:", "    npm install --include=optional sharp", "- Ensure your package manager supports multi-platform installation:", "    See https://sharp.pixelplumbing.com/install#cross-platform", "- Add platform-specific dependencies:", `    npm install --os=${os.replace("musl", "")}${libc} --cpu=${cpu} sharp`);
    } else {
      help.push(`- Manually install libvips >= ${minimumLibvipsVersion}`, "- Add experimental WebAssembly-based dependencies:", "    npm install --cpu=wasm32 sharp", "    npm install @img/sharp-wasm32");
    }
    if (isLinux && /(symbol not found|CXXABI_)/i.test(messages)) {
      try {
        const { config: config3 } = __require(`@img/sharp-libvips-${runtimePlatform}/package`);
        const libcFound = `${familySync()} ${versionSync()}`;
        const libcRequires = `${config3.musl ? "musl" : "glibc"} ${config3.musl || config3.glibc}`;
        help.push("- Update your OS:", `    Found ${libcFound}`, `    Requires ${libcRequires}`);
      } catch (_errEngines) {}
    }
    if (isLinux && /\/snap\/core[0-9]{2}/.test(messages)) {
      help.push("- Remove the Node.js Snap, which does not support native modules", "    snap remove node");
    }
    if (isMacOs && /Incompatible library version/.test(messages)) {
      help.push("- Update Homebrew:", "    brew update && brew upgrade vips");
    }
    if (errors5.some((err) => err.code === "ERR_DLOPEN_DISABLED")) {
      help.push("- Run Node.js without using the --no-addons flag");
    }
    if (isWindows && /The specified procedure could not be found/.test(messages)) {
      help.push("- Using the canvas package on Windows?", "    See https://sharp.pixelplumbing.com/install#canvas-and-windows", "- Check for outdated versions of sharp in the dependency tree:", "    npm ls sharp");
    }
    help.push("- Consult the installation documentation:", "    See https://sharp.pixelplumbing.com/install");
    throw new Error(help.join(`
`));
  }
});

// node_modules/sharp/lib/constructor.js
var require_constructor = __commonJS((exports, module) => {
  /*!
    Copyright 2013 Lovell Fuller and others.
    SPDX-License-Identifier: Apache-2.0
  */
  var util = __require("util");
  var stream = __require("stream");
  var is2 = require_is();
  require_sharp();
  var debuglog = util.debuglog("sharp");
  var queueListener = (queueLength) => {
    Sharp.queue.emit("change", queueLength);
  };
  var Sharp = function(input, options2) {
    if (arguments.length === 1 && !is2.defined(input)) {
      throw new Error("Invalid input");
    }
    if (!(this instanceof Sharp)) {
      return new Sharp(input, options2);
    }
    stream.Duplex.call(this);
    this.options = {
      topOffsetPre: -1,
      leftOffsetPre: -1,
      widthPre: -1,
      heightPre: -1,
      topOffsetPost: -1,
      leftOffsetPost: -1,
      widthPost: -1,
      heightPost: -1,
      width: -1,
      height: -1,
      canvas: "crop",
      position: 0,
      resizeBackground: [0, 0, 0, 255],
      angle: 0,
      rotationAngle: 0,
      rotationBackground: [0, 0, 0, 255],
      rotateBefore: false,
      orientBefore: false,
      flip: false,
      flop: false,
      extendTop: 0,
      extendBottom: 0,
      extendLeft: 0,
      extendRight: 0,
      extendBackground: [0, 0, 0, 255],
      extendWith: "background",
      withoutEnlargement: false,
      withoutReduction: false,
      affineMatrix: [],
      affineBackground: [0, 0, 0, 255],
      affineIdx: 0,
      affineIdy: 0,
      affineOdx: 0,
      affineOdy: 0,
      affineInterpolator: this.constructor.interpolators.bilinear,
      kernel: "lanczos3",
      fastShrinkOnLoad: true,
      tint: [-1, 0, 0, 0],
      flatten: false,
      flattenBackground: [0, 0, 0],
      unflatten: false,
      negate: false,
      negateAlpha: true,
      medianSize: 0,
      blurSigma: 0,
      precision: "integer",
      minAmpl: 0.2,
      sharpenSigma: 0,
      sharpenM1: 1,
      sharpenM2: 2,
      sharpenX1: 2,
      sharpenY2: 10,
      sharpenY3: 20,
      threshold: 0,
      thresholdGrayscale: true,
      trimBackground: [],
      trimThreshold: -1,
      trimLineArt: false,
      dilateWidth: 0,
      erodeWidth: 0,
      gamma: 0,
      gammaOut: 0,
      greyscale: false,
      normalise: false,
      normaliseLower: 1,
      normaliseUpper: 99,
      claheWidth: 0,
      claheHeight: 0,
      claheMaxSlope: 3,
      brightness: 1,
      saturation: 1,
      hue: 0,
      lightness: 0,
      booleanBufferIn: null,
      booleanFileIn: "",
      joinChannelIn: [],
      extractChannel: -1,
      removeAlpha: false,
      ensureAlpha: -1,
      colourspace: "srgb",
      colourspacePipeline: "last",
      composite: [],
      fileOut: "",
      formatOut: "input",
      streamOut: false,
      keepMetadata: 0,
      withMetadataOrientation: -1,
      withMetadataDensity: 0,
      withIccProfile: "",
      withExif: {},
      withExifMerge: true,
      withXmp: "",
      resolveWithObject: false,
      loop: -1,
      delay: [],
      jpegQuality: 80,
      jpegProgressive: false,
      jpegChromaSubsampling: "4:2:0",
      jpegTrellisQuantisation: false,
      jpegOvershootDeringing: false,
      jpegOptimiseScans: false,
      jpegOptimiseCoding: true,
      jpegQuantisationTable: 0,
      pngProgressive: false,
      pngCompressionLevel: 6,
      pngAdaptiveFiltering: false,
      pngPalette: false,
      pngQuality: 100,
      pngEffort: 7,
      pngBitdepth: 8,
      pngDither: 1,
      jp2Quality: 80,
      jp2TileHeight: 512,
      jp2TileWidth: 512,
      jp2Lossless: false,
      jp2ChromaSubsampling: "4:4:4",
      webpQuality: 80,
      webpAlphaQuality: 100,
      webpLossless: false,
      webpNearLossless: false,
      webpSmartSubsample: false,
      webpSmartDeblock: false,
      webpPreset: "default",
      webpEffort: 4,
      webpMinSize: false,
      webpMixed: false,
      gifBitdepth: 8,
      gifEffort: 7,
      gifDither: 1,
      gifInterFrameMaxError: 0,
      gifInterPaletteMaxError: 3,
      gifKeepDuplicateFrames: false,
      gifReuse: true,
      gifProgressive: false,
      tiffQuality: 80,
      tiffCompression: "jpeg",
      tiffBigtiff: false,
      tiffPredictor: "horizontal",
      tiffPyramid: false,
      tiffMiniswhite: false,
      tiffBitdepth: 8,
      tiffTile: false,
      tiffTileHeight: 256,
      tiffTileWidth: 256,
      tiffXres: 1,
      tiffYres: 1,
      tiffResolutionUnit: "inch",
      heifQuality: 50,
      heifLossless: false,
      heifCompression: "av1",
      heifEffort: 4,
      heifChromaSubsampling: "4:4:4",
      heifBitdepth: 8,
      jxlDistance: 1,
      jxlDecodingTier: 0,
      jxlEffort: 7,
      jxlLossless: false,
      rawDepth: "uchar",
      tileSize: 256,
      tileOverlap: 0,
      tileContainer: "fs",
      tileLayout: "dz",
      tileFormat: "last",
      tileDepth: "last",
      tileAngle: 0,
      tileSkipBlanks: -1,
      tileBackground: [255, 255, 255, 255],
      tileCentre: false,
      tileId: "https://example.com/iiif",
      tileBasename: "",
      timeoutSeconds: 0,
      linearA: [],
      linearB: [],
      pdfBackground: [255, 255, 255, 255],
      debuglog: (warning) => {
        this.emit("warning", warning);
        debuglog(warning);
      },
      queueListener
    };
    this.options.input = this._createInputDescriptor(input, options2, { allowStream: true });
    return this;
  };
  Object.setPrototypeOf(Sharp.prototype, stream.Duplex.prototype);
  Object.setPrototypeOf(Sharp, stream.Duplex);
  function clone3() {
    const clone4 = this.constructor.call();
    const { debuglog: debuglog2, queueListener: queueListener2, ...options2 } = this.options;
    clone4.options = structuredClone(options2);
    clone4.options.debuglog = debuglog2;
    clone4.options.queueListener = queueListener2;
    if (this._isStreamInput()) {
      this.on("finish", () => {
        this._flattenBufferIn();
        clone4.options.input.buffer = this.options.input.buffer;
        clone4.emit("finish");
      });
    }
    return clone4;
  }
  Object.assign(Sharp.prototype, { clone: clone3 });
  module.exports = Sharp;
});

// node_modules/sharp/lib/input.js
var require_input = __commonJS((exports, module) => {
  /*!
    Copyright 2013 Lovell Fuller and others.
    SPDX-License-Identifier: Apache-2.0
  */
  var is2 = require_is();
  var sharp = require_sharp();
  var align = {
    left: "low",
    top: "low",
    low: "low",
    center: "centre",
    centre: "centre",
    right: "high",
    bottom: "high",
    high: "high"
  };
  var inputStreamParameters = [
    "failOn",
    "limitInputPixels",
    "unlimited",
    "animated",
    "autoOrient",
    "density",
    "ignoreIcc",
    "page",
    "pages",
    "sequentialRead",
    "jp2",
    "openSlide",
    "pdf",
    "raw",
    "svg",
    "tiff",
    "failOnError",
    "openSlideLevel",
    "pdfBackground",
    "tiffSubifd"
  ];
  function _inputOptionsFromObject(obj) {
    const params = inputStreamParameters.filter((p) => is2.defined(obj[p])).map((p) => [p, obj[p]]);
    return params.length ? Object.fromEntries(params) : undefined;
  }
  function _createInputDescriptor(input, inputOptions, containerOptions) {
    const inputDescriptor = {
      autoOrient: false,
      failOn: "warning",
      limitInputPixels: 16383 ** 2,
      ignoreIcc: false,
      unlimited: false,
      sequentialRead: true
    };
    if (is2.string(input)) {
      inputDescriptor.file = input;
    } else if (is2.buffer(input)) {
      if (input.length === 0) {
        throw Error("Input Buffer is empty");
      }
      inputDescriptor.buffer = input;
    } else if (is2.arrayBuffer(input)) {
      if (input.byteLength === 0) {
        throw Error("Input bit Array is empty");
      }
      inputDescriptor.buffer = Buffer.from(input, 0, input.byteLength);
    } else if (is2.typedArray(input)) {
      if (input.length === 0) {
        throw Error("Input Bit Array is empty");
      }
      inputDescriptor.buffer = Buffer.from(input.buffer, input.byteOffset, input.byteLength);
    } else if (is2.plainObject(input) && !is2.defined(inputOptions)) {
      inputOptions = input;
      if (_inputOptionsFromObject(inputOptions)) {
        inputDescriptor.buffer = [];
      }
    } else if (!is2.defined(input) && !is2.defined(inputOptions) && is2.object(containerOptions) && containerOptions.allowStream) {
      inputDescriptor.buffer = [];
    } else if (Array.isArray(input)) {
      if (input.length > 1) {
        if (!this.options.joining) {
          this.options.joining = true;
          this.options.join = input.map((i) => this._createInputDescriptor(i));
        } else {
          throw new Error("Recursive join is unsupported");
        }
      } else {
        throw new Error("Expected at least two images to join");
      }
    } else {
      throw new Error(`Unsupported input '${input}' of type ${typeof input}${is2.defined(inputOptions) ? ` when also providing options of type ${typeof inputOptions}` : ""}`);
    }
    if (is2.object(inputOptions)) {
      if (is2.defined(inputOptions.failOnError)) {
        if (is2.bool(inputOptions.failOnError)) {
          inputDescriptor.failOn = inputOptions.failOnError ? "warning" : "none";
        } else {
          throw is2.invalidParameterError("failOnError", "boolean", inputOptions.failOnError);
        }
      }
      if (is2.defined(inputOptions.failOn)) {
        if (is2.string(inputOptions.failOn) && is2.inArray(inputOptions.failOn, ["none", "truncated", "error", "warning"])) {
          inputDescriptor.failOn = inputOptions.failOn;
        } else {
          throw is2.invalidParameterError("failOn", "one of: none, truncated, error, warning", inputOptions.failOn);
        }
      }
      if (is2.defined(inputOptions.autoOrient)) {
        if (is2.bool(inputOptions.autoOrient)) {
          inputDescriptor.autoOrient = inputOptions.autoOrient;
        } else {
          throw is2.invalidParameterError("autoOrient", "boolean", inputOptions.autoOrient);
        }
      }
      if (is2.defined(inputOptions.density)) {
        if (is2.inRange(inputOptions.density, 1, 1e5)) {
          inputDescriptor.density = inputOptions.density;
        } else {
          throw is2.invalidParameterError("density", "number between 1 and 100000", inputOptions.density);
        }
      }
      if (is2.defined(inputOptions.ignoreIcc)) {
        if (is2.bool(inputOptions.ignoreIcc)) {
          inputDescriptor.ignoreIcc = inputOptions.ignoreIcc;
        } else {
          throw is2.invalidParameterError("ignoreIcc", "boolean", inputOptions.ignoreIcc);
        }
      }
      if (is2.defined(inputOptions.limitInputPixels)) {
        if (is2.bool(inputOptions.limitInputPixels)) {
          inputDescriptor.limitInputPixels = inputOptions.limitInputPixels ? 16383 ** 2 : 0;
        } else if (is2.integer(inputOptions.limitInputPixels) && is2.inRange(inputOptions.limitInputPixels, 0, Number.MAX_SAFE_INTEGER)) {
          inputDescriptor.limitInputPixels = inputOptions.limitInputPixels;
        } else {
          throw is2.invalidParameterError("limitInputPixels", "positive integer", inputOptions.limitInputPixels);
        }
      }
      if (is2.defined(inputOptions.unlimited)) {
        if (is2.bool(inputOptions.unlimited)) {
          inputDescriptor.unlimited = inputOptions.unlimited;
        } else {
          throw is2.invalidParameterError("unlimited", "boolean", inputOptions.unlimited);
        }
      }
      if (is2.defined(inputOptions.sequentialRead)) {
        if (is2.bool(inputOptions.sequentialRead)) {
          inputDescriptor.sequentialRead = inputOptions.sequentialRead;
        } else {
          throw is2.invalidParameterError("sequentialRead", "boolean", inputOptions.sequentialRead);
        }
      }
      if (is2.defined(inputOptions.raw)) {
        if (is2.object(inputOptions.raw) && is2.integer(inputOptions.raw.width) && inputOptions.raw.width > 0 && is2.integer(inputOptions.raw.height) && inputOptions.raw.height > 0 && is2.integer(inputOptions.raw.channels) && is2.inRange(inputOptions.raw.channels, 1, 4)) {
          inputDescriptor.rawWidth = inputOptions.raw.width;
          inputDescriptor.rawHeight = inputOptions.raw.height;
          inputDescriptor.rawChannels = inputOptions.raw.channels;
          switch (input.constructor) {
            case Uint8Array:
            case Uint8ClampedArray:
              inputDescriptor.rawDepth = "uchar";
              break;
            case Int8Array:
              inputDescriptor.rawDepth = "char";
              break;
            case Uint16Array:
              inputDescriptor.rawDepth = "ushort";
              break;
            case Int16Array:
              inputDescriptor.rawDepth = "short";
              break;
            case Uint32Array:
              inputDescriptor.rawDepth = "uint";
              break;
            case Int32Array:
              inputDescriptor.rawDepth = "int";
              break;
            case Float32Array:
              inputDescriptor.rawDepth = "float";
              break;
            case Float64Array:
              inputDescriptor.rawDepth = "double";
              break;
            default:
              inputDescriptor.rawDepth = "uchar";
              break;
          }
        } else {
          throw new Error("Expected width, height and channels for raw pixel input");
        }
        inputDescriptor.rawPremultiplied = false;
        if (is2.defined(inputOptions.raw.premultiplied)) {
          if (is2.bool(inputOptions.raw.premultiplied)) {
            inputDescriptor.rawPremultiplied = inputOptions.raw.premultiplied;
          } else {
            throw is2.invalidParameterError("raw.premultiplied", "boolean", inputOptions.raw.premultiplied);
          }
        }
        inputDescriptor.rawPageHeight = 0;
        if (is2.defined(inputOptions.raw.pageHeight)) {
          if (is2.integer(inputOptions.raw.pageHeight) && inputOptions.raw.pageHeight > 0 && inputOptions.raw.pageHeight <= inputOptions.raw.height) {
            if (inputOptions.raw.height % inputOptions.raw.pageHeight !== 0) {
              throw new Error(`Expected raw.height ${inputOptions.raw.height} to be a multiple of raw.pageHeight ${inputOptions.raw.pageHeight}`);
            }
            inputDescriptor.rawPageHeight = inputOptions.raw.pageHeight;
          } else {
            throw is2.invalidParameterError("raw.pageHeight", "positive integer", inputOptions.raw.pageHeight);
          }
        }
      }
      if (is2.defined(inputOptions.animated)) {
        if (is2.bool(inputOptions.animated)) {
          inputDescriptor.pages = inputOptions.animated ? -1 : 1;
        } else {
          throw is2.invalidParameterError("animated", "boolean", inputOptions.animated);
        }
      }
      if (is2.defined(inputOptions.pages)) {
        if (is2.integer(inputOptions.pages) && is2.inRange(inputOptions.pages, -1, 1e5)) {
          inputDescriptor.pages = inputOptions.pages;
        } else {
          throw is2.invalidParameterError("pages", "integer between -1 and 100000", inputOptions.pages);
        }
      }
      if (is2.defined(inputOptions.page)) {
        if (is2.integer(inputOptions.page) && is2.inRange(inputOptions.page, 0, 1e5)) {
          inputDescriptor.page = inputOptions.page;
        } else {
          throw is2.invalidParameterError("page", "integer between 0 and 100000", inputOptions.page);
        }
      }
      if (is2.object(inputOptions.openSlide) && is2.defined(inputOptions.openSlide.level)) {
        if (is2.integer(inputOptions.openSlide.level) && is2.inRange(inputOptions.openSlide.level, 0, 256)) {
          inputDescriptor.openSlideLevel = inputOptions.openSlide.level;
        } else {
          throw is2.invalidParameterError("openSlide.level", "integer between 0 and 256", inputOptions.openSlide.level);
        }
      } else if (is2.defined(inputOptions.level)) {
        if (is2.integer(inputOptions.level) && is2.inRange(inputOptions.level, 0, 256)) {
          inputDescriptor.openSlideLevel = inputOptions.level;
        } else {
          throw is2.invalidParameterError("level", "integer between 0 and 256", inputOptions.level);
        }
      }
      if (is2.object(inputOptions.tiff) && is2.defined(inputOptions.tiff.subifd)) {
        if (is2.integer(inputOptions.tiff.subifd) && is2.inRange(inputOptions.tiff.subifd, -1, 1e5)) {
          inputDescriptor.tiffSubifd = inputOptions.tiff.subifd;
        } else {
          throw is2.invalidParameterError("tiff.subifd", "integer between -1 and 100000", inputOptions.tiff.subifd);
        }
      } else if (is2.defined(inputOptions.subifd)) {
        if (is2.integer(inputOptions.subifd) && is2.inRange(inputOptions.subifd, -1, 1e5)) {
          inputDescriptor.tiffSubifd = inputOptions.subifd;
        } else {
          throw is2.invalidParameterError("subifd", "integer between -1 and 100000", inputOptions.subifd);
        }
      }
      if (is2.object(inputOptions.svg)) {
        if (is2.defined(inputOptions.svg.stylesheet)) {
          if (is2.string(inputOptions.svg.stylesheet)) {
            inputDescriptor.svgStylesheet = inputOptions.svg.stylesheet;
          } else {
            throw is2.invalidParameterError("svg.stylesheet", "string", inputOptions.svg.stylesheet);
          }
        }
        if (is2.defined(inputOptions.svg.highBitdepth)) {
          if (is2.bool(inputOptions.svg.highBitdepth)) {
            inputDescriptor.svgHighBitdepth = inputOptions.svg.highBitdepth;
          } else {
            throw is2.invalidParameterError("svg.highBitdepth", "boolean", inputOptions.svg.highBitdepth);
          }
        }
      }
      if (is2.object(inputOptions.pdf) && is2.defined(inputOptions.pdf.background)) {
        inputDescriptor.pdfBackground = this._getBackgroundColourOption(inputOptions.pdf.background);
      } else if (is2.defined(inputOptions.pdfBackground)) {
        inputDescriptor.pdfBackground = this._getBackgroundColourOption(inputOptions.pdfBackground);
      }
      if (is2.object(inputOptions.jp2) && is2.defined(inputOptions.jp2.oneshot)) {
        if (is2.bool(inputOptions.jp2.oneshot)) {
          inputDescriptor.jp2Oneshot = inputOptions.jp2.oneshot;
        } else {
          throw is2.invalidParameterError("jp2.oneshot", "boolean", inputOptions.jp2.oneshot);
        }
      }
      if (is2.defined(inputOptions.create)) {
        if (is2.object(inputOptions.create) && is2.integer(inputOptions.create.width) && inputOptions.create.width > 0 && is2.integer(inputOptions.create.height) && inputOptions.create.height > 0 && is2.integer(inputOptions.create.channels)) {
          inputDescriptor.createWidth = inputOptions.create.width;
          inputDescriptor.createHeight = inputOptions.create.height;
          inputDescriptor.createChannels = inputOptions.create.channels;
          inputDescriptor.createPageHeight = 0;
          if (is2.defined(inputOptions.create.pageHeight)) {
            if (is2.integer(inputOptions.create.pageHeight) && inputOptions.create.pageHeight > 0 && inputOptions.create.pageHeight <= inputOptions.create.height) {
              if (inputOptions.create.height % inputOptions.create.pageHeight !== 0) {
                throw new Error(`Expected create.height ${inputOptions.create.height} to be a multiple of create.pageHeight ${inputOptions.create.pageHeight}`);
              }
              inputDescriptor.createPageHeight = inputOptions.create.pageHeight;
            } else {
              throw is2.invalidParameterError("create.pageHeight", "positive integer", inputOptions.create.pageHeight);
            }
          }
          if (is2.defined(inputOptions.create.noise)) {
            if (!is2.object(inputOptions.create.noise)) {
              throw new Error("Expected noise to be an object");
            }
            if (inputOptions.create.noise.type !== "gaussian") {
              throw new Error("Only gaussian noise is supported at the moment");
            }
            inputDescriptor.createNoiseType = inputOptions.create.noise.type;
            if (!is2.inRange(inputOptions.create.channels, 1, 4)) {
              throw is2.invalidParameterError("create.channels", "number between 1 and 4", inputOptions.create.channels);
            }
            inputDescriptor.createNoiseMean = 128;
            if (is2.defined(inputOptions.create.noise.mean)) {
              if (is2.number(inputOptions.create.noise.mean) && is2.inRange(inputOptions.create.noise.mean, 0, 1e4)) {
                inputDescriptor.createNoiseMean = inputOptions.create.noise.mean;
              } else {
                throw is2.invalidParameterError("create.noise.mean", "number between 0 and 10000", inputOptions.create.noise.mean);
              }
            }
            inputDescriptor.createNoiseSigma = 30;
            if (is2.defined(inputOptions.create.noise.sigma)) {
              if (is2.number(inputOptions.create.noise.sigma) && is2.inRange(inputOptions.create.noise.sigma, 0, 1e4)) {
                inputDescriptor.createNoiseSigma = inputOptions.create.noise.sigma;
              } else {
                throw is2.invalidParameterError("create.noise.sigma", "number between 0 and 10000", inputOptions.create.noise.sigma);
              }
            }
          } else if (is2.defined(inputOptions.create.background)) {
            if (!is2.inRange(inputOptions.create.channels, 3, 4)) {
              throw is2.invalidParameterError("create.channels", "number between 3 and 4", inputOptions.create.channels);
            }
            inputDescriptor.createBackground = this._getBackgroundColourOption(inputOptions.create.background);
          } else {
            throw new Error("Expected valid noise or background to create a new input image");
          }
          delete inputDescriptor.buffer;
        } else {
          throw new Error("Expected valid width, height and channels to create a new input image");
        }
      }
      if (is2.defined(inputOptions.text)) {
        if (is2.object(inputOptions.text) && is2.string(inputOptions.text.text)) {
          inputDescriptor.textValue = inputOptions.text.text;
          if (is2.defined(inputOptions.text.height) && is2.defined(inputOptions.text.dpi)) {
            throw new Error("Expected only one of dpi or height");
          }
          if (is2.defined(inputOptions.text.font)) {
            if (is2.string(inputOptions.text.font)) {
              inputDescriptor.textFont = inputOptions.text.font;
            } else {
              throw is2.invalidParameterError("text.font", "string", inputOptions.text.font);
            }
          }
          if (is2.defined(inputOptions.text.fontfile)) {
            if (is2.string(inputOptions.text.fontfile)) {
              inputDescriptor.textFontfile = inputOptions.text.fontfile;
            } else {
              throw is2.invalidParameterError("text.fontfile", "string", inputOptions.text.fontfile);
            }
          }
          if (is2.defined(inputOptions.text.width)) {
            if (is2.integer(inputOptions.text.width) && inputOptions.text.width > 0) {
              inputDescriptor.textWidth = inputOptions.text.width;
            } else {
              throw is2.invalidParameterError("text.width", "positive integer", inputOptions.text.width);
            }
          }
          if (is2.defined(inputOptions.text.height)) {
            if (is2.integer(inputOptions.text.height) && inputOptions.text.height > 0) {
              inputDescriptor.textHeight = inputOptions.text.height;
            } else {
              throw is2.invalidParameterError("text.height", "positive integer", inputOptions.text.height);
            }
          }
          if (is2.defined(inputOptions.text.align)) {
            if (is2.string(inputOptions.text.align) && is2.string(this.constructor.align[inputOptions.text.align])) {
              inputDescriptor.textAlign = this.constructor.align[inputOptions.text.align];
            } else {
              throw is2.invalidParameterError("text.align", "valid alignment", inputOptions.text.align);
            }
          }
          if (is2.defined(inputOptions.text.justify)) {
            if (is2.bool(inputOptions.text.justify)) {
              inputDescriptor.textJustify = inputOptions.text.justify;
            } else {
              throw is2.invalidParameterError("text.justify", "boolean", inputOptions.text.justify);
            }
          }
          if (is2.defined(inputOptions.text.dpi)) {
            if (is2.integer(inputOptions.text.dpi) && is2.inRange(inputOptions.text.dpi, 1, 1e6)) {
              inputDescriptor.textDpi = inputOptions.text.dpi;
            } else {
              throw is2.invalidParameterError("text.dpi", "integer between 1 and 1000000", inputOptions.text.dpi);
            }
          }
          if (is2.defined(inputOptions.text.rgba)) {
            if (is2.bool(inputOptions.text.rgba)) {
              inputDescriptor.textRgba = inputOptions.text.rgba;
            } else {
              throw is2.invalidParameterError("text.rgba", "bool", inputOptions.text.rgba);
            }
          }
          if (is2.defined(inputOptions.text.spacing)) {
            if (is2.integer(inputOptions.text.spacing) && is2.inRange(inputOptions.text.spacing, -1e6, 1e6)) {
              inputDescriptor.textSpacing = inputOptions.text.spacing;
            } else {
              throw is2.invalidParameterError("text.spacing", "integer between -1000000 and 1000000", inputOptions.text.spacing);
            }
          }
          if (is2.defined(inputOptions.text.wrap)) {
            if (is2.string(inputOptions.text.wrap) && is2.inArray(inputOptions.text.wrap, ["word", "char", "word-char", "none"])) {
              inputDescriptor.textWrap = inputOptions.text.wrap;
            } else {
              throw is2.invalidParameterError("text.wrap", "one of: word, char, word-char, none", inputOptions.text.wrap);
            }
          }
          delete inputDescriptor.buffer;
        } else {
          throw new Error("Expected a valid string to create an image with text.");
        }
      }
      if (is2.defined(inputOptions.join)) {
        if (is2.defined(this.options.join)) {
          if (is2.defined(inputOptions.join.animated)) {
            if (is2.bool(inputOptions.join.animated)) {
              inputDescriptor.joinAnimated = inputOptions.join.animated;
            } else {
              throw is2.invalidParameterError("join.animated", "boolean", inputOptions.join.animated);
            }
          }
          if (is2.defined(inputOptions.join.across)) {
            if (is2.integer(inputOptions.join.across) && is2.inRange(inputOptions.join.across, 1, 1e6)) {
              inputDescriptor.joinAcross = inputOptions.join.across;
            } else {
              throw is2.invalidParameterError("join.across", "integer between 1 and 100000", inputOptions.join.across);
            }
          }
          if (is2.defined(inputOptions.join.shim)) {
            if (is2.integer(inputOptions.join.shim) && is2.inRange(inputOptions.join.shim, 0, 1e6)) {
              inputDescriptor.joinShim = inputOptions.join.shim;
            } else {
              throw is2.invalidParameterError("join.shim", "integer between 0 and 100000", inputOptions.join.shim);
            }
          }
          if (is2.defined(inputOptions.join.background)) {
            inputDescriptor.joinBackground = this._getBackgroundColourOption(inputOptions.join.background);
          }
          if (is2.defined(inputOptions.join.halign)) {
            if (is2.string(inputOptions.join.halign) && is2.string(this.constructor.align[inputOptions.join.halign])) {
              inputDescriptor.joinHalign = this.constructor.align[inputOptions.join.halign];
            } else {
              throw is2.invalidParameterError("join.halign", "valid alignment", inputOptions.join.halign);
            }
          }
          if (is2.defined(inputOptions.join.valign)) {
            if (is2.string(inputOptions.join.valign) && is2.string(this.constructor.align[inputOptions.join.valign])) {
              inputDescriptor.joinValign = this.constructor.align[inputOptions.join.valign];
            } else {
              throw is2.invalidParameterError("join.valign", "valid alignment", inputOptions.join.valign);
            }
          }
        } else {
          throw new Error("Expected input to be an array of images to join");
        }
      }
    } else if (is2.defined(inputOptions)) {
      throw new Error(`Invalid input options ${inputOptions}`);
    }
    return inputDescriptor;
  }
  function _write(chunk, _encoding, callback) {
    if (Array.isArray(this.options.input.buffer)) {
      if (is2.buffer(chunk)) {
        if (this.options.input.buffer.length === 0) {
          this.on("finish", () => {
            this.streamInFinished = true;
          });
        }
        this.options.input.buffer.push(chunk);
        callback();
      } else {
        callback(new Error("Non-Buffer data on Writable Stream"));
      }
    } else {
      callback(new Error("Unexpected data on Writable Stream"));
    }
  }
  function _flattenBufferIn() {
    if (this._isStreamInput()) {
      this.options.input.buffer = Buffer.concat(this.options.input.buffer);
    }
  }
  function _isStreamInput() {
    return Array.isArray(this.options.input.buffer);
  }
  function metadata(callback) {
    const stack = Error();
    if (is2.fn(callback)) {
      if (this._isStreamInput()) {
        this.on("finish", () => {
          this._flattenBufferIn();
          sharp.metadata(this.options, (err, metadata2) => {
            if (err) {
              callback(is2.nativeError(err, stack));
            } else {
              callback(null, metadata2);
            }
          });
        });
      } else {
        sharp.metadata(this.options, (err, metadata2) => {
          if (err) {
            callback(is2.nativeError(err, stack));
          } else {
            callback(null, metadata2);
          }
        });
      }
      return this;
    } else {
      if (this._isStreamInput()) {
        return new Promise((resolve4, reject) => {
          const finished = () => {
            this._flattenBufferIn();
            sharp.metadata(this.options, (err, metadata2) => {
              if (err) {
                reject(is2.nativeError(err, stack));
              } else {
                resolve4(metadata2);
              }
            });
          };
          if (this.writableFinished) {
            finished();
          } else {
            this.once("finish", finished);
          }
        });
      } else {
        return new Promise((resolve4, reject) => {
          sharp.metadata(this.options, (err, metadata2) => {
            if (err) {
              reject(is2.nativeError(err, stack));
            } else {
              resolve4(metadata2);
            }
          });
        });
      }
    }
  }
  function stats(callback) {
    const stack = Error();
    if (is2.fn(callback)) {
      if (this._isStreamInput()) {
        this.on("finish", () => {
          this._flattenBufferIn();
          sharp.stats(this.options, (err, stats2) => {
            if (err) {
              callback(is2.nativeError(err, stack));
            } else {
              callback(null, stats2);
            }
          });
        });
      } else {
        sharp.stats(this.options, (err, stats2) => {
          if (err) {
            callback(is2.nativeError(err, stack));
          } else {
            callback(null, stats2);
          }
        });
      }
      return this;
    } else {
      if (this._isStreamInput()) {
        return new Promise((resolve4, reject) => {
          this.on("finish", function() {
            this._flattenBufferIn();
            sharp.stats(this.options, (err, stats2) => {
              if (err) {
                reject(is2.nativeError(err, stack));
              } else {
                resolve4(stats2);
              }
            });
          });
        });
      } else {
        return new Promise((resolve4, reject) => {
          sharp.stats(this.options, (err, stats2) => {
            if (err) {
              reject(is2.nativeError(err, stack));
            } else {
              resolve4(stats2);
            }
          });
        });
      }
    }
  }
  module.exports = (Sharp) => {
    Object.assign(Sharp.prototype, {
      _inputOptionsFromObject,
      _createInputDescriptor,
      _write,
      _flattenBufferIn,
      _isStreamInput,
      metadata,
      stats
    });
    Sharp.align = align;
  };
});

// node_modules/sharp/lib/resize.js
var require_resize = __commonJS((exports, module) => {
  /*!
    Copyright 2013 Lovell Fuller and others.
    SPDX-License-Identifier: Apache-2.0
  */
  var is2 = require_is();
  var gravity = {
    center: 0,
    centre: 0,
    north: 1,
    east: 2,
    south: 3,
    west: 4,
    northeast: 5,
    southeast: 6,
    southwest: 7,
    northwest: 8
  };
  var position = {
    top: 1,
    right: 2,
    bottom: 3,
    left: 4,
    "right top": 5,
    "right bottom": 6,
    "left bottom": 7,
    "left top": 8
  };
  var extendWith = {
    background: "background",
    copy: "copy",
    repeat: "repeat",
    mirror: "mirror"
  };
  var strategy = {
    entropy: 16,
    attention: 17
  };
  var kernel = {
    nearest: "nearest",
    linear: "linear",
    cubic: "cubic",
    mitchell: "mitchell",
    lanczos2: "lanczos2",
    lanczos3: "lanczos3",
    mks2013: "mks2013",
    mks2021: "mks2021"
  };
  var fit = {
    contain: "contain",
    cover: "cover",
    fill: "fill",
    inside: "inside",
    outside: "outside"
  };
  var mapFitToCanvas = {
    contain: "embed",
    cover: "crop",
    fill: "ignore_aspect",
    inside: "max",
    outside: "min"
  };
  function isRotationExpected(options2) {
    return options2.angle % 360 !== 0 || options2.rotationAngle !== 0;
  }
  function isResizeExpected(options2) {
    return options2.width !== -1 || options2.height !== -1;
  }
  function resize(widthOrOptions, height, options2) {
    if (isResizeExpected(this.options)) {
      this.options.debuglog("ignoring previous resize options");
    }
    if (this.options.widthPost !== -1) {
      this.options.debuglog("operation order will be: extract, resize, extract");
    }
    if (is2.defined(widthOrOptions)) {
      if (is2.object(widthOrOptions) && !is2.defined(options2)) {
        options2 = widthOrOptions;
      } else if (is2.integer(widthOrOptions) && widthOrOptions > 0) {
        this.options.width = widthOrOptions;
      } else {
        throw is2.invalidParameterError("width", "positive integer", widthOrOptions);
      }
    } else {
      this.options.width = -1;
    }
    if (is2.defined(height)) {
      if (is2.integer(height) && height > 0) {
        this.options.height = height;
      } else {
        throw is2.invalidParameterError("height", "positive integer", height);
      }
    } else {
      this.options.height = -1;
    }
    if (is2.object(options2)) {
      if (is2.defined(options2.width)) {
        if (is2.integer(options2.width) && options2.width > 0) {
          this.options.width = options2.width;
        } else {
          throw is2.invalidParameterError("width", "positive integer", options2.width);
        }
      }
      if (is2.defined(options2.height)) {
        if (is2.integer(options2.height) && options2.height > 0) {
          this.options.height = options2.height;
        } else {
          throw is2.invalidParameterError("height", "positive integer", options2.height);
        }
      }
      if (is2.defined(options2.fit)) {
        const canvas = mapFitToCanvas[options2.fit];
        if (is2.string(canvas)) {
          this.options.canvas = canvas;
        } else {
          throw is2.invalidParameterError("fit", "valid fit", options2.fit);
        }
      }
      if (is2.defined(options2.position)) {
        const pos = is2.integer(options2.position) ? options2.position : strategy[options2.position] || position[options2.position] || gravity[options2.position];
        if (is2.integer(pos) && (is2.inRange(pos, 0, 8) || is2.inRange(pos, 16, 17))) {
          this.options.position = pos;
        } else {
          throw is2.invalidParameterError("position", "valid position/gravity/strategy", options2.position);
        }
      }
      this._setBackgroundColourOption("resizeBackground", options2.background);
      if (is2.defined(options2.kernel)) {
        if (is2.string(kernel[options2.kernel])) {
          this.options.kernel = kernel[options2.kernel];
        } else {
          throw is2.invalidParameterError("kernel", "valid kernel name", options2.kernel);
        }
      }
      if (is2.defined(options2.withoutEnlargement)) {
        this._setBooleanOption("withoutEnlargement", options2.withoutEnlargement);
      }
      if (is2.defined(options2.withoutReduction)) {
        this._setBooleanOption("withoutReduction", options2.withoutReduction);
      }
      if (is2.defined(options2.fastShrinkOnLoad)) {
        this._setBooleanOption("fastShrinkOnLoad", options2.fastShrinkOnLoad);
      }
    }
    if (isRotationExpected(this.options) && isResizeExpected(this.options)) {
      this.options.rotateBefore = true;
    }
    return this;
  }
  function extend4(extend5) {
    if (is2.integer(extend5) && extend5 > 0) {
      this.options.extendTop = extend5;
      this.options.extendBottom = extend5;
      this.options.extendLeft = extend5;
      this.options.extendRight = extend5;
    } else if (is2.object(extend5)) {
      if (is2.defined(extend5.top)) {
        if (is2.integer(extend5.top) && extend5.top >= 0) {
          this.options.extendTop = extend5.top;
        } else {
          throw is2.invalidParameterError("top", "positive integer", extend5.top);
        }
      }
      if (is2.defined(extend5.bottom)) {
        if (is2.integer(extend5.bottom) && extend5.bottom >= 0) {
          this.options.extendBottom = extend5.bottom;
        } else {
          throw is2.invalidParameterError("bottom", "positive integer", extend5.bottom);
        }
      }
      if (is2.defined(extend5.left)) {
        if (is2.integer(extend5.left) && extend5.left >= 0) {
          this.options.extendLeft = extend5.left;
        } else {
          throw is2.invalidParameterError("left", "positive integer", extend5.left);
        }
      }
      if (is2.defined(extend5.right)) {
        if (is2.integer(extend5.right) && extend5.right >= 0) {
          this.options.extendRight = extend5.right;
        } else {
          throw is2.invalidParameterError("right", "positive integer", extend5.right);
        }
      }
      this._setBackgroundColourOption("extendBackground", extend5.background);
      if (is2.defined(extend5.extendWith)) {
        if (is2.string(extendWith[extend5.extendWith])) {
          this.options.extendWith = extendWith[extend5.extendWith];
        } else {
          throw is2.invalidParameterError("extendWith", "one of: background, copy, repeat, mirror", extend5.extendWith);
        }
      }
    } else {
      throw is2.invalidParameterError("extend", "integer or object", extend5);
    }
    return this;
  }
  function extract(options2) {
    const suffix = isResizeExpected(this.options) || this.options.widthPre !== -1 ? "Post" : "Pre";
    if (this.options[`width${suffix}`] !== -1) {
      this.options.debuglog("ignoring previous extract options");
    }
    ["left", "top", "width", "height"].forEach(function(name) {
      const value = options2[name];
      if (is2.integer(value) && value >= 0) {
        this.options[name + (name === "left" || name === "top" ? "Offset" : "") + suffix] = value;
      } else {
        throw is2.invalidParameterError(name, "integer", value);
      }
    }, this);
    if (isRotationExpected(this.options) && !isResizeExpected(this.options)) {
      if (this.options.widthPre === -1 || this.options.widthPost === -1) {
        this.options.rotateBefore = true;
      }
    }
    if (this.options.input.autoOrient) {
      this.options.orientBefore = true;
    }
    return this;
  }
  function trim(options2) {
    this.options.trimThreshold = 10;
    if (is2.defined(options2)) {
      if (is2.object(options2)) {
        if (is2.defined(options2.background)) {
          this._setBackgroundColourOption("trimBackground", options2.background);
        }
        if (is2.defined(options2.threshold)) {
          if (is2.number(options2.threshold) && options2.threshold >= 0) {
            this.options.trimThreshold = options2.threshold;
          } else {
            throw is2.invalidParameterError("threshold", "positive number", options2.threshold);
          }
        }
        if (is2.defined(options2.lineArt)) {
          this._setBooleanOption("trimLineArt", options2.lineArt);
        }
      } else {
        throw is2.invalidParameterError("trim", "object", options2);
      }
    }
    if (isRotationExpected(this.options)) {
      this.options.rotateBefore = true;
    }
    return this;
  }
  module.exports = (Sharp) => {
    Object.assign(Sharp.prototype, {
      resize,
      extend: extend4,
      extract,
      trim
    });
    Sharp.gravity = gravity;
    Sharp.strategy = strategy;
    Sharp.kernel = kernel;
    Sharp.fit = fit;
    Sharp.position = position;
  };
});

// node_modules/sharp/lib/composite.js
var require_composite = __commonJS((exports, module) => {
  /*!
    Copyright 2013 Lovell Fuller and others.
    SPDX-License-Identifier: Apache-2.0
  */
  var is2 = require_is();
  var blend = {
    clear: "clear",
    source: "source",
    over: "over",
    in: "in",
    out: "out",
    atop: "atop",
    dest: "dest",
    "dest-over": "dest-over",
    "dest-in": "dest-in",
    "dest-out": "dest-out",
    "dest-atop": "dest-atop",
    xor: "xor",
    add: "add",
    saturate: "saturate",
    multiply: "multiply",
    screen: "screen",
    overlay: "overlay",
    darken: "darken",
    lighten: "lighten",
    "colour-dodge": "colour-dodge",
    "color-dodge": "colour-dodge",
    "colour-burn": "colour-burn",
    "color-burn": "colour-burn",
    "hard-light": "hard-light",
    "soft-light": "soft-light",
    difference: "difference",
    exclusion: "exclusion"
  };
  function composite(images) {
    if (!Array.isArray(images)) {
      throw is2.invalidParameterError("images to composite", "array", images);
    }
    this.options.composite = images.map((image) => {
      if (!is2.object(image)) {
        throw is2.invalidParameterError("image to composite", "object", image);
      }
      const inputOptions = this._inputOptionsFromObject(image);
      const composite2 = {
        input: this._createInputDescriptor(image.input, inputOptions, { allowStream: false }),
        blend: "over",
        tile: false,
        left: 0,
        top: 0,
        hasOffset: false,
        gravity: 0,
        premultiplied: false
      };
      if (is2.defined(image.blend)) {
        if (is2.string(blend[image.blend])) {
          composite2.blend = blend[image.blend];
        } else {
          throw is2.invalidParameterError("blend", "valid blend name", image.blend);
        }
      }
      if (is2.defined(image.tile)) {
        if (is2.bool(image.tile)) {
          composite2.tile = image.tile;
        } else {
          throw is2.invalidParameterError("tile", "boolean", image.tile);
        }
      }
      if (is2.defined(image.left)) {
        if (is2.integer(image.left)) {
          composite2.left = image.left;
        } else {
          throw is2.invalidParameterError("left", "integer", image.left);
        }
      }
      if (is2.defined(image.top)) {
        if (is2.integer(image.top)) {
          composite2.top = image.top;
        } else {
          throw is2.invalidParameterError("top", "integer", image.top);
        }
      }
      if (is2.defined(image.top) !== is2.defined(image.left)) {
        throw new Error("Expected both left and top to be set");
      } else {
        composite2.hasOffset = is2.integer(image.top) && is2.integer(image.left);
      }
      if (is2.defined(image.gravity)) {
        if (is2.integer(image.gravity) && is2.inRange(image.gravity, 0, 8)) {
          composite2.gravity = image.gravity;
        } else if (is2.string(image.gravity) && is2.integer(this.constructor.gravity[image.gravity])) {
          composite2.gravity = this.constructor.gravity[image.gravity];
        } else {
          throw is2.invalidParameterError("gravity", "valid gravity", image.gravity);
        }
      }
      if (is2.defined(image.premultiplied)) {
        if (is2.bool(image.premultiplied)) {
          composite2.premultiplied = image.premultiplied;
        } else {
          throw is2.invalidParameterError("premultiplied", "boolean", image.premultiplied);
        }
      }
      return composite2;
    });
    return this;
  }
  module.exports = (Sharp) => {
    Sharp.prototype.composite = composite;
    Sharp.blend = blend;
  };
});

// node_modules/sharp/lib/operation.js
var require_operation = __commonJS((exports, module) => {
  /*!
    Copyright 2013 Lovell Fuller and others.
    SPDX-License-Identifier: Apache-2.0
  */
  var is2 = require_is();
  var vipsPrecision = {
    integer: "integer",
    float: "float",
    approximate: "approximate"
  };
  function rotate(angle, options2) {
    if (!is2.defined(angle)) {
      return this.autoOrient();
    }
    if (this.options.angle || this.options.rotationAngle) {
      this.options.debuglog("ignoring previous rotate options");
      this.options.angle = 0;
      this.options.rotationAngle = 0;
    }
    if (is2.integer(angle) && !(angle % 90)) {
      this.options.angle = angle;
    } else if (is2.number(angle)) {
      this.options.rotationAngle = angle;
      if (is2.object(options2) && options2.background) {
        this._setBackgroundColourOption("rotationBackground", options2.background);
      }
    } else {
      throw is2.invalidParameterError("angle", "numeric", angle);
    }
    return this;
  }
  function autoOrient() {
    this.options.input.autoOrient = true;
    return this;
  }
  function flip(flip2) {
    this.options.flip = is2.bool(flip2) ? flip2 : true;
    return this;
  }
  function flop(flop2) {
    this.options.flop = is2.bool(flop2) ? flop2 : true;
    return this;
  }
  function affine(matrix, options2) {
    const flatMatrix = [].concat(...matrix);
    if (flatMatrix.length === 4 && flatMatrix.every(is2.number)) {
      this.options.affineMatrix = flatMatrix;
    } else {
      throw is2.invalidParameterError("matrix", "1x4 or 2x2 array", matrix);
    }
    if (is2.defined(options2)) {
      if (is2.object(options2)) {
        this._setBackgroundColourOption("affineBackground", options2.background);
        if (is2.defined(options2.idx)) {
          if (is2.number(options2.idx)) {
            this.options.affineIdx = options2.idx;
          } else {
            throw is2.invalidParameterError("options.idx", "number", options2.idx);
          }
        }
        if (is2.defined(options2.idy)) {
          if (is2.number(options2.idy)) {
            this.options.affineIdy = options2.idy;
          } else {
            throw is2.invalidParameterError("options.idy", "number", options2.idy);
          }
        }
        if (is2.defined(options2.odx)) {
          if (is2.number(options2.odx)) {
            this.options.affineOdx = options2.odx;
          } else {
            throw is2.invalidParameterError("options.odx", "number", options2.odx);
          }
        }
        if (is2.defined(options2.ody)) {
          if (is2.number(options2.ody)) {
            this.options.affineOdy = options2.ody;
          } else {
            throw is2.invalidParameterError("options.ody", "number", options2.ody);
          }
        }
        if (is2.defined(options2.interpolator)) {
          if (is2.inArray(options2.interpolator, Object.values(this.constructor.interpolators))) {
            this.options.affineInterpolator = options2.interpolator;
          } else {
            throw is2.invalidParameterError("options.interpolator", "valid interpolator name", options2.interpolator);
          }
        }
      } else {
        throw is2.invalidParameterError("options", "object", options2);
      }
    }
    return this;
  }
  function sharpen(options2, flat, jagged) {
    if (!is2.defined(options2)) {
      this.options.sharpenSigma = -1;
    } else if (is2.bool(options2)) {
      this.options.sharpenSigma = options2 ? -1 : 0;
    } else if (is2.number(options2) && is2.inRange(options2, 0.01, 1e4)) {
      this.options.sharpenSigma = options2;
      if (is2.defined(flat)) {
        if (is2.number(flat) && is2.inRange(flat, 0, 1e4)) {
          this.options.sharpenM1 = flat;
        } else {
          throw is2.invalidParameterError("flat", "number between 0 and 10000", flat);
        }
      }
      if (is2.defined(jagged)) {
        if (is2.number(jagged) && is2.inRange(jagged, 0, 1e4)) {
          this.options.sharpenM2 = jagged;
        } else {
          throw is2.invalidParameterError("jagged", "number between 0 and 10000", jagged);
        }
      }
    } else if (is2.plainObject(options2)) {
      if (is2.number(options2.sigma) && is2.inRange(options2.sigma, 0.000001, 10)) {
        this.options.sharpenSigma = options2.sigma;
      } else {
        throw is2.invalidParameterError("options.sigma", "number between 0.000001 and 10", options2.sigma);
      }
      if (is2.defined(options2.m1)) {
        if (is2.number(options2.m1) && is2.inRange(options2.m1, 0, 1e6)) {
          this.options.sharpenM1 = options2.m1;
        } else {
          throw is2.invalidParameterError("options.m1", "number between 0 and 1000000", options2.m1);
        }
      }
      if (is2.defined(options2.m2)) {
        if (is2.number(options2.m2) && is2.inRange(options2.m2, 0, 1e6)) {
          this.options.sharpenM2 = options2.m2;
        } else {
          throw is2.invalidParameterError("options.m2", "number between 0 and 1000000", options2.m2);
        }
      }
      if (is2.defined(options2.x1)) {
        if (is2.number(options2.x1) && is2.inRange(options2.x1, 0, 1e6)) {
          this.options.sharpenX1 = options2.x1;
        } else {
          throw is2.invalidParameterError("options.x1", "number between 0 and 1000000", options2.x1);
        }
      }
      if (is2.defined(options2.y2)) {
        if (is2.number(options2.y2) && is2.inRange(options2.y2, 0, 1e6)) {
          this.options.sharpenY2 = options2.y2;
        } else {
          throw is2.invalidParameterError("options.y2", "number between 0 and 1000000", options2.y2);
        }
      }
      if (is2.defined(options2.y3)) {
        if (is2.number(options2.y3) && is2.inRange(options2.y3, 0, 1e6)) {
          this.options.sharpenY3 = options2.y3;
        } else {
          throw is2.invalidParameterError("options.y3", "number between 0 and 1000000", options2.y3);
        }
      }
    } else {
      throw is2.invalidParameterError("sigma", "number between 0.01 and 10000", options2);
    }
    return this;
  }
  function median(size) {
    if (!is2.defined(size)) {
      this.options.medianSize = 3;
    } else if (is2.integer(size) && is2.inRange(size, 1, 1000)) {
      this.options.medianSize = size;
    } else {
      throw is2.invalidParameterError("size", "integer between 1 and 1000", size);
    }
    return this;
  }
  function blur(options2) {
    let sigma;
    if (is2.number(options2)) {
      sigma = options2;
    } else if (is2.plainObject(options2)) {
      if (!is2.number(options2.sigma)) {
        throw is2.invalidParameterError("options.sigma", "number between 0.3 and 1000", sigma);
      }
      sigma = options2.sigma;
      if ("precision" in options2) {
        if (is2.string(vipsPrecision[options2.precision])) {
          this.options.precision = vipsPrecision[options2.precision];
        } else {
          throw is2.invalidParameterError("precision", "one of: integer, float, approximate", options2.precision);
        }
      }
      if ("minAmplitude" in options2) {
        if (is2.number(options2.minAmplitude) && is2.inRange(options2.minAmplitude, 0.001, 1)) {
          this.options.minAmpl = options2.minAmplitude;
        } else {
          throw is2.invalidParameterError("minAmplitude", "number between 0.001 and 1", options2.minAmplitude);
        }
      }
    }
    if (!is2.defined(options2)) {
      this.options.blurSigma = -1;
    } else if (is2.bool(options2)) {
      this.options.blurSigma = options2 ? -1 : 0;
    } else if (is2.number(sigma) && is2.inRange(sigma, 0.3, 1000)) {
      this.options.blurSigma = sigma;
    } else {
      throw is2.invalidParameterError("sigma", "number between 0.3 and 1000", sigma);
    }
    return this;
  }
  function dilate(width) {
    if (!is2.defined(width)) {
      this.options.dilateWidth = 1;
    } else if (is2.integer(width) && width > 0) {
      this.options.dilateWidth = width;
    } else {
      throw is2.invalidParameterError("dilate", "positive integer", dilate);
    }
    return this;
  }
  function erode(width) {
    if (!is2.defined(width)) {
      this.options.erodeWidth = 1;
    } else if (is2.integer(width) && width > 0) {
      this.options.erodeWidth = width;
    } else {
      throw is2.invalidParameterError("erode", "positive integer", erode);
    }
    return this;
  }
  function flatten(options2) {
    this.options.flatten = is2.bool(options2) ? options2 : true;
    if (is2.object(options2)) {
      this._setBackgroundColourOption("flattenBackground", options2.background);
    }
    return this;
  }
  function unflatten() {
    this.options.unflatten = true;
    return this;
  }
  function gamma(gamma2, gammaOut) {
    if (!is2.defined(gamma2)) {
      this.options.gamma = 2.2;
    } else if (is2.number(gamma2) && is2.inRange(gamma2, 1, 3)) {
      this.options.gamma = gamma2;
    } else {
      throw is2.invalidParameterError("gamma", "number between 1.0 and 3.0", gamma2);
    }
    if (!is2.defined(gammaOut)) {
      this.options.gammaOut = this.options.gamma;
    } else if (is2.number(gammaOut) && is2.inRange(gammaOut, 1, 3)) {
      this.options.gammaOut = gammaOut;
    } else {
      throw is2.invalidParameterError("gammaOut", "number between 1.0 and 3.0", gammaOut);
    }
    return this;
  }
  function negate(options2) {
    this.options.negate = is2.bool(options2) ? options2 : true;
    if (is2.plainObject(options2) && "alpha" in options2) {
      if (!is2.bool(options2.alpha)) {
        throw is2.invalidParameterError("alpha", "should be boolean value", options2.alpha);
      } else {
        this.options.negateAlpha = options2.alpha;
      }
    }
    return this;
  }
  function normalise(options2) {
    if (is2.plainObject(options2)) {
      if (is2.defined(options2.lower)) {
        if (is2.number(options2.lower) && is2.inRange(options2.lower, 0, 99)) {
          this.options.normaliseLower = options2.lower;
        } else {
          throw is2.invalidParameterError("lower", "number between 0 and 99", options2.lower);
        }
      }
      if (is2.defined(options2.upper)) {
        if (is2.number(options2.upper) && is2.inRange(options2.upper, 1, 100)) {
          this.options.normaliseUpper = options2.upper;
        } else {
          throw is2.invalidParameterError("upper", "number between 1 and 100", options2.upper);
        }
      }
    }
    if (this.options.normaliseLower >= this.options.normaliseUpper) {
      throw is2.invalidParameterError("range", "lower to be less than upper", `${this.options.normaliseLower} >= ${this.options.normaliseUpper}`);
    }
    this.options.normalise = true;
    return this;
  }
  function normalize2(options2) {
    return this.normalise(options2);
  }
  function clahe(options2) {
    if (is2.plainObject(options2)) {
      if (is2.integer(options2.width) && options2.width > 0) {
        this.options.claheWidth = options2.width;
      } else {
        throw is2.invalidParameterError("width", "integer greater than zero", options2.width);
      }
      if (is2.integer(options2.height) && options2.height > 0) {
        this.options.claheHeight = options2.height;
      } else {
        throw is2.invalidParameterError("height", "integer greater than zero", options2.height);
      }
      if (is2.defined(options2.maxSlope)) {
        if (is2.integer(options2.maxSlope) && is2.inRange(options2.maxSlope, 0, 100)) {
          this.options.claheMaxSlope = options2.maxSlope;
        } else {
          throw is2.invalidParameterError("maxSlope", "integer between 0 and 100", options2.maxSlope);
        }
      }
    } else {
      throw is2.invalidParameterError("options", "plain object", options2);
    }
    return this;
  }
  function convolve(kernel) {
    if (!is2.object(kernel) || !Array.isArray(kernel.kernel) || !is2.integer(kernel.width) || !is2.integer(kernel.height) || !is2.inRange(kernel.width, 3, 1001) || !is2.inRange(kernel.height, 3, 1001) || kernel.height * kernel.width !== kernel.kernel.length) {
      throw new Error("Invalid convolution kernel");
    }
    if (!is2.integer(kernel.scale)) {
      kernel.scale = kernel.kernel.reduce((a, b) => a + b, 0);
    }
    if (kernel.scale < 1) {
      kernel.scale = 1;
    }
    if (!is2.integer(kernel.offset)) {
      kernel.offset = 0;
    }
    this.options.convKernel = kernel;
    return this;
  }
  function threshold(threshold2, options2) {
    if (!is2.defined(threshold2)) {
      this.options.threshold = 128;
    } else if (is2.bool(threshold2)) {
      this.options.threshold = threshold2 ? 128 : 0;
    } else if (is2.integer(threshold2) && is2.inRange(threshold2, 0, 255)) {
      this.options.threshold = threshold2;
    } else {
      throw is2.invalidParameterError("threshold", "integer between 0 and 255", threshold2);
    }
    if (!is2.object(options2) || options2.greyscale === true || options2.grayscale === true) {
      this.options.thresholdGrayscale = true;
    } else {
      this.options.thresholdGrayscale = false;
    }
    return this;
  }
  function boolean7(operand, operator, options2) {
    this.options.boolean = this._createInputDescriptor(operand, options2);
    if (is2.string(operator) && is2.inArray(operator, ["and", "or", "eor"])) {
      this.options.booleanOp = operator;
    } else {
      throw is2.invalidParameterError("operator", "one of: and, or, eor", operator);
    }
    return this;
  }
  function linear(a, b) {
    if (!is2.defined(a) && is2.number(b)) {
      a = 1;
    } else if (is2.number(a) && !is2.defined(b)) {
      b = 0;
    }
    if (!is2.defined(a)) {
      this.options.linearA = [];
    } else if (is2.number(a)) {
      this.options.linearA = [a];
    } else if (Array.isArray(a) && a.length && a.every(is2.number)) {
      this.options.linearA = a;
    } else {
      throw is2.invalidParameterError("a", "number or array of numbers", a);
    }
    if (!is2.defined(b)) {
      this.options.linearB = [];
    } else if (is2.number(b)) {
      this.options.linearB = [b];
    } else if (Array.isArray(b) && b.length && b.every(is2.number)) {
      this.options.linearB = b;
    } else {
      throw is2.invalidParameterError("b", "number or array of numbers", b);
    }
    if (this.options.linearA.length !== this.options.linearB.length) {
      throw new Error("Expected a and b to be arrays of the same length");
    }
    return this;
  }
  function recomb(inputMatrix) {
    if (!Array.isArray(inputMatrix)) {
      throw is2.invalidParameterError("inputMatrix", "array", inputMatrix);
    }
    if (inputMatrix.length !== 3 && inputMatrix.length !== 4) {
      throw is2.invalidParameterError("inputMatrix", "3x3 or 4x4 array", inputMatrix.length);
    }
    const recombMatrix = inputMatrix.flat().map(Number);
    if (recombMatrix.length !== 9 && recombMatrix.length !== 16) {
      throw is2.invalidParameterError("inputMatrix", "cardinality of 9 or 16", recombMatrix.length);
    }
    this.options.recombMatrix = recombMatrix;
    return this;
  }
  function modulate(options2) {
    if (!is2.plainObject(options2)) {
      throw is2.invalidParameterError("options", "plain object", options2);
    }
    if ("brightness" in options2) {
      if (is2.number(options2.brightness) && options2.brightness >= 0) {
        this.options.brightness = options2.brightness;
      } else {
        throw is2.invalidParameterError("brightness", "number above zero", options2.brightness);
      }
    }
    if ("saturation" in options2) {
      if (is2.number(options2.saturation) && options2.saturation >= 0) {
        this.options.saturation = options2.saturation;
      } else {
        throw is2.invalidParameterError("saturation", "number above zero", options2.saturation);
      }
    }
    if ("hue" in options2) {
      if (is2.integer(options2.hue)) {
        this.options.hue = options2.hue % 360;
      } else {
        throw is2.invalidParameterError("hue", "number", options2.hue);
      }
    }
    if ("lightness" in options2) {
      if (is2.number(options2.lightness)) {
        this.options.lightness = options2.lightness;
      } else {
        throw is2.invalidParameterError("lightness", "number", options2.lightness);
      }
    }
    return this;
  }
  module.exports = (Sharp) => {
    Object.assign(Sharp.prototype, {
      autoOrient,
      rotate,
      flip,
      flop,
      affine,
      sharpen,
      erode,
      dilate,
      median,
      blur,
      flatten,
      unflatten,
      gamma,
      negate,
      normalise,
      normalize: normalize2,
      clahe,
      convolve,
      threshold,
      boolean: boolean7,
      linear,
      recomb,
      modulate
    });
  };
});

// node_modules/@img/colour/color.cjs
var require_color = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except2, desc2) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except2)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc2 = __getOwnPropDesc(from, key)) || desc2.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var index_exports = {};
  __export2(index_exports, {
    default: () => index_default
  });
  module.exports = __toCommonJS(index_exports);
  var color_name_default = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  };
  var reverseNames = /* @__PURE__ */ Object.create(null);
  for (const name in color_name_default) {
    if (Object.hasOwn(color_name_default, name)) {
      reverseNames[color_name_default[name]] = name;
    }
  }
  var cs = {
    to: {},
    get: {}
  };
  cs.get = function(string7) {
    const prefix = string7.slice(0, 3).toLowerCase();
    let value;
    let model;
    switch (prefix) {
      case "hsl": {
        value = cs.get.hsl(string7);
        model = "hsl";
        break;
      }
      case "hwb": {
        value = cs.get.hwb(string7);
        model = "hwb";
        break;
      }
      default: {
        value = cs.get.rgb(string7);
        model = "rgb";
        break;
      }
    }
    if (!value) {
      return null;
    }
    return { model, value };
  };
  cs.get.rgb = function(string7) {
    if (!string7) {
      return null;
    }
    const abbr = /^#([a-f\d]{3,4})$/i;
    const hex3 = /^#([a-f\d]{6})([a-f\d]{2})?$/i;
    const rgba = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[\s,|/]\s*([+-]?[\d.]+)(%?)\s*)?\)$/;
    const per = /^rgba?\(\s*([+-]?[\d.]+)%\s*,?\s*([+-]?[\d.]+)%\s*,?\s*([+-]?[\d.]+)%\s*(?:[\s,|/]\s*([+-]?[\d.]+)(%?)\s*)?\)$/;
    const keyword = /^(\w+)$/;
    let rgb = [0, 0, 0, 1];
    let match;
    let i;
    let hexAlpha;
    if (match = string7.match(hex3)) {
      hexAlpha = match[2];
      match = match[1];
      for (i = 0;i < 3; i++) {
        const i2 = i * 2;
        rgb[i] = Number.parseInt(match.slice(i2, i2 + 2), 16);
      }
      if (hexAlpha) {
        rgb[3] = Number.parseInt(hexAlpha, 16) / 255;
      }
    } else if (match = string7.match(abbr)) {
      match = match[1];
      hexAlpha = match[3];
      for (i = 0;i < 3; i++) {
        rgb[i] = Number.parseInt(match[i] + match[i], 16);
      }
      if (hexAlpha) {
        rgb[3] = Number.parseInt(hexAlpha + hexAlpha, 16) / 255;
      }
    } else if (match = string7.match(rgba)) {
      for (i = 0;i < 3; i++) {
        rgb[i] = Number.parseInt(match[i + 1], 10);
      }
      if (match[4]) {
        rgb[3] = match[5] ? Number.parseFloat(match[4]) * 0.01 : Number.parseFloat(match[4]);
      }
    } else if (match = string7.match(per)) {
      for (i = 0;i < 3; i++) {
        rgb[i] = Math.round(Number.parseFloat(match[i + 1]) * 2.55);
      }
      if (match[4]) {
        rgb[3] = match[5] ? Number.parseFloat(match[4]) * 0.01 : Number.parseFloat(match[4]);
      }
    } else if (match = string7.match(keyword)) {
      if (match[1] === "transparent") {
        return [0, 0, 0, 0];
      }
      if (!Object.hasOwn(color_name_default, match[1])) {
        return null;
      }
      rgb = color_name_default[match[1]];
      rgb[3] = 1;
      return rgb;
    } else {
      return null;
    }
    for (i = 0;i < 3; i++) {
      rgb[i] = clamp(rgb[i], 0, 255);
    }
    rgb[3] = clamp(rgb[3], 0, 1);
    return rgb;
  };
  cs.get.hsl = function(string7) {
    if (!string7) {
      return null;
    }
    const hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d.]+)%\s*,?\s*([+-]?[\d.]+)%\s*(?:[,|/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
    const match = string7.match(hsl);
    if (match) {
      const alpha = Number.parseFloat(match[4]);
      const h = (Number.parseFloat(match[1]) % 360 + 360) % 360;
      const s = clamp(Number.parseFloat(match[2]), 0, 100);
      const l = clamp(Number.parseFloat(match[3]), 0, 100);
      const a = clamp(Number.isNaN(alpha) ? 1 : alpha, 0, 1);
      return [h, s, l, a];
    }
    return null;
  };
  cs.get.hwb = function(string7) {
    if (!string7) {
      return null;
    }
    const hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*[\s,]\s*([+-]?[\d.]+)%\s*[\s,]\s*([+-]?[\d.]+)%\s*(?:[\s,]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
    const match = string7.match(hwb);
    if (match) {
      const alpha = Number.parseFloat(match[4]);
      const h = (Number.parseFloat(match[1]) % 360 + 360) % 360;
      const w = clamp(Number.parseFloat(match[2]), 0, 100);
      const b = clamp(Number.parseFloat(match[3]), 0, 100);
      const a = clamp(Number.isNaN(alpha) ? 1 : alpha, 0, 1);
      return [h, w, b, a];
    }
    return null;
  };
  cs.to.hex = function(...rgba) {
    return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (rgba[3] < 1 ? hexDouble(Math.round(rgba[3] * 255)) : "");
  };
  cs.to.rgb = function(...rgba) {
    return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ")" : "rgba(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ", " + rgba[3] + ")";
  };
  cs.to.rgb.percent = function(...rgba) {
    const r = Math.round(rgba[0] / 255 * 100);
    const g = Math.round(rgba[1] / 255 * 100);
    const b = Math.round(rgba[2] / 255 * 100);
    return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + r + "%, " + g + "%, " + b + "%)" : "rgba(" + r + "%, " + g + "%, " + b + "%, " + rgba[3] + ")";
  };
  cs.to.hsl = function(...hsla) {
    return hsla.length < 4 || hsla[3] === 1 ? "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)" : "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + hsla[3] + ")";
  };
  cs.to.hwb = function(...hwba) {
    let a = "";
    if (hwba.length >= 4 && hwba[3] !== 1) {
      a = ", " + hwba[3];
    }
    return "hwb(" + hwba[0] + ", " + hwba[1] + "%, " + hwba[2] + "%" + a + ")";
  };
  cs.to.keyword = function(...rgb) {
    return reverseNames[rgb.slice(0, 3)];
  };
  function clamp(number_, min, max) {
    return Math.min(Math.max(min, number_), max);
  }
  function hexDouble(number_) {
    const string_ = Math.round(number_).toString(16).toUpperCase();
    return string_.length < 2 ? "0" + string_ : string_;
  }
  var color_string_default = cs;
  var reverseKeywords = {};
  for (const key of Object.keys(color_name_default)) {
    reverseKeywords[color_name_default[key]] = key;
  }
  var convert = {
    rgb: { channels: 3, labels: "rgb" },
    hsl: { channels: 3, labels: "hsl" },
    hsv: { channels: 3, labels: "hsv" },
    hwb: { channels: 3, labels: "hwb" },
    cmyk: { channels: 4, labels: "cmyk" },
    xyz: { channels: 3, labels: "xyz" },
    lab: { channels: 3, labels: "lab" },
    oklab: { channels: 3, labels: ["okl", "oka", "okb"] },
    lch: { channels: 3, labels: "lch" },
    oklch: { channels: 3, labels: ["okl", "okc", "okh"] },
    hex: { channels: 1, labels: ["hex"] },
    keyword: { channels: 1, labels: ["keyword"] },
    ansi16: { channels: 1, labels: ["ansi16"] },
    ansi256: { channels: 1, labels: ["ansi256"] },
    hcg: { channels: 3, labels: ["h", "c", "g"] },
    apple: { channels: 3, labels: ["r16", "g16", "b16"] },
    gray: { channels: 1, labels: ["gray"] }
  };
  var conversions_default = convert;
  var LAB_FT = (6 / 29) ** 3;
  function srgbNonlinearTransform(c) {
    const cc = c > 0.0031308 ? 1.055 * c ** (1 / 2.4) - 0.055 : c * 12.92;
    return Math.min(Math.max(0, cc), 1);
  }
  function srgbNonlinearTransformInv(c) {
    return c > 0.04045 ? ((c + 0.055) / 1.055) ** 2.4 : c / 12.92;
  }
  for (const model of Object.keys(convert)) {
    if (!("channels" in convert[model])) {
      throw new Error("missing channels property: " + model);
    }
    if (!("labels" in convert[model])) {
      throw new Error("missing channel labels property: " + model);
    }
    if (convert[model].labels.length !== convert[model].channels) {
      throw new Error("channel and label counts mismatch: " + model);
    }
    const { channels, labels } = convert[model];
    delete convert[model].channels;
    delete convert[model].labels;
    Object.defineProperty(convert[model], "channels", { value: channels });
    Object.defineProperty(convert[model], "labels", { value: labels });
  }
  convert.rgb.hsl = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const min = Math.min(r, g, b);
    const max = Math.max(r, g, b);
    const delta = max - min;
    let h;
    let s;
    switch (max) {
      case min: {
        h = 0;
        break;
      }
      case r: {
        h = (g - b) / delta;
        break;
      }
      case g: {
        h = 2 + (b - r) / delta;
        break;
      }
      case b: {
        h = 4 + (r - g) / delta;
        break;
      }
    }
    h = Math.min(h * 60, 360);
    if (h < 0) {
      h += 360;
    }
    const l = (min + max) / 2;
    if (max === min) {
      s = 0;
    } else if (l <= 0.5) {
      s = delta / (max + min);
    } else {
      s = delta / (2 - max - min);
    }
    return [h, s * 100, l * 100];
  };
  convert.rgb.hsv = function(rgb) {
    let rdif;
    let gdif;
    let bdif;
    let h;
    let s;
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const v = Math.max(r, g, b);
    const diff = v - Math.min(r, g, b);
    const diffc = function(c) {
      return (v - c) / 6 / diff + 1 / 2;
    };
    if (diff === 0) {
      h = 0;
      s = 0;
    } else {
      s = diff / v;
      rdif = diffc(r);
      gdif = diffc(g);
      bdif = diffc(b);
      switch (v) {
        case r: {
          h = bdif - gdif;
          break;
        }
        case g: {
          h = 1 / 3 + rdif - bdif;
          break;
        }
        case b: {
          h = 2 / 3 + gdif - rdif;
          break;
        }
      }
      if (h < 0) {
        h += 1;
      } else if (h > 1) {
        h -= 1;
      }
    }
    return [
      h * 360,
      s * 100,
      v * 100
    ];
  };
  convert.rgb.hwb = function(rgb) {
    const r = rgb[0];
    const g = rgb[1];
    let b = rgb[2];
    const h = convert.rgb.hsl(rgb)[0];
    const w = 1 / 255 * Math.min(r, Math.min(g, b));
    b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
    return [h, w * 100, b * 100];
  };
  convert.rgb.oklab = function(rgb) {
    const r = srgbNonlinearTransformInv(rgb[0] / 255);
    const g = srgbNonlinearTransformInv(rgb[1] / 255);
    const b = srgbNonlinearTransformInv(rgb[2] / 255);
    const lp = Math.cbrt(0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b);
    const mp = Math.cbrt(0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b);
    const sp = Math.cbrt(0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b);
    const l = 0.2104542553 * lp + 0.793617785 * mp - 0.0040720468 * sp;
    const aa = 1.9779984951 * lp - 2.428592205 * mp + 0.4505937099 * sp;
    const bb = 0.0259040371 * lp + 0.7827717662 * mp - 0.808675766 * sp;
    return [l * 100, aa * 100, bb * 100];
  };
  convert.rgb.cmyk = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const k = Math.min(1 - r, 1 - g, 1 - b);
    const c = (1 - r - k) / (1 - k) || 0;
    const m = (1 - g - k) / (1 - k) || 0;
    const y = (1 - b - k) / (1 - k) || 0;
    return [c * 100, m * 100, y * 100, k * 100];
  };
  function comparativeDistance(x, y) {
    return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
  }
  convert.rgb.keyword = function(rgb) {
    const reversed = reverseKeywords[rgb];
    if (reversed) {
      return reversed;
    }
    let currentClosestDistance = Number.POSITIVE_INFINITY;
    let currentClosestKeyword;
    for (const keyword of Object.keys(color_name_default)) {
      const value = color_name_default[keyword];
      const distance = comparativeDistance(rgb, value);
      if (distance < currentClosestDistance) {
        currentClosestDistance = distance;
        currentClosestKeyword = keyword;
      }
    }
    return currentClosestKeyword;
  };
  convert.keyword.rgb = function(keyword) {
    return color_name_default[keyword];
  };
  convert.rgb.xyz = function(rgb) {
    const r = srgbNonlinearTransformInv(rgb[0] / 255);
    const g = srgbNonlinearTransformInv(rgb[1] / 255);
    const b = srgbNonlinearTransformInv(rgb[2] / 255);
    const x = r * 0.4124564 + g * 0.3575761 + b * 0.1804375;
    const y = r * 0.2126729 + g * 0.7151522 + b * 0.072175;
    const z2 = r * 0.0193339 + g * 0.119192 + b * 0.9503041;
    return [x * 100, y * 100, z2 * 100];
  };
  convert.rgb.lab = function(rgb) {
    const xyz = convert.rgb.xyz(rgb);
    let x = xyz[0];
    let y = xyz[1];
    let z2 = xyz[2];
    x /= 95.047;
    y /= 100;
    z2 /= 108.883;
    x = x > LAB_FT ? x ** (1 / 3) : 7.787 * x + 16 / 116;
    y = y > LAB_FT ? y ** (1 / 3) : 7.787 * y + 16 / 116;
    z2 = z2 > LAB_FT ? z2 ** (1 / 3) : 7.787 * z2 + 16 / 116;
    const l = 116 * y - 16;
    const a = 500 * (x - y);
    const b = 200 * (y - z2);
    return [l, a, b];
  };
  convert.hsl.rgb = function(hsl) {
    const h = hsl[0] / 360;
    const s = hsl[1] / 100;
    const l = hsl[2] / 100;
    let t3;
    let value;
    if (s === 0) {
      value = l * 255;
      return [value, value, value];
    }
    const t2 = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const t1 = 2 * l - t2;
    const rgb = [0, 0, 0];
    for (let i = 0;i < 3; i++) {
      t3 = h + 1 / 3 * -(i - 1);
      if (t3 < 0) {
        t3++;
      }
      if (t3 > 1) {
        t3--;
      }
      if (6 * t3 < 1) {
        value = t1 + (t2 - t1) * 6 * t3;
      } else if (2 * t3 < 1) {
        value = t2;
      } else if (3 * t3 < 2) {
        value = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
      } else {
        value = t1;
      }
      rgb[i] = value * 255;
    }
    return rgb;
  };
  convert.hsl.hsv = function(hsl) {
    const h = hsl[0];
    let s = hsl[1] / 100;
    let l = hsl[2] / 100;
    let smin = s;
    const lmin = Math.max(l, 0.01);
    l *= 2;
    s *= l <= 1 ? l : 2 - l;
    smin *= lmin <= 1 ? lmin : 2 - lmin;
    const v = (l + s) / 2;
    const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
    return [h, sv * 100, v * 100];
  };
  convert.hsv.rgb = function(hsv) {
    const h = hsv[0] / 60;
    const s = hsv[1] / 100;
    let v = hsv[2] / 100;
    const hi = Math.floor(h) % 6;
    const f = h - Math.floor(h);
    const p = 255 * v * (1 - s);
    const q = 255 * v * (1 - s * f);
    const t = 255 * v * (1 - s * (1 - f));
    v *= 255;
    switch (hi) {
      case 0: {
        return [v, t, p];
      }
      case 1: {
        return [q, v, p];
      }
      case 2: {
        return [p, v, t];
      }
      case 3: {
        return [p, q, v];
      }
      case 4: {
        return [t, p, v];
      }
      case 5: {
        return [v, p, q];
      }
    }
  };
  convert.hsv.hsl = function(hsv) {
    const h = hsv[0];
    const s = hsv[1] / 100;
    const v = hsv[2] / 100;
    const vmin = Math.max(v, 0.01);
    let sl;
    let l;
    l = (2 - s) * v;
    const lmin = (2 - s) * vmin;
    sl = s * vmin;
    sl /= lmin <= 1 ? lmin : 2 - lmin;
    sl = sl || 0;
    l /= 2;
    return [h, sl * 100, l * 100];
  };
  convert.hwb.rgb = function(hwb) {
    const h = hwb[0] / 360;
    let wh = hwb[1] / 100;
    let bl = hwb[2] / 100;
    const ratio = wh + bl;
    let f;
    if (ratio > 1) {
      wh /= ratio;
      bl /= ratio;
    }
    const i = Math.floor(6 * h);
    const v = 1 - bl;
    f = 6 * h - i;
    if ((i & 1) !== 0) {
      f = 1 - f;
    }
    const n = wh + f * (v - wh);
    let r;
    let g;
    let b;
    switch (i) {
      default:
      case 6:
      case 0: {
        r = v;
        g = n;
        b = wh;
        break;
      }
      case 1: {
        r = n;
        g = v;
        b = wh;
        break;
      }
      case 2: {
        r = wh;
        g = v;
        b = n;
        break;
      }
      case 3: {
        r = wh;
        g = n;
        b = v;
        break;
      }
      case 4: {
        r = n;
        g = wh;
        b = v;
        break;
      }
      case 5: {
        r = v;
        g = wh;
        b = n;
        break;
      }
    }
    return [r * 255, g * 255, b * 255];
  };
  convert.cmyk.rgb = function(cmyk) {
    const c = cmyk[0] / 100;
    const m = cmyk[1] / 100;
    const y = cmyk[2] / 100;
    const k = cmyk[3] / 100;
    const r = 1 - Math.min(1, c * (1 - k) + k);
    const g = 1 - Math.min(1, m * (1 - k) + k);
    const b = 1 - Math.min(1, y * (1 - k) + k);
    return [r * 255, g * 255, b * 255];
  };
  convert.xyz.rgb = function(xyz) {
    const x = xyz[0] / 100;
    const y = xyz[1] / 100;
    const z2 = xyz[2] / 100;
    let r;
    let g;
    let b;
    r = x * 3.2404542 + y * -1.5371385 + z2 * -0.4985314;
    g = x * -0.969266 + y * 1.8760108 + z2 * 0.041556;
    b = x * 0.0556434 + y * -0.2040259 + z2 * 1.0572252;
    r = srgbNonlinearTransform(r);
    g = srgbNonlinearTransform(g);
    b = srgbNonlinearTransform(b);
    return [r * 255, g * 255, b * 255];
  };
  convert.xyz.lab = function(xyz) {
    let x = xyz[0];
    let y = xyz[1];
    let z2 = xyz[2];
    x /= 95.047;
    y /= 100;
    z2 /= 108.883;
    x = x > LAB_FT ? x ** (1 / 3) : 7.787 * x + 16 / 116;
    y = y > LAB_FT ? y ** (1 / 3) : 7.787 * y + 16 / 116;
    z2 = z2 > LAB_FT ? z2 ** (1 / 3) : 7.787 * z2 + 16 / 116;
    const l = 116 * y - 16;
    const a = 500 * (x - y);
    const b = 200 * (y - z2);
    return [l, a, b];
  };
  convert.xyz.oklab = function(xyz) {
    const x = xyz[0] / 100;
    const y = xyz[1] / 100;
    const z2 = xyz[2] / 100;
    const lp = Math.cbrt(0.8189330101 * x + 0.3618667424 * y - 0.1288597137 * z2);
    const mp = Math.cbrt(0.0329845436 * x + 0.9293118715 * y + 0.0361456387 * z2);
    const sp = Math.cbrt(0.0482003018 * x + 0.2643662691 * y + 0.633851707 * z2);
    const l = 0.2104542553 * lp + 0.793617785 * mp - 0.0040720468 * sp;
    const a = 1.9779984951 * lp - 2.428592205 * mp + 0.4505937099 * sp;
    const b = 0.0259040371 * lp + 0.7827717662 * mp - 0.808675766 * sp;
    return [l * 100, a * 100, b * 100];
  };
  convert.oklab.oklch = function(oklab) {
    return convert.lab.lch(oklab);
  };
  convert.oklab.xyz = function(oklab) {
    const ll = oklab[0] / 100;
    const a = oklab[1] / 100;
    const b = oklab[2] / 100;
    const l = (0.999999998 * ll + 0.396337792 * a + 0.215803758 * b) ** 3;
    const m = (1.000000008 * ll - 0.105561342 * a - 0.063854175 * b) ** 3;
    const s = (1.000000055 * ll - 0.089484182 * a - 1.291485538 * b) ** 3;
    const x = 1.227013851 * l - 0.55779998 * m + 0.281256149 * s;
    const y = -0.040580178 * l + 1.11225687 * m - 0.071676679 * s;
    const z2 = -0.076381285 * l - 0.421481978 * m + 1.58616322 * s;
    return [x * 100, y * 100, z2 * 100];
  };
  convert.oklab.rgb = function(oklab) {
    const ll = oklab[0] / 100;
    const aa = oklab[1] / 100;
    const bb = oklab[2] / 100;
    const l = (ll + 0.3963377774 * aa + 0.2158037573 * bb) ** 3;
    const m = (ll - 0.1055613458 * aa - 0.0638541728 * bb) ** 3;
    const s = (ll - 0.0894841775 * aa - 1.291485548 * bb) ** 3;
    const r = srgbNonlinearTransform(4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s);
    const g = srgbNonlinearTransform(-1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s);
    const b = srgbNonlinearTransform(-0.0041960863 * l - 0.7034186147 * m + 1.707614701 * s);
    return [r * 255, g * 255, b * 255];
  };
  convert.oklch.oklab = function(oklch) {
    return convert.lch.lab(oklch);
  };
  convert.lab.xyz = function(lab) {
    const l = lab[0];
    const a = lab[1];
    const b = lab[2];
    let x;
    let y;
    let z2;
    y = (l + 16) / 116;
    x = a / 500 + y;
    z2 = y - b / 200;
    const y2 = y ** 3;
    const x2 = x ** 3;
    const z22 = z2 ** 3;
    y = y2 > LAB_FT ? y2 : (y - 16 / 116) / 7.787;
    x = x2 > LAB_FT ? x2 : (x - 16 / 116) / 7.787;
    z2 = z22 > LAB_FT ? z22 : (z2 - 16 / 116) / 7.787;
    x *= 95.047;
    y *= 100;
    z2 *= 108.883;
    return [x, y, z2];
  };
  convert.lab.lch = function(lab) {
    const l = lab[0];
    const a = lab[1];
    const b = lab[2];
    let h;
    const hr = Math.atan2(b, a);
    h = hr * 360 / 2 / Math.PI;
    if (h < 0) {
      h += 360;
    }
    const c = Math.sqrt(a * a + b * b);
    return [l, c, h];
  };
  convert.lch.lab = function(lch) {
    const l = lch[0];
    const c = lch[1];
    const h = lch[2];
    const hr = h / 360 * 2 * Math.PI;
    const a = c * Math.cos(hr);
    const b = c * Math.sin(hr);
    return [l, a, b];
  };
  convert.rgb.ansi16 = function(args, saturation = null) {
    const [r, g, b] = args;
    let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
    value = Math.round(value / 50);
    if (value === 0) {
      return 30;
    }
    let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
    if (value === 2) {
      ansi += 60;
    }
    return ansi;
  };
  convert.hsv.ansi16 = function(args) {
    return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
  };
  convert.rgb.ansi256 = function(args) {
    const r = args[0];
    const g = args[1];
    const b = args[2];
    if (r >> 4 === g >> 4 && g >> 4 === b >> 4) {
      if (r < 8) {
        return 16;
      }
      if (r > 248) {
        return 231;
      }
      return Math.round((r - 8) / 247 * 24) + 232;
    }
    const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
    return ansi;
  };
  convert.ansi16.rgb = function(args) {
    args = args[0];
    let color = args % 10;
    if (color === 0 || color === 7) {
      if (args > 50) {
        color += 3.5;
      }
      color = color / 10.5 * 255;
      return [color, color, color];
    }
    const mult = (Math.trunc(args > 50) + 1) * 0.5;
    const r = (color & 1) * mult * 255;
    const g = (color >> 1 & 1) * mult * 255;
    const b = (color >> 2 & 1) * mult * 255;
    return [r, g, b];
  };
  convert.ansi256.rgb = function(args) {
    args = args[0];
    if (args >= 232) {
      const c = (args - 232) * 10 + 8;
      return [c, c, c];
    }
    args -= 16;
    let rem;
    const r = Math.floor(args / 36) / 5 * 255;
    const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
    const b = rem % 6 / 5 * 255;
    return [r, g, b];
  };
  convert.rgb.hex = function(args) {
    const integer3 = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
    const string7 = integer3.toString(16).toUpperCase();
    return "000000".slice(string7.length) + string7;
  };
  convert.hex.rgb = function(args) {
    const match = args.toString(16).match(/[a-f\d]{6}|[a-f\d]{3}/i);
    if (!match) {
      return [0, 0, 0];
    }
    let colorString = match[0];
    if (match[0].length === 3) {
      colorString = [...colorString].map((char) => char + char).join("");
    }
    const integer3 = Number.parseInt(colorString, 16);
    const r = integer3 >> 16 & 255;
    const g = integer3 >> 8 & 255;
    const b = integer3 & 255;
    return [r, g, b];
  };
  convert.rgb.hcg = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const max = Math.max(Math.max(r, g), b);
    const min = Math.min(Math.min(r, g), b);
    const chroma = max - min;
    let hue;
    const grayscale = chroma < 1 ? min / (1 - chroma) : 0;
    if (chroma <= 0) {
      hue = 0;
    } else if (max === r) {
      hue = (g - b) / chroma % 6;
    } else if (max === g) {
      hue = 2 + (b - r) / chroma;
    } else {
      hue = 4 + (r - g) / chroma;
    }
    hue /= 6;
    hue %= 1;
    return [hue * 360, chroma * 100, grayscale * 100];
  };
  convert.hsl.hcg = function(hsl) {
    const s = hsl[1] / 100;
    const l = hsl[2] / 100;
    const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
    let f = 0;
    if (c < 1) {
      f = (l - 0.5 * c) / (1 - c);
    }
    return [hsl[0], c * 100, f * 100];
  };
  convert.hsv.hcg = function(hsv) {
    const s = hsv[1] / 100;
    const v = hsv[2] / 100;
    const c = s * v;
    let f = 0;
    if (c < 1) {
      f = (v - c) / (1 - c);
    }
    return [hsv[0], c * 100, f * 100];
  };
  convert.hcg.rgb = function(hcg) {
    const h = hcg[0] / 360;
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    if (c === 0) {
      return [g * 255, g * 255, g * 255];
    }
    const pure = [0, 0, 0];
    const hi = h % 1 * 6;
    const v = hi % 1;
    const w = 1 - v;
    let mg = 0;
    switch (Math.floor(hi)) {
      case 0: {
        pure[0] = 1;
        pure[1] = v;
        pure[2] = 0;
        break;
      }
      case 1: {
        pure[0] = w;
        pure[1] = 1;
        pure[2] = 0;
        break;
      }
      case 2: {
        pure[0] = 0;
        pure[1] = 1;
        pure[2] = v;
        break;
      }
      case 3: {
        pure[0] = 0;
        pure[1] = w;
        pure[2] = 1;
        break;
      }
      case 4: {
        pure[0] = v;
        pure[1] = 0;
        pure[2] = 1;
        break;
      }
      default: {
        pure[0] = 1;
        pure[1] = 0;
        pure[2] = w;
      }
    }
    mg = (1 - c) * g;
    return [
      (c * pure[0] + mg) * 255,
      (c * pure[1] + mg) * 255,
      (c * pure[2] + mg) * 255
    ];
  };
  convert.hcg.hsv = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const v = c + g * (1 - c);
    let f = 0;
    if (v > 0) {
      f = c / v;
    }
    return [hcg[0], f * 100, v * 100];
  };
  convert.hcg.hsl = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const l = g * (1 - c) + 0.5 * c;
    let s = 0;
    if (l > 0 && l < 0.5) {
      s = c / (2 * l);
    } else if (l >= 0.5 && l < 1) {
      s = c / (2 * (1 - l));
    }
    return [hcg[0], s * 100, l * 100];
  };
  convert.hcg.hwb = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const v = c + g * (1 - c);
    return [hcg[0], (v - c) * 100, (1 - v) * 100];
  };
  convert.hwb.hcg = function(hwb) {
    const w = hwb[1] / 100;
    const b = hwb[2] / 100;
    const v = 1 - b;
    const c = v - w;
    let g = 0;
    if (c < 1) {
      g = (v - c) / (1 - c);
    }
    return [hwb[0], c * 100, g * 100];
  };
  convert.apple.rgb = function(apple) {
    return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
  };
  convert.rgb.apple = function(rgb) {
    return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
  };
  convert.gray.rgb = function(args) {
    return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
  };
  convert.gray.hsl = function(args) {
    return [0, 0, args[0]];
  };
  convert.gray.hsv = convert.gray.hsl;
  convert.gray.hwb = function(gray) {
    return [0, 100, gray[0]];
  };
  convert.gray.cmyk = function(gray) {
    return [0, 0, 0, gray[0]];
  };
  convert.gray.lab = function(gray) {
    return [gray[0], 0, 0];
  };
  convert.gray.hex = function(gray) {
    const value = Math.round(gray[0] / 100 * 255) & 255;
    const integer3 = (value << 16) + (value << 8) + value;
    const string7 = integer3.toString(16).toUpperCase();
    return "000000".slice(string7.length) + string7;
  };
  convert.rgb.gray = function(rgb) {
    const value = (rgb[0] + rgb[1] + rgb[2]) / 3;
    return [value / 255 * 100];
  };
  function buildGraph() {
    const graph = {};
    const models2 = Object.keys(conversions_default);
    for (let { length } = models2, i = 0;i < length; i++) {
      graph[models2[i]] = {
        distance: -1,
        parent: null
      };
    }
    return graph;
  }
  function deriveBFS(fromModel) {
    const graph = buildGraph();
    const queue = [fromModel];
    graph[fromModel].distance = 0;
    while (queue.length > 0) {
      const current = queue.pop();
      const adjacents = Object.keys(conversions_default[current]);
      for (let { length } = adjacents, i = 0;i < length; i++) {
        const adjacent = adjacents[i];
        const node = graph[adjacent];
        if (node.distance === -1) {
          node.distance = graph[current].distance + 1;
          node.parent = current;
          queue.unshift(adjacent);
        }
      }
    }
    return graph;
  }
  function link(from, to) {
    return function(args) {
      return to(from(args));
    };
  }
  function wrapConversion(toModel, graph) {
    const path2 = [graph[toModel].parent, toModel];
    let fn = conversions_default[graph[toModel].parent][toModel];
    let cur = graph[toModel].parent;
    while (graph[cur].parent) {
      path2.unshift(graph[cur].parent);
      fn = link(conversions_default[graph[cur].parent][cur], fn);
      cur = graph[cur].parent;
    }
    fn.conversion = path2;
    return fn;
  }
  function route(fromModel) {
    const graph = deriveBFS(fromModel);
    const conversion = {};
    const models2 = Object.keys(graph);
    for (let { length } = models2, i = 0;i < length; i++) {
      const toModel = models2[i];
      const node = graph[toModel];
      if (node.parent === null) {
        continue;
      }
      conversion[toModel] = wrapConversion(toModel, graph);
    }
    return conversion;
  }
  var route_default = route;
  var convert2 = {};
  var models = Object.keys(conversions_default);
  function wrapRaw(fn) {
    const wrappedFn = function(...args) {
      const arg0 = args[0];
      if (arg0 === undefined || arg0 === null) {
        return arg0;
      }
      if (arg0.length > 1) {
        args = arg0;
      }
      return fn(args);
    };
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  }
  function wrapRounded(fn) {
    const wrappedFn = function(...args) {
      const arg0 = args[0];
      if (arg0 === undefined || arg0 === null) {
        return arg0;
      }
      if (arg0.length > 1) {
        args = arg0;
      }
      const result = fn(args);
      if (typeof result === "object") {
        for (let { length } = result, i = 0;i < length; i++) {
          result[i] = Math.round(result[i]);
        }
      }
      return result;
    };
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  }
  for (const fromModel of models) {
    convert2[fromModel] = {};
    Object.defineProperty(convert2[fromModel], "channels", { value: conversions_default[fromModel].channels });
    Object.defineProperty(convert2[fromModel], "labels", { value: conversions_default[fromModel].labels });
    const routes = route_default(fromModel);
    const routeModels = Object.keys(routes);
    for (const toModel of routeModels) {
      const fn = routes[toModel];
      convert2[fromModel][toModel] = wrapRounded(fn);
      convert2[fromModel][toModel].raw = wrapRaw(fn);
    }
  }
  var color_convert_default = convert2;
  var skippedModels = [
    "keyword",
    "gray",
    "hex"
  ];
  var hashedModelKeys = {};
  for (const model of Object.keys(color_convert_default)) {
    hashedModelKeys[[...color_convert_default[model].labels].sort().join("")] = model;
  }
  var limiters = {};
  function Color(object5, model) {
    if (!(this instanceof Color)) {
      return new Color(object5, model);
    }
    if (model && model in skippedModels) {
      model = null;
    }
    if (model && !(model in color_convert_default)) {
      throw new Error("Unknown model: " + model);
    }
    let i;
    let channels;
    if (object5 == null) {
      this.model = "rgb";
      this.color = [0, 0, 0];
      this.valpha = 1;
    } else if (object5 instanceof Color) {
      this.model = object5.model;
      this.color = [...object5.color];
      this.valpha = object5.valpha;
    } else if (typeof object5 === "string") {
      const result = color_string_default.get(object5);
      if (result === null) {
        throw new Error("Unable to parse color from string: " + object5);
      }
      this.model = result.model;
      channels = color_convert_default[this.model].channels;
      this.color = result.value.slice(0, channels);
      this.valpha = typeof result.value[channels] === "number" ? result.value[channels] : 1;
    } else if (object5.length > 0) {
      this.model = model || "rgb";
      channels = color_convert_default[this.model].channels;
      const newArray = Array.prototype.slice.call(object5, 0, channels);
      this.color = zeroArray(newArray, channels);
      this.valpha = typeof object5[channels] === "number" ? object5[channels] : 1;
    } else if (typeof object5 === "number") {
      this.model = "rgb";
      this.color = [
        object5 >> 16 & 255,
        object5 >> 8 & 255,
        object5 & 255
      ];
      this.valpha = 1;
    } else {
      this.valpha = 1;
      const keys = Object.keys(object5);
      if ("alpha" in object5) {
        keys.splice(keys.indexOf("alpha"), 1);
        this.valpha = typeof object5.alpha === "number" ? object5.alpha : 0;
      }
      const hashedKeys = keys.sort().join("");
      if (!(hashedKeys in hashedModelKeys)) {
        throw new Error("Unable to parse color from object: " + JSON.stringify(object5));
      }
      this.model = hashedModelKeys[hashedKeys];
      const { labels } = color_convert_default[this.model];
      const color = [];
      for (i = 0;i < labels.length; i++) {
        color.push(object5[labels[i]]);
      }
      this.color = zeroArray(color);
    }
    if (limiters[this.model]) {
      channels = color_convert_default[this.model].channels;
      for (i = 0;i < channels; i++) {
        const limit = limiters[this.model][i];
        if (limit) {
          this.color[i] = limit(this.color[i]);
        }
      }
    }
    this.valpha = Math.max(0, Math.min(1, this.valpha));
    if (Object.freeze) {
      Object.freeze(this);
    }
  }
  Color.prototype = {
    toString() {
      return this.string();
    },
    toJSON() {
      return this[this.model]();
    },
    string(places) {
      let self2 = this.model in color_string_default.to ? this : this.rgb();
      self2 = self2.round(typeof places === "number" ? places : 1);
      const arguments_ = self2.valpha === 1 ? self2.color : [...self2.color, this.valpha];
      return color_string_default.to[self2.model](...arguments_);
    },
    percentString(places) {
      const self2 = this.rgb().round(typeof places === "number" ? places : 1);
      const arguments_ = self2.valpha === 1 ? self2.color : [...self2.color, this.valpha];
      return color_string_default.to.rgb.percent(...arguments_);
    },
    array() {
      return this.valpha === 1 ? [...this.color] : [...this.color, this.valpha];
    },
    object() {
      const result = {};
      const { channels } = color_convert_default[this.model];
      const { labels } = color_convert_default[this.model];
      for (let i = 0;i < channels; i++) {
        result[labels[i]] = this.color[i];
      }
      if (this.valpha !== 1) {
        result.alpha = this.valpha;
      }
      return result;
    },
    unitArray() {
      const rgb = this.rgb().color;
      rgb[0] /= 255;
      rgb[1] /= 255;
      rgb[2] /= 255;
      if (this.valpha !== 1) {
        rgb.push(this.valpha);
      }
      return rgb;
    },
    unitObject() {
      const rgb = this.rgb().object();
      rgb.r /= 255;
      rgb.g /= 255;
      rgb.b /= 255;
      if (this.valpha !== 1) {
        rgb.alpha = this.valpha;
      }
      return rgb;
    },
    round(places) {
      places = Math.max(places || 0, 0);
      return new Color([...this.color.map(roundToPlace(places)), this.valpha], this.model);
    },
    alpha(value) {
      if (value !== undefined) {
        return new Color([...this.color, Math.max(0, Math.min(1, value))], this.model);
      }
      return this.valpha;
    },
    red: getset("rgb", 0, maxfn(255)),
    green: getset("rgb", 1, maxfn(255)),
    blue: getset("rgb", 2, maxfn(255)),
    hue: getset(["hsl", "hsv", "hsl", "hwb", "hcg"], 0, (value) => (value % 360 + 360) % 360),
    saturationl: getset("hsl", 1, maxfn(100)),
    lightness: getset("hsl", 2, maxfn(100)),
    saturationv: getset("hsv", 1, maxfn(100)),
    value: getset("hsv", 2, maxfn(100)),
    chroma: getset("hcg", 1, maxfn(100)),
    gray: getset("hcg", 2, maxfn(100)),
    white: getset("hwb", 1, maxfn(100)),
    wblack: getset("hwb", 2, maxfn(100)),
    cyan: getset("cmyk", 0, maxfn(100)),
    magenta: getset("cmyk", 1, maxfn(100)),
    yellow: getset("cmyk", 2, maxfn(100)),
    black: getset("cmyk", 3, maxfn(100)),
    x: getset("xyz", 0, maxfn(95.047)),
    y: getset("xyz", 1, maxfn(100)),
    z: getset("xyz", 2, maxfn(108.833)),
    l: getset("lab", 0, maxfn(100)),
    a: getset("lab", 1),
    b: getset("lab", 2),
    keyword(value) {
      if (value !== undefined) {
        return new Color(value);
      }
      return color_convert_default[this.model].keyword(this.color);
    },
    hex(value) {
      if (value !== undefined) {
        return new Color(value);
      }
      return color_string_default.to.hex(...this.rgb().round().color);
    },
    hexa(value) {
      if (value !== undefined) {
        return new Color(value);
      }
      const rgbArray = this.rgb().round().color;
      let alphaHex = Math.round(this.valpha * 255).toString(16).toUpperCase();
      if (alphaHex.length === 1) {
        alphaHex = "0" + alphaHex;
      }
      return color_string_default.to.hex(...rgbArray) + alphaHex;
    },
    rgbNumber() {
      const rgb = this.rgb().color;
      return (rgb[0] & 255) << 16 | (rgb[1] & 255) << 8 | rgb[2] & 255;
    },
    luminosity() {
      const rgb = this.rgb().color;
      const lum = [];
      for (const [i, element] of rgb.entries()) {
        const chan = element / 255;
        lum[i] = chan <= 0.04045 ? chan / 12.92 : ((chan + 0.055) / 1.055) ** 2.4;
      }
      return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
    },
    contrast(color2) {
      const lum1 = this.luminosity();
      const lum2 = color2.luminosity();
      if (lum1 > lum2) {
        return (lum1 + 0.05) / (lum2 + 0.05);
      }
      return (lum2 + 0.05) / (lum1 + 0.05);
    },
    level(color2) {
      const contrastRatio = this.contrast(color2);
      if (contrastRatio >= 7) {
        return "AAA";
      }
      return contrastRatio >= 4.5 ? "AA" : "";
    },
    isDark() {
      const rgb = this.rgb().color;
      const yiq = (rgb[0] * 2126 + rgb[1] * 7152 + rgb[2] * 722) / 1e4;
      return yiq < 128;
    },
    isLight() {
      return !this.isDark();
    },
    negate() {
      const rgb = this.rgb();
      for (let i = 0;i < 3; i++) {
        rgb.color[i] = 255 - rgb.color[i];
      }
      return rgb;
    },
    lighten(ratio) {
      const hsl = this.hsl();
      hsl.color[2] += hsl.color[2] * ratio;
      return hsl;
    },
    darken(ratio) {
      const hsl = this.hsl();
      hsl.color[2] -= hsl.color[2] * ratio;
      return hsl;
    },
    saturate(ratio) {
      const hsl = this.hsl();
      hsl.color[1] += hsl.color[1] * ratio;
      return hsl;
    },
    desaturate(ratio) {
      const hsl = this.hsl();
      hsl.color[1] -= hsl.color[1] * ratio;
      return hsl;
    },
    whiten(ratio) {
      const hwb = this.hwb();
      hwb.color[1] += hwb.color[1] * ratio;
      return hwb;
    },
    blacken(ratio) {
      const hwb = this.hwb();
      hwb.color[2] += hwb.color[2] * ratio;
      return hwb;
    },
    grayscale() {
      const rgb = this.rgb().color;
      const value = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
      return Color.rgb(value, value, value);
    },
    fade(ratio) {
      return this.alpha(this.valpha - this.valpha * ratio);
    },
    opaquer(ratio) {
      return this.alpha(this.valpha + this.valpha * ratio);
    },
    rotate(degrees) {
      const hsl = this.hsl();
      let hue = hsl.color[0];
      hue = (hue + degrees) % 360;
      hue = hue < 0 ? 360 + hue : hue;
      hsl.color[0] = hue;
      return hsl;
    },
    mix(mixinColor, weight) {
      if (!mixinColor || !mixinColor.rgb) {
        throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof mixinColor);
      }
      const color1 = mixinColor.rgb();
      const color2 = this.rgb();
      const p = weight === undefined ? 0.5 : weight;
      const w = 2 * p - 1;
      const a = color1.alpha() - color2.alpha();
      const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
      const w2 = 1 - w1;
      return Color.rgb(w1 * color1.red() + w2 * color2.red(), w1 * color1.green() + w2 * color2.green(), w1 * color1.blue() + w2 * color2.blue(), color1.alpha() * p + color2.alpha() * (1 - p));
    }
  };
  for (const model of Object.keys(color_convert_default)) {
    if (skippedModels.includes(model)) {
      continue;
    }
    const { channels } = color_convert_default[model];
    Color.prototype[model] = function(...arguments_) {
      if (this.model === model) {
        return new Color(this);
      }
      if (arguments_.length > 0) {
        return new Color(arguments_, model);
      }
      return new Color([...assertArray(color_convert_default[this.model][model].raw(this.color)), this.valpha], model);
    };
    Color[model] = function(...arguments_) {
      let color = arguments_[0];
      if (typeof color === "number") {
        color = zeroArray(arguments_, channels);
      }
      return new Color(color, model);
    };
  }
  function roundTo(number7, places) {
    return Number(number7.toFixed(places));
  }
  function roundToPlace(places) {
    return function(number7) {
      return roundTo(number7, places);
    };
  }
  function getset(model, channel, modifier) {
    model = Array.isArray(model) ? model : [model];
    for (const m of model) {
      (limiters[m] ||= [])[channel] = modifier;
    }
    model = model[0];
    return function(value) {
      let result;
      if (value !== undefined) {
        if (modifier) {
          value = modifier(value);
        }
        result = this[model]();
        result.color[channel] = value;
        return result;
      }
      result = this[model]().color[channel];
      if (modifier) {
        result = modifier(result);
      }
      return result;
    };
  }
  function maxfn(max) {
    return function(v) {
      return Math.max(0, Math.min(max, v));
    };
  }
  function assertArray(value) {
    return Array.isArray(value) ? value : [value];
  }
  function zeroArray(array4, length) {
    for (let i = 0;i < length; i++) {
      if (typeof array4[i] !== "number") {
        array4[i] = 0;
      }
    }
    return array4;
  }
  var index_default = Color;
});

// node_modules/@img/colour/index.cjs
var require_colour = __commonJS((exports, module) => {
  module.exports = require_color().default;
});

// node_modules/sharp/lib/colour.js
var require_colour2 = __commonJS((exports, module) => {
  /*!
    Copyright 2013 Lovell Fuller and others.
    SPDX-License-Identifier: Apache-2.0
  */
  var color = require_colour();
  var is2 = require_is();
  var colourspace = {
    multiband: "multiband",
    "b-w": "b-w",
    bw: "b-w",
    cmyk: "cmyk",
    srgb: "srgb"
  };
  function tint(tint2) {
    this._setBackgroundColourOption("tint", tint2);
    return this;
  }
  function greyscale(greyscale2) {
    this.options.greyscale = is2.bool(greyscale2) ? greyscale2 : true;
    return this;
  }
  function grayscale(grayscale2) {
    return this.greyscale(grayscale2);
  }
  function pipelineColourspace(colourspace2) {
    if (!is2.string(colourspace2)) {
      throw is2.invalidParameterError("colourspace", "string", colourspace2);
    }
    this.options.colourspacePipeline = colourspace2;
    return this;
  }
  function pipelineColorspace(colorspace) {
    return this.pipelineColourspace(colorspace);
  }
  function toColourspace(colourspace2) {
    if (!is2.string(colourspace2)) {
      throw is2.invalidParameterError("colourspace", "string", colourspace2);
    }
    this.options.colourspace = colourspace2;
    return this;
  }
  function toColorspace(colorspace) {
    return this.toColourspace(colorspace);
  }
  function _getBackgroundColourOption(value) {
    if (is2.object(value) || is2.string(value) && value.length >= 3 && value.length <= 200) {
      const colour = color(value);
      return [
        colour.red(),
        colour.green(),
        colour.blue(),
        Math.round(colour.alpha() * 255)
      ];
    } else {
      throw is2.invalidParameterError("background", "object or string", value);
    }
  }
  function _setBackgroundColourOption(key, value) {
    if (is2.defined(value)) {
      this.options[key] = _getBackgroundColourOption(value);
    }
  }
  module.exports = (Sharp) => {
    Object.assign(Sharp.prototype, {
      tint,
      greyscale,
      grayscale,
      pipelineColourspace,
      pipelineColorspace,
      toColourspace,
      toColorspace,
      _getBackgroundColourOption,
      _setBackgroundColourOption
    });
    Sharp.colourspace = colourspace;
    Sharp.colorspace = colourspace;
  };
});

// node_modules/sharp/lib/channel.js
var require_channel = __commonJS((exports, module) => {
  /*!
    Copyright 2013 Lovell Fuller and others.
    SPDX-License-Identifier: Apache-2.0
  */
  var is2 = require_is();
  var bool = {
    and: "and",
    or: "or",
    eor: "eor"
  };
  function removeAlpha() {
    this.options.removeAlpha = true;
    return this;
  }
  function ensureAlpha(alpha) {
    if (is2.defined(alpha)) {
      if (is2.number(alpha) && is2.inRange(alpha, 0, 1)) {
        this.options.ensureAlpha = alpha;
      } else {
        throw is2.invalidParameterError("alpha", "number between 0 and 1", alpha);
      }
    } else {
      this.options.ensureAlpha = 1;
    }
    return this;
  }
  function extractChannel(channel) {
    const channelMap = { red: 0, green: 1, blue: 2, alpha: 3 };
    if (Object.keys(channelMap).includes(channel)) {
      channel = channelMap[channel];
    }
    if (is2.integer(channel) && is2.inRange(channel, 0, 4)) {
      this.options.extractChannel = channel;
    } else {
      throw is2.invalidParameterError("channel", "integer or one of: red, green, blue, alpha", channel);
    }
    return this;
  }
  function joinChannel(images, options2) {
    if (Array.isArray(images)) {
      images.forEach(function(image) {
        this.options.joinChannelIn.push(this._createInputDescriptor(image, options2));
      }, this);
    } else {
      this.options.joinChannelIn.push(this._createInputDescriptor(images, options2));
    }
    return this;
  }
  function bandbool(boolOp) {
    if (is2.string(boolOp) && is2.inArray(boolOp, ["and", "or", "eor"])) {
      this.options.bandBoolOp = boolOp;
    } else {
      throw is2.invalidParameterError("boolOp", "one of: and, or, eor", boolOp);
    }
    return this;
  }
  module.exports = (Sharp) => {
    Object.assign(Sharp.prototype, {
      removeAlpha,
      ensureAlpha,
      extractChannel,
      joinChannel,
      bandbool
    });
    Sharp.bool = bool;
  };
});

// node_modules/sharp/lib/output.js
var require_output = __commonJS((exports, module) => {
  /*!
    Copyright 2013 Lovell Fuller and others.
    SPDX-License-Identifier: Apache-2.0
  */
  var path2 = __require("path");
  var is2 = require_is();
  var sharp = require_sharp();
  var formats = new Map([
    ["heic", "heif"],
    ["heif", "heif"],
    ["avif", "avif"],
    ["jpeg", "jpeg"],
    ["jpg", "jpeg"],
    ["jpe", "jpeg"],
    ["tile", "tile"],
    ["dz", "tile"],
    ["png", "png"],
    ["raw", "raw"],
    ["tiff", "tiff"],
    ["tif", "tiff"],
    ["webp", "webp"],
    ["gif", "gif"],
    ["jp2", "jp2"],
    ["jpx", "jp2"],
    ["j2k", "jp2"],
    ["j2c", "jp2"],
    ["jxl", "jxl"]
  ]);
  var jp2Regex = /\.(jp[2x]|j2[kc])$/i;
  var errJp2Save = () => new Error("JP2 output requires libvips with support for OpenJPEG");
  var bitdepthFromColourCount = (colours) => 1 << 31 - Math.clz32(Math.ceil(Math.log2(colours)));
  function toFile(fileOut, callback) {
    let err;
    if (!is2.string(fileOut)) {
      err = new Error("Missing output file path");
    } else if (is2.string(this.options.input.file) && path2.resolve(this.options.input.file) === path2.resolve(fileOut)) {
      err = new Error("Cannot use same file for input and output");
    } else if (jp2Regex.test(path2.extname(fileOut)) && !this.constructor.format.jp2k.output.file) {
      err = errJp2Save();
    }
    if (err) {
      if (is2.fn(callback)) {
        callback(err);
      } else {
        return Promise.reject(err);
      }
    } else {
      this.options.fileOut = fileOut;
      const stack = Error();
      return this._pipeline(callback, stack);
    }
    return this;
  }
  function toBuffer(options2, callback) {
    if (is2.object(options2)) {
      this._setBooleanOption("resolveWithObject", options2.resolveWithObject);
    } else if (this.options.resolveWithObject) {
      this.options.resolveWithObject = false;
    }
    this.options.fileOut = "";
    const stack = Error();
    return this._pipeline(is2.fn(options2) ? options2 : callback, stack);
  }
  function keepExif() {
    this.options.keepMetadata |= 1;
    return this;
  }
  function withExif(exif) {
    if (is2.object(exif)) {
      for (const [ifd, entries] of Object.entries(exif)) {
        if (is2.object(entries)) {
          for (const [k, v] of Object.entries(entries)) {
            if (is2.string(v)) {
              this.options.withExif[`exif-${ifd.toLowerCase()}-${k}`] = v;
            } else {
              throw is2.invalidParameterError(`${ifd}.${k}`, "string", v);
            }
          }
        } else {
          throw is2.invalidParameterError(ifd, "object", entries);
        }
      }
    } else {
      throw is2.invalidParameterError("exif", "object", exif);
    }
    this.options.withExifMerge = false;
    return this.keepExif();
  }
  function withExifMerge(exif) {
    this.withExif(exif);
    this.options.withExifMerge = true;
    return this;
  }
  function keepIccProfile() {
    this.options.keepMetadata |= 8;
    return this;
  }
  function withIccProfile(icc, options2) {
    if (is2.string(icc)) {
      this.options.withIccProfile = icc;
    } else {
      throw is2.invalidParameterError("icc", "string", icc);
    }
    this.keepIccProfile();
    if (is2.object(options2)) {
      if (is2.defined(options2.attach)) {
        if (is2.bool(options2.attach)) {
          if (!options2.attach) {
            this.options.keepMetadata &= ~8;
          }
        } else {
          throw is2.invalidParameterError("attach", "boolean", options2.attach);
        }
      }
    }
    return this;
  }
  function keepXmp() {
    this.options.keepMetadata |= 2;
    return this;
  }
  function withXmp(xmp) {
    if (is2.string(xmp) && xmp.length > 0) {
      this.options.withXmp = xmp;
      this.options.keepMetadata |= 2;
    } else {
      throw is2.invalidParameterError("xmp", "non-empty string", xmp);
    }
    return this;
  }
  function keepMetadata() {
    this.options.keepMetadata = 31;
    return this;
  }
  function withMetadata(options2) {
    this.keepMetadata();
    this.withIccProfile("srgb");
    if (is2.object(options2)) {
      if (is2.defined(options2.orientation)) {
        if (is2.integer(options2.orientation) && is2.inRange(options2.orientation, 1, 8)) {
          this.options.withMetadataOrientation = options2.orientation;
        } else {
          throw is2.invalidParameterError("orientation", "integer between 1 and 8", options2.orientation);
        }
      }
      if (is2.defined(options2.density)) {
        if (is2.number(options2.density) && options2.density > 0) {
          this.options.withMetadataDensity = options2.density;
        } else {
          throw is2.invalidParameterError("density", "positive number", options2.density);
        }
      }
      if (is2.defined(options2.icc)) {
        this.withIccProfile(options2.icc);
      }
      if (is2.defined(options2.exif)) {
        this.withExifMerge(options2.exif);
      }
    }
    return this;
  }
  function toFormat(format, options2) {
    const actualFormat = formats.get((is2.object(format) && is2.string(format.id) ? format.id : format).toLowerCase());
    if (!actualFormat) {
      throw is2.invalidParameterError("format", `one of: ${[...formats.keys()].join(", ")}`, format);
    }
    return this[actualFormat](options2);
  }
  function jpeg(options2) {
    if (is2.object(options2)) {
      if (is2.defined(options2.quality)) {
        if (is2.integer(options2.quality) && is2.inRange(options2.quality, 1, 100)) {
          this.options.jpegQuality = options2.quality;
        } else {
          throw is2.invalidParameterError("quality", "integer between 1 and 100", options2.quality);
        }
      }
      if (is2.defined(options2.progressive)) {
        this._setBooleanOption("jpegProgressive", options2.progressive);
      }
      if (is2.defined(options2.chromaSubsampling)) {
        if (is2.string(options2.chromaSubsampling) && is2.inArray(options2.chromaSubsampling, ["4:2:0", "4:4:4"])) {
          this.options.jpegChromaSubsampling = options2.chromaSubsampling;
        } else {
          throw is2.invalidParameterError("chromaSubsampling", "one of: 4:2:0, 4:4:4", options2.chromaSubsampling);
        }
      }
      const optimiseCoding = is2.bool(options2.optimizeCoding) ? options2.optimizeCoding : options2.optimiseCoding;
      if (is2.defined(optimiseCoding)) {
        this._setBooleanOption("jpegOptimiseCoding", optimiseCoding);
      }
      if (is2.defined(options2.mozjpeg)) {
        if (is2.bool(options2.mozjpeg)) {
          if (options2.mozjpeg) {
            this.options.jpegTrellisQuantisation = true;
            this.options.jpegOvershootDeringing = true;
            this.options.jpegOptimiseScans = true;
            this.options.jpegProgressive = true;
            this.options.jpegQuantisationTable = 3;
          }
        } else {
          throw is2.invalidParameterError("mozjpeg", "boolean", options2.mozjpeg);
        }
      }
      const trellisQuantisation = is2.bool(options2.trellisQuantization) ? options2.trellisQuantization : options2.trellisQuantisation;
      if (is2.defined(trellisQuantisation)) {
        this._setBooleanOption("jpegTrellisQuantisation", trellisQuantisation);
      }
      if (is2.defined(options2.overshootDeringing)) {
        this._setBooleanOption("jpegOvershootDeringing", options2.overshootDeringing);
      }
      const optimiseScans = is2.bool(options2.optimizeScans) ? options2.optimizeScans : options2.optimiseScans;
      if (is2.defined(optimiseScans)) {
        this._setBooleanOption("jpegOptimiseScans", optimiseScans);
        if (optimiseScans) {
          this.options.jpegProgressive = true;
        }
      }
      const quantisationTable = is2.number(options2.quantizationTable) ? options2.quantizationTable : options2.quantisationTable;
      if (is2.defined(quantisationTable)) {
        if (is2.integer(quantisationTable) && is2.inRange(quantisationTable, 0, 8)) {
          this.options.jpegQuantisationTable = quantisationTable;
        } else {
          throw is2.invalidParameterError("quantisationTable", "integer between 0 and 8", quantisationTable);
        }
      }
    }
    return this._updateFormatOut("jpeg", options2);
  }
  function png(options2) {
    if (is2.object(options2)) {
      if (is2.defined(options2.progressive)) {
        this._setBooleanOption("pngProgressive", options2.progressive);
      }
      if (is2.defined(options2.compressionLevel)) {
        if (is2.integer(options2.compressionLevel) && is2.inRange(options2.compressionLevel, 0, 9)) {
          this.options.pngCompressionLevel = options2.compressionLevel;
        } else {
          throw is2.invalidParameterError("compressionLevel", "integer between 0 and 9", options2.compressionLevel);
        }
      }
      if (is2.defined(options2.adaptiveFiltering)) {
        this._setBooleanOption("pngAdaptiveFiltering", options2.adaptiveFiltering);
      }
      const colours = options2.colours || options2.colors;
      if (is2.defined(colours)) {
        if (is2.integer(colours) && is2.inRange(colours, 2, 256)) {
          this.options.pngBitdepth = bitdepthFromColourCount(colours);
        } else {
          throw is2.invalidParameterError("colours", "integer between 2 and 256", colours);
        }
      }
      if (is2.defined(options2.palette)) {
        this._setBooleanOption("pngPalette", options2.palette);
      } else if ([options2.quality, options2.effort, options2.colours, options2.colors, options2.dither].some(is2.defined)) {
        this._setBooleanOption("pngPalette", true);
      }
      if (this.options.pngPalette) {
        if (is2.defined(options2.quality)) {
          if (is2.integer(options2.quality) && is2.inRange(options2.quality, 0, 100)) {
            this.options.pngQuality = options2.quality;
          } else {
            throw is2.invalidParameterError("quality", "integer between 0 and 100", options2.quality);
          }
        }
        if (is2.defined(options2.effort)) {
          if (is2.integer(options2.effort) && is2.inRange(options2.effort, 1, 10)) {
            this.options.pngEffort = options2.effort;
          } else {
            throw is2.invalidParameterError("effort", "integer between 1 and 10", options2.effort);
          }
        }
        if (is2.defined(options2.dither)) {
          if (is2.number(options2.dither) && is2.inRange(options2.dither, 0, 1)) {
            this.options.pngDither = options2.dither;
          } else {
            throw is2.invalidParameterError("dither", "number between 0.0 and 1.0", options2.dither);
          }
        }
      }
    }
    return this._updateFormatOut("png", options2);
  }
  function webp(options2) {
    if (is2.object(options2)) {
      if (is2.defined(options2.quality)) {
        if (is2.integer(options2.quality) && is2.inRange(options2.quality, 1, 100)) {
          this.options.webpQuality = options2.quality;
        } else {
          throw is2.invalidParameterError("quality", "integer between 1 and 100", options2.quality);
        }
      }
      if (is2.defined(options2.alphaQuality)) {
        if (is2.integer(options2.alphaQuality) && is2.inRange(options2.alphaQuality, 0, 100)) {
          this.options.webpAlphaQuality = options2.alphaQuality;
        } else {
          throw is2.invalidParameterError("alphaQuality", "integer between 0 and 100", options2.alphaQuality);
        }
      }
      if (is2.defined(options2.lossless)) {
        this._setBooleanOption("webpLossless", options2.lossless);
      }
      if (is2.defined(options2.nearLossless)) {
        this._setBooleanOption("webpNearLossless", options2.nearLossless);
      }
      if (is2.defined(options2.smartSubsample)) {
        this._setBooleanOption("webpSmartSubsample", options2.smartSubsample);
      }
      if (is2.defined(options2.smartDeblock)) {
        this._setBooleanOption("webpSmartDeblock", options2.smartDeblock);
      }
      if (is2.defined(options2.preset)) {
        if (is2.string(options2.preset) && is2.inArray(options2.preset, ["default", "photo", "picture", "drawing", "icon", "text"])) {
          this.options.webpPreset = options2.preset;
        } else {
          throw is2.invalidParameterError("preset", "one of: default, photo, picture, drawing, icon, text", options2.preset);
        }
      }
      if (is2.defined(options2.effort)) {
        if (is2.integer(options2.effort) && is2.inRange(options2.effort, 0, 6)) {
          this.options.webpEffort = options2.effort;
        } else {
          throw is2.invalidParameterError("effort", "integer between 0 and 6", options2.effort);
        }
      }
      if (is2.defined(options2.minSize)) {
        this._setBooleanOption("webpMinSize", options2.minSize);
      }
      if (is2.defined(options2.mixed)) {
        this._setBooleanOption("webpMixed", options2.mixed);
      }
    }
    trySetAnimationOptions(options2, this.options);
    return this._updateFormatOut("webp", options2);
  }
  function gif(options2) {
    if (is2.object(options2)) {
      if (is2.defined(options2.reuse)) {
        this._setBooleanOption("gifReuse", options2.reuse);
      }
      if (is2.defined(options2.progressive)) {
        this._setBooleanOption("gifProgressive", options2.progressive);
      }
      const colours = options2.colours || options2.colors;
      if (is2.defined(colours)) {
        if (is2.integer(colours) && is2.inRange(colours, 2, 256)) {
          this.options.gifBitdepth = bitdepthFromColourCount(colours);
        } else {
          throw is2.invalidParameterError("colours", "integer between 2 and 256", colours);
        }
      }
      if (is2.defined(options2.effort)) {
        if (is2.number(options2.effort) && is2.inRange(options2.effort, 1, 10)) {
          this.options.gifEffort = options2.effort;
        } else {
          throw is2.invalidParameterError("effort", "integer between 1 and 10", options2.effort);
        }
      }
      if (is2.defined(options2.dither)) {
        if (is2.number(options2.dither) && is2.inRange(options2.dither, 0, 1)) {
          this.options.gifDither = options2.dither;
        } else {
          throw is2.invalidParameterError("dither", "number between 0.0 and 1.0", options2.dither);
        }
      }
      if (is2.defined(options2.interFrameMaxError)) {
        if (is2.number(options2.interFrameMaxError) && is2.inRange(options2.interFrameMaxError, 0, 32)) {
          this.options.gifInterFrameMaxError = options2.interFrameMaxError;
        } else {
          throw is2.invalidParameterError("interFrameMaxError", "number between 0.0 and 32.0", options2.interFrameMaxError);
        }
      }
      if (is2.defined(options2.interPaletteMaxError)) {
        if (is2.number(options2.interPaletteMaxError) && is2.inRange(options2.interPaletteMaxError, 0, 256)) {
          this.options.gifInterPaletteMaxError = options2.interPaletteMaxError;
        } else {
          throw is2.invalidParameterError("interPaletteMaxError", "number between 0.0 and 256.0", options2.interPaletteMaxError);
        }
      }
      if (is2.defined(options2.keepDuplicateFrames)) {
        if (is2.bool(options2.keepDuplicateFrames)) {
          this._setBooleanOption("gifKeepDuplicateFrames", options2.keepDuplicateFrames);
        } else {
          throw is2.invalidParameterError("keepDuplicateFrames", "boolean", options2.keepDuplicateFrames);
        }
      }
    }
    trySetAnimationOptions(options2, this.options);
    return this._updateFormatOut("gif", options2);
  }
  function jp2(options2) {
    if (!this.constructor.format.jp2k.output.buffer) {
      throw errJp2Save();
    }
    if (is2.object(options2)) {
      if (is2.defined(options2.quality)) {
        if (is2.integer(options2.quality) && is2.inRange(options2.quality, 1, 100)) {
          this.options.jp2Quality = options2.quality;
        } else {
          throw is2.invalidParameterError("quality", "integer between 1 and 100", options2.quality);
        }
      }
      if (is2.defined(options2.lossless)) {
        if (is2.bool(options2.lossless)) {
          this.options.jp2Lossless = options2.lossless;
        } else {
          throw is2.invalidParameterError("lossless", "boolean", options2.lossless);
        }
      }
      if (is2.defined(options2.tileWidth)) {
        if (is2.integer(options2.tileWidth) && is2.inRange(options2.tileWidth, 1, 32768)) {
          this.options.jp2TileWidth = options2.tileWidth;
        } else {
          throw is2.invalidParameterError("tileWidth", "integer between 1 and 32768", options2.tileWidth);
        }
      }
      if (is2.defined(options2.tileHeight)) {
        if (is2.integer(options2.tileHeight) && is2.inRange(options2.tileHeight, 1, 32768)) {
          this.options.jp2TileHeight = options2.tileHeight;
        } else {
          throw is2.invalidParameterError("tileHeight", "integer between 1 and 32768", options2.tileHeight);
        }
      }
      if (is2.defined(options2.chromaSubsampling)) {
        if (is2.string(options2.chromaSubsampling) && is2.inArray(options2.chromaSubsampling, ["4:2:0", "4:4:4"])) {
          this.options.jp2ChromaSubsampling = options2.chromaSubsampling;
        } else {
          throw is2.invalidParameterError("chromaSubsampling", "one of: 4:2:0, 4:4:4", options2.chromaSubsampling);
        }
      }
    }
    return this._updateFormatOut("jp2", options2);
  }
  function trySetAnimationOptions(source, target) {
    if (is2.object(source) && is2.defined(source.loop)) {
      if (is2.integer(source.loop) && is2.inRange(source.loop, 0, 65535)) {
        target.loop = source.loop;
      } else {
        throw is2.invalidParameterError("loop", "integer between 0 and 65535", source.loop);
      }
    }
    if (is2.object(source) && is2.defined(source.delay)) {
      if (is2.integer(source.delay) && is2.inRange(source.delay, 0, 65535)) {
        target.delay = [source.delay];
      } else if (Array.isArray(source.delay) && source.delay.every(is2.integer) && source.delay.every((v) => is2.inRange(v, 0, 65535))) {
        target.delay = source.delay;
      } else {
        throw is2.invalidParameterError("delay", "integer or an array of integers between 0 and 65535", source.delay);
      }
    }
  }
  function tiff(options2) {
    if (is2.object(options2)) {
      if (is2.defined(options2.quality)) {
        if (is2.integer(options2.quality) && is2.inRange(options2.quality, 1, 100)) {
          this.options.tiffQuality = options2.quality;
        } else {
          throw is2.invalidParameterError("quality", "integer between 1 and 100", options2.quality);
        }
      }
      if (is2.defined(options2.bitdepth)) {
        if (is2.integer(options2.bitdepth) && is2.inArray(options2.bitdepth, [1, 2, 4, 8])) {
          this.options.tiffBitdepth = options2.bitdepth;
        } else {
          throw is2.invalidParameterError("bitdepth", "1, 2, 4 or 8", options2.bitdepth);
        }
      }
      if (is2.defined(options2.tile)) {
        this._setBooleanOption("tiffTile", options2.tile);
      }
      if (is2.defined(options2.tileWidth)) {
        if (is2.integer(options2.tileWidth) && options2.tileWidth > 0) {
          this.options.tiffTileWidth = options2.tileWidth;
        } else {
          throw is2.invalidParameterError("tileWidth", "integer greater than zero", options2.tileWidth);
        }
      }
      if (is2.defined(options2.tileHeight)) {
        if (is2.integer(options2.tileHeight) && options2.tileHeight > 0) {
          this.options.tiffTileHeight = options2.tileHeight;
        } else {
          throw is2.invalidParameterError("tileHeight", "integer greater than zero", options2.tileHeight);
        }
      }
      if (is2.defined(options2.miniswhite)) {
        this._setBooleanOption("tiffMiniswhite", options2.miniswhite);
      }
      if (is2.defined(options2.pyramid)) {
        this._setBooleanOption("tiffPyramid", options2.pyramid);
      }
      if (is2.defined(options2.xres)) {
        if (is2.number(options2.xres) && options2.xres > 0) {
          this.options.tiffXres = options2.xres;
        } else {
          throw is2.invalidParameterError("xres", "number greater than zero", options2.xres);
        }
      }
      if (is2.defined(options2.yres)) {
        if (is2.number(options2.yres) && options2.yres > 0) {
          this.options.tiffYres = options2.yres;
        } else {
          throw is2.invalidParameterError("yres", "number greater than zero", options2.yres);
        }
      }
      if (is2.defined(options2.compression)) {
        if (is2.string(options2.compression) && is2.inArray(options2.compression, ["none", "jpeg", "deflate", "packbits", "ccittfax4", "lzw", "webp", "zstd", "jp2k"])) {
          this.options.tiffCompression = options2.compression;
        } else {
          throw is2.invalidParameterError("compression", "one of: none, jpeg, deflate, packbits, ccittfax4, lzw, webp, zstd, jp2k", options2.compression);
        }
      }
      if (is2.defined(options2.bigtiff)) {
        this._setBooleanOption("tiffBigtiff", options2.bigtiff);
      }
      if (is2.defined(options2.predictor)) {
        if (is2.string(options2.predictor) && is2.inArray(options2.predictor, ["none", "horizontal", "float"])) {
          this.options.tiffPredictor = options2.predictor;
        } else {
          throw is2.invalidParameterError("predictor", "one of: none, horizontal, float", options2.predictor);
        }
      }
      if (is2.defined(options2.resolutionUnit)) {
        if (is2.string(options2.resolutionUnit) && is2.inArray(options2.resolutionUnit, ["inch", "cm"])) {
          this.options.tiffResolutionUnit = options2.resolutionUnit;
        } else {
          throw is2.invalidParameterError("resolutionUnit", "one of: inch, cm", options2.resolutionUnit);
        }
      }
    }
    return this._updateFormatOut("tiff", options2);
  }
  function avif(options2) {
    return this.heif({ ...options2, compression: "av1" });
  }
  function heif(options2) {
    if (is2.object(options2)) {
      if (is2.string(options2.compression) && is2.inArray(options2.compression, ["av1", "hevc"])) {
        this.options.heifCompression = options2.compression;
      } else {
        throw is2.invalidParameterError("compression", "one of: av1, hevc", options2.compression);
      }
      if (is2.defined(options2.quality)) {
        if (is2.integer(options2.quality) && is2.inRange(options2.quality, 1, 100)) {
          this.options.heifQuality = options2.quality;
        } else {
          throw is2.invalidParameterError("quality", "integer between 1 and 100", options2.quality);
        }
      }
      if (is2.defined(options2.lossless)) {
        if (is2.bool(options2.lossless)) {
          this.options.heifLossless = options2.lossless;
        } else {
          throw is2.invalidParameterError("lossless", "boolean", options2.lossless);
        }
      }
      if (is2.defined(options2.effort)) {
        if (is2.integer(options2.effort) && is2.inRange(options2.effort, 0, 9)) {
          this.options.heifEffort = options2.effort;
        } else {
          throw is2.invalidParameterError("effort", "integer between 0 and 9", options2.effort);
        }
      }
      if (is2.defined(options2.chromaSubsampling)) {
        if (is2.string(options2.chromaSubsampling) && is2.inArray(options2.chromaSubsampling, ["4:2:0", "4:4:4"])) {
          this.options.heifChromaSubsampling = options2.chromaSubsampling;
        } else {
          throw is2.invalidParameterError("chromaSubsampling", "one of: 4:2:0, 4:4:4", options2.chromaSubsampling);
        }
      }
      if (is2.defined(options2.bitdepth)) {
        if (is2.integer(options2.bitdepth) && is2.inArray(options2.bitdepth, [8, 10, 12])) {
          if (options2.bitdepth !== 8 && this.constructor.versions.heif) {
            throw is2.invalidParameterError("bitdepth when using prebuilt binaries", 8, options2.bitdepth);
          }
          this.options.heifBitdepth = options2.bitdepth;
        } else {
          throw is2.invalidParameterError("bitdepth", "8, 10 or 12", options2.bitdepth);
        }
      }
    } else {
      throw is2.invalidParameterError("options", "Object", options2);
    }
    return this._updateFormatOut("heif", options2);
  }
  function jxl(options2) {
    if (is2.object(options2)) {
      if (is2.defined(options2.quality)) {
        if (is2.integer(options2.quality) && is2.inRange(options2.quality, 1, 100)) {
          this.options.jxlDistance = options2.quality >= 30 ? 0.1 + (100 - options2.quality) * 0.09 : 53 / 3000 * options2.quality * options2.quality - 23 / 20 * options2.quality + 25;
        } else {
          throw is2.invalidParameterError("quality", "integer between 1 and 100", options2.quality);
        }
      } else if (is2.defined(options2.distance)) {
        if (is2.number(options2.distance) && is2.inRange(options2.distance, 0, 15)) {
          this.options.jxlDistance = options2.distance;
        } else {
          throw is2.invalidParameterError("distance", "number between 0.0 and 15.0", options2.distance);
        }
      }
      if (is2.defined(options2.decodingTier)) {
        if (is2.integer(options2.decodingTier) && is2.inRange(options2.decodingTier, 0, 4)) {
          this.options.jxlDecodingTier = options2.decodingTier;
        } else {
          throw is2.invalidParameterError("decodingTier", "integer between 0 and 4", options2.decodingTier);
        }
      }
      if (is2.defined(options2.lossless)) {
        if (is2.bool(options2.lossless)) {
          this.options.jxlLossless = options2.lossless;
        } else {
          throw is2.invalidParameterError("lossless", "boolean", options2.lossless);
        }
      }
      if (is2.defined(options2.effort)) {
        if (is2.integer(options2.effort) && is2.inRange(options2.effort, 1, 9)) {
          this.options.jxlEffort = options2.effort;
        } else {
          throw is2.invalidParameterError("effort", "integer between 1 and 9", options2.effort);
        }
      }
    }
    trySetAnimationOptions(options2, this.options);
    return this._updateFormatOut("jxl", options2);
  }
  function raw(options2) {
    if (is2.object(options2)) {
      if (is2.defined(options2.depth)) {
        if (is2.string(options2.depth) && is2.inArray(options2.depth, ["char", "uchar", "short", "ushort", "int", "uint", "float", "complex", "double", "dpcomplex"])) {
          this.options.rawDepth = options2.depth;
        } else {
          throw is2.invalidParameterError("depth", "one of: char, uchar, short, ushort, int, uint, float, complex, double, dpcomplex", options2.depth);
        }
      }
    }
    return this._updateFormatOut("raw");
  }
  function tile(options2) {
    if (is2.object(options2)) {
      if (is2.defined(options2.size)) {
        if (is2.integer(options2.size) && is2.inRange(options2.size, 1, 8192)) {
          this.options.tileSize = options2.size;
        } else {
          throw is2.invalidParameterError("size", "integer between 1 and 8192", options2.size);
        }
      }
      if (is2.defined(options2.overlap)) {
        if (is2.integer(options2.overlap) && is2.inRange(options2.overlap, 0, 8192)) {
          if (options2.overlap > this.options.tileSize) {
            throw is2.invalidParameterError("overlap", `<= size (${this.options.tileSize})`, options2.overlap);
          }
          this.options.tileOverlap = options2.overlap;
        } else {
          throw is2.invalidParameterError("overlap", "integer between 0 and 8192", options2.overlap);
        }
      }
      if (is2.defined(options2.container)) {
        if (is2.string(options2.container) && is2.inArray(options2.container, ["fs", "zip"])) {
          this.options.tileContainer = options2.container;
        } else {
          throw is2.invalidParameterError("container", "one of: fs, zip", options2.container);
        }
      }
      if (is2.defined(options2.layout)) {
        if (is2.string(options2.layout) && is2.inArray(options2.layout, ["dz", "google", "iiif", "iiif3", "zoomify"])) {
          this.options.tileLayout = options2.layout;
        } else {
          throw is2.invalidParameterError("layout", "one of: dz, google, iiif, iiif3, zoomify", options2.layout);
        }
      }
      if (is2.defined(options2.angle)) {
        if (is2.integer(options2.angle) && !(options2.angle % 90)) {
          this.options.tileAngle = options2.angle;
        } else {
          throw is2.invalidParameterError("angle", "positive/negative multiple of 90", options2.angle);
        }
      }
      this._setBackgroundColourOption("tileBackground", options2.background);
      if (is2.defined(options2.depth)) {
        if (is2.string(options2.depth) && is2.inArray(options2.depth, ["onepixel", "onetile", "one"])) {
          this.options.tileDepth = options2.depth;
        } else {
          throw is2.invalidParameterError("depth", "one of: onepixel, onetile, one", options2.depth);
        }
      }
      if (is2.defined(options2.skipBlanks)) {
        if (is2.integer(options2.skipBlanks) && is2.inRange(options2.skipBlanks, -1, 65535)) {
          this.options.tileSkipBlanks = options2.skipBlanks;
        } else {
          throw is2.invalidParameterError("skipBlanks", "integer between -1 and 255/65535", options2.skipBlanks);
        }
      } else if (is2.defined(options2.layout) && options2.layout === "google") {
        this.options.tileSkipBlanks = 5;
      }
      const centre = is2.bool(options2.center) ? options2.center : options2.centre;
      if (is2.defined(centre)) {
        this._setBooleanOption("tileCentre", centre);
      }
      if (is2.defined(options2.id)) {
        if (is2.string(options2.id)) {
          this.options.tileId = options2.id;
        } else {
          throw is2.invalidParameterError("id", "string", options2.id);
        }
      }
      if (is2.defined(options2.basename)) {
        if (is2.string(options2.basename)) {
          this.options.tileBasename = options2.basename;
        } else {
          throw is2.invalidParameterError("basename", "string", options2.basename);
        }
      }
    }
    if (is2.inArray(this.options.formatOut, ["jpeg", "png", "webp"])) {
      this.options.tileFormat = this.options.formatOut;
    } else if (this.options.formatOut !== "input") {
      throw is2.invalidParameterError("format", "one of: jpeg, png, webp", this.options.formatOut);
    }
    return this._updateFormatOut("dz");
  }
  function timeout(options2) {
    if (!is2.plainObject(options2)) {
      throw is2.invalidParameterError("options", "object", options2);
    }
    if (is2.integer(options2.seconds) && is2.inRange(options2.seconds, 0, 3600)) {
      this.options.timeoutSeconds = options2.seconds;
    } else {
      throw is2.invalidParameterError("seconds", "integer between 0 and 3600", options2.seconds);
    }
    return this;
  }
  function _updateFormatOut(formatOut, options2) {
    if (!(is2.object(options2) && options2.force === false)) {
      this.options.formatOut = formatOut;
    }
    return this;
  }
  function _setBooleanOption(key, val) {
    if (is2.bool(val)) {
      this.options[key] = val;
    } else {
      throw is2.invalidParameterError(key, "boolean", val);
    }
  }
  function _read() {
    if (!this.options.streamOut) {
      this.options.streamOut = true;
      const stack = Error();
      this._pipeline(undefined, stack);
    }
  }
  function _pipeline(callback, stack) {
    if (typeof callback === "function") {
      if (this._isStreamInput()) {
        this.on("finish", () => {
          this._flattenBufferIn();
          sharp.pipeline(this.options, (err, data, info) => {
            if (err) {
              callback(is2.nativeError(err, stack));
            } else {
              callback(null, data, info);
            }
          });
        });
      } else {
        sharp.pipeline(this.options, (err, data, info) => {
          if (err) {
            callback(is2.nativeError(err, stack));
          } else {
            callback(null, data, info);
          }
        });
      }
      return this;
    } else if (this.options.streamOut) {
      if (this._isStreamInput()) {
        this.once("finish", () => {
          this._flattenBufferIn();
          sharp.pipeline(this.options, (err, data, info) => {
            if (err) {
              this.emit("error", is2.nativeError(err, stack));
            } else {
              this.emit("info", info);
              this.push(data);
            }
            this.push(null);
            this.on("end", () => this.emit("close"));
          });
        });
        if (this.streamInFinished) {
          this.emit("finish");
        }
      } else {
        sharp.pipeline(this.options, (err, data, info) => {
          if (err) {
            this.emit("error", is2.nativeError(err, stack));
          } else {
            this.emit("info", info);
            this.push(data);
          }
          this.push(null);
          this.on("end", () => this.emit("close"));
        });
      }
      return this;
    } else {
      if (this._isStreamInput()) {
        return new Promise((resolve4, reject) => {
          this.once("finish", () => {
            this._flattenBufferIn();
            sharp.pipeline(this.options, (err, data, info) => {
              if (err) {
                reject(is2.nativeError(err, stack));
              } else {
                if (this.options.resolveWithObject) {
                  resolve4({ data, info });
                } else {
                  resolve4(data);
                }
              }
            });
          });
        });
      } else {
        return new Promise((resolve4, reject) => {
          sharp.pipeline(this.options, (err, data, info) => {
            if (err) {
              reject(is2.nativeError(err, stack));
            } else {
              if (this.options.resolveWithObject) {
                resolve4({ data, info });
              } else {
                resolve4(data);
              }
            }
          });
        });
      }
    }
  }
  module.exports = (Sharp) => {
    Object.assign(Sharp.prototype, {
      toFile,
      toBuffer,
      keepExif,
      withExif,
      withExifMerge,
      keepIccProfile,
      withIccProfile,
      keepXmp,
      withXmp,
      keepMetadata,
      withMetadata,
      toFormat,
      jpeg,
      jp2,
      png,
      webp,
      tiff,
      avif,
      heif,
      jxl,
      gif,
      raw,
      tile,
      timeout,
      _updateFormatOut,
      _setBooleanOption,
      _read,
      _pipeline
    });
  };
});

// node_modules/sharp/lib/utility.js
var require_utility = __commonJS((exports, module) => {
  /*!
    Copyright 2013 Lovell Fuller and others.
    SPDX-License-Identifier: Apache-2.0
  */
  var events = __require("events");
  var detectLibc = require_detect_libc();
  var is2 = require_is();
  var { runtimePlatformArch } = require_libvips();
  var sharp = require_sharp();
  var runtimePlatform = runtimePlatformArch();
  var libvipsVersion = sharp.libvipsVersion();
  var format = sharp.format();
  format.heif.output.alias = ["avif", "heic"];
  format.jpeg.output.alias = ["jpe", "jpg"];
  format.tiff.output.alias = ["tif"];
  format.jp2k.output.alias = ["j2c", "j2k", "jp2", "jpx"];
  var interpolators = {
    nearest: "nearest",
    bilinear: "bilinear",
    bicubic: "bicubic",
    locallyBoundedBicubic: "lbb",
    nohalo: "nohalo",
    vertexSplitQuadraticBasisSpline: "vsqbs"
  };
  var versions3 = {
    vips: libvipsVersion.semver
  };
  if (!libvipsVersion.isGlobal) {
    if (!libvipsVersion.isWasm) {
      try {
        versions3 = __require(`@img/sharp-${runtimePlatform}/versions`);
      } catch (_) {
        try {
          versions3 = __require(`@img/sharp-libvips-${runtimePlatform}/versions`);
        } catch (_2) {}
      }
    } else {
      try {
        versions3 = (()=>{throw new Error("Cannot require module "+"@img/sharp-wasm32/versions");})();
      } catch (_) {}
    }
  }
  versions3.sharp = require_package2().version;
  if (versions3.heif && format.heif) {
    format.heif.input.fileSuffix = [".avif"];
    format.heif.output.alias = ["avif"];
  }
  function cache(options2) {
    if (is2.bool(options2)) {
      if (options2) {
        return sharp.cache(50, 20, 100);
      } else {
        return sharp.cache(0, 0, 0);
      }
    } else if (is2.object(options2)) {
      return sharp.cache(options2.memory, options2.files, options2.items);
    } else {
      return sharp.cache();
    }
  }
  cache(true);
  function concurrency(concurrency2) {
    return sharp.concurrency(is2.integer(concurrency2) ? concurrency2 : null);
  }
  if (detectLibc.familySync() === detectLibc.GLIBC && !sharp._isUsingJemalloc()) {
    sharp.concurrency(1);
  } else if (detectLibc.familySync() === detectLibc.MUSL && sharp.concurrency() === 1024) {
    sharp.concurrency(__require("os").availableParallelism());
  }
  var queue = new events.EventEmitter;
  function counters() {
    return sharp.counters();
  }
  function simd(simd2) {
    return sharp.simd(is2.bool(simd2) ? simd2 : null);
  }
  function block(options2) {
    if (is2.object(options2)) {
      if (Array.isArray(options2.operation) && options2.operation.every(is2.string)) {
        sharp.block(options2.operation, true);
      } else {
        throw is2.invalidParameterError("operation", "Array<string>", options2.operation);
      }
    } else {
      throw is2.invalidParameterError("options", "object", options2);
    }
  }
  function unblock(options2) {
    if (is2.object(options2)) {
      if (Array.isArray(options2.operation) && options2.operation.every(is2.string)) {
        sharp.block(options2.operation, false);
      } else {
        throw is2.invalidParameterError("operation", "Array<string>", options2.operation);
      }
    } else {
      throw is2.invalidParameterError("options", "object", options2);
    }
  }
  module.exports = (Sharp) => {
    Sharp.cache = cache;
    Sharp.concurrency = concurrency;
    Sharp.counters = counters;
    Sharp.simd = simd;
    Sharp.format = format;
    Sharp.interpolators = interpolators;
    Sharp.versions = versions3;
    Sharp.queue = queue;
    Sharp.block = block;
    Sharp.unblock = unblock;
  };
});

// node_modules/sharp/lib/index.js
var require_lib = __commonJS((exports, module) => {
  /*!
    Copyright 2013 Lovell Fuller and others.
    SPDX-License-Identifier: Apache-2.0
  */
  var Sharp = require_constructor();
  require_input()(Sharp);
  require_resize()(Sharp);
  require_composite()(Sharp);
  require_operation()(Sharp);
  require_colour2()(Sharp);
  require_channel()(Sharp);
  require_output()(Sharp);
  require_utility()(Sharp);
  module.exports = Sharp;
});

// src/utils/ServiceLifecycle.ts
import { existsSync as existsSync16, writeFileSync as writeFileSync6 } from "fs";
import { unlink as unlink2 } from "fs/promises";

class ServiceLifecycle {
  config;
  constructor(config3) {
    this.config = config3;
  }
  async isRunning(pid) {
    try {
      process.kill(pid, 0);
      return true;
    } catch (_e) {
      return false;
    }
  }
  async start() {
    initAmalfaDirs();
    if (await Bun.file(this.config.pidFile).exists()) {
      const pid = parseInt(await Bun.file(this.config.pidFile).text(), 10);
      if (await this.isRunning(pid)) {
        console.log(`\u26A0\uFE0F  ${this.config.name} is already running (PID: ${pid})`);
        return;
      }
      console.log(`\u26A0\uFE0F  Found stale PID file for ${this.config.name}. Clearing...`);
      await unlink2(this.config.pidFile);
    }
    const logFile = Bun.file(this.config.logFile);
    await Bun.write(logFile, "");
    const subprocess = Bun.spawn(["bun", "run", this.config.entryPoint, "serve"], {
      cwd: process.cwd(),
      detached: true,
      stdout: logFile,
      stderr: logFile,
      env: process.env
    });
    writeFileSync6(this.config.pidFile, subprocess.pid.toString());
    subprocess.unref();
    console.log(`\u2705 ${this.config.name} started in background (PID: ${subprocess.pid})`);
    console.log(`\uD83D\uDCDD Logs: ${this.config.logFile}`);
  }
  async stop() {
    if (!await Bun.file(this.config.pidFile).exists()) {
      console.log(`\u2139\uFE0F  ${this.config.name} is not running.`);
      return;
    }
    const pid = parseInt(await Bun.file(this.config.pidFile).text(), 10);
    if (await this.isRunning(pid)) {
      console.log(`\uD83D\uDED1 Stopping ${this.config.name} (PID: ${pid})...`);
      process.kill(pid, "SIGTERM");
      let attempts = 0;
      while (await this.isRunning(pid) && attempts < 10) {
        await new Promise((r) => setTimeout(r, 100));
        attempts++;
      }
      if (await this.isRunning(pid)) {
        console.log("\u26A0\uFE0F  Process did not exit gracefully. Force killing...");
        process.kill(pid, "SIGKILL");
      }
      console.log(`\u2705 ${this.config.name} stopped.`);
    } else {
      console.log("\u26A0\uFE0F  Stale PID file found. Cleaning up.");
    }
    try {
      await unlink2(this.config.pidFile);
    } catch (e) {
      const err = e;
      if (err.code !== "ENOENT") {
        console.warn(`\u26A0\uFE0F Failed to remove PID file: ${err.message}`);
      }
    }
  }
  async status() {
    if (await Bun.file(this.config.pidFile).exists()) {
      const pid = parseInt(await Bun.file(this.config.pidFile).text(), 10);
      if (await this.isRunning(pid)) {
        console.log(`\uD83D\uDFE2 ${this.config.name} is RUNNING (PID: ${pid})`);
        return;
      }
      console.log(`\uD83D\uDD34 ${this.config.name} is NOT RUNNING (Stale PID: ${pid})`);
    } else {
      console.log(`\u26AA\uFE0F ${this.config.name} is STOPPED`);
    }
  }
  async serve(serverLogic) {
    initAmalfaDirs();
    writeFileSync6(this.config.pidFile, process.pid.toString());
    let cleanupCalled = false;
    const cleanup = async (signal) => {
      if (cleanupCalled)
        return;
      cleanupCalled = true;
      try {
        if (await Bun.file(this.config.pidFile).exists()) {
          await unlink2(this.config.pidFile);
          if (signal) {
            console.error(`
\uD83E\uDDF9 ${this.config.name}: PID file cleaned up on ${signal}`);
          }
        }
      } catch (_e) {}
    };
    process.on("SIGINT", () => cleanup("SIGINT").then(() => process.exit(0)));
    process.on("SIGTERM", () => cleanup("SIGTERM").then(() => process.exit(0)));
    process.on("exit", () => {
      if (!cleanupCalled && existsSync16(this.config.pidFile)) {
        cleanupCalled = true;
        try {
          writeFileSync6(this.config.pidFile, "");
        } catch {}
      }
    });
    await serverLogic();
  }
  async run(command, serverLogic) {
    switch (command) {
      case "start":
        await this.start();
        process.exit(0);
        break;
      case "stop":
        await this.stop();
        process.exit(0);
        break;
      case "status":
        await this.status();
        process.exit(0);
        break;
      case "restart":
        await this.stop();
        await new Promise((r) => setTimeout(r, 500));
        await this.start();
        process.exit(0);
        break;
      case "serve":
        await this.serve(serverLogic);
        break;
      default:
        console.log(`Unknown command '${command}'. Use: start, stop, status, restart, or serve`);
        process.exit(1);
    }
  }
}
var init_ServiceLifecycle = __esm(() => {
  init_defaults();
});

// src/utils/DaemonManager.ts
import { existsSync as existsSync17 } from "fs";
import { join as join20 } from "path";

class DaemonManager {
  vectorLifecycle;
  watcherLifecycle;
  sonarLifecycle;
  rerankerLifecycle;
  constructor() {
    this.vectorLifecycle = new ServiceLifecycle({
      name: "Vector-Daemon",
      pidFile: join20(AMALFA_DIRS.runtime, "vector-daemon.pid"),
      logFile: join20(AMALFA_DIRS.logs, "vector-daemon.log"),
      entryPoint: "src/resonance/services/vector-daemon.ts"
    });
    this.rerankerLifecycle = new ServiceLifecycle({
      name: "Reranker-Daemon",
      pidFile: join20(AMALFA_DIRS.runtime, "reranker-daemon.pid"),
      logFile: join20(AMALFA_DIRS.logs, "reranker-daemon.log"),
      entryPoint: "src/resonance/services/reranker-daemon.ts"
    });
    this.watcherLifecycle = new ServiceLifecycle({
      name: "File-Watcher",
      pidFile: join20(AMALFA_DIRS.runtime, "daemon.pid"),
      logFile: join20(AMALFA_DIRS.logs, "daemon.log"),
      entryPoint: "src/daemon/index.ts"
    });
    this.sonarLifecycle = new ServiceLifecycle({
      name: "SonarAgent",
      pidFile: join20(AMALFA_DIRS.runtime, "sonar.pid"),
      logFile: join20(AMALFA_DIRS.logs, "sonar.log"),
      entryPoint: "src/daemon/sonar-agent.ts"
    });
  }
  async isProcessRunning(pid) {
    try {
      process.kill(pid, 0);
      return true;
    } catch {
      return false;
    }
  }
  async readPid(pidFile) {
    if (!existsSync17(pidFile)) {
      return null;
    }
    try {
      const content = await Bun.file(pidFile).text();
      const pid = Number.parseInt(content.trim(), 10);
      return Number.isNaN(pid) ? null : pid;
    } catch {
      return null;
    }
  }
  async checkVectorDaemon() {
    const pid = await this.readPid(join20(AMALFA_DIRS.runtime, "vector-daemon.pid"));
    if (!pid) {
      return { running: false };
    }
    const running = await this.isProcessRunning(pid);
    return {
      running,
      pid: running ? pid : undefined,
      port: running ? 3010 : undefined
    };
  }
  async startVectorDaemon() {
    await this.vectorLifecycle.start();
    await new Promise((resolve4) => setTimeout(resolve4, 1000));
  }
  async stopVectorDaemon() {
    await this.vectorLifecycle.stop();
  }
  async checkRerankerDaemon() {
    const pid = await this.readPid(join20(AMALFA_DIRS.runtime, "reranker-daemon.pid"));
    if (!pid) {
      return { running: false };
    }
    const running = await this.isProcessRunning(pid);
    return {
      running,
      pid: running ? pid : undefined,
      port: running ? 3011 : undefined
    };
  }
  async startRerankerDaemon() {
    await this.rerankerLifecycle.start();
    await new Promise((resolve4) => setTimeout(resolve4, 1000));
  }
  async stopRerankerDaemon() {
    await this.rerankerLifecycle.stop();
  }
  async checkFileWatcher() {
    const pid = await this.readPid(join20(AMALFA_DIRS.runtime, "daemon.pid"));
    if (!pid) {
      return { running: false };
    }
    const running = await this.isProcessRunning(pid);
    return {
      running,
      pid: running ? pid : undefined
    };
  }
  async startFileWatcher() {
    await this.watcherLifecycle.start();
    await new Promise((resolve4) => setTimeout(resolve4, 500));
  }
  async stopFileWatcher() {
    await this.watcherLifecycle.stop();
  }
  async checkSonarAgent() {
    const pid = await this.readPid(join20(AMALFA_DIRS.runtime, "sonar.pid"));
    if (!pid) {
      return { running: false };
    }
    const running = await this.isProcessRunning(pid);
    let activeModel;
    if (running) {
      try {
        const health = await fetch("http://localhost:3012/health").then((r) => r.json());
        activeModel = health.model;
      } catch {}
    }
    return {
      running,
      pid: running ? pid : undefined,
      port: running ? 3012 : undefined,
      activeModel
    };
  }
  async startSonarAgent() {
    await this.sonarLifecycle.start();
    await new Promise((resolve4) => setTimeout(resolve4, 1000));
  }
  async stopSonarAgent() {
    await this.sonarLifecycle.stop();
  }
  async checkAll() {
    const [vector, reranker, watcher, sonar] = await Promise.all([
      this.checkVectorDaemon(),
      this.checkRerankerDaemon(),
      this.checkFileWatcher(),
      this.checkSonarAgent()
    ]);
    return { vector, reranker, watcher, sonar };
  }
  async stopAll() {
    await Promise.all([
      this.stopVectorDaemon(),
      this.stopRerankerDaemon(),
      this.stopFileWatcher(),
      this.stopSonarAgent()
    ]);
  }
}
var init_DaemonManager = __esm(() => {
  init_defaults();
  init_ServiceLifecycle();
});

// src/cli/sonar-chat.ts
var exports_sonar_chat = {};
__export(exports_sonar_chat, {
  chatLoop: () => chatLoop
});
import { createInterface as createInterface2 } from "readline";
async function chatLoop() {
  const manager = new DaemonManager;
  let status = await manager.checkSonarAgent();
  if (!status.running) {
    console.log("\uD83D\uDE80 Sonar Agent not running. Starting it now...");
    await manager.startSonarAgent();
    await new Promise((resolve4) => setTimeout(resolve4, 2000));
    status = await manager.checkSonarAgent();
    if (!status.running) {
      console.log("\u274C Failed to start Sonar Agent. Check logs: .amalfa/logs/sonar.log");
      process.exit(1);
    }
    console.log(`\u2705 Sonar Agent started.
`);
  }
  const BASE_URL = `http://localhost:${status.port}`;
  let sessionId;
  let providerInfo = "";
  try {
    const health = await fetch(`${BASE_URL}/health`).then((r) => r.json());
    const providerLabel = health.provider === "cloud" ? "\u2601\uFE0F  Cloud" : "\uD83D\uDCBB Local";
    providerInfo = ` [${providerLabel}: ${health.model || "unknown"}]`;
  } catch {
    providerInfo = "";
  }
  console.log(`\uD83D\uDCAC AMALFA Corpus Assistant${providerInfo}`);
  console.log(`   Type 'exit' or 'quit' to leave.
`);
  const rl = createInterface2({
    input: process.stdin,
    output: process.stdout,
    prompt: "You > "
  });
  rl.prompt();
  rl.on("line", async (line) => {
    const input = line.trim();
    if (["exit", "quit"].includes(input.toLowerCase())) {
      rl.close();
      return;
    }
    if (!input) {
      rl.prompt();
      return;
    }
    let timer;
    try {
      const start = Date.now();
      process.stdout.write("\uD83E\uDD16 Thinking... (0s)");
      timer = setInterval(() => {
        const elapsed = Math.floor((Date.now() - start) / 1000);
        process.stdout.clearLine(0);
        process.stdout.cursorTo(0);
        process.stdout.write(`\uD83E\uDD16 Thinking... (${elapsed}s)`);
      }, 1000);
      const res = await fetch(`${BASE_URL}/chat`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ message: input, sessionId })
      });
      clearInterval(timer);
      if (!res.ok) {
        throw new Error(`API Error: ${res.statusText}`);
      }
      const data = await res.json();
      if (!sessionId) {
        sessionId = data.sessionId;
      }
      process.stdout.clearLine(0);
      process.stdout.cursorTo(0);
      console.log(`Sonar > ${data.message.content}
`);
    } catch (e) {
      clearInterval(timer);
      process.stdout.clearLine(0);
      process.stdout.cursorTo(0);
      console.error(`\u274C Error: ${e instanceof Error ? e.message : String(e)}
`);
    }
    rl.prompt();
  }).on("close", () => {
    console.log(`
\uD83D\uDC4B Goodbye!`);
    process.exit(0);
  });
}
var init_sonar_chat = __esm(() => {
  init_DaemonManager();
});

// src/cli/list-scripts.ts
var exports_list_scripts = {};
import { existsSync as existsSync22, readFileSync as readFileSync9 } from "fs";
import { join as join23 } from "path";
import { fileURLToPath as fileURLToPath3 } from "url";
function loadRegistry() {
  if (!existsSync22(REGISTRY_PATH)) {
    console.error(`\u274C Registry not found at: ${REGISTRY_PATH}`);
    process.exit(1);
  }
  return JSON.parse(readFileSync9(REGISTRY_PATH, "utf-8"));
}
function printScripts() {
  const scripts = loadRegistry();
  const grouped = {};
  const rootDir = join23(__dirname2, "../../");
  const scriptsDir = join23(rootDir, "scripts");
  const isDevMode = existsSync22(scriptsDir);
  for (const s of scripts) {
    if (!isDevMode && s.type === "dev")
      continue;
    if (!grouped[s.category])
      grouped[s.category] = [];
    grouped[s.category]?.push(s);
  }
  console.log(`
\uD83D\uDCDC AMALFA Command Registry
`);
  if (isDevMode) {
    console.log(`\uD83D\uDEE0\uFE0F  Development Mode Detected (showing all repo scripts)
`);
  } else {
    console.log(`\uD83D\uDCE6 Production Mode (showing user commands)
`);
  }
  const categories = Object.keys(grouped).sort();
  for (const cat of categories) {
    console.log(`[${cat.toUpperCase()}]`);
    const catScripts = grouped[cat];
    if (catScripts) {
      for (const script of catScripts) {
        console.log(`  $ ${script.command}`);
        console.log(`    ${script.description}`);
        console.log("");
      }
    }
  }
}
var __dirname2, REGISTRY_PATH;
var init_list_scripts = __esm(() => {
  __dirname2 = fileURLToPath3(new URL(".", import.meta.url));
  REGISTRY_PATH = join23(__dirname2, "../config/scripts-registry.json");
  printScripts();
});

// src/cli/enhance-commands.ts
var exports_enhance_commands = {};
__export(exports_enhance_commands, {
  cmdEnhance: () => cmdEnhance
});
async function cmdEnhance(args) {
  const manager = new DaemonManager;
  const status = await manager.checkSonarAgent();
  if (!status.running) {
    console.error("\u274C Sonar Agent is not running.");
    console.error("   Please start it first: amalfa sonar start");
    process.exit(1);
  }
  const BASE_URL = `http://localhost:${status.port}`;
  const batchIdx = args.indexOf("--batch");
  const docIdx = args.indexOf("--doc");
  const limitIdx = args.indexOf("--limit");
  if (batchIdx !== -1) {
    let limit = 50;
    if (limitIdx !== -1) {
      const limitArg = args[limitIdx + 1];
      if (limitArg !== undefined) {
        limit = parseInt(limitArg, 10);
      }
    }
    console.log(`\uD83D\uDE80 Starting batch enhancement (Limit: ${limit})...`);
    try {
      const res = await fetch(`${BASE_URL}/metadata/batch`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ limit })
      });
      if (!res.ok)
        throw new Error(res.statusText);
      const result = await res.json();
      console.log(`\u2705 Batch complete:`);
      console.log(`   Processed: ${result.processed}`);
      console.log(`   Errors:    ${result.errors}`);
    } catch (e) {
      console.error("\u274C Batch enhancement failed:", e);
    }
    return;
  }
  if (docIdx !== -1 && args[docIdx + 1]) {
    const docId = args[docIdx + 1];
    console.log(`\uD83D\uDD0D Enhancing document: ${docId}...`);
    try {
      const res = await fetch(`${BASE_URL}/metadata/enhance`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ docId })
      });
      if (!res.ok)
        throw new Error(res.statusText);
      const result = await res.json();
      console.log("\u2705 Enhancement successful!");
      console.log(JSON.stringify(result, null, 2));
    } catch (e) {
      console.error("\u274C Enhancement failed:", e);
    }
    return;
  }
  console.log("Usage:");
  console.log("  amalfa enhance --batch [--limit <n>]");
  console.log("  amalfa enhance --doc <id>");
}
var init_enhance_commands = __esm(() => {
  init_DaemonManager();
});

// src/cli.ts
import { existsSync as existsSync23 } from "fs";
import { join as join24, resolve as resolve5 } from "path";
// package.json
var package_default = {
  name: "amalfa",
  version: "1.5.1",
  description: "Local-first knowledge graph engine for AI agents. Transforms markdown into searchable memory with MCP protocol.",
  license: "MIT",
  homepage: "https://github.com/pjsvis/amalfa#readme",
  bugs: {
    url: "https://github.com/pjsvis/amalfa/issues"
  },
  author: "Peter John Smith <729613+pjsvis@users.noreply.github.com>",
  repository: {
    type: "git",
    url: "git+https://github.com/pjsvis/amalfa.git"
  },
  main: "src/cli.ts",
  type: "module",
  files: [
    "src",
    "src/sidecars",
    "tsconfig.json",
    "README.md",
    "CHANGELOG.md",
    "LICENSE"
  ],
  keywords: [
    "mcp",
    "model-context-protocol",
    "knowledge-graph",
    "ai-agents",
    "vector-search",
    "sqlite",
    "embeddings",
    "markdown",
    "local-first",
    "privacy",
    "claude",
    "semantic-search",
    "zettelkasten",
    "pkm"
  ],
  bin: {
    amalfa: "src/cli.ts"
  },
  engines: {
    bun: ">=1.3.8"
  },
  devDependencies: {
    "@biomejs/biome": "^2.3.11",
    "@types/bun": "1.3.4",
    "only-allow": "1.2.2",
    "pino-pretty": "13.1.3",
    typescript: "5.9.3"
  },
  scripts: {
    precommit: "bun run scripts/maintenance/pre-commit.ts",
    check: "biome check .",
    format: "biome format --write .",
    "validate-config": "bun run scripts/validate-config.ts",
    build: "tsc --noEmit",
    dev: "bun run --watch src/cli.ts",
    amalfa: "bun run src/cli.ts",
    servers: "bun run src/cli.ts servers",
    "servers:dot": "bun run src/cli.ts servers --dot",
    stats: "bun run src/cli.ts stats",
    doctor: "bun run src/cli.ts doctor",
    watcher: "bun run src/cli.ts watcher status",
    "consistency-report": "bun run scripts/maintenance/consistency-report.ts",
    help: "bun run src/cli.ts --help",
    "bundle:analyze": "bun run scripts/lab/bun-1-3-8-markdown-test/analyze-bundle.ts",
    "bundle:build": "rm -rf .bun-dist && bun build --target bun --outdir .bun-dist src/cli.ts --metafile meta.json"
  },
  dependencies: {
    "@google/generative-ai": "^0.24.1",
    "@huggingface/transformers": "^3.8.1",
    "@modelcontextprotocol/sdk": "^1.25.2",
    "@xenova/transformers": "^2.17.2",
    "drizzle-kit": "0.31.8",
    "drizzle-orm": "0.45.1",
    fastembed: "^1.0.0",
    glob: "^13.0.0",
    graphology: "0.26.0",
    "graphology-library": "0.8.0",
    "gray-matter": "^4.0.3",
    hono: "4.11.3",
    pino: "10.1.0",
    zod: "^4.3.5"
  },
  trustedDependencies: [
    "onnxruntime-node",
    "protobufjs"
  ]
};

// src/cli/commands/doctor.ts
init_defaults();
import { existsSync as existsSync4, statSync } from "fs";
import { join as join5 } from "path";

// src/cli/utils.ts
import { existsSync as existsSync2 } from "fs";
import { join as join3 } from "path";
var DB_PATH = null;
async function getDbPath() {
  if (DB_PATH)
    return DB_PATH;
  const { loadConfig: loadConfig2 } = await Promise.resolve().then(() => (init_defaults(), exports_defaults));
  const config2 = await loadConfig2();
  DB_PATH = join3(process.cwd(), config2.database);
  return DB_PATH;
}
async function checkDatabase() {
  const dbPath = await getDbPath();
  if (!existsSync2(dbPath)) {
    console.error(`
\u274C Database not found at: ${dbPath}
   (CWD: ${process.cwd()})

To initialize AMALFA:
1. Create markdown files in ./docs/ (or your preferred location)
2. Run: amalfa init
`);
    return false;
  }
  return true;
}

// src/cli/commands/doctor.ts
async function cmdDoctor(_args) {
  console.log(`\uD83E\uDE7A AMALFA Health Check
`);
  let issues = 0;
  console.log("\u2713 Bun runtime: OK");
  const dbPath = await getDbPath();
  if (existsSync4(dbPath)) {
    const fileSizeMB = (statSync(dbPath).size / 1024 / 1024).toFixed(2);
    console.log(`\u2713 Database found: ${dbPath} (${fileSizeMB} MB)`);
  } else {
    console.log(`\u2717 Database not found: ${dbPath}`);
    console.log(`  Run: amalfa init`);
    issues++;
  }
  const amalfaDir = join5(process.cwd(), ".amalfa");
  if (existsSync4(amalfaDir)) {
    console.log(`\u2713 AMALFA directory: ${amalfaDir}`);
  } else {
    console.log(`\u2717 AMALFA directory not found: ${amalfaDir}`);
    issues++;
  }
  try {
    loadSettings(false);
    console.log("\u2713 Settings (SSOT): OK");
  } catch (e) {
    console.log(`\u2717 Settings (SSOT) Invalid/Missing`);
    console.log(`  Error: ${e.message || e}`);
    issues++;
  }
  const config3 = await loadConfig();
  const sources = config3.sources || ["./docs"];
  let sourcesFound = 0;
  for (const source of sources) {
    const sourcePath = join5(process.cwd(), source);
    if (existsSync4(sourcePath)) {
      console.log(`\u2713 Source directory: ${sourcePath}`);
      sourcesFound++;
    } else {
      console.log(`\u2717 Source directory not found: ${sourcePath}`);
      issues++;
    }
  }
  if (sourcesFound === 0) {
    console.log(`  Configure sources in amalfa.config.json`);
  }
  try {
    await Promise.resolve().then(() => (init_esm(), exports_esm));
    console.log("\u2713 FastEmbed: OK");
  } catch {
    console.log("\u2717 FastEmbed not found (run: bun install)");
    issues++;
  }
  try {
    await Promise.resolve().then(() => (init_server(), exports_server));
    console.log("\u2713 MCP SDK: OK");
  } catch {
    console.log("\u2717 MCP SDK not found (run: bun install)");
    issues++;
  }
  console.log("");
  if (issues === 0) {
    console.log("\u2705 All checks passed! AMALFA is ready to use.");
    console.log(`
Next steps:`);
    console.log("  amalfa serve    # Start MCP server");
    console.log("  amalfa stats    # View database statistics");
  } else {
    console.log(`\u274C Found ${issues} issue(s). Please resolve them and try again.`);
    process.exit(1);
  }
}

// src/resonance/db.ts
init_defaults();
import { existsSync as existsSync5 } from "fs";

// src/utils/Logger.ts
var import_pino = __toESM(require_pino(), 1);
var loggerConfig = {
  level: process.env.LOG_LEVEL || "info",
  base: undefined,
  timestamp: import_pino.default.stdTimeFunctions.isoTime
};
var rootLogger = import_pino.default(loggerConfig, import_pino.default.destination(2));
var log = rootLogger;
var getLogger = (component) => {
  return rootLogger.child({ component });
};

// node_modules/drizzle-orm/bun-sqlite/driver.js
import { Database } from "bun:sqlite";

// node_modules/drizzle-orm/entity.js
var entityKind = Symbol.for("drizzle:entityKind");
var hasOwnEntityKind = Symbol.for("drizzle:hasOwnEntityKind");
function is(value, type) {
  if (!value || typeof value !== "object") {
    return false;
  }
  if (value instanceof type) {
    return true;
  }
  if (!Object.prototype.hasOwnProperty.call(type, entityKind)) {
    throw new Error(`Class "${type.name ?? "<unknown>"}" doesn't look like a Drizzle entity. If this is incorrect and the class is provided by Drizzle, please report this as a bug.`);
  }
  let cls = Object.getPrototypeOf(value).constructor;
  if (cls) {
    while (cls) {
      if (entityKind in cls && cls[entityKind] === type[entityKind]) {
        return true;
      }
      cls = Object.getPrototypeOf(cls);
    }
  }
  return false;
}

// node_modules/drizzle-orm/logger.js
class ConsoleLogWriter {
  static [entityKind] = "ConsoleLogWriter";
  write(message) {
    console.log(message);
  }
}

class DefaultLogger {
  static [entityKind] = "DefaultLogger";
  writer;
  constructor(config3) {
    this.writer = config3?.writer ?? new ConsoleLogWriter;
  }
  logQuery(query, params) {
    const stringifiedParams = params.map((p) => {
      try {
        return JSON.stringify(p);
      } catch {
        return String(p);
      }
    });
    const paramsStr = stringifiedParams.length ? ` -- params: [${stringifiedParams.join(", ")}]` : "";
    this.writer.write(`Query: ${query}${paramsStr}`);
  }
}

class NoopLogger {
  static [entityKind] = "NoopLogger";
  logQuery() {}
}

// node_modules/drizzle-orm/table.utils.js
var TableName = Symbol.for("drizzle:Name");

// node_modules/drizzle-orm/table.js
var Schema = Symbol.for("drizzle:Schema");
var Columns = Symbol.for("drizzle:Columns");
var ExtraConfigColumns = Symbol.for("drizzle:ExtraConfigColumns");
var OriginalName = Symbol.for("drizzle:OriginalName");
var BaseName = Symbol.for("drizzle:BaseName");
var IsAlias = Symbol.for("drizzle:IsAlias");
var ExtraConfigBuilder = Symbol.for("drizzle:ExtraConfigBuilder");
var IsDrizzleTable = Symbol.for("drizzle:IsDrizzleTable");

class Table {
  static [entityKind] = "Table";
  static Symbol = {
    Name: TableName,
    Schema,
    OriginalName,
    Columns,
    ExtraConfigColumns,
    BaseName,
    IsAlias,
    ExtraConfigBuilder
  };
  [TableName];
  [OriginalName];
  [Schema];
  [Columns];
  [ExtraConfigColumns];
  [BaseName];
  [IsAlias] = false;
  [IsDrizzleTable] = true;
  [ExtraConfigBuilder] = undefined;
  constructor(name, schema, baseName) {
    this[TableName] = this[OriginalName] = name;
    this[Schema] = schema;
    this[BaseName] = baseName;
  }
}
function getTableName(table) {
  return table[TableName];
}
function getTableUniqueName(table) {
  return `${table[Schema] ?? "public"}.${table[TableName]}`;
}

// node_modules/drizzle-orm/column.js
class Column {
  constructor(table, config3) {
    this.table = table;
    this.config = config3;
    this.name = config3.name;
    this.keyAsName = config3.keyAsName;
    this.notNull = config3.notNull;
    this.default = config3.default;
    this.defaultFn = config3.defaultFn;
    this.onUpdateFn = config3.onUpdateFn;
    this.hasDefault = config3.hasDefault;
    this.primary = config3.primaryKey;
    this.isUnique = config3.isUnique;
    this.uniqueName = config3.uniqueName;
    this.uniqueType = config3.uniqueType;
    this.dataType = config3.dataType;
    this.columnType = config3.columnType;
    this.generated = config3.generated;
    this.generatedIdentity = config3.generatedIdentity;
  }
  static [entityKind] = "Column";
  name;
  keyAsName;
  primary;
  notNull;
  default;
  defaultFn;
  onUpdateFn;
  hasDefault;
  isUnique;
  uniqueName;
  uniqueType;
  dataType;
  columnType;
  enumValues = undefined;
  generated = undefined;
  generatedIdentity = undefined;
  config;
  mapFromDriverValue(value) {
    return value;
  }
  mapToDriverValue(value) {
    return value;
  }
  shouldDisableInsert() {
    return this.config.generated !== undefined && this.config.generated.type !== "byDefault";
  }
}

// node_modules/drizzle-orm/tracing-utils.js
function iife(fn, ...args) {
  return fn(...args);
}

// node_modules/drizzle-orm/pg-core/unique-constraint.js
function uniqueKeyName(table, columns) {
  return `${table[TableName]}_${columns.join("_")}_unique`;
}

// node_modules/drizzle-orm/pg-core/columns/common.js
class PgColumn extends Column {
  constructor(table, config3) {
    if (!config3.uniqueName) {
      config3.uniqueName = uniqueKeyName(table, [config3.name]);
    }
    super(table, config3);
    this.table = table;
  }
  static [entityKind] = "PgColumn";
}

class ExtraConfigColumn extends PgColumn {
  static [entityKind] = "ExtraConfigColumn";
  getSQLType() {
    return this.getSQLType();
  }
  indexConfig = {
    order: this.config.order ?? "asc",
    nulls: this.config.nulls ?? "last",
    opClass: this.config.opClass
  };
  defaultConfig = {
    order: "asc",
    nulls: "last",
    opClass: undefined
  };
  asc() {
    this.indexConfig.order = "asc";
    return this;
  }
  desc() {
    this.indexConfig.order = "desc";
    return this;
  }
  nullsFirst() {
    this.indexConfig.nulls = "first";
    return this;
  }
  nullsLast() {
    this.indexConfig.nulls = "last";
    return this;
  }
  op(opClass) {
    this.indexConfig.opClass = opClass;
    return this;
  }
}

// node_modules/drizzle-orm/pg-core/columns/enum.js
class PgEnumObjectColumn extends PgColumn {
  static [entityKind] = "PgEnumObjectColumn";
  enum;
  enumValues = this.config.enum.enumValues;
  constructor(table, config3) {
    super(table, config3);
    this.enum = config3.enum;
  }
  getSQLType() {
    return this.enum.enumName;
  }
}
var isPgEnumSym = Symbol.for("drizzle:isPgEnum");
function isPgEnum(obj) {
  return !!obj && typeof obj === "function" && isPgEnumSym in obj && obj[isPgEnumSym] === true;
}
class PgEnumColumn extends PgColumn {
  static [entityKind] = "PgEnumColumn";
  enum = this.config.enum;
  enumValues = this.config.enum.enumValues;
  constructor(table, config3) {
    super(table, config3);
    this.enum = config3.enum;
  }
  getSQLType() {
    return this.enum.enumName;
  }
}

// node_modules/drizzle-orm/subquery.js
class Subquery {
  static [entityKind] = "Subquery";
  constructor(sql, fields, alias, isWith = false, usedTables = []) {
    this._ = {
      brand: "Subquery",
      sql,
      selectedFields: fields,
      alias,
      isWith,
      usedTables
    };
  }
}

class WithSubquery extends Subquery {
  static [entityKind] = "WithSubquery";
}

// node_modules/drizzle-orm/version.js
var version3 = "0.45.1";

// node_modules/drizzle-orm/tracing.js
var otel;
var rawTracer;
var tracer = {
  startActiveSpan(name, fn) {
    if (!otel) {
      return fn();
    }
    if (!rawTracer) {
      rawTracer = otel.trace.getTracer("drizzle-orm", version3);
    }
    return iife((otel2, rawTracer2) => rawTracer2.startActiveSpan(name, (span) => {
      try {
        return fn(span);
      } catch (e) {
        span.setStatus({
          code: otel2.SpanStatusCode.ERROR,
          message: e instanceof Error ? e.message : "Unknown error"
        });
        throw e;
      } finally {
        span.end();
      }
    }), otel, rawTracer);
  }
};

// node_modules/drizzle-orm/view-common.js
var ViewBaseConfig = Symbol.for("drizzle:ViewBaseConfig");

// node_modules/drizzle-orm/sql/sql.js
function isSQLWrapper(value) {
  return value !== null && value !== undefined && typeof value.getSQL === "function";
}
function mergeQueries(queries) {
  const result = { sql: "", params: [] };
  for (const query of queries) {
    result.sql += query.sql;
    result.params.push(...query.params);
    if (query.typings?.length) {
      if (!result.typings) {
        result.typings = [];
      }
      result.typings.push(...query.typings);
    }
  }
  return result;
}

class StringChunk {
  static [entityKind] = "StringChunk";
  value;
  constructor(value) {
    this.value = Array.isArray(value) ? value : [value];
  }
  getSQL() {
    return new SQL([this]);
  }
}

class SQL {
  constructor(queryChunks) {
    this.queryChunks = queryChunks;
    for (const chunk of queryChunks) {
      if (is(chunk, Table)) {
        const schemaName = chunk[Table.Symbol.Schema];
        this.usedTables.push(schemaName === undefined ? chunk[Table.Symbol.Name] : schemaName + "." + chunk[Table.Symbol.Name]);
      }
    }
  }
  static [entityKind] = "SQL";
  decoder = noopDecoder;
  shouldInlineParams = false;
  usedTables = [];
  append(query) {
    this.queryChunks.push(...query.queryChunks);
    return this;
  }
  toQuery(config3) {
    return tracer.startActiveSpan("drizzle.buildSQL", (span) => {
      const query = this.buildQueryFromSourceParams(this.queryChunks, config3);
      span?.setAttributes({
        "drizzle.query.text": query.sql,
        "drizzle.query.params": JSON.stringify(query.params)
      });
      return query;
    });
  }
  buildQueryFromSourceParams(chunks, _config) {
    const config3 = Object.assign({}, _config, {
      inlineParams: _config.inlineParams || this.shouldInlineParams,
      paramStartIndex: _config.paramStartIndex || { value: 0 }
    });
    const {
      casing,
      escapeName,
      escapeParam,
      prepareTyping,
      inlineParams,
      paramStartIndex
    } = config3;
    return mergeQueries(chunks.map((chunk) => {
      if (is(chunk, StringChunk)) {
        return { sql: chunk.value.join(""), params: [] };
      }
      if (is(chunk, Name)) {
        return { sql: escapeName(chunk.value), params: [] };
      }
      if (chunk === undefined) {
        return { sql: "", params: [] };
      }
      if (Array.isArray(chunk)) {
        const result = [new StringChunk("(")];
        for (const [i, p] of chunk.entries()) {
          result.push(p);
          if (i < chunk.length - 1) {
            result.push(new StringChunk(", "));
          }
        }
        result.push(new StringChunk(")"));
        return this.buildQueryFromSourceParams(result, config3);
      }
      if (is(chunk, SQL)) {
        return this.buildQueryFromSourceParams(chunk.queryChunks, {
          ...config3,
          inlineParams: inlineParams || chunk.shouldInlineParams
        });
      }
      if (is(chunk, Table)) {
        const schemaName = chunk[Table.Symbol.Schema];
        const tableName = chunk[Table.Symbol.Name];
        return {
          sql: schemaName === undefined || chunk[IsAlias] ? escapeName(tableName) : escapeName(schemaName) + "." + escapeName(tableName),
          params: []
        };
      }
      if (is(chunk, Column)) {
        const columnName = casing.getColumnCasing(chunk);
        if (_config.invokeSource === "indexes") {
          return { sql: escapeName(columnName), params: [] };
        }
        const schemaName = chunk.table[Table.Symbol.Schema];
        return {
          sql: chunk.table[IsAlias] || schemaName === undefined ? escapeName(chunk.table[Table.Symbol.Name]) + "." + escapeName(columnName) : escapeName(schemaName) + "." + escapeName(chunk.table[Table.Symbol.Name]) + "." + escapeName(columnName),
          params: []
        };
      }
      if (is(chunk, View)) {
        const schemaName = chunk[ViewBaseConfig].schema;
        const viewName = chunk[ViewBaseConfig].name;
        return {
          sql: schemaName === undefined || chunk[ViewBaseConfig].isAlias ? escapeName(viewName) : escapeName(schemaName) + "." + escapeName(viewName),
          params: []
        };
      }
      if (is(chunk, Param)) {
        if (is(chunk.value, Placeholder)) {
          return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ["none"] };
        }
        const mappedValue = chunk.value === null ? null : chunk.encoder.mapToDriverValue(chunk.value);
        if (is(mappedValue, SQL)) {
          return this.buildQueryFromSourceParams([mappedValue], config3);
        }
        if (inlineParams) {
          return { sql: this.mapInlineParam(mappedValue, config3), params: [] };
        }
        let typings = ["none"];
        if (prepareTyping) {
          typings = [prepareTyping(chunk.encoder)];
        }
        return { sql: escapeParam(paramStartIndex.value++, mappedValue), params: [mappedValue], typings };
      }
      if (is(chunk, Placeholder)) {
        return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ["none"] };
      }
      if (is(chunk, SQL.Aliased) && chunk.fieldAlias !== undefined) {
        return { sql: escapeName(chunk.fieldAlias), params: [] };
      }
      if (is(chunk, Subquery)) {
        if (chunk._.isWith) {
          return { sql: escapeName(chunk._.alias), params: [] };
        }
        return this.buildQueryFromSourceParams([
          new StringChunk("("),
          chunk._.sql,
          new StringChunk(") "),
          new Name(chunk._.alias)
        ], config3);
      }
      if (isPgEnum(chunk)) {
        if (chunk.schema) {
          return { sql: escapeName(chunk.schema) + "." + escapeName(chunk.enumName), params: [] };
        }
        return { sql: escapeName(chunk.enumName), params: [] };
      }
      if (isSQLWrapper(chunk)) {
        if (chunk.shouldOmitSQLParens?.()) {
          return this.buildQueryFromSourceParams([chunk.getSQL()], config3);
        }
        return this.buildQueryFromSourceParams([
          new StringChunk("("),
          chunk.getSQL(),
          new StringChunk(")")
        ], config3);
      }
      if (inlineParams) {
        return { sql: this.mapInlineParam(chunk, config3), params: [] };
      }
      return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ["none"] };
    }));
  }
  mapInlineParam(chunk, { escapeString }) {
    if (chunk === null) {
      return "null";
    }
    if (typeof chunk === "number" || typeof chunk === "boolean") {
      return chunk.toString();
    }
    if (typeof chunk === "string") {
      return escapeString(chunk);
    }
    if (typeof chunk === "object") {
      const mappedValueAsString = chunk.toString();
      if (mappedValueAsString === "[object Object]") {
        return escapeString(JSON.stringify(chunk));
      }
      return escapeString(mappedValueAsString);
    }
    throw new Error("Unexpected param value: " + chunk);
  }
  getSQL() {
    return this;
  }
  as(alias) {
    if (alias === undefined) {
      return this;
    }
    return new SQL.Aliased(this, alias);
  }
  mapWith(decoder) {
    this.decoder = typeof decoder === "function" ? { mapFromDriverValue: decoder } : decoder;
    return this;
  }
  inlineParams() {
    this.shouldInlineParams = true;
    return this;
  }
  if(condition) {
    return condition ? this : undefined;
  }
}

class Name {
  constructor(value) {
    this.value = value;
  }
  static [entityKind] = "Name";
  brand;
  getSQL() {
    return new SQL([this]);
  }
}
function isDriverValueEncoder(value) {
  return typeof value === "object" && value !== null && "mapToDriverValue" in value && typeof value.mapToDriverValue === "function";
}
var noopDecoder = {
  mapFromDriverValue: (value) => value
};
var noopEncoder = {
  mapToDriverValue: (value) => value
};
var noopMapper = {
  ...noopDecoder,
  ...noopEncoder
};

class Param {
  constructor(value, encoder = noopEncoder) {
    this.value = value;
    this.encoder = encoder;
  }
  static [entityKind] = "Param";
  brand;
  getSQL() {
    return new SQL([this]);
  }
}
function sql(strings, ...params) {
  const queryChunks = [];
  if (params.length > 0 || strings.length > 0 && strings[0] !== "") {
    queryChunks.push(new StringChunk(strings[0]));
  }
  for (const [paramIndex, param2] of params.entries()) {
    queryChunks.push(param2, new StringChunk(strings[paramIndex + 1]));
  }
  return new SQL(queryChunks);
}
((sql2) => {
  function empty() {
    return new SQL([]);
  }
  sql2.empty = empty;
  function fromList(list) {
    return new SQL(list);
  }
  sql2.fromList = fromList;
  function raw(str2) {
    return new SQL([new StringChunk(str2)]);
  }
  sql2.raw = raw;
  function join6(chunks, separator) {
    const result = [];
    for (const [i, chunk] of chunks.entries()) {
      if (i > 0 && separator !== undefined) {
        result.push(separator);
      }
      result.push(chunk);
    }
    return new SQL(result);
  }
  sql2.join = join6;
  function identifier(value) {
    return new Name(value);
  }
  sql2.identifier = identifier;
  function placeholder2(name2) {
    return new Placeholder(name2);
  }
  sql2.placeholder = placeholder2;
  function param2(value, encoder) {
    return new Param(value, encoder);
  }
  sql2.param = param2;
})(sql || (sql = {}));
((SQL2) => {

  class Aliased {
    constructor(sql2, fieldAlias) {
      this.sql = sql2;
      this.fieldAlias = fieldAlias;
    }
    static [entityKind] = "SQL.Aliased";
    isSelectionField = false;
    getSQL() {
      return this.sql;
    }
    clone() {
      return new Aliased(this.sql, this.fieldAlias);
    }
  }
  SQL2.Aliased = Aliased;
})(SQL || (SQL = {}));

class Placeholder {
  constructor(name2) {
    this.name = name2;
  }
  static [entityKind] = "Placeholder";
  getSQL() {
    return new SQL([this]);
  }
}
function fillPlaceholders(params, values) {
  return params.map((p) => {
    if (is(p, Placeholder)) {
      if (!(p.name in values)) {
        throw new Error(`No value for placeholder "${p.name}" was provided`);
      }
      return values[p.name];
    }
    if (is(p, Param) && is(p.value, Placeholder)) {
      if (!(p.value.name in values)) {
        throw new Error(`No value for placeholder "${p.value.name}" was provided`);
      }
      return p.encoder.mapToDriverValue(values[p.value.name]);
    }
    return p;
  });
}
var IsDrizzleView = Symbol.for("drizzle:IsDrizzleView");

class View {
  static [entityKind] = "View";
  [ViewBaseConfig];
  [IsDrizzleView] = true;
  constructor({ name: name2, schema, selectedFields, query }) {
    this[ViewBaseConfig] = {
      name: name2,
      originalName: name2,
      schema,
      selectedFields,
      query,
      isExisting: !query,
      isAlias: false
    };
  }
  getSQL() {
    return new SQL([this]);
  }
}
Column.prototype.getSQL = function() {
  return new SQL([this]);
};
Table.prototype.getSQL = function() {
  return new SQL([this]);
};
Subquery.prototype.getSQL = function() {
  return new SQL([this]);
};

// node_modules/drizzle-orm/utils.js
function mapResultRow(columns, row, joinsNotNullableMap) {
  const nullifyMap = {};
  const result = columns.reduce((result2, { path: path2, field }, columnIndex) => {
    let decoder;
    if (is(field, Column)) {
      decoder = field;
    } else if (is(field, SQL)) {
      decoder = field.decoder;
    } else if (is(field, Subquery)) {
      decoder = field._.sql.decoder;
    } else {
      decoder = field.sql.decoder;
    }
    let node = result2;
    for (const [pathChunkIndex, pathChunk] of path2.entries()) {
      if (pathChunkIndex < path2.length - 1) {
        if (!(pathChunk in node)) {
          node[pathChunk] = {};
        }
        node = node[pathChunk];
      } else {
        const rawValue = row[columnIndex];
        const value = node[pathChunk] = rawValue === null ? null : decoder.mapFromDriverValue(rawValue);
        if (joinsNotNullableMap && is(field, Column) && path2.length === 2) {
          const objectName = path2[0];
          if (!(objectName in nullifyMap)) {
            nullifyMap[objectName] = value === null ? getTableName(field.table) : false;
          } else if (typeof nullifyMap[objectName] === "string" && nullifyMap[objectName] !== getTableName(field.table)) {
            nullifyMap[objectName] = false;
          }
        }
      }
    }
    return result2;
  }, {});
  if (joinsNotNullableMap && Object.keys(nullifyMap).length > 0) {
    for (const [objectName, tableName] of Object.entries(nullifyMap)) {
      if (typeof tableName === "string" && !joinsNotNullableMap[tableName]) {
        result[objectName] = null;
      }
    }
  }
  return result;
}
function orderSelectedFields(fields, pathPrefix) {
  return Object.entries(fields).reduce((result, [name, field]) => {
    if (typeof name !== "string") {
      return result;
    }
    const newPath = pathPrefix ? [...pathPrefix, name] : [name];
    if (is(field, Column) || is(field, SQL) || is(field, SQL.Aliased) || is(field, Subquery)) {
      result.push({ path: newPath, field });
    } else if (is(field, Table)) {
      result.push(...orderSelectedFields(field[Table.Symbol.Columns], newPath));
    } else {
      result.push(...orderSelectedFields(field, newPath));
    }
    return result;
  }, []);
}
function haveSameKeys(left, right) {
  const leftKeys = Object.keys(left);
  const rightKeys = Object.keys(right);
  if (leftKeys.length !== rightKeys.length) {
    return false;
  }
  for (const [index, key] of leftKeys.entries()) {
    if (key !== rightKeys[index]) {
      return false;
    }
  }
  return true;
}
function mapUpdateSet(table, values) {
  const entries = Object.entries(values).filter(([, value]) => value !== undefined).map(([key, value]) => {
    if (is(value, SQL) || is(value, Column)) {
      return [key, value];
    } else {
      return [key, new Param(value, table[Table.Symbol.Columns][key])];
    }
  });
  if (entries.length === 0) {
    throw new Error("No values to set");
  }
  return Object.fromEntries(entries);
}
function applyMixins(baseClass, extendedClasses) {
  for (const extendedClass of extendedClasses) {
    for (const name of Object.getOwnPropertyNames(extendedClass.prototype)) {
      if (name === "constructor")
        continue;
      Object.defineProperty(baseClass.prototype, name, Object.getOwnPropertyDescriptor(extendedClass.prototype, name) || /* @__PURE__ */ Object.create(null));
    }
  }
}
function getTableColumns(table) {
  return table[Table.Symbol.Columns];
}
function getTableLikeName(table) {
  return is(table, Subquery) ? table._.alias : is(table, View) ? table[ViewBaseConfig].name : is(table, SQL) ? undefined : table[Table.Symbol.IsAlias] ? table[Table.Symbol.Name] : table[Table.Symbol.BaseName];
}
function isConfig(data) {
  if (typeof data !== "object" || data === null)
    return false;
  if (data.constructor.name !== "Object")
    return false;
  if ("logger" in data) {
    const type = typeof data["logger"];
    if (type !== "boolean" && (type !== "object" || typeof data["logger"]["logQuery"] !== "function") && type !== "undefined")
      return false;
    return true;
  }
  if ("schema" in data) {
    const type = typeof data["schema"];
    if (type !== "object" && type !== "undefined")
      return false;
    return true;
  }
  if ("casing" in data) {
    const type = typeof data["casing"];
    if (type !== "string" && type !== "undefined")
      return false;
    return true;
  }
  if ("mode" in data) {
    if (data["mode"] !== "default" || data["mode"] !== "planetscale" || data["mode"] !== undefined)
      return false;
    return true;
  }
  if ("connection" in data) {
    const type = typeof data["connection"];
    if (type !== "string" && type !== "object" && type !== "undefined")
      return false;
    return true;
  }
  if ("client" in data) {
    const type = typeof data["client"];
    if (type !== "object" && type !== "function" && type !== "undefined")
      return false;
    return true;
  }
  if (Object.keys(data).length === 0)
    return true;
  return false;
}
var textDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder;

// node_modules/drizzle-orm/pg-core/table.js
var InlineForeignKeys = Symbol.for("drizzle:PgInlineForeignKeys");
var EnableRLS = Symbol.for("drizzle:EnableRLS");

class PgTable extends Table {
  static [entityKind] = "PgTable";
  static Symbol = Object.assign({}, Table.Symbol, {
    InlineForeignKeys,
    EnableRLS
  });
  [InlineForeignKeys] = [];
  [EnableRLS] = false;
  [Table.Symbol.ExtraConfigBuilder] = undefined;
  [Table.Symbol.ExtraConfigColumns] = {};
}

// node_modules/drizzle-orm/pg-core/primary-keys.js
class PrimaryKeyBuilder {
  static [entityKind] = "PgPrimaryKeyBuilder";
  columns;
  name;
  constructor(columns, name) {
    this.columns = columns;
    this.name = name;
  }
  build(table) {
    return new PrimaryKey(table, this.columns, this.name);
  }
}

class PrimaryKey {
  constructor(table, columns, name) {
    this.table = table;
    this.columns = columns;
    this.name = name;
  }
  static [entityKind] = "PgPrimaryKey";
  columns;
  name;
  getName() {
    return this.name ?? `${this.table[PgTable.Symbol.Name]}_${this.columns.map((column) => column.name).join("_")}_pk`;
  }
}

// node_modules/drizzle-orm/sql/expressions/conditions.js
function bindIfParam(value, column) {
  if (isDriverValueEncoder(column) && !isSQLWrapper(value) && !is(value, Param) && !is(value, Placeholder) && !is(value, Column) && !is(value, Table) && !is(value, View)) {
    return new Param(value, column);
  }
  return value;
}
var eq = (left, right) => {
  return sql`${left} = ${bindIfParam(right, left)}`;
};
var ne = (left, right) => {
  return sql`${left} <> ${bindIfParam(right, left)}`;
};
function and(...unfilteredConditions) {
  const conditions = unfilteredConditions.filter((c) => c !== undefined);
  if (conditions.length === 0) {
    return;
  }
  if (conditions.length === 1) {
    return new SQL(conditions);
  }
  return new SQL([
    new StringChunk("("),
    sql.join(conditions, new StringChunk(" and ")),
    new StringChunk(")")
  ]);
}
function or(...unfilteredConditions) {
  const conditions = unfilteredConditions.filter((c) => c !== undefined);
  if (conditions.length === 0) {
    return;
  }
  if (conditions.length === 1) {
    return new SQL(conditions);
  }
  return new SQL([
    new StringChunk("("),
    sql.join(conditions, new StringChunk(" or ")),
    new StringChunk(")")
  ]);
}
function not(condition) {
  return sql`not ${condition}`;
}
var gt = (left, right) => {
  return sql`${left} > ${bindIfParam(right, left)}`;
};
var gte = (left, right) => {
  return sql`${left} >= ${bindIfParam(right, left)}`;
};
var lt = (left, right) => {
  return sql`${left} < ${bindIfParam(right, left)}`;
};
var lte = (left, right) => {
  return sql`${left} <= ${bindIfParam(right, left)}`;
};
function inArray(column, values) {
  if (Array.isArray(values)) {
    if (values.length === 0) {
      return sql`false`;
    }
    return sql`${column} in ${values.map((v) => bindIfParam(v, column))}`;
  }
  return sql`${column} in ${bindIfParam(values, column)}`;
}
function notInArray(column, values) {
  if (Array.isArray(values)) {
    if (values.length === 0) {
      return sql`true`;
    }
    return sql`${column} not in ${values.map((v) => bindIfParam(v, column))}`;
  }
  return sql`${column} not in ${bindIfParam(values, column)}`;
}
function isNull(value) {
  return sql`${value} is null`;
}
function isNotNull(value) {
  return sql`${value} is not null`;
}
function exists(subquery) {
  return sql`exists ${subquery}`;
}
function notExists(subquery) {
  return sql`not exists ${subquery}`;
}
function between(column, min, max) {
  return sql`${column} between ${bindIfParam(min, column)} and ${bindIfParam(max, column)}`;
}
function notBetween(column, min, max) {
  return sql`${column} not between ${bindIfParam(min, column)} and ${bindIfParam(max, column)}`;
}
function like(column, value) {
  return sql`${column} like ${value}`;
}
function notLike(column, value) {
  return sql`${column} not like ${value}`;
}
function ilike(column, value) {
  return sql`${column} ilike ${value}`;
}
function notIlike(column, value) {
  return sql`${column} not ilike ${value}`;
}

// node_modules/drizzle-orm/sql/expressions/select.js
function asc(column) {
  return sql`${column} asc`;
}
function desc(column) {
  return sql`${column} desc`;
}

// node_modules/drizzle-orm/relations.js
class Relation {
  constructor(sourceTable, referencedTable, relationName) {
    this.sourceTable = sourceTable;
    this.referencedTable = referencedTable;
    this.relationName = relationName;
    this.referencedTableName = referencedTable[Table.Symbol.Name];
  }
  static [entityKind] = "Relation";
  referencedTableName;
  fieldName;
}

class Relations {
  constructor(table, config3) {
    this.table = table;
    this.config = config3;
  }
  static [entityKind] = "Relations";
}

class One extends Relation {
  constructor(sourceTable, referencedTable, config3, isNullable) {
    super(sourceTable, referencedTable, config3?.relationName);
    this.config = config3;
    this.isNullable = isNullable;
  }
  static [entityKind] = "One";
  withFieldName(fieldName) {
    const relation = new One(this.sourceTable, this.referencedTable, this.config, this.isNullable);
    relation.fieldName = fieldName;
    return relation;
  }
}

class Many extends Relation {
  constructor(sourceTable, referencedTable, config3) {
    super(sourceTable, referencedTable, config3?.relationName);
    this.config = config3;
  }
  static [entityKind] = "Many";
  withFieldName(fieldName) {
    const relation = new Many(this.sourceTable, this.referencedTable, this.config);
    relation.fieldName = fieldName;
    return relation;
  }
}
function getOperators() {
  return {
    and,
    between,
    eq,
    exists,
    gt,
    gte,
    ilike,
    inArray,
    isNull,
    isNotNull,
    like,
    lt,
    lte,
    ne,
    not,
    notBetween,
    notExists,
    notLike,
    notIlike,
    notInArray,
    or,
    sql
  };
}
function getOrderByOperators() {
  return {
    sql,
    asc,
    desc
  };
}
function extractTablesRelationalConfig(schema, configHelpers) {
  if (Object.keys(schema).length === 1 && "default" in schema && !is(schema["default"], Table)) {
    schema = schema["default"];
  }
  const tableNamesMap = {};
  const relationsBuffer = {};
  const tablesConfig = {};
  for (const [key, value] of Object.entries(schema)) {
    if (is(value, Table)) {
      const dbName = getTableUniqueName(value);
      const bufferedRelations = relationsBuffer[dbName];
      tableNamesMap[dbName] = key;
      tablesConfig[key] = {
        tsName: key,
        dbName: value[Table.Symbol.Name],
        schema: value[Table.Symbol.Schema],
        columns: value[Table.Symbol.Columns],
        relations: bufferedRelations?.relations ?? {},
        primaryKey: bufferedRelations?.primaryKey ?? []
      };
      for (const column of Object.values(value[Table.Symbol.Columns])) {
        if (column.primary) {
          tablesConfig[key].primaryKey.push(column);
        }
      }
      const extraConfig = value[Table.Symbol.ExtraConfigBuilder]?.(value[Table.Symbol.ExtraConfigColumns]);
      if (extraConfig) {
        for (const configEntry of Object.values(extraConfig)) {
          if (is(configEntry, PrimaryKeyBuilder)) {
            tablesConfig[key].primaryKey.push(...configEntry.columns);
          }
        }
      }
    } else if (is(value, Relations)) {
      const dbName = getTableUniqueName(value.table);
      const tableName = tableNamesMap[dbName];
      const relations2 = value.config(configHelpers(value.table));
      let primaryKey;
      for (const [relationName, relation] of Object.entries(relations2)) {
        if (tableName) {
          const tableConfig = tablesConfig[tableName];
          tableConfig.relations[relationName] = relation;
          if (primaryKey) {
            tableConfig.primaryKey.push(...primaryKey);
          }
        } else {
          if (!(dbName in relationsBuffer)) {
            relationsBuffer[dbName] = {
              relations: {},
              primaryKey
            };
          }
          relationsBuffer[dbName].relations[relationName] = relation;
        }
      }
    }
  }
  return { tables: tablesConfig, tableNamesMap };
}
function createOne(sourceTable) {
  return function one(table, config3) {
    return new One(sourceTable, table, config3, config3?.fields.reduce((res, f) => res && f.notNull, true) ?? false);
  };
}
function createMany(sourceTable) {
  return function many(referencedTable, config3) {
    return new Many(sourceTable, referencedTable, config3);
  };
}
function normalizeRelation(schema, tableNamesMap, relation) {
  if (is(relation, One) && relation.config) {
    return {
      fields: relation.config.fields,
      references: relation.config.references
    };
  }
  const referencedTableTsName = tableNamesMap[getTableUniqueName(relation.referencedTable)];
  if (!referencedTableTsName) {
    throw new Error(`Table "${relation.referencedTable[Table.Symbol.Name]}" not found in schema`);
  }
  const referencedTableConfig = schema[referencedTableTsName];
  if (!referencedTableConfig) {
    throw new Error(`Table "${referencedTableTsName}" not found in schema`);
  }
  const sourceTable = relation.sourceTable;
  const sourceTableTsName = tableNamesMap[getTableUniqueName(sourceTable)];
  if (!sourceTableTsName) {
    throw new Error(`Table "${sourceTable[Table.Symbol.Name]}" not found in schema`);
  }
  const reverseRelations = [];
  for (const referencedTableRelation of Object.values(referencedTableConfig.relations)) {
    if (relation.relationName && relation !== referencedTableRelation && referencedTableRelation.relationName === relation.relationName || !relation.relationName && referencedTableRelation.referencedTable === relation.sourceTable) {
      reverseRelations.push(referencedTableRelation);
    }
  }
  if (reverseRelations.length > 1) {
    throw relation.relationName ? new Error(`There are multiple relations with name "${relation.relationName}" in table "${referencedTableTsName}"`) : new Error(`There are multiple relations between "${referencedTableTsName}" and "${relation.sourceTable[Table.Symbol.Name]}". Please specify relation name`);
  }
  if (reverseRelations[0] && is(reverseRelations[0], One) && reverseRelations[0].config) {
    return {
      fields: reverseRelations[0].config.references,
      references: reverseRelations[0].config.fields
    };
  }
  throw new Error(`There is not enough information to infer relation "${sourceTableTsName}.${relation.fieldName}"`);
}
function createTableRelationsHelpers(sourceTable) {
  return {
    one: createOne(sourceTable),
    many: createMany(sourceTable)
  };
}
function mapRelationalRow(tablesConfig, tableConfig, row, buildQueryResultSelection, mapColumnValue = (value) => value) {
  const result = {};
  for (const [
    selectionItemIndex,
    selectionItem
  ] of buildQueryResultSelection.entries()) {
    if (selectionItem.isJson) {
      const relation = tableConfig.relations[selectionItem.tsKey];
      const rawSubRows = row[selectionItemIndex];
      const subRows = typeof rawSubRows === "string" ? JSON.parse(rawSubRows) : rawSubRows;
      result[selectionItem.tsKey] = is(relation, One) ? subRows && mapRelationalRow(tablesConfig, tablesConfig[selectionItem.relationTableTsKey], subRows, selectionItem.selection, mapColumnValue) : subRows.map((subRow) => mapRelationalRow(tablesConfig, tablesConfig[selectionItem.relationTableTsKey], subRow, selectionItem.selection, mapColumnValue));
    } else {
      const value = mapColumnValue(row[selectionItemIndex]);
      const field = selectionItem.field;
      let decoder;
      if (is(field, Column)) {
        decoder = field;
      } else if (is(field, SQL)) {
        decoder = field.decoder;
      } else {
        decoder = field.sql.decoder;
      }
      result[selectionItem.tsKey] = value === null ? null : decoder.mapFromDriverValue(value);
    }
  }
  return result;
}

// node_modules/drizzle-orm/alias.js
class ColumnAliasProxyHandler {
  constructor(table) {
    this.table = table;
  }
  static [entityKind] = "ColumnAliasProxyHandler";
  get(columnObj, prop) {
    if (prop === "table") {
      return this.table;
    }
    return columnObj[prop];
  }
}

class TableAliasProxyHandler {
  constructor(alias, replaceOriginalName) {
    this.alias = alias;
    this.replaceOriginalName = replaceOriginalName;
  }
  static [entityKind] = "TableAliasProxyHandler";
  get(target, prop) {
    if (prop === Table.Symbol.IsAlias) {
      return true;
    }
    if (prop === Table.Symbol.Name) {
      return this.alias;
    }
    if (this.replaceOriginalName && prop === Table.Symbol.OriginalName) {
      return this.alias;
    }
    if (prop === ViewBaseConfig) {
      return {
        ...target[ViewBaseConfig],
        name: this.alias,
        isAlias: true
      };
    }
    if (prop === Table.Symbol.Columns) {
      const columns = target[Table.Symbol.Columns];
      if (!columns) {
        return columns;
      }
      const proxiedColumns = {};
      Object.keys(columns).map((key) => {
        proxiedColumns[key] = new Proxy(columns[key], new ColumnAliasProxyHandler(new Proxy(target, this)));
      });
      return proxiedColumns;
    }
    const value = target[prop];
    if (is(value, Column)) {
      return new Proxy(value, new ColumnAliasProxyHandler(new Proxy(target, this)));
    }
    return value;
  }
}
function aliasedTable(table, tableAlias) {
  return new Proxy(table, new TableAliasProxyHandler(tableAlias, false));
}
function aliasedTableColumn(column, tableAlias) {
  return new Proxy(column, new ColumnAliasProxyHandler(new Proxy(column.table, new TableAliasProxyHandler(tableAlias, false))));
}
function mapColumnsInAliasedSQLToAlias(query, alias) {
  return new SQL.Aliased(mapColumnsInSQLToAlias(query.sql, alias), query.fieldAlias);
}
function mapColumnsInSQLToAlias(query, alias) {
  return sql.join(query.queryChunks.map((c) => {
    if (is(c, Column)) {
      return aliasedTableColumn(c, alias);
    }
    if (is(c, SQL)) {
      return mapColumnsInSQLToAlias(c, alias);
    }
    if (is(c, SQL.Aliased)) {
      return mapColumnsInAliasedSQLToAlias(c, alias);
    }
    return c;
  }));
}

// node_modules/drizzle-orm/selection-proxy.js
class SelectionProxyHandler {
  static [entityKind] = "SelectionProxyHandler";
  config;
  constructor(config3) {
    this.config = { ...config3 };
  }
  get(subquery, prop) {
    if (prop === "_") {
      return {
        ...subquery["_"],
        selectedFields: new Proxy(subquery._.selectedFields, this)
      };
    }
    if (prop === ViewBaseConfig) {
      return {
        ...subquery[ViewBaseConfig],
        selectedFields: new Proxy(subquery[ViewBaseConfig].selectedFields, this)
      };
    }
    if (typeof prop === "symbol") {
      return subquery[prop];
    }
    const columns = is(subquery, Subquery) ? subquery._.selectedFields : is(subquery, View) ? subquery[ViewBaseConfig].selectedFields : subquery;
    const value = columns[prop];
    if (is(value, SQL.Aliased)) {
      if (this.config.sqlAliasedBehavior === "sql" && !value.isSelectionField) {
        return value.sql;
      }
      const newValue = value.clone();
      newValue.isSelectionField = true;
      return newValue;
    }
    if (is(value, SQL)) {
      if (this.config.sqlBehavior === "sql") {
        return value;
      }
      throw new Error(`You tried to reference "${prop}" field from a subquery, which is a raw SQL field, but it doesn't have an alias declared. Please add an alias to the field using ".as('alias')" method.`);
    }
    if (is(value, Column)) {
      if (this.config.alias) {
        return new Proxy(value, new ColumnAliasProxyHandler(new Proxy(value.table, new TableAliasProxyHandler(this.config.alias, this.config.replaceOriginalName ?? false))));
      }
      return value;
    }
    if (typeof value !== "object" || value === null) {
      return value;
    }
    return new Proxy(value, new SelectionProxyHandler(this.config));
  }
}

// node_modules/drizzle-orm/query-promise.js
class QueryPromise {
  static [entityKind] = "QueryPromise";
  [Symbol.toStringTag] = "QueryPromise";
  catch(onRejected) {
    return this.then(undefined, onRejected);
  }
  finally(onFinally) {
    return this.then((value) => {
      onFinally?.();
      return value;
    }, (reason) => {
      onFinally?.();
      throw reason;
    });
  }
  then(onFulfilled, onRejected) {
    return this.execute().then(onFulfilled, onRejected);
  }
}

// node_modules/drizzle-orm/sqlite-core/unique-constraint.js
function uniqueKeyName2(table, columns) {
  return `${table[TableName]}_${columns.join("_")}_unique`;
}

// node_modules/drizzle-orm/sqlite-core/columns/common.js
class SQLiteColumn extends Column {
  constructor(table, config3) {
    if (!config3.uniqueName) {
      config3.uniqueName = uniqueKeyName2(table, [config3.name]);
    }
    super(table, config3);
    this.table = table;
  }
  static [entityKind] = "SQLiteColumn";
}

// node_modules/drizzle-orm/sqlite-core/table.js
var InlineForeignKeys2 = Symbol.for("drizzle:SQLiteInlineForeignKeys");

class SQLiteTable extends Table {
  static [entityKind] = "SQLiteTable";
  static Symbol = Object.assign({}, Table.Symbol, {
    InlineForeignKeys: InlineForeignKeys2
  });
  [Table.Symbol.Columns];
  [InlineForeignKeys2] = [];
  [Table.Symbol.ExtraConfigBuilder] = undefined;
}

// node_modules/drizzle-orm/sqlite-core/utils.js
function extractUsedTable(table) {
  if (is(table, SQLiteTable)) {
    return [`${table[Table.Symbol.BaseName]}`];
  }
  if (is(table, Subquery)) {
    return table._.usedTables ?? [];
  }
  if (is(table, SQL)) {
    return table.usedTables ?? [];
  }
  return [];
}

// node_modules/drizzle-orm/sqlite-core/query-builders/delete.js
class SQLiteDeleteBase extends QueryPromise {
  constructor(table, session, dialect, withList) {
    super();
    this.table = table;
    this.session = session;
    this.dialect = dialect;
    this.config = { table, withList };
  }
  static [entityKind] = "SQLiteDelete";
  config;
  where(where) {
    this.config.where = where;
    return this;
  }
  orderBy(...columns) {
    if (typeof columns[0] === "function") {
      const orderBy = columns[0](new Proxy(this.config.table[Table.Symbol.Columns], new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })));
      const orderByArray = Array.isArray(orderBy) ? orderBy : [orderBy];
      this.config.orderBy = orderByArray;
    } else {
      const orderByArray = columns;
      this.config.orderBy = orderByArray;
    }
    return this;
  }
  limit(limit) {
    this.config.limit = limit;
    return this;
  }
  returning(fields = this.table[SQLiteTable.Symbol.Columns]) {
    this.config.returning = orderSelectedFields(fields);
    return this;
  }
  getSQL() {
    return this.dialect.buildDeleteQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  _prepare(isOneTimeQuery = true) {
    return this.session[isOneTimeQuery ? "prepareOneTimeQuery" : "prepareQuery"](this.dialect.sqlToQuery(this.getSQL()), this.config.returning, this.config.returning ? "all" : "run", true, undefined, {
      type: "delete",
      tables: extractUsedTable(this.config.table)
    });
  }
  prepare() {
    return this._prepare(false);
  }
  run = (placeholderValues) => {
    return this._prepare().run(placeholderValues);
  };
  all = (placeholderValues) => {
    return this._prepare().all(placeholderValues);
  };
  get = (placeholderValues) => {
    return this._prepare().get(placeholderValues);
  };
  values = (placeholderValues) => {
    return this._prepare().values(placeholderValues);
  };
  async execute(placeholderValues) {
    return this._prepare().execute(placeholderValues);
  }
  $dynamic() {
    return this;
  }
}

// node_modules/drizzle-orm/casing.js
function toSnakeCase(input) {
  const words = input.replace(/['\u2019]/g, "").match(/[\da-z]+|[A-Z]+(?![a-z])|[A-Z][\da-z]+/g) ?? [];
  return words.map((word) => word.toLowerCase()).join("_");
}
function toCamelCase(input) {
  const words = input.replace(/['\u2019]/g, "").match(/[\da-z]+|[A-Z]+(?![a-z])|[A-Z][\da-z]+/g) ?? [];
  return words.reduce((acc, word, i) => {
    const formattedWord = i === 0 ? word.toLowerCase() : `${word[0].toUpperCase()}${word.slice(1)}`;
    return acc + formattedWord;
  }, "");
}
function noopCase(input) {
  return input;
}

class CasingCache {
  static [entityKind] = "CasingCache";
  cache = {};
  cachedTables = {};
  convert;
  constructor(casing) {
    this.convert = casing === "snake_case" ? toSnakeCase : casing === "camelCase" ? toCamelCase : noopCase;
  }
  getColumnCasing(column) {
    if (!column.keyAsName)
      return column.name;
    const schema = column.table[Table.Symbol.Schema] ?? "public";
    const tableName = column.table[Table.Symbol.OriginalName];
    const key = `${schema}.${tableName}.${column.name}`;
    if (!this.cache[key]) {
      this.cacheTable(column.table);
    }
    return this.cache[key];
  }
  cacheTable(table) {
    const schema = table[Table.Symbol.Schema] ?? "public";
    const tableName = table[Table.Symbol.OriginalName];
    const tableKey = `${schema}.${tableName}`;
    if (!this.cachedTables[tableKey]) {
      for (const column of Object.values(table[Table.Symbol.Columns])) {
        const columnKey = `${tableKey}.${column.name}`;
        this.cache[columnKey] = this.convert(column.name);
      }
      this.cachedTables[tableKey] = true;
    }
  }
  clearCache() {
    this.cache = {};
    this.cachedTables = {};
  }
}

// node_modules/drizzle-orm/errors.js
class DrizzleError extends Error {
  static [entityKind] = "DrizzleError";
  constructor({ message, cause }) {
    super(message);
    this.name = "DrizzleError";
    this.cause = cause;
  }
}

class DrizzleQueryError extends Error {
  constructor(query, params, cause) {
    super(`Failed query: ${query}
params: ${params}`);
    this.query = query;
    this.params = params;
    this.cause = cause;
    Error.captureStackTrace(this, DrizzleQueryError);
    if (cause)
      this.cause = cause;
  }
}

class TransactionRollbackError extends DrizzleError {
  static [entityKind] = "TransactionRollbackError";
  constructor() {
    super({ message: "Rollback" });
  }
}

// node_modules/drizzle-orm/sqlite-core/view-base.js
class SQLiteViewBase extends View {
  static [entityKind] = "SQLiteViewBase";
}

// node_modules/drizzle-orm/sqlite-core/dialect.js
class SQLiteDialect {
  static [entityKind] = "SQLiteDialect";
  casing;
  constructor(config3) {
    this.casing = new CasingCache(config3?.casing);
  }
  escapeName(name) {
    return `"${name}"`;
  }
  escapeParam(_num) {
    return "?";
  }
  escapeString(str2) {
    return `'${str2.replace(/'/g, "''")}'`;
  }
  buildWithCTE(queries) {
    if (!queries?.length)
      return;
    const withSqlChunks = [sql`with `];
    for (const [i, w] of queries.entries()) {
      withSqlChunks.push(sql`${sql.identifier(w._.alias)} as (${w._.sql})`);
      if (i < queries.length - 1) {
        withSqlChunks.push(sql`, `);
      }
    }
    withSqlChunks.push(sql` `);
    return sql.join(withSqlChunks);
  }
  buildDeleteQuery({ table, where, returning, withList, limit, orderBy }) {
    const withSql = this.buildWithCTE(withList);
    const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : undefined;
    const whereSql = where ? sql` where ${where}` : undefined;
    const orderBySql = this.buildOrderBy(orderBy);
    const limitSql = this.buildLimit(limit);
    return sql`${withSql}delete from ${table}${whereSql}${returningSql}${orderBySql}${limitSql}`;
  }
  buildUpdateSet(table, set3) {
    const tableColumns = table[Table.Symbol.Columns];
    const columnNames = Object.keys(tableColumns).filter((colName) => set3[colName] !== undefined || tableColumns[colName]?.onUpdateFn !== undefined);
    const setSize = columnNames.length;
    return sql.join(columnNames.flatMap((colName, i) => {
      const col = tableColumns[colName];
      const onUpdateFnResult = col.onUpdateFn?.();
      const value = set3[colName] ?? (is(onUpdateFnResult, SQL) ? onUpdateFnResult : sql.param(onUpdateFnResult, col));
      const res = sql`${sql.identifier(this.casing.getColumnCasing(col))} = ${value}`;
      if (i < setSize - 1) {
        return [res, sql.raw(", ")];
      }
      return [res];
    }));
  }
  buildUpdateQuery({ table, set: set3, where, returning, withList, joins, from, limit, orderBy }) {
    const withSql = this.buildWithCTE(withList);
    const setSql = this.buildUpdateSet(table, set3);
    const fromSql = from && sql.join([sql.raw(" from "), this.buildFromTable(from)]);
    const joinsSql = this.buildJoins(joins);
    const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : undefined;
    const whereSql = where ? sql` where ${where}` : undefined;
    const orderBySql = this.buildOrderBy(orderBy);
    const limitSql = this.buildLimit(limit);
    return sql`${withSql}update ${table} set ${setSql}${fromSql}${joinsSql}${whereSql}${returningSql}${orderBySql}${limitSql}`;
  }
  buildSelection(fields, { isSingleTable = false } = {}) {
    const columnsLen = fields.length;
    const chunks = fields.flatMap(({ field }, i) => {
      const chunk = [];
      if (is(field, SQL.Aliased) && field.isSelectionField) {
        chunk.push(sql.identifier(field.fieldAlias));
      } else if (is(field, SQL.Aliased) || is(field, SQL)) {
        const query = is(field, SQL.Aliased) ? field.sql : field;
        if (isSingleTable) {
          chunk.push(new SQL(query.queryChunks.map((c) => {
            if (is(c, Column)) {
              return sql.identifier(this.casing.getColumnCasing(c));
            }
            return c;
          })));
        } else {
          chunk.push(query);
        }
        if (is(field, SQL.Aliased)) {
          chunk.push(sql` as ${sql.identifier(field.fieldAlias)}`);
        }
      } else if (is(field, Column)) {
        const tableName = field.table[Table.Symbol.Name];
        if (field.columnType === "SQLiteNumericBigInt") {
          if (isSingleTable) {
            chunk.push(sql`cast(${sql.identifier(this.casing.getColumnCasing(field))} as text)`);
          } else {
            chunk.push(sql`cast(${sql.identifier(tableName)}.${sql.identifier(this.casing.getColumnCasing(field))} as text)`);
          }
        } else {
          if (isSingleTable) {
            chunk.push(sql.identifier(this.casing.getColumnCasing(field)));
          } else {
            chunk.push(sql`${sql.identifier(tableName)}.${sql.identifier(this.casing.getColumnCasing(field))}`);
          }
        }
      } else if (is(field, Subquery)) {
        const entries = Object.entries(field._.selectedFields);
        if (entries.length === 1) {
          const entry = entries[0][1];
          const fieldDecoder = is(entry, SQL) ? entry.decoder : is(entry, Column) ? { mapFromDriverValue: (v) => entry.mapFromDriverValue(v) } : entry.sql.decoder;
          if (fieldDecoder)
            field._.sql.decoder = fieldDecoder;
        }
        chunk.push(field);
      }
      if (i < columnsLen - 1) {
        chunk.push(sql`, `);
      }
      return chunk;
    });
    return sql.join(chunks);
  }
  buildJoins(joins) {
    if (!joins || joins.length === 0) {
      return;
    }
    const joinsArray = [];
    if (joins) {
      for (const [index, joinMeta] of joins.entries()) {
        if (index === 0) {
          joinsArray.push(sql` `);
        }
        const table = joinMeta.table;
        const onSql = joinMeta.on ? sql` on ${joinMeta.on}` : undefined;
        if (is(table, SQLiteTable)) {
          const tableName = table[SQLiteTable.Symbol.Name];
          const tableSchema = table[SQLiteTable.Symbol.Schema];
          const origTableName = table[SQLiteTable.Symbol.OriginalName];
          const alias = tableName === origTableName ? undefined : joinMeta.alias;
          joinsArray.push(sql`${sql.raw(joinMeta.joinType)} join ${tableSchema ? sql`${sql.identifier(tableSchema)}.` : undefined}${sql.identifier(origTableName)}${alias && sql` ${sql.identifier(alias)}`}${onSql}`);
        } else {
          joinsArray.push(sql`${sql.raw(joinMeta.joinType)} join ${table}${onSql}`);
        }
        if (index < joins.length - 1) {
          joinsArray.push(sql` `);
        }
      }
    }
    return sql.join(joinsArray);
  }
  buildLimit(limit) {
    return typeof limit === "object" || typeof limit === "number" && limit >= 0 ? sql` limit ${limit}` : undefined;
  }
  buildOrderBy(orderBy) {
    const orderByList = [];
    if (orderBy) {
      for (const [index, orderByValue] of orderBy.entries()) {
        orderByList.push(orderByValue);
        if (index < orderBy.length - 1) {
          orderByList.push(sql`, `);
        }
      }
    }
    return orderByList.length > 0 ? sql` order by ${sql.join(orderByList)}` : undefined;
  }
  buildFromTable(table) {
    if (is(table, Table) && table[Table.Symbol.IsAlias]) {
      return sql`${sql`${sql.identifier(table[Table.Symbol.Schema] ?? "")}.`.if(table[Table.Symbol.Schema])}${sql.identifier(table[Table.Symbol.OriginalName])} ${sql.identifier(table[Table.Symbol.Name])}`;
    }
    return table;
  }
  buildSelectQuery({
    withList,
    fields,
    fieldsFlat,
    where,
    having,
    table,
    joins,
    orderBy,
    groupBy,
    limit,
    offset,
    distinct,
    setOperators
  }) {
    const fieldsList = fieldsFlat ?? orderSelectedFields(fields);
    for (const f of fieldsList) {
      if (is(f.field, Column) && getTableName(f.field.table) !== (is(table, Subquery) ? table._.alias : is(table, SQLiteViewBase) ? table[ViewBaseConfig].name : is(table, SQL) ? undefined : getTableName(table)) && !((table2) => joins?.some(({ alias }) => alias === (table2[Table.Symbol.IsAlias] ? getTableName(table2) : table2[Table.Symbol.BaseName])))(f.field.table)) {
        const tableName = getTableName(f.field.table);
        throw new Error(`Your "${f.path.join("->")}" field references a column "${tableName}"."${f.field.name}", but the table "${tableName}" is not part of the query! Did you forget to join it?`);
      }
    }
    const isSingleTable = !joins || joins.length === 0;
    const withSql = this.buildWithCTE(withList);
    const distinctSql = distinct ? sql` distinct` : undefined;
    const selection = this.buildSelection(fieldsList, { isSingleTable });
    const tableSql = this.buildFromTable(table);
    const joinsSql = this.buildJoins(joins);
    const whereSql = where ? sql` where ${where}` : undefined;
    const havingSql = having ? sql` having ${having}` : undefined;
    const groupByList = [];
    if (groupBy) {
      for (const [index, groupByValue] of groupBy.entries()) {
        groupByList.push(groupByValue);
        if (index < groupBy.length - 1) {
          groupByList.push(sql`, `);
        }
      }
    }
    const groupBySql = groupByList.length > 0 ? sql` group by ${sql.join(groupByList)}` : undefined;
    const orderBySql = this.buildOrderBy(orderBy);
    const limitSql = this.buildLimit(limit);
    const offsetSql = offset ? sql` offset ${offset}` : undefined;
    const finalQuery = sql`${withSql}select${distinctSql} ${selection} from ${tableSql}${joinsSql}${whereSql}${groupBySql}${havingSql}${orderBySql}${limitSql}${offsetSql}`;
    if (setOperators.length > 0) {
      return this.buildSetOperations(finalQuery, setOperators);
    }
    return finalQuery;
  }
  buildSetOperations(leftSelect, setOperators) {
    const [setOperator, ...rest] = setOperators;
    if (!setOperator) {
      throw new Error("Cannot pass undefined values to any set operator");
    }
    if (rest.length === 0) {
      return this.buildSetOperationQuery({ leftSelect, setOperator });
    }
    return this.buildSetOperations(this.buildSetOperationQuery({ leftSelect, setOperator }), rest);
  }
  buildSetOperationQuery({
    leftSelect,
    setOperator: { type, isAll, rightSelect, limit, orderBy, offset }
  }) {
    const leftChunk = sql`${leftSelect.getSQL()} `;
    const rightChunk = sql`${rightSelect.getSQL()}`;
    let orderBySql;
    if (orderBy && orderBy.length > 0) {
      const orderByValues = [];
      for (const singleOrderBy of orderBy) {
        if (is(singleOrderBy, SQLiteColumn)) {
          orderByValues.push(sql.identifier(singleOrderBy.name));
        } else if (is(singleOrderBy, SQL)) {
          for (let i = 0;i < singleOrderBy.queryChunks.length; i++) {
            const chunk = singleOrderBy.queryChunks[i];
            if (is(chunk, SQLiteColumn)) {
              singleOrderBy.queryChunks[i] = sql.identifier(this.casing.getColumnCasing(chunk));
            }
          }
          orderByValues.push(sql`${singleOrderBy}`);
        } else {
          orderByValues.push(sql`${singleOrderBy}`);
        }
      }
      orderBySql = sql` order by ${sql.join(orderByValues, sql`, `)}`;
    }
    const limitSql = typeof limit === "object" || typeof limit === "number" && limit >= 0 ? sql` limit ${limit}` : undefined;
    const operatorChunk = sql.raw(`${type} ${isAll ? "all " : ""}`);
    const offsetSql = offset ? sql` offset ${offset}` : undefined;
    return sql`${leftChunk}${operatorChunk}${rightChunk}${orderBySql}${limitSql}${offsetSql}`;
  }
  buildInsertQuery({ table, values: valuesOrSelect, onConflict, returning, withList, select }) {
    const valuesSqlList = [];
    const columns = table[Table.Symbol.Columns];
    const colEntries = Object.entries(columns).filter(([_, col]) => !col.shouldDisableInsert());
    const insertOrder = colEntries.map(([, column]) => sql.identifier(this.casing.getColumnCasing(column)));
    if (select) {
      const select2 = valuesOrSelect;
      if (is(select2, SQL)) {
        valuesSqlList.push(select2);
      } else {
        valuesSqlList.push(select2.getSQL());
      }
    } else {
      const values = valuesOrSelect;
      valuesSqlList.push(sql.raw("values "));
      for (const [valueIndex, value] of values.entries()) {
        const valueList = [];
        for (const [fieldName, col] of colEntries) {
          const colValue = value[fieldName];
          if (colValue === undefined || is(colValue, Param) && colValue.value === undefined) {
            let defaultValue;
            if (col.default !== null && col.default !== undefined) {
              defaultValue = is(col.default, SQL) ? col.default : sql.param(col.default, col);
            } else if (col.defaultFn !== undefined) {
              const defaultFnResult = col.defaultFn();
              defaultValue = is(defaultFnResult, SQL) ? defaultFnResult : sql.param(defaultFnResult, col);
            } else if (!col.default && col.onUpdateFn !== undefined) {
              const onUpdateFnResult = col.onUpdateFn();
              defaultValue = is(onUpdateFnResult, SQL) ? onUpdateFnResult : sql.param(onUpdateFnResult, col);
            } else {
              defaultValue = sql`null`;
            }
            valueList.push(defaultValue);
          } else {
            valueList.push(colValue);
          }
        }
        valuesSqlList.push(valueList);
        if (valueIndex < values.length - 1) {
          valuesSqlList.push(sql`, `);
        }
      }
    }
    const withSql = this.buildWithCTE(withList);
    const valuesSql = sql.join(valuesSqlList);
    const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : undefined;
    const onConflictSql = onConflict?.length ? sql.join(onConflict) : undefined;
    return sql`${withSql}insert into ${table} ${insertOrder} ${valuesSql}${onConflictSql}${returningSql}`;
  }
  sqlToQuery(sql2, invokeSource) {
    return sql2.toQuery({
      casing: this.casing,
      escapeName: this.escapeName,
      escapeParam: this.escapeParam,
      escapeString: this.escapeString,
      invokeSource
    });
  }
  buildRelationalQuery({
    fullSchema,
    schema,
    tableNamesMap,
    table,
    tableConfig,
    queryConfig: config3,
    tableAlias,
    nestedQueryRelation,
    joinOn
  }) {
    let selection = [];
    let limit, offset, orderBy = [], where;
    const joins = [];
    if (config3 === true) {
      const selectionEntries = Object.entries(tableConfig.columns);
      selection = selectionEntries.map(([key, value]) => ({
        dbKey: value.name,
        tsKey: key,
        field: aliasedTableColumn(value, tableAlias),
        relationTableTsKey: undefined,
        isJson: false,
        selection: []
      }));
    } else {
      const aliasedColumns = Object.fromEntries(Object.entries(tableConfig.columns).map(([key, value]) => [key, aliasedTableColumn(value, tableAlias)]));
      if (config3.where) {
        const whereSql = typeof config3.where === "function" ? config3.where(aliasedColumns, getOperators()) : config3.where;
        where = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);
      }
      const fieldsSelection = [];
      let selectedColumns = [];
      if (config3.columns) {
        let isIncludeMode = false;
        for (const [field, value] of Object.entries(config3.columns)) {
          if (value === undefined) {
            continue;
          }
          if (field in tableConfig.columns) {
            if (!isIncludeMode && value === true) {
              isIncludeMode = true;
            }
            selectedColumns.push(field);
          }
        }
        if (selectedColumns.length > 0) {
          selectedColumns = isIncludeMode ? selectedColumns.filter((c) => config3.columns?.[c] === true) : Object.keys(tableConfig.columns).filter((key) => !selectedColumns.includes(key));
        }
      } else {
        selectedColumns = Object.keys(tableConfig.columns);
      }
      for (const field of selectedColumns) {
        const column = tableConfig.columns[field];
        fieldsSelection.push({ tsKey: field, value: column });
      }
      let selectedRelations = [];
      if (config3.with) {
        selectedRelations = Object.entries(config3.with).filter((entry) => !!entry[1]).map(([tsKey, queryConfig]) => ({ tsKey, queryConfig, relation: tableConfig.relations[tsKey] }));
      }
      let extras;
      if (config3.extras) {
        extras = typeof config3.extras === "function" ? config3.extras(aliasedColumns, { sql }) : config3.extras;
        for (const [tsKey, value] of Object.entries(extras)) {
          fieldsSelection.push({
            tsKey,
            value: mapColumnsInAliasedSQLToAlias(value, tableAlias)
          });
        }
      }
      for (const { tsKey, value } of fieldsSelection) {
        selection.push({
          dbKey: is(value, SQL.Aliased) ? value.fieldAlias : tableConfig.columns[tsKey].name,
          tsKey,
          field: is(value, Column) ? aliasedTableColumn(value, tableAlias) : value,
          relationTableTsKey: undefined,
          isJson: false,
          selection: []
        });
      }
      let orderByOrig = typeof config3.orderBy === "function" ? config3.orderBy(aliasedColumns, getOrderByOperators()) : config3.orderBy ?? [];
      if (!Array.isArray(orderByOrig)) {
        orderByOrig = [orderByOrig];
      }
      orderBy = orderByOrig.map((orderByValue) => {
        if (is(orderByValue, Column)) {
          return aliasedTableColumn(orderByValue, tableAlias);
        }
        return mapColumnsInSQLToAlias(orderByValue, tableAlias);
      });
      limit = config3.limit;
      offset = config3.offset;
      for (const {
        tsKey: selectedRelationTsKey,
        queryConfig: selectedRelationConfigValue,
        relation
      } of selectedRelations) {
        const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
        const relationTableName = getTableUniqueName(relation.referencedTable);
        const relationTableTsName = tableNamesMap[relationTableName];
        const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
        const joinOn2 = and(...normalizedRelation.fields.map((field2, i) => eq(aliasedTableColumn(normalizedRelation.references[i], relationTableAlias), aliasedTableColumn(field2, tableAlias))));
        const builtRelation = this.buildRelationalQuery({
          fullSchema,
          schema,
          tableNamesMap,
          table: fullSchema[relationTableTsName],
          tableConfig: schema[relationTableTsName],
          queryConfig: is(relation, One) ? selectedRelationConfigValue === true ? { limit: 1 } : { ...selectedRelationConfigValue, limit: 1 } : selectedRelationConfigValue,
          tableAlias: relationTableAlias,
          joinOn: joinOn2,
          nestedQueryRelation: relation
        });
        const field = sql`(${builtRelation.sql})`.as(selectedRelationTsKey);
        selection.push({
          dbKey: selectedRelationTsKey,
          tsKey: selectedRelationTsKey,
          field,
          relationTableTsKey: relationTableTsName,
          isJson: true,
          selection: builtRelation.selection
        });
      }
    }
    if (selection.length === 0) {
      throw new DrizzleError({
        message: `No fields selected for table "${tableConfig.tsName}" ("${tableAlias}"). You need to have at least one item in "columns", "with" or "extras". If you need to select all columns, omit the "columns" key or set it to undefined.`
      });
    }
    let result;
    where = and(joinOn, where);
    if (nestedQueryRelation) {
      let field = sql`json_array(${sql.join(selection.map(({ field: field2 }) => is(field2, SQLiteColumn) ? sql.identifier(this.casing.getColumnCasing(field2)) : is(field2, SQL.Aliased) ? field2.sql : field2), sql`, `)})`;
      if (is(nestedQueryRelation, Many)) {
        field = sql`coalesce(json_group_array(${field}), json_array())`;
      }
      const nestedSelection = [{
        dbKey: "data",
        tsKey: "data",
        field: field.as("data"),
        isJson: true,
        relationTableTsKey: tableConfig.tsName,
        selection
      }];
      const needsSubquery = limit !== undefined || offset !== undefined || orderBy.length > 0;
      if (needsSubquery) {
        result = this.buildSelectQuery({
          table: aliasedTable(table, tableAlias),
          fields: {},
          fieldsFlat: [
            {
              path: [],
              field: sql.raw("*")
            }
          ],
          where,
          limit,
          offset,
          orderBy,
          setOperators: []
        });
        where = undefined;
        limit = undefined;
        offset = undefined;
        orderBy = undefined;
      } else {
        result = aliasedTable(table, tableAlias);
      }
      result = this.buildSelectQuery({
        table: is(result, SQLiteTable) ? result : new Subquery(result, {}, tableAlias),
        fields: {},
        fieldsFlat: nestedSelection.map(({ field: field2 }) => ({
          path: [],
          field: is(field2, Column) ? aliasedTableColumn(field2, tableAlias) : field2
        })),
        joins,
        where,
        limit,
        offset,
        orderBy,
        setOperators: []
      });
    } else {
      result = this.buildSelectQuery({
        table: aliasedTable(table, tableAlias),
        fields: {},
        fieldsFlat: selection.map(({ field }) => ({
          path: [],
          field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field
        })),
        joins,
        where,
        limit,
        offset,
        orderBy,
        setOperators: []
      });
    }
    return {
      tableTsKey: tableConfig.tsName,
      sql: result,
      selection
    };
  }
}

class SQLiteSyncDialect extends SQLiteDialect {
  static [entityKind] = "SQLiteSyncDialect";
  migrate(migrations, session, config3) {
    const migrationsTable = config3 === undefined ? "__drizzle_migrations" : typeof config3 === "string" ? "__drizzle_migrations" : config3.migrationsTable ?? "__drizzle_migrations";
    const migrationTableCreate = sql`
			CREATE TABLE IF NOT EXISTS ${sql.identifier(migrationsTable)} (
				id SERIAL PRIMARY KEY,
				hash text NOT NULL,
				created_at numeric
			)
		`;
    session.run(migrationTableCreate);
    const dbMigrations = session.values(sql`SELECT id, hash, created_at FROM ${sql.identifier(migrationsTable)} ORDER BY created_at DESC LIMIT 1`);
    const lastDbMigration = dbMigrations[0] ?? undefined;
    session.run(sql`BEGIN`);
    try {
      for (const migration of migrations) {
        if (!lastDbMigration || Number(lastDbMigration[2]) < migration.folderMillis) {
          for (const stmt of migration.sql) {
            session.run(sql.raw(stmt));
          }
          session.run(sql`INSERT INTO ${sql.identifier(migrationsTable)} ("hash", "created_at") VALUES(${migration.hash}, ${migration.folderMillis})`);
        }
      }
      session.run(sql`COMMIT`);
    } catch (e) {
      session.run(sql`ROLLBACK`);
      throw e;
    }
  }
}

// node_modules/drizzle-orm/query-builders/query-builder.js
class TypedQueryBuilder {
  static [entityKind] = "TypedQueryBuilder";
  getSelectedFields() {
    return this._.selectedFields;
  }
}

// node_modules/drizzle-orm/sqlite-core/query-builders/select.js
class SQLiteSelectBuilder {
  static [entityKind] = "SQLiteSelectBuilder";
  fields;
  session;
  dialect;
  withList;
  distinct;
  constructor(config3) {
    this.fields = config3.fields;
    this.session = config3.session;
    this.dialect = config3.dialect;
    this.withList = config3.withList;
    this.distinct = config3.distinct;
  }
  from(source) {
    const isPartialSelect = !!this.fields;
    let fields;
    if (this.fields) {
      fields = this.fields;
    } else if (is(source, Subquery)) {
      fields = Object.fromEntries(Object.keys(source._.selectedFields).map((key) => [key, source[key]]));
    } else if (is(source, SQLiteViewBase)) {
      fields = source[ViewBaseConfig].selectedFields;
    } else if (is(source, SQL)) {
      fields = {};
    } else {
      fields = getTableColumns(source);
    }
    return new SQLiteSelectBase({
      table: source,
      fields,
      isPartialSelect,
      session: this.session,
      dialect: this.dialect,
      withList: this.withList,
      distinct: this.distinct
    });
  }
}

class SQLiteSelectQueryBuilderBase extends TypedQueryBuilder {
  static [entityKind] = "SQLiteSelectQueryBuilder";
  _;
  config;
  joinsNotNullableMap;
  tableName;
  isPartialSelect;
  session;
  dialect;
  cacheConfig = undefined;
  usedTables = /* @__PURE__ */ new Set;
  constructor({ table, fields, isPartialSelect, session, dialect, withList, distinct }) {
    super();
    this.config = {
      withList,
      table,
      fields: { ...fields },
      distinct,
      setOperators: []
    };
    this.isPartialSelect = isPartialSelect;
    this.session = session;
    this.dialect = dialect;
    this._ = {
      selectedFields: fields,
      config: this.config
    };
    this.tableName = getTableLikeName(table);
    this.joinsNotNullableMap = typeof this.tableName === "string" ? { [this.tableName]: true } : {};
    for (const item of extractUsedTable(table))
      this.usedTables.add(item);
  }
  getUsedTables() {
    return [...this.usedTables];
  }
  createJoin(joinType) {
    return (table, on) => {
      const baseTableName = this.tableName;
      const tableName = getTableLikeName(table);
      for (const item of extractUsedTable(table))
        this.usedTables.add(item);
      if (typeof tableName === "string" && this.config.joins?.some((join6) => join6.alias === tableName)) {
        throw new Error(`Alias "${tableName}" is already used in this query`);
      }
      if (!this.isPartialSelect) {
        if (Object.keys(this.joinsNotNullableMap).length === 1 && typeof baseTableName === "string") {
          this.config.fields = {
            [baseTableName]: this.config.fields
          };
        }
        if (typeof tableName === "string" && !is(table, SQL)) {
          const selection = is(table, Subquery) ? table._.selectedFields : is(table, View) ? table[ViewBaseConfig].selectedFields : table[Table.Symbol.Columns];
          this.config.fields[tableName] = selection;
        }
      }
      if (typeof on === "function") {
        on = on(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
      }
      if (!this.config.joins) {
        this.config.joins = [];
      }
      this.config.joins.push({ on, table, joinType, alias: tableName });
      if (typeof tableName === "string") {
        switch (joinType) {
          case "left": {
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
          case "right": {
            this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "cross":
          case "inner": {
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "full": {
            this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
        }
      }
      return this;
    };
  }
  leftJoin = this.createJoin("left");
  rightJoin = this.createJoin("right");
  innerJoin = this.createJoin("inner");
  fullJoin = this.createJoin("full");
  crossJoin = this.createJoin("cross");
  createSetOperator(type, isAll) {
    return (rightSelection) => {
      const rightSelect = typeof rightSelection === "function" ? rightSelection(getSQLiteSetOperators()) : rightSelection;
      if (!haveSameKeys(this.getSelectedFields(), rightSelect.getSelectedFields())) {
        throw new Error("Set operator error (union / intersect / except): selected fields are not the same or are in a different order");
      }
      this.config.setOperators.push({ type, isAll, rightSelect });
      return this;
    };
  }
  union = this.createSetOperator("union", false);
  unionAll = this.createSetOperator("union", true);
  intersect = this.createSetOperator("intersect", false);
  except = this.createSetOperator("except", false);
  addSetOperators(setOperators) {
    this.config.setOperators.push(...setOperators);
    return this;
  }
  where(where) {
    if (typeof where === "function") {
      where = where(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
    }
    this.config.where = where;
    return this;
  }
  having(having) {
    if (typeof having === "function") {
      having = having(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
    }
    this.config.having = having;
    return this;
  }
  groupBy(...columns) {
    if (typeof columns[0] === "function") {
      const groupBy = columns[0](new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })));
      this.config.groupBy = Array.isArray(groupBy) ? groupBy : [groupBy];
    } else {
      this.config.groupBy = columns;
    }
    return this;
  }
  orderBy(...columns) {
    if (typeof columns[0] === "function") {
      const orderBy = columns[0](new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })));
      const orderByArray = Array.isArray(orderBy) ? orderBy : [orderBy];
      if (this.config.setOperators.length > 0) {
        this.config.setOperators.at(-1).orderBy = orderByArray;
      } else {
        this.config.orderBy = orderByArray;
      }
    } else {
      const orderByArray = columns;
      if (this.config.setOperators.length > 0) {
        this.config.setOperators.at(-1).orderBy = orderByArray;
      } else {
        this.config.orderBy = orderByArray;
      }
    }
    return this;
  }
  limit(limit) {
    if (this.config.setOperators.length > 0) {
      this.config.setOperators.at(-1).limit = limit;
    } else {
      this.config.limit = limit;
    }
    return this;
  }
  offset(offset) {
    if (this.config.setOperators.length > 0) {
      this.config.setOperators.at(-1).offset = offset;
    } else {
      this.config.offset = offset;
    }
    return this;
  }
  getSQL() {
    return this.dialect.buildSelectQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  as(alias) {
    const usedTables = [];
    usedTables.push(...extractUsedTable(this.config.table));
    if (this.config.joins) {
      for (const it of this.config.joins)
        usedTables.push(...extractUsedTable(it.table));
    }
    return new Proxy(new Subquery(this.getSQL(), this.config.fields, alias, false, [...new Set(usedTables)]), new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
  }
  getSelectedFields() {
    return new Proxy(this.config.fields, new SelectionProxyHandler({ alias: this.tableName, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
  }
  $dynamic() {
    return this;
  }
}

class SQLiteSelectBase extends SQLiteSelectQueryBuilderBase {
  static [entityKind] = "SQLiteSelect";
  _prepare(isOneTimeQuery = true) {
    if (!this.session) {
      throw new Error("Cannot execute a query on a query builder. Please use a database instance instead.");
    }
    const fieldsList = orderSelectedFields(this.config.fields);
    const query = this.session[isOneTimeQuery ? "prepareOneTimeQuery" : "prepareQuery"](this.dialect.sqlToQuery(this.getSQL()), fieldsList, "all", true, undefined, {
      type: "select",
      tables: [...this.usedTables]
    }, this.cacheConfig);
    query.joinsNotNullableMap = this.joinsNotNullableMap;
    return query;
  }
  $withCache(config3) {
    this.cacheConfig = config3 === undefined ? { config: {}, enable: true, autoInvalidate: true } : config3 === false ? { enable: false } : { enable: true, autoInvalidate: true, ...config3 };
    return this;
  }
  prepare() {
    return this._prepare(false);
  }
  run = (placeholderValues) => {
    return this._prepare().run(placeholderValues);
  };
  all = (placeholderValues) => {
    return this._prepare().all(placeholderValues);
  };
  get = (placeholderValues) => {
    return this._prepare().get(placeholderValues);
  };
  values = (placeholderValues) => {
    return this._prepare().values(placeholderValues);
  };
  async execute() {
    return this.all();
  }
}
applyMixins(SQLiteSelectBase, [QueryPromise]);
function createSetOperator(type, isAll) {
  return (leftSelect, rightSelect, ...restSelects) => {
    const setOperators = [rightSelect, ...restSelects].map((select) => ({
      type,
      isAll,
      rightSelect: select
    }));
    for (const setOperator of setOperators) {
      if (!haveSameKeys(leftSelect.getSelectedFields(), setOperator.rightSelect.getSelectedFields())) {
        throw new Error("Set operator error (union / intersect / except): selected fields are not the same or are in a different order");
      }
    }
    return leftSelect.addSetOperators(setOperators);
  };
}
var getSQLiteSetOperators = () => ({
  union: union4,
  unionAll,
  intersect,
  except
});
var union4 = createSetOperator("union", false);
var unionAll = createSetOperator("union", true);
var intersect = createSetOperator("intersect", false);
var except = createSetOperator("except", false);

// node_modules/drizzle-orm/sqlite-core/query-builders/query-builder.js
class QueryBuilder {
  static [entityKind] = "SQLiteQueryBuilder";
  dialect;
  dialectConfig;
  constructor(dialect) {
    this.dialect = is(dialect, SQLiteDialect) ? dialect : undefined;
    this.dialectConfig = is(dialect, SQLiteDialect) ? undefined : dialect;
  }
  $with = (alias, selection) => {
    const queryBuilder = this;
    const as = (qb) => {
      if (typeof qb === "function") {
        qb = qb(queryBuilder);
      }
      return new Proxy(new WithSubquery(qb.getSQL(), selection ?? ("getSelectedFields" in qb ? qb.getSelectedFields() ?? {} : {}), alias, true), new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
    };
    return { as };
  };
  with(...queries) {
    const self2 = this;
    function select(fields) {
      return new SQLiteSelectBuilder({
        fields: fields ?? undefined,
        session: undefined,
        dialect: self2.getDialect(),
        withList: queries
      });
    }
    function selectDistinct(fields) {
      return new SQLiteSelectBuilder({
        fields: fields ?? undefined,
        session: undefined,
        dialect: self2.getDialect(),
        withList: queries,
        distinct: true
      });
    }
    return { select, selectDistinct };
  }
  select(fields) {
    return new SQLiteSelectBuilder({ fields: fields ?? undefined, session: undefined, dialect: this.getDialect() });
  }
  selectDistinct(fields) {
    return new SQLiteSelectBuilder({
      fields: fields ?? undefined,
      session: undefined,
      dialect: this.getDialect(),
      distinct: true
    });
  }
  getDialect() {
    if (!this.dialect) {
      this.dialect = new SQLiteSyncDialect(this.dialectConfig);
    }
    return this.dialect;
  }
}

// node_modules/drizzle-orm/sqlite-core/query-builders/insert.js
class SQLiteInsertBuilder {
  constructor(table, session, dialect, withList) {
    this.table = table;
    this.session = session;
    this.dialect = dialect;
    this.withList = withList;
  }
  static [entityKind] = "SQLiteInsertBuilder";
  values(values) {
    values = Array.isArray(values) ? values : [values];
    if (values.length === 0) {
      throw new Error("values() must be called with at least one value");
    }
    const mappedValues = values.map((entry) => {
      const result = {};
      const cols = this.table[Table.Symbol.Columns];
      for (const colKey of Object.keys(entry)) {
        const colValue = entry[colKey];
        result[colKey] = is(colValue, SQL) ? colValue : new Param(colValue, cols[colKey]);
      }
      return result;
    });
    return new SQLiteInsertBase(this.table, mappedValues, this.session, this.dialect, this.withList);
  }
  select(selectQuery) {
    const select = typeof selectQuery === "function" ? selectQuery(new QueryBuilder) : selectQuery;
    if (!is(select, SQL) && !haveSameKeys(this.table[Columns], select._.selectedFields)) {
      throw new Error("Insert select error: selected fields are not the same or are in a different order compared to the table definition");
    }
    return new SQLiteInsertBase(this.table, select, this.session, this.dialect, this.withList, true);
  }
}

class SQLiteInsertBase extends QueryPromise {
  constructor(table, values, session, dialect, withList, select) {
    super();
    this.session = session;
    this.dialect = dialect;
    this.config = { table, values, withList, select };
  }
  static [entityKind] = "SQLiteInsert";
  config;
  returning(fields = this.config.table[SQLiteTable.Symbol.Columns]) {
    this.config.returning = orderSelectedFields(fields);
    return this;
  }
  onConflictDoNothing(config3 = {}) {
    if (!this.config.onConflict)
      this.config.onConflict = [];
    if (config3.target === undefined) {
      this.config.onConflict.push(sql` on conflict do nothing`);
    } else {
      const targetSql = Array.isArray(config3.target) ? sql`${config3.target}` : sql`${[config3.target]}`;
      const whereSql = config3.where ? sql` where ${config3.where}` : sql``;
      this.config.onConflict.push(sql` on conflict ${targetSql} do nothing${whereSql}`);
    }
    return this;
  }
  onConflictDoUpdate(config3) {
    if (config3.where && (config3.targetWhere || config3.setWhere)) {
      throw new Error('You cannot use both "where" and "targetWhere"/"setWhere" at the same time - "where" is deprecated, use "targetWhere" or "setWhere" instead.');
    }
    if (!this.config.onConflict)
      this.config.onConflict = [];
    const whereSql = config3.where ? sql` where ${config3.where}` : undefined;
    const targetWhereSql = config3.targetWhere ? sql` where ${config3.targetWhere}` : undefined;
    const setWhereSql = config3.setWhere ? sql` where ${config3.setWhere}` : undefined;
    const targetSql = Array.isArray(config3.target) ? sql`${config3.target}` : sql`${[config3.target]}`;
    const setSql = this.dialect.buildUpdateSet(this.config.table, mapUpdateSet(this.config.table, config3.set));
    this.config.onConflict.push(sql` on conflict ${targetSql}${targetWhereSql} do update set ${setSql}${whereSql}${setWhereSql}`);
    return this;
  }
  getSQL() {
    return this.dialect.buildInsertQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  _prepare(isOneTimeQuery = true) {
    return this.session[isOneTimeQuery ? "prepareOneTimeQuery" : "prepareQuery"](this.dialect.sqlToQuery(this.getSQL()), this.config.returning, this.config.returning ? "all" : "run", true, undefined, {
      type: "insert",
      tables: extractUsedTable(this.config.table)
    });
  }
  prepare() {
    return this._prepare(false);
  }
  run = (placeholderValues) => {
    return this._prepare().run(placeholderValues);
  };
  all = (placeholderValues) => {
    return this._prepare().all(placeholderValues);
  };
  get = (placeholderValues) => {
    return this._prepare().get(placeholderValues);
  };
  values = (placeholderValues) => {
    return this._prepare().values(placeholderValues);
  };
  async execute() {
    return this.config.returning ? this.all() : this.run();
  }
  $dynamic() {
    return this;
  }
}

// node_modules/drizzle-orm/sqlite-core/query-builders/update.js
class SQLiteUpdateBuilder {
  constructor(table, session, dialect, withList) {
    this.table = table;
    this.session = session;
    this.dialect = dialect;
    this.withList = withList;
  }
  static [entityKind] = "SQLiteUpdateBuilder";
  set(values) {
    return new SQLiteUpdateBase(this.table, mapUpdateSet(this.table, values), this.session, this.dialect, this.withList);
  }
}

class SQLiteUpdateBase extends QueryPromise {
  constructor(table, set3, session, dialect, withList) {
    super();
    this.session = session;
    this.dialect = dialect;
    this.config = { set: set3, table, withList, joins: [] };
  }
  static [entityKind] = "SQLiteUpdate";
  config;
  from(source) {
    this.config.from = source;
    return this;
  }
  createJoin(joinType) {
    return (table, on) => {
      const tableName = getTableLikeName(table);
      if (typeof tableName === "string" && this.config.joins.some((join6) => join6.alias === tableName)) {
        throw new Error(`Alias "${tableName}" is already used in this query`);
      }
      if (typeof on === "function") {
        const from = this.config.from ? is(table, SQLiteTable) ? table[Table.Symbol.Columns] : is(table, Subquery) ? table._.selectedFields : is(table, SQLiteViewBase) ? table[ViewBaseConfig].selectedFields : undefined : undefined;
        on = on(new Proxy(this.config.table[Table.Symbol.Columns], new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })), from && new Proxy(from, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
      }
      this.config.joins.push({ on, table, joinType, alias: tableName });
      return this;
    };
  }
  leftJoin = this.createJoin("left");
  rightJoin = this.createJoin("right");
  innerJoin = this.createJoin("inner");
  fullJoin = this.createJoin("full");
  where(where) {
    this.config.where = where;
    return this;
  }
  orderBy(...columns) {
    if (typeof columns[0] === "function") {
      const orderBy = columns[0](new Proxy(this.config.table[Table.Symbol.Columns], new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })));
      const orderByArray = Array.isArray(orderBy) ? orderBy : [orderBy];
      this.config.orderBy = orderByArray;
    } else {
      const orderByArray = columns;
      this.config.orderBy = orderByArray;
    }
    return this;
  }
  limit(limit) {
    this.config.limit = limit;
    return this;
  }
  returning(fields = this.config.table[SQLiteTable.Symbol.Columns]) {
    this.config.returning = orderSelectedFields(fields);
    return this;
  }
  getSQL() {
    return this.dialect.buildUpdateQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  _prepare(isOneTimeQuery = true) {
    return this.session[isOneTimeQuery ? "prepareOneTimeQuery" : "prepareQuery"](this.dialect.sqlToQuery(this.getSQL()), this.config.returning, this.config.returning ? "all" : "run", true, undefined, {
      type: "insert",
      tables: extractUsedTable(this.config.table)
    });
  }
  prepare() {
    return this._prepare(false);
  }
  run = (placeholderValues) => {
    return this._prepare().run(placeholderValues);
  };
  all = (placeholderValues) => {
    return this._prepare().all(placeholderValues);
  };
  get = (placeholderValues) => {
    return this._prepare().get(placeholderValues);
  };
  values = (placeholderValues) => {
    return this._prepare().values(placeholderValues);
  };
  async execute() {
    return this.config.returning ? this.all() : this.run();
  }
  $dynamic() {
    return this;
  }
}

// node_modules/drizzle-orm/sqlite-core/query-builders/count.js
class SQLiteCountBuilder extends SQL {
  constructor(params) {
    super(SQLiteCountBuilder.buildEmbeddedCount(params.source, params.filters).queryChunks);
    this.params = params;
    this.session = params.session;
    this.sql = SQLiteCountBuilder.buildCount(params.source, params.filters);
  }
  sql;
  static [entityKind] = "SQLiteCountBuilderAsync";
  [Symbol.toStringTag] = "SQLiteCountBuilderAsync";
  session;
  static buildEmbeddedCount(source, filters) {
    return sql`(select count(*) from ${source}${sql.raw(" where ").if(filters)}${filters})`;
  }
  static buildCount(source, filters) {
    return sql`select count(*) from ${source}${sql.raw(" where ").if(filters)}${filters}`;
  }
  then(onfulfilled, onrejected) {
    return Promise.resolve(this.session.count(this.sql)).then(onfulfilled, onrejected);
  }
  catch(onRejected) {
    return this.then(undefined, onRejected);
  }
  finally(onFinally) {
    return this.then((value) => {
      onFinally?.();
      return value;
    }, (reason) => {
      onFinally?.();
      throw reason;
    });
  }
}

// node_modules/drizzle-orm/sqlite-core/query-builders/query.js
class RelationalQueryBuilder {
  constructor(mode, fullSchema, schema, tableNamesMap, table, tableConfig, dialect, session) {
    this.mode = mode;
    this.fullSchema = fullSchema;
    this.schema = schema;
    this.tableNamesMap = tableNamesMap;
    this.table = table;
    this.tableConfig = tableConfig;
    this.dialect = dialect;
    this.session = session;
  }
  static [entityKind] = "SQLiteAsyncRelationalQueryBuilder";
  findMany(config3) {
    return this.mode === "sync" ? new SQLiteSyncRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config3 ? config3 : {}, "many") : new SQLiteRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config3 ? config3 : {}, "many");
  }
  findFirst(config3) {
    return this.mode === "sync" ? new SQLiteSyncRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config3 ? { ...config3, limit: 1 } : { limit: 1 }, "first") : new SQLiteRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config3 ? { ...config3, limit: 1 } : { limit: 1 }, "first");
  }
}

class SQLiteRelationalQuery extends QueryPromise {
  constructor(fullSchema, schema, tableNamesMap, table, tableConfig, dialect, session, config3, mode) {
    super();
    this.fullSchema = fullSchema;
    this.schema = schema;
    this.tableNamesMap = tableNamesMap;
    this.table = table;
    this.tableConfig = tableConfig;
    this.dialect = dialect;
    this.session = session;
    this.config = config3;
    this.mode = mode;
  }
  static [entityKind] = "SQLiteAsyncRelationalQuery";
  mode;
  getSQL() {
    return this.dialect.buildRelationalQuery({
      fullSchema: this.fullSchema,
      schema: this.schema,
      tableNamesMap: this.tableNamesMap,
      table: this.table,
      tableConfig: this.tableConfig,
      queryConfig: this.config,
      tableAlias: this.tableConfig.tsName
    }).sql;
  }
  _prepare(isOneTimeQuery = false) {
    const { query, builtQuery } = this._toSQL();
    return this.session[isOneTimeQuery ? "prepareOneTimeQuery" : "prepareQuery"](builtQuery, undefined, this.mode === "first" ? "get" : "all", true, (rawRows, mapColumnValue) => {
      const rows = rawRows.map((row) => mapRelationalRow(this.schema, this.tableConfig, row, query.selection, mapColumnValue));
      if (this.mode === "first") {
        return rows[0];
      }
      return rows;
    });
  }
  prepare() {
    return this._prepare(false);
  }
  _toSQL() {
    const query = this.dialect.buildRelationalQuery({
      fullSchema: this.fullSchema,
      schema: this.schema,
      tableNamesMap: this.tableNamesMap,
      table: this.table,
      tableConfig: this.tableConfig,
      queryConfig: this.config,
      tableAlias: this.tableConfig.tsName
    });
    const builtQuery = this.dialect.sqlToQuery(query.sql);
    return { query, builtQuery };
  }
  toSQL() {
    return this._toSQL().builtQuery;
  }
  executeRaw() {
    if (this.mode === "first") {
      return this._prepare(false).get();
    }
    return this._prepare(false).all();
  }
  async execute() {
    return this.executeRaw();
  }
}

class SQLiteSyncRelationalQuery extends SQLiteRelationalQuery {
  static [entityKind] = "SQLiteSyncRelationalQuery";
  sync() {
    return this.executeRaw();
  }
}

// node_modules/drizzle-orm/sqlite-core/query-builders/raw.js
class SQLiteRaw extends QueryPromise {
  constructor(execute, getSQL, action, dialect, mapBatchResult) {
    super();
    this.execute = execute;
    this.getSQL = getSQL;
    this.dialect = dialect;
    this.mapBatchResult = mapBatchResult;
    this.config = { action };
  }
  static [entityKind] = "SQLiteRaw";
  config;
  getQuery() {
    return { ...this.dialect.sqlToQuery(this.getSQL()), method: this.config.action };
  }
  mapResult(result, isFromBatch) {
    return isFromBatch ? this.mapBatchResult(result) : result;
  }
  _prepare() {
    return this;
  }
  isResponseInArrayMode() {
    return false;
  }
}

// node_modules/drizzle-orm/sqlite-core/db.js
class BaseSQLiteDatabase {
  constructor(resultKind, dialect, session, schema) {
    this.resultKind = resultKind;
    this.dialect = dialect;
    this.session = session;
    this._ = schema ? {
      schema: schema.schema,
      fullSchema: schema.fullSchema,
      tableNamesMap: schema.tableNamesMap
    } : {
      schema: undefined,
      fullSchema: {},
      tableNamesMap: {}
    };
    this.query = {};
    const query = this.query;
    if (this._.schema) {
      for (const [tableName, columns] of Object.entries(this._.schema)) {
        query[tableName] = new RelationalQueryBuilder(resultKind, schema.fullSchema, this._.schema, this._.tableNamesMap, schema.fullSchema[tableName], columns, dialect, session);
      }
    }
    this.$cache = { invalidate: async (_params) => {} };
  }
  static [entityKind] = "BaseSQLiteDatabase";
  query;
  $with = (alias, selection) => {
    const self2 = this;
    const as = (qb) => {
      if (typeof qb === "function") {
        qb = qb(new QueryBuilder(self2.dialect));
      }
      return new Proxy(new WithSubquery(qb.getSQL(), selection ?? ("getSelectedFields" in qb ? qb.getSelectedFields() ?? {} : {}), alias, true), new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
    };
    return { as };
  };
  $count(source, filters) {
    return new SQLiteCountBuilder({ source, filters, session: this.session });
  }
  with(...queries) {
    const self2 = this;
    function select(fields) {
      return new SQLiteSelectBuilder({
        fields: fields ?? undefined,
        session: self2.session,
        dialect: self2.dialect,
        withList: queries
      });
    }
    function selectDistinct(fields) {
      return new SQLiteSelectBuilder({
        fields: fields ?? undefined,
        session: self2.session,
        dialect: self2.dialect,
        withList: queries,
        distinct: true
      });
    }
    function update(table) {
      return new SQLiteUpdateBuilder(table, self2.session, self2.dialect, queries);
    }
    function insert(into) {
      return new SQLiteInsertBuilder(into, self2.session, self2.dialect, queries);
    }
    function delete_(from) {
      return new SQLiteDeleteBase(from, self2.session, self2.dialect, queries);
    }
    return { select, selectDistinct, update, insert, delete: delete_ };
  }
  select(fields) {
    return new SQLiteSelectBuilder({ fields: fields ?? undefined, session: this.session, dialect: this.dialect });
  }
  selectDistinct(fields) {
    return new SQLiteSelectBuilder({
      fields: fields ?? undefined,
      session: this.session,
      dialect: this.dialect,
      distinct: true
    });
  }
  update(table) {
    return new SQLiteUpdateBuilder(table, this.session, this.dialect);
  }
  $cache;
  insert(into) {
    return new SQLiteInsertBuilder(into, this.session, this.dialect);
  }
  delete(from) {
    return new SQLiteDeleteBase(from, this.session, this.dialect);
  }
  run(query) {
    const sequel = typeof query === "string" ? sql.raw(query) : query.getSQL();
    if (this.resultKind === "async") {
      return new SQLiteRaw(async () => this.session.run(sequel), () => sequel, "run", this.dialect, this.session.extractRawRunValueFromBatchResult.bind(this.session));
    }
    return this.session.run(sequel);
  }
  all(query) {
    const sequel = typeof query === "string" ? sql.raw(query) : query.getSQL();
    if (this.resultKind === "async") {
      return new SQLiteRaw(async () => this.session.all(sequel), () => sequel, "all", this.dialect, this.session.extractRawAllValueFromBatchResult.bind(this.session));
    }
    return this.session.all(sequel);
  }
  get(query) {
    const sequel = typeof query === "string" ? sql.raw(query) : query.getSQL();
    if (this.resultKind === "async") {
      return new SQLiteRaw(async () => this.session.get(sequel), () => sequel, "get", this.dialect, this.session.extractRawGetValueFromBatchResult.bind(this.session));
    }
    return this.session.get(sequel);
  }
  values(query) {
    const sequel = typeof query === "string" ? sql.raw(query) : query.getSQL();
    if (this.resultKind === "async") {
      return new SQLiteRaw(async () => this.session.values(sequel), () => sequel, "values", this.dialect, this.session.extractRawValuesValueFromBatchResult.bind(this.session));
    }
    return this.session.values(sequel);
  }
  transaction(transaction, config3) {
    return this.session.transaction(transaction, config3);
  }
}

// node_modules/drizzle-orm/cache/core/cache.js
class Cache {
  static [entityKind] = "Cache";
}

class NoopCache extends Cache {
  strategy() {
    return "all";
  }
  static [entityKind] = "NoopCache";
  async get(_key) {
    return;
  }
  async put(_hashedQuery, _response, _tables, _config) {}
  async onMutate(_params) {}
}
async function hashQuery(sql2, params) {
  const dataToHash = `${sql2}-${JSON.stringify(params)}`;
  const encoder = new TextEncoder;
  const data = encoder.encode(dataToHash);
  const hashBuffer = await crypto.subtle.digest("SHA-256", data);
  const hashArray = [...new Uint8Array(hashBuffer)];
  const hashHex = hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
  return hashHex;
}

// node_modules/drizzle-orm/sqlite-core/session.js
class ExecuteResultSync extends QueryPromise {
  constructor(resultCb) {
    super();
    this.resultCb = resultCb;
  }
  static [entityKind] = "ExecuteResultSync";
  async execute() {
    return this.resultCb();
  }
  sync() {
    return this.resultCb();
  }
}

class SQLitePreparedQuery {
  constructor(mode, executeMethod, query, cache, queryMetadata, cacheConfig) {
    this.mode = mode;
    this.executeMethod = executeMethod;
    this.query = query;
    this.cache = cache;
    this.queryMetadata = queryMetadata;
    this.cacheConfig = cacheConfig;
    if (cache && cache.strategy() === "all" && cacheConfig === undefined) {
      this.cacheConfig = { enable: true, autoInvalidate: true };
    }
    if (!this.cacheConfig?.enable) {
      this.cacheConfig = undefined;
    }
  }
  static [entityKind] = "PreparedQuery";
  joinsNotNullableMap;
  async queryWithCache(queryString, params, query) {
    if (this.cache === undefined || is(this.cache, NoopCache) || this.queryMetadata === undefined) {
      try {
        return await query();
      } catch (e) {
        throw new DrizzleQueryError(queryString, params, e);
      }
    }
    if (this.cacheConfig && !this.cacheConfig.enable) {
      try {
        return await query();
      } catch (e) {
        throw new DrizzleQueryError(queryString, params, e);
      }
    }
    if ((this.queryMetadata.type === "insert" || this.queryMetadata.type === "update" || this.queryMetadata.type === "delete") && this.queryMetadata.tables.length > 0) {
      try {
        const [res] = await Promise.all([
          query(),
          this.cache.onMutate({ tables: this.queryMetadata.tables })
        ]);
        return res;
      } catch (e) {
        throw new DrizzleQueryError(queryString, params, e);
      }
    }
    if (!this.cacheConfig) {
      try {
        return await query();
      } catch (e) {
        throw new DrizzleQueryError(queryString, params, e);
      }
    }
    if (this.queryMetadata.type === "select") {
      const fromCache = await this.cache.get(this.cacheConfig.tag ?? await hashQuery(queryString, params), this.queryMetadata.tables, this.cacheConfig.tag !== undefined, this.cacheConfig.autoInvalidate);
      if (fromCache === undefined) {
        let result;
        try {
          result = await query();
        } catch (e) {
          throw new DrizzleQueryError(queryString, params, e);
        }
        await this.cache.put(this.cacheConfig.tag ?? await hashQuery(queryString, params), result, this.cacheConfig.autoInvalidate ? this.queryMetadata.tables : [], this.cacheConfig.tag !== undefined, this.cacheConfig.config);
        return result;
      }
      return fromCache;
    }
    try {
      return await query();
    } catch (e) {
      throw new DrizzleQueryError(queryString, params, e);
    }
  }
  getQuery() {
    return this.query;
  }
  mapRunResult(result, _isFromBatch) {
    return result;
  }
  mapAllResult(_result, _isFromBatch) {
    throw new Error("Not implemented");
  }
  mapGetResult(_result, _isFromBatch) {
    throw new Error("Not implemented");
  }
  execute(placeholderValues) {
    if (this.mode === "async") {
      return this[this.executeMethod](placeholderValues);
    }
    return new ExecuteResultSync(() => this[this.executeMethod](placeholderValues));
  }
  mapResult(response, isFromBatch) {
    switch (this.executeMethod) {
      case "run": {
        return this.mapRunResult(response, isFromBatch);
      }
      case "all": {
        return this.mapAllResult(response, isFromBatch);
      }
      case "get": {
        return this.mapGetResult(response, isFromBatch);
      }
    }
  }
}

class SQLiteSession {
  constructor(dialect) {
    this.dialect = dialect;
  }
  static [entityKind] = "SQLiteSession";
  prepareOneTimeQuery(query, fields, executeMethod, isResponseInArrayMode, customResultMapper, queryMetadata, cacheConfig) {
    return this.prepareQuery(query, fields, executeMethod, isResponseInArrayMode, customResultMapper, queryMetadata, cacheConfig);
  }
  run(query) {
    const staticQuery = this.dialect.sqlToQuery(query);
    try {
      return this.prepareOneTimeQuery(staticQuery, undefined, "run", false).run();
    } catch (err) {
      throw new DrizzleError({ cause: err, message: `Failed to run the query '${staticQuery.sql}'` });
    }
  }
  extractRawRunValueFromBatchResult(result) {
    return result;
  }
  all(query) {
    return this.prepareOneTimeQuery(this.dialect.sqlToQuery(query), undefined, "run", false).all();
  }
  extractRawAllValueFromBatchResult(_result) {
    throw new Error("Not implemented");
  }
  get(query) {
    return this.prepareOneTimeQuery(this.dialect.sqlToQuery(query), undefined, "run", false).get();
  }
  extractRawGetValueFromBatchResult(_result) {
    throw new Error("Not implemented");
  }
  values(query) {
    return this.prepareOneTimeQuery(this.dialect.sqlToQuery(query), undefined, "run", false).values();
  }
  async count(sql2) {
    const result = await this.values(sql2);
    return result[0][0];
  }
  extractRawValuesValueFromBatchResult(_result) {
    throw new Error("Not implemented");
  }
}

class SQLiteTransaction extends BaseSQLiteDatabase {
  constructor(resultType, dialect, session, schema, nestedIndex = 0) {
    super(resultType, dialect, session, schema);
    this.schema = schema;
    this.nestedIndex = nestedIndex;
  }
  static [entityKind] = "SQLiteTransaction";
  rollback() {
    throw new TransactionRollbackError;
  }
}

// node_modules/drizzle-orm/bun-sqlite/session.js
class SQLiteBunSession extends SQLiteSession {
  constructor(client, dialect, schema, options2 = {}) {
    super(dialect);
    this.client = client;
    this.schema = schema;
    this.logger = options2.logger ?? new NoopLogger;
  }
  static [entityKind] = "SQLiteBunSession";
  logger;
  exec(query) {
    this.client.exec(query);
  }
  prepareQuery(query, fields, executeMethod, isResponseInArrayMode, customResultMapper) {
    const stmt = this.client.prepare(query.sql);
    return new PreparedQuery(stmt, query, this.logger, fields, executeMethod, isResponseInArrayMode, customResultMapper);
  }
  transaction(transaction, config3 = {}) {
    const tx = new SQLiteBunTransaction("sync", this.dialect, this, this.schema);
    let result;
    const nativeTx = this.client.transaction(() => {
      result = transaction(tx);
    });
    nativeTx[config3.behavior ?? "deferred"]();
    return result;
  }
}

class SQLiteBunTransaction extends SQLiteTransaction {
  static [entityKind] = "SQLiteBunTransaction";
  transaction(transaction) {
    const savepointName = `sp${this.nestedIndex}`;
    const tx = new SQLiteBunTransaction("sync", this.dialect, this.session, this.schema, this.nestedIndex + 1);
    this.session.run(sql.raw(`savepoint ${savepointName}`));
    try {
      const result = transaction(tx);
      this.session.run(sql.raw(`release savepoint ${savepointName}`));
      return result;
    } catch (err) {
      this.session.run(sql.raw(`rollback to savepoint ${savepointName}`));
      throw err;
    }
  }
}

class PreparedQuery extends SQLitePreparedQuery {
  constructor(stmt, query, logger, fields, executeMethod, _isResponseInArrayMode, customResultMapper) {
    super("sync", executeMethod, query);
    this.stmt = stmt;
    this.logger = logger;
    this.fields = fields;
    this._isResponseInArrayMode = _isResponseInArrayMode;
    this.customResultMapper = customResultMapper;
  }
  static [entityKind] = "SQLiteBunPreparedQuery";
  run(placeholderValues) {
    const params = fillPlaceholders(this.query.params, placeholderValues ?? {});
    this.logger.logQuery(this.query.sql, params);
    return this.stmt.run(...params);
  }
  all(placeholderValues) {
    const { fields, query, logger, joinsNotNullableMap, stmt, customResultMapper } = this;
    if (!fields && !customResultMapper) {
      const params = fillPlaceholders(query.params, placeholderValues ?? {});
      logger.logQuery(query.sql, params);
      return stmt.all(...params);
    }
    const rows = this.values(placeholderValues);
    if (customResultMapper) {
      return customResultMapper(rows);
    }
    return rows.map((row) => mapResultRow(fields, row, joinsNotNullableMap));
  }
  get(placeholderValues) {
    const params = fillPlaceholders(this.query.params, placeholderValues ?? {});
    this.logger.logQuery(this.query.sql, params);
    const row = this.stmt.values(...params)[0];
    if (!row) {
      return;
    }
    const { fields, joinsNotNullableMap, customResultMapper } = this;
    if (!fields && !customResultMapper) {
      return row;
    }
    if (customResultMapper) {
      return customResultMapper([row]);
    }
    return mapResultRow(fields, row, joinsNotNullableMap);
  }
  values(placeholderValues) {
    const params = fillPlaceholders(this.query.params, placeholderValues ?? {});
    this.logger.logQuery(this.query.sql, params);
    return this.stmt.values(...params);
  }
  isResponseInArrayMode() {
    return this._isResponseInArrayMode;
  }
}

// node_modules/drizzle-orm/bun-sqlite/driver.js
class BunSQLiteDatabase extends BaseSQLiteDatabase {
  static [entityKind] = "BunSQLiteDatabase";
}
function construct(client, config3 = {}) {
  const dialect = new SQLiteSyncDialect({ casing: config3.casing });
  let logger;
  if (config3.logger === true) {
    logger = new DefaultLogger;
  } else if (config3.logger !== false) {
    logger = config3.logger;
  }
  let schema;
  if (config3.schema) {
    const tablesConfig = extractTablesRelationalConfig(config3.schema, createTableRelationsHelpers);
    schema = {
      fullSchema: config3.schema,
      schema: tablesConfig.tables,
      tableNamesMap: tablesConfig.tableNamesMap
    };
  }
  const session = new SQLiteBunSession(client, dialect, schema, { logger });
  const db = new BunSQLiteDatabase("sync", dialect, session, schema);
  db.$client = client;
  return db;
}
function drizzle(...params) {
  if (params[0] === undefined || typeof params[0] === "string") {
    const instance = params[0] === undefined ? new Database : new Database(params[0]);
    return construct(instance, params[1]);
  }
  if (isConfig(params[0])) {
    const { connection, client, ...drizzleConfig } = params[0];
    if (client)
      return construct(client, drizzleConfig);
    if (typeof connection === "object") {
      const { source, ...opts } = connection;
      const options2 = Object.values(opts).filter((v) => v !== undefined).length ? opts : undefined;
      const instance2 = new Database(source, options2);
      return construct(instance2, drizzleConfig);
    }
    const instance = new Database(connection);
    return construct(instance, drizzleConfig);
  }
  return construct(params[0], params[1]);
}
((drizzle2) => {
  function mock(config3) {
    return construct({}, config3);
  }
  drizzle2.mock = mock;
})(drizzle || (drizzle = {}));

// node_modules/drizzle-orm/migrator.js
import crypto2 from "crypto";
import fs2 from "fs";
function readMigrationFiles(config3) {
  const migrationFolderTo = config3.migrationsFolder;
  const migrationQueries = [];
  const journalPath = `${migrationFolderTo}/meta/_journal.json`;
  if (!fs2.existsSync(journalPath)) {
    throw new Error(`Can't find meta/_journal.json file`);
  }
  const journalAsString = fs2.readFileSync(`${migrationFolderTo}/meta/_journal.json`).toString();
  const journal = JSON.parse(journalAsString);
  for (const journalEntry of journal.entries) {
    const migrationPath = `${migrationFolderTo}/${journalEntry.tag}.sql`;
    try {
      const query = fs2.readFileSync(`${migrationFolderTo}/${journalEntry.tag}.sql`).toString();
      const result = query.split("--> statement-breakpoint").map((it) => {
        return it;
      });
      migrationQueries.push({
        sql: result,
        bps: journalEntry.breakpoints,
        folderMillis: journalEntry.when,
        hash: crypto2.createHash("sha256").update(query).digest("hex")
      });
    } catch {
      throw new Error(`No file ${migrationPath} found in ${migrationFolderTo} folder`);
    }
  }
  return migrationQueries;
}

// node_modules/drizzle-orm/bun-sqlite/migrator.js
function migrate(db, config3) {
  const migrations = readMigrationFiles(config3);
  db.dialect.migrate(migrations, db.session, config3);
}

// src/resonance/DatabaseFactory.ts
import { Database as Database2 } from "bun:sqlite";
var DatabaseFactory = {
  connectToResonance(dbPath, options2 = {}) {
    return DatabaseFactory.connect(dbPath, options2);
  },
  connect(path2, options2 = {}) {
    const finalOptions = {
      create: options2.readonly ? undefined : true,
      ...options2
    };
    const db = new Database2(path2, finalOptions);
    db.run("PRAGMA busy_timeout = 5000;");
    const currentMode = db.query("PRAGMA journal_mode;").get();
    if (currentMode?.journal_mode !== "wal") {
      db.run("PRAGMA journal_mode = WAL;");
    }
    db.run("PRAGMA synchronous = NORMAL;");
    db.run("PRAGMA mmap_size = 0;");
    db.run("PRAGMA temp_store = memory;");
    db.run("PRAGMA foreign_keys = ON;");
    return db;
  },
  performHealthCheck(db) {
    const journal = db.query("PRAGMA journal_mode;").get();
    const mmap = db.query("PRAGMA mmap_size;").get();
    const busy = db.query("PRAGMA busy_timeout;").get();
    if (journal.journal_mode !== "wal")
      console.warn("\u26A0\uFE0F HealthWarning: WAL mode not active.");
    if (mmap.mmap_size !== 0)
      console.warn("\u26A0\uFE0F HealthWarning: mmap should be 0 for stability.");
    if (busy.timeout < 5000)
      console.warn("\u26A0\uFE0F HealthWarning: busy_timeout < 5000ms.");
    try {
      db.run("CREATE TABLE IF NOT EXISTS _health (id INTEGER PRIMARY KEY, ts TEXT)");
      db.run("INSERT INTO _health (ts) VALUES (datetime('now'))");
      db.run("DELETE FROM _health WHERE id NOT IN (SELECT id FROM _health ORDER BY id DESC LIMIT 10)");
      return { status: "Healthy", mode: journal.journal_mode };
    } catch (e) {
      console.error("\u274C HealthCheck Failed:", e);
      throw e;
    }
  }
};

// src/resonance/db.ts
var log2 = getLogger("ResonanceDB");

class ResonanceDB {
  db;
  static init(dbPath) {
    const config3 = loadSettings();
    const path2 = dbPath ?? config3.database;
    return new ResonanceDB(path2);
  }
  constructor(dbPath) {
    if (!existsSync5(dbPath)) {
      throw new Error(`Database not found at: ${dbPath}
` + `Please ensure the database file exists or check the 'database' setting in amalfa.settings.json
` + `Canonical location: .amalfa/resonance.db`);
    }
    try {
      this.db = DatabaseFactory.connect(dbPath, { readonly: false });
    } catch (error49) {
      throw new Error(`Failed to open database at: ${dbPath}
` + `Error: ${error49}
` + `Please check the 'database' setting in amalfa.settings.json`);
    }
    this.migrate();
  }
  migrate() {
    try {
      const drizzleDb = drizzle(this.db);
      migrate(drizzleDb, {
        migrationsFolder: "src/resonance/drizzle/migrations"
      });
      log2.info("\uD83D\uDCE6 ResonanceDB: Drizzle migrations applied");
    } catch (error49) {
      log2.error({ error: error49 }, "Migration failed");
      throw new Error(`Database migration failed: ${error49}`);
    }
  }
  insertNode(node) {
    const stmt = this.db.prepare(`
            INSERT OR REPLACE INTO nodes (id, type, title, domain, layer, embedding, hash, meta, date)
            VALUES ($id, $type, $title, $domain, $layer, $embedding, $hash, $meta, $date)
        `);
    try {
      const blob = node.embedding ? new Uint8Array(node.embedding.buffer, node.embedding.byteOffset, node.embedding.byteLength) : null;
      stmt.run({
        $id: String(node.id),
        $type: String(node.type),
        $title: node.label ? String(node.label) : null,
        $domain: String(node.domain || "knowledge"),
        $layer: String(node.layer || "experience"),
        $embedding: blob,
        $hash: node.hash ? String(node.hash) : null,
        $meta: node.meta ? JSON.stringify(node.meta) : null,
        $date: node.date ? String(node.date) : null
      });
      this.logHistory("upsert", "node", node.id, undefined, node);
    } catch (err) {
      log2.error({
        err,
        id: node.id,
        blobSize: node.embedding ? node.embedding.byteLength : 0,
        blobType: node.embedding ? node.embedding instanceof Float32Array ? "F32" : "Other" : "Null"
      }, "\u274C Failed to insert node");
      throw err;
    }
  }
  getRawDb() {
    return this.db;
  }
  insertEdge(source, target, type = "related_to") {
    this.db.run(`
            INSERT OR IGNORE INTO edges (source, target, type)
            VALUES (?, ?, ?)
        `, [source, target, type]);
    this.logHistory("insert", "edge", `${source}-${target}-${type}`, undefined, {
      source,
      target,
      type
    });
  }
  insertSemanticEdge(source, target, type, confidence = 1, veracity = 1, contextSource) {
    this.db.run(`
            INSERT INTO edges (source, target, type, confidence, veracity, context_source)
            VALUES (?, ?, ?, ?, ?, ?)
            ON CONFLICT(source, target, type) DO UPDATE SET
                confidence = excluded.confidence,
                veracity = excluded.veracity,
                context_source = excluded.context_source
        `, [source, target, type, confidence, veracity, contextSource ?? null]);
  }
  getNodes(options2 = {}) {
    const cols = options2.excludeContent ? "id, type, title, domain, layer, hash, meta" : "*";
    let sql2 = `SELECT ${cols} FROM nodes WHERE 1=1`;
    const params = [];
    if (options2.domain) {
      sql2 += " AND domain = ?";
      params.push(options2.domain);
    }
    if (options2.type) {
      sql2 += " AND type = ?";
      params.push(options2.type);
    }
    if (options2.limit) {
      sql2 += " LIMIT ?";
      params.push(options2.limit);
    }
    if (options2.offset) {
      sql2 += " OFFSET ?";
      params.push(options2.offset);
    }
    const rows = this.db.query(sql2).all(...params);
    return rows.map((row) => this.mapRowToNode(row));
  }
  updateNodeDate(id, date8) {
    this.db.run("UPDATE nodes SET date = ? WHERE id = ?", [date8, id]);
  }
  getLexicon() {
    const _sql = "SELECT id, title, meta, content FROM nodes WHERE domain = 'lexicon' AND type = 'concept'";
    const rows = this.db.query("SELECT id, title, meta, content FROM nodes WHERE domain = 'lexicon' AND type = 'concept'").all();
    return rows.map((row) => {
      const meta3 = row.meta ? JSON.parse(row.meta) : {};
      return {
        id: row.id,
        label: row.title,
        aliases: meta3.aliases || [],
        definition: row.content,
        ...meta3
      };
    });
  }
  mapRowToNode(row) {
    return {
      id: row.id,
      type: row.type,
      label: row.title,
      domain: row.domain,
      layer: row.layer,
      summary: row.summary,
      embedding: row.embedding ? new Float32Array(row.embedding.buffer, row.embedding.byteOffset, row.embedding.byteLength / 4) : undefined,
      hash: row.hash,
      meta: row.meta ? JSON.parse(row.meta) : {},
      date: row.date
    };
  }
  getNodeHash(id) {
    const row = this.db.prepare("SELECT hash FROM nodes WHERE id = ?").get(id);
    return row ? row.hash : null;
  }
  getStats() {
    const nodesCount = this.db.query("SELECT COUNT(*) as c FROM nodes").get().c;
    const edgesCount = this.db.query("SELECT COUNT(*) as c FROM edges").get().c;
    const vectorsCount = this.db.query("SELECT COUNT(*) as c FROM nodes WHERE embedding IS NOT NULL").get().c;
    const semanticTokensCount = this.db.query("SELECT COUNT(*) as c FROM nodes WHERE meta LIKE '%semantic_tokens%'").get().c;
    return {
      nodes: nodesCount,
      edges: edgesCount,
      vectors: vectorsCount,
      semantic_tokens: semanticTokensCount,
      db_size_bytes: this.db.query("PRAGMA page_count").get().page_count * this.db.query("PRAGMA page_size").get().page_size
    };
  }
  getNodesByType(type) {
    return this.getNodes({ type });
  }
  beginTransaction() {
    this.db.run("BEGIN TRANSACTION");
  }
  commit() {
    this.db.run("COMMIT");
  }
  rollback() {
    this.db.run("ROLLBACK");
  }
  close() {
    this.db.close();
  }
  checkpoint() {
    this.db.run("PRAGMA wal_checkpoint(TRUNCATE);");
  }
  getNode(id) {
    const row = this.db.query("SELECT * FROM nodes WHERE id = ?").get(id);
    if (!row)
      return null;
    return this.mapRowToNode(row);
  }
  generateId(input) {
    const withoutRelativePrefix = input.replace(/^\.*\//, "");
    const withoutExtension = withoutRelativePrefix.replace(/\.(md|ts|js|json)$/, "");
    const lowercased = withoutExtension.toLowerCase();
    const alphanumericWithSlashes = lowercased.replace(/[^a-z0-9/]/g, "-");
    const slashesToDashes = alphanumericWithSlashes.replace(/\/+/g, "-");
    const collapsedDashes = slashesToDashes.replace(/-+/g, "-");
    const trimmed = collapsedDashes.replace(/^-|-$/g, "");
    return trimmed;
  }
  updateNodeMeta(id, meta3) {
    const oldMeta = this.getNode(id)?.meta;
    this.db.run("UPDATE nodes SET meta = ? WHERE id = ?", [
      JSON.stringify(meta3),
      id
    ]);
    this.logHistory("update", "node", id, oldMeta, meta3);
  }
  logHistory(action, type, id, oldValue, newValue) {
    try {
      this.db.run(`INSERT INTO history (entity_type, entity_id, action, old_value, new_value) VALUES (?, ?, ?, ?, ?)`, [
        type,
        id,
        action,
        oldValue ? JSON.stringify(oldValue) : null,
        newValue ? JSON.stringify(newValue) : null
      ]);
    } catch (_e) {}
  }
}
function toFafcas(vector) {
  let sum = 0;
  for (let i = 0;i < vector.length; i++) {
    const val = vector[i] || 0;
    sum += val * val;
  }
  const magnitude = Math.sqrt(sum);
  if (magnitude > 0.000001) {
    for (let i = 0;i < vector.length; i++) {
      const val = vector[i] || 0;
      vector[i] = val / magnitude;
    }
  }
  return new Uint8Array(vector.buffer, vector.byteOffset, vector.byteLength);
}

// src/cli/commands/explore.ts
async function cmdExplore(args) {
  const nodeId = args.find((arg) => !arg.startsWith("--"));
  let relationType;
  const relationEqIdx = args.findIndex((arg) => arg.startsWith("--relation="));
  const relationSpaceIdx = args.indexOf("--relation");
  if (relationEqIdx !== -1) {
    relationType = args[relationEqIdx]?.split("=")[1];
  } else if (relationSpaceIdx !== -1 && args[relationSpaceIdx + 1]) {
    relationType = args[relationSpaceIdx + 1];
  }
  const jsonOutput = args.includes("--json");
  if (!nodeId) {
    if (jsonOutput) {
      console.error(JSON.stringify({
        error: "Missing node ID argument",
        usage: "amalfa explore <node-id> [--relation type] [--json]"
      }));
    } else {
      console.error("\u274C Error: Missing node ID argument");
      console.error(`
Usage: amalfa explore <node-id> [--relation type] [--json]`);
      console.error(`
Examples:`);
      console.error("  amalfa explore docs/README.md");
      console.error('  amalfa explore "brief-auth" --relation references');
      console.error("  amalfa explore docs/README.md --json");
      console.error(`
\uD83D\uDCA1 Tip: Get node IDs from 'amalfa search' results`);
    }
    process.exit(1);
  }
  if (!await checkDatabase()) {
    if (jsonOutput) {
      console.error(JSON.stringify({
        error: "Database not found",
        suggestion: "Run 'amalfa init' first"
      }));
    } else {
      console.error("\u274C Database not found. Run 'amalfa init' first.");
    }
    process.exit(1);
  }
  const dbPath = await getDbPath();
  const db = new ResonanceDB(dbPath);
  try {
    const allEdges = db.getRawDb().query("SELECT target, type FROM edges WHERE source = ?").all(nodeId);
    if (!allEdges || allEdges.length === 0) {
      if (jsonOutput) {
        console.log(JSON.stringify([]));
      } else {
        console.log(`
\uD83D\uDD17 No outgoing links found for: ${nodeId}
`);
        console.log("This node either:");
        console.log("  - Has no explicit links to other documents");
        console.log("  - Doesn't exist in the graph");
        console.log(`
\uD83D\uDCA1 Tip: Use 'amalfa read' to verify the node exists`);
      }
      process.exit(0);
    }
    const edges = relationType ? allEdges.filter((e) => e.type === relationType) : allEdges;
    if (jsonOutput) {
      console.log(JSON.stringify(edges, null, 2));
    } else {
      if (edges.length === 0 && relationType) {
        console.log(`
\uD83D\uDD17 No links of type "${relationType}" found for: ${nodeId}
`);
        console.log("Available relation types:");
        const types = new Set(allEdges.map((e) => e.type));
        for (const type of types) {
          console.log(`  - ${type}`);
        }
        console.log();
      } else {
        const title = relationType ? `Links (${relationType})` : "All Links";
        console.log(`
\uD83D\uDD17 ${title} from: ${nodeId}
`);
        const byType = new Map;
        for (const edge of edges) {
          const e = edge;
          if (!byType.has(e.type)) {
            byType.set(e.type, []);
          }
          byType.get(e.type)?.push(e);
        }
        for (const [type, typeEdges] of byType) {
          console.log(`${type.toUpperCase()}:`);
          for (const edge of typeEdges) {
            console.log(`  \u2192 ${edge.target}`);
          }
          console.log();
        }
        console.log(`\uD83D\uDCA1 Tip: Use 'amalfa read <target>' to view linked documents
`);
      }
    }
  } catch (error49) {
    if (jsonOutput) {
      console.error(JSON.stringify({
        error: error49 instanceof Error ? error49.message : String(error49),
        node_id: nodeId
      }));
    } else {
      console.error("\u274C Explore failed:", error49 instanceof Error ? error49.message : error49);
    }
    process.exit(1);
  } finally {
    db.close();
  }
}

// src/cli/commands/find-gaps.ts
import { Database as Database3 } from "bun:sqlite";
import { mkdirSync as mkdirSync2, writeFileSync } from "fs";
import { join as join6 } from "path";
async function findGaps(options2) {
  const dbPath = await getDbPath();
  const db = new Database3(dbPath);
  const gapsQuery = db.prepare(`
    WITH similar_pairs AS (
      SELECT
        n1.id as source_id,
        n2.id as target_id,
        n1.title as source_title,
        n2.title as target_title,
        (
          SELECT COUNT(*) FROM nodes n3
          WHERE n3.domain = n1.domain
          AND (n3.embedding <=> n1.embedding) > ?
        ) as similarity_count
      FROM nodes n1
      JOIN nodes n2 ON n1.id < n2.id
      WHERE n1.domain = n2.domain
      AND n1.id NOT IN (SELECT source FROM edges WHERE target = n2.id)
      AND n2.id NOT IN (SELECT source FROM edges WHERE target = n1.id)
      ORDER BY similarity_count DESC
      LIMIT ?
    )
    SELECT * FROM similar_pairs
  `);
  const threshold = options2.threshold ?? 0.8;
  const limit = options2.limit ?? 10;
  const gaps = gapsQuery.all(threshold, limit);
  console.log(`
\uD83D\uDD0D Found ${gaps.length} potential gaps:
`);
  if (gaps.length === 0) {
    console.log("  No gaps found above threshold.");
    db.close();
    return;
  }
  for (let i = 0;i < gaps.length; i++) {
    const gap = gaps[i];
    console.log(`${i + 1}. ${gap.source_id} \u2194 ${gap.target_id}`);
    console.log(`   Similarity: ${gap.similarity?.toFixed(3) || "N/A"}`);
    if (gap.reason) {
      console.log(`   Reason: ${gap.reason}`);
    }
    if (gap.suggested_link_type) {
      console.log(`   Suggested: ${gap.suggested_link_type}`);
    }
    console.log();
  }
  const exportPath = join6(dbPath, "..", "gaps.json");
  const exportDir = join6(dbPath, "..");
  mkdirSync2(exportDir, { recursive: true });
  writeFileSync(exportPath, JSON.stringify(gaps, null, 2));
  console.log(`\uD83D\uDCC1 Gaps exported to: ${exportPath}`);
  db.close();
}
async function cmdFindGaps(args) {
  const options2 = {
    limit: Number(args.find((a) => a.startsWith("--limit="))?.split("=")[1]) ?? 10,
    threshold: Number(args.find((a) => a.startsWith("--threshold="))?.split("=")[1]) ?? 0.8
  };
  await findGaps(options2);
}
if (false) {}

// src/cli/commands/harvest.ts
import { readFileSync as readFileSync4, statSync as statSync2 } from "fs";
import { readdir, writeFile } from "fs/promises";
import { join as join9 } from "path";

// src/services/LangExtractClient.ts
import { existsSync as existsSync7 } from "fs";
import { join as join8, resolve } from "path";

// node_modules/@modelcontextprotocol/sdk/dist/esm/client/index.js
init_protocol();
init_types();
init_ajv_provider();
init_zod_compat();

// node_modules/@modelcontextprotocol/sdk/dist/esm/experimental/tasks/client.js
init_types();

class ExperimentalClientTasks {
  constructor(_client) {
    this._client = _client;
  }
  async* callToolStream(params, resultSchema = CallToolResultSchema, options2) {
    const clientInternal = this._client;
    const optionsWithTask = {
      ...options2,
      task: options2?.task ?? (clientInternal.isToolTask(params.name) ? {} : undefined)
    };
    const stream = clientInternal.requestStream({ method: "tools/call", params }, resultSchema, optionsWithTask);
    const validator = clientInternal.getToolOutputValidator(params.name);
    for await (const message of stream) {
      if (message.type === "result" && validator) {
        const result = message.result;
        if (!result.structuredContent && !result.isError) {
          yield {
            type: "error",
            error: new McpError(ErrorCode.InvalidRequest, `Tool ${params.name} has an output schema but did not return structured content`)
          };
          return;
        }
        if (result.structuredContent) {
          try {
            const validationResult = validator(result.structuredContent);
            if (!validationResult.valid) {
              yield {
                type: "error",
                error: new McpError(ErrorCode.InvalidParams, `Structured content does not match the tool's output schema: ${validationResult.errorMessage}`)
              };
              return;
            }
          } catch (error49) {
            if (error49 instanceof McpError) {
              yield { type: "error", error: error49 };
              return;
            }
            yield {
              type: "error",
              error: new McpError(ErrorCode.InvalidParams, `Failed to validate structured content: ${error49 instanceof Error ? error49.message : String(error49)}`)
            };
            return;
          }
        }
      }
      yield message;
    }
  }
  async getTask(taskId, options2) {
    return this._client.getTask({ taskId }, options2);
  }
  async getTaskResult(taskId, resultSchema, options2) {
    return this._client.getTaskResult({ taskId }, resultSchema, options2);
  }
  async listTasks(cursor, options2) {
    return this._client.listTasks(cursor ? { cursor } : undefined, options2);
  }
  async cancelTask(taskId, options2) {
    return this._client.cancelTask({ taskId }, options2);
  }
  requestStream(request, resultSchema, options2) {
    return this._client.requestStream(request, resultSchema, options2);
  }
}

// node_modules/@modelcontextprotocol/sdk/dist/esm/client/index.js
function applyElicitationDefaults(schema, data) {
  if (!schema || data === null || typeof data !== "object")
    return;
  if (schema.type === "object" && schema.properties && typeof schema.properties === "object") {
    const obj = data;
    const props = schema.properties;
    for (const key of Object.keys(props)) {
      const propSchema = props[key];
      if (obj[key] === undefined && Object.prototype.hasOwnProperty.call(propSchema, "default")) {
        obj[key] = propSchema.default;
      }
      if (obj[key] !== undefined) {
        applyElicitationDefaults(propSchema, obj[key]);
      }
    }
  }
  if (Array.isArray(schema.anyOf)) {
    for (const sub of schema.anyOf) {
      if (typeof sub !== "boolean") {
        applyElicitationDefaults(sub, data);
      }
    }
  }
  if (Array.isArray(schema.oneOf)) {
    for (const sub of schema.oneOf) {
      if (typeof sub !== "boolean") {
        applyElicitationDefaults(sub, data);
      }
    }
  }
}
function getSupportedElicitationModes(capabilities) {
  if (!capabilities) {
    return { supportsFormMode: false, supportsUrlMode: false };
  }
  const hasFormCapability = capabilities.form !== undefined;
  const hasUrlCapability = capabilities.url !== undefined;
  const supportsFormMode = hasFormCapability || !hasFormCapability && !hasUrlCapability;
  const supportsUrlMode = hasUrlCapability;
  return { supportsFormMode, supportsUrlMode };
}

class Client extends Protocol {
  constructor(_clientInfo, options2) {
    super(options2);
    this._clientInfo = _clientInfo;
    this._cachedToolOutputValidators = new Map;
    this._cachedKnownTaskTools = new Set;
    this._cachedRequiredTaskTools = new Set;
    this._listChangedDebounceTimers = new Map;
    this._capabilities = options2?.capabilities ?? {};
    this._jsonSchemaValidator = options2?.jsonSchemaValidator ?? new AjvJsonSchemaValidator;
    if (options2?.listChanged) {
      this._pendingListChangedConfig = options2.listChanged;
    }
  }
  _setupListChangedHandlers(config3) {
    if (config3.tools && this._serverCapabilities?.tools?.listChanged) {
      this._setupListChangedHandler("tools", ToolListChangedNotificationSchema, config3.tools, async () => {
        const result = await this.listTools();
        return result.tools;
      });
    }
    if (config3.prompts && this._serverCapabilities?.prompts?.listChanged) {
      this._setupListChangedHandler("prompts", PromptListChangedNotificationSchema, config3.prompts, async () => {
        const result = await this.listPrompts();
        return result.prompts;
      });
    }
    if (config3.resources && this._serverCapabilities?.resources?.listChanged) {
      this._setupListChangedHandler("resources", ResourceListChangedNotificationSchema, config3.resources, async () => {
        const result = await this.listResources();
        return result.resources;
      });
    }
  }
  get experimental() {
    if (!this._experimental) {
      this._experimental = {
        tasks: new ExperimentalClientTasks(this)
      };
    }
    return this._experimental;
  }
  registerCapabilities(capabilities) {
    if (this.transport) {
      throw new Error("Cannot register capabilities after connecting to transport");
    }
    this._capabilities = mergeCapabilities(this._capabilities, capabilities);
  }
  setRequestHandler(requestSchema, handler) {
    const shape = getObjectShape(requestSchema);
    const methodSchema = shape?.method;
    if (!methodSchema) {
      throw new Error("Schema is missing a method literal");
    }
    let methodValue;
    if (isZ4Schema(methodSchema)) {
      const v4Schema = methodSchema;
      const v4Def = v4Schema._zod?.def;
      methodValue = v4Def?.value ?? v4Schema.value;
    } else {
      const v3Schema = methodSchema;
      const legacyDef = v3Schema._def;
      methodValue = legacyDef?.value ?? v3Schema.value;
    }
    if (typeof methodValue !== "string") {
      throw new Error("Schema method literal must be a string");
    }
    const method = methodValue;
    if (method === "elicitation/create") {
      const wrappedHandler = async (request, extra) => {
        const validatedRequest = safeParse4(ElicitRequestSchema, request);
        if (!validatedRequest.success) {
          const errorMessage = validatedRequest.error instanceof Error ? validatedRequest.error.message : String(validatedRequest.error);
          throw new McpError(ErrorCode.InvalidParams, `Invalid elicitation request: ${errorMessage}`);
        }
        const { params } = validatedRequest.data;
        params.mode = params.mode ?? "form";
        const { supportsFormMode, supportsUrlMode } = getSupportedElicitationModes(this._capabilities.elicitation);
        if (params.mode === "form" && !supportsFormMode) {
          throw new McpError(ErrorCode.InvalidParams, "Client does not support form-mode elicitation requests");
        }
        if (params.mode === "url" && !supportsUrlMode) {
          throw new McpError(ErrorCode.InvalidParams, "Client does not support URL-mode elicitation requests");
        }
        const result = await Promise.resolve(handler(request, extra));
        if (params.task) {
          const taskValidationResult = safeParse4(CreateTaskResultSchema, result);
          if (!taskValidationResult.success) {
            const errorMessage = taskValidationResult.error instanceof Error ? taskValidationResult.error.message : String(taskValidationResult.error);
            throw new McpError(ErrorCode.InvalidParams, `Invalid task creation result: ${errorMessage}`);
          }
          return taskValidationResult.data;
        }
        const validationResult = safeParse4(ElicitResultSchema, result);
        if (!validationResult.success) {
          const errorMessage = validationResult.error instanceof Error ? validationResult.error.message : String(validationResult.error);
          throw new McpError(ErrorCode.InvalidParams, `Invalid elicitation result: ${errorMessage}`);
        }
        const validatedResult = validationResult.data;
        const requestedSchema = params.mode === "form" ? params.requestedSchema : undefined;
        if (params.mode === "form" && validatedResult.action === "accept" && validatedResult.content && requestedSchema) {
          if (this._capabilities.elicitation?.form?.applyDefaults) {
            try {
              applyElicitationDefaults(requestedSchema, validatedResult.content);
            } catch {}
          }
        }
        return validatedResult;
      };
      return super.setRequestHandler(requestSchema, wrappedHandler);
    }
    if (method === "sampling/createMessage") {
      const wrappedHandler = async (request, extra) => {
        const validatedRequest = safeParse4(CreateMessageRequestSchema, request);
        if (!validatedRequest.success) {
          const errorMessage = validatedRequest.error instanceof Error ? validatedRequest.error.message : String(validatedRequest.error);
          throw new McpError(ErrorCode.InvalidParams, `Invalid sampling request: ${errorMessage}`);
        }
        const { params } = validatedRequest.data;
        const result = await Promise.resolve(handler(request, extra));
        if (params.task) {
          const taskValidationResult = safeParse4(CreateTaskResultSchema, result);
          if (!taskValidationResult.success) {
            const errorMessage = taskValidationResult.error instanceof Error ? taskValidationResult.error.message : String(taskValidationResult.error);
            throw new McpError(ErrorCode.InvalidParams, `Invalid task creation result: ${errorMessage}`);
          }
          return taskValidationResult.data;
        }
        const validationResult = safeParse4(CreateMessageResultSchema, result);
        if (!validationResult.success) {
          const errorMessage = validationResult.error instanceof Error ? validationResult.error.message : String(validationResult.error);
          throw new McpError(ErrorCode.InvalidParams, `Invalid sampling result: ${errorMessage}`);
        }
        return validationResult.data;
      };
      return super.setRequestHandler(requestSchema, wrappedHandler);
    }
    return super.setRequestHandler(requestSchema, handler);
  }
  assertCapability(capability, method) {
    if (!this._serverCapabilities?.[capability]) {
      throw new Error(`Server does not support ${capability} (required for ${method})`);
    }
  }
  async connect(transport, options2) {
    await super.connect(transport);
    if (transport.sessionId !== undefined) {
      return;
    }
    try {
      const result = await this.request({
        method: "initialize",
        params: {
          protocolVersion: LATEST_PROTOCOL_VERSION,
          capabilities: this._capabilities,
          clientInfo: this._clientInfo
        }
      }, InitializeResultSchema, options2);
      if (result === undefined) {
        throw new Error(`Server sent invalid initialize result: ${result}`);
      }
      if (!SUPPORTED_PROTOCOL_VERSIONS.includes(result.protocolVersion)) {
        throw new Error(`Server's protocol version is not supported: ${result.protocolVersion}`);
      }
      this._serverCapabilities = result.capabilities;
      this._serverVersion = result.serverInfo;
      if (transport.setProtocolVersion) {
        transport.setProtocolVersion(result.protocolVersion);
      }
      this._instructions = result.instructions;
      await this.notification({
        method: "notifications/initialized"
      });
      if (this._pendingListChangedConfig) {
        this._setupListChangedHandlers(this._pendingListChangedConfig);
        this._pendingListChangedConfig = undefined;
      }
    } catch (error49) {
      this.close();
      throw error49;
    }
  }
  getServerCapabilities() {
    return this._serverCapabilities;
  }
  getServerVersion() {
    return this._serverVersion;
  }
  getInstructions() {
    return this._instructions;
  }
  assertCapabilityForMethod(method) {
    switch (method) {
      case "logging/setLevel":
        if (!this._serverCapabilities?.logging) {
          throw new Error(`Server does not support logging (required for ${method})`);
        }
        break;
      case "prompts/get":
      case "prompts/list":
        if (!this._serverCapabilities?.prompts) {
          throw new Error(`Server does not support prompts (required for ${method})`);
        }
        break;
      case "resources/list":
      case "resources/templates/list":
      case "resources/read":
      case "resources/subscribe":
      case "resources/unsubscribe":
        if (!this._serverCapabilities?.resources) {
          throw new Error(`Server does not support resources (required for ${method})`);
        }
        if (method === "resources/subscribe" && !this._serverCapabilities.resources.subscribe) {
          throw new Error(`Server does not support resource subscriptions (required for ${method})`);
        }
        break;
      case "tools/call":
      case "tools/list":
        if (!this._serverCapabilities?.tools) {
          throw new Error(`Server does not support tools (required for ${method})`);
        }
        break;
      case "completion/complete":
        if (!this._serverCapabilities?.completions) {
          throw new Error(`Server does not support completions (required for ${method})`);
        }
        break;
      case "initialize":
        break;
      case "ping":
        break;
    }
  }
  assertNotificationCapability(method) {
    switch (method) {
      case "notifications/roots/list_changed":
        if (!this._capabilities.roots?.listChanged) {
          throw new Error(`Client does not support roots list changed notifications (required for ${method})`);
        }
        break;
      case "notifications/initialized":
        break;
      case "notifications/cancelled":
        break;
      case "notifications/progress":
        break;
    }
  }
  assertRequestHandlerCapability(method) {
    if (!this._capabilities) {
      return;
    }
    switch (method) {
      case "sampling/createMessage":
        if (!this._capabilities.sampling) {
          throw new Error(`Client does not support sampling capability (required for ${method})`);
        }
        break;
      case "elicitation/create":
        if (!this._capabilities.elicitation) {
          throw new Error(`Client does not support elicitation capability (required for ${method})`);
        }
        break;
      case "roots/list":
        if (!this._capabilities.roots) {
          throw new Error(`Client does not support roots capability (required for ${method})`);
        }
        break;
      case "tasks/get":
      case "tasks/list":
      case "tasks/result":
      case "tasks/cancel":
        if (!this._capabilities.tasks) {
          throw new Error(`Client does not support tasks capability (required for ${method})`);
        }
        break;
      case "ping":
        break;
    }
  }
  assertTaskCapability(method) {
    assertToolsCallTaskCapability(this._serverCapabilities?.tasks?.requests, method, "Server");
  }
  assertTaskHandlerCapability(method) {
    if (!this._capabilities) {
      return;
    }
    assertClientRequestTaskCapability(this._capabilities.tasks?.requests, method, "Client");
  }
  async ping(options2) {
    return this.request({ method: "ping" }, EmptyResultSchema, options2);
  }
  async complete(params, options2) {
    return this.request({ method: "completion/complete", params }, CompleteResultSchema, options2);
  }
  async setLoggingLevel(level, options2) {
    return this.request({ method: "logging/setLevel", params: { level } }, EmptyResultSchema, options2);
  }
  async getPrompt(params, options2) {
    return this.request({ method: "prompts/get", params }, GetPromptResultSchema, options2);
  }
  async listPrompts(params, options2) {
    return this.request({ method: "prompts/list", params }, ListPromptsResultSchema, options2);
  }
  async listResources(params, options2) {
    return this.request({ method: "resources/list", params }, ListResourcesResultSchema, options2);
  }
  async listResourceTemplates(params, options2) {
    return this.request({ method: "resources/templates/list", params }, ListResourceTemplatesResultSchema, options2);
  }
  async readResource(params, options2) {
    return this.request({ method: "resources/read", params }, ReadResourceResultSchema, options2);
  }
  async subscribeResource(params, options2) {
    return this.request({ method: "resources/subscribe", params }, EmptyResultSchema, options2);
  }
  async unsubscribeResource(params, options2) {
    return this.request({ method: "resources/unsubscribe", params }, EmptyResultSchema, options2);
  }
  async callTool(params, resultSchema = CallToolResultSchema, options2) {
    if (this.isToolTaskRequired(params.name)) {
      throw new McpError(ErrorCode.InvalidRequest, `Tool "${params.name}" requires task-based execution. Use client.experimental.tasks.callToolStream() instead.`);
    }
    const result = await this.request({ method: "tools/call", params }, resultSchema, options2);
    const validator = this.getToolOutputValidator(params.name);
    if (validator) {
      if (!result.structuredContent && !result.isError) {
        throw new McpError(ErrorCode.InvalidRequest, `Tool ${params.name} has an output schema but did not return structured content`);
      }
      if (result.structuredContent) {
        try {
          const validationResult = validator(result.structuredContent);
          if (!validationResult.valid) {
            throw new McpError(ErrorCode.InvalidParams, `Structured content does not match the tool's output schema: ${validationResult.errorMessage}`);
          }
        } catch (error49) {
          if (error49 instanceof McpError) {
            throw error49;
          }
          throw new McpError(ErrorCode.InvalidParams, `Failed to validate structured content: ${error49 instanceof Error ? error49.message : String(error49)}`);
        }
      }
    }
    return result;
  }
  isToolTask(toolName) {
    if (!this._serverCapabilities?.tasks?.requests?.tools?.call) {
      return false;
    }
    return this._cachedKnownTaskTools.has(toolName);
  }
  isToolTaskRequired(toolName) {
    return this._cachedRequiredTaskTools.has(toolName);
  }
  cacheToolMetadata(tools) {
    this._cachedToolOutputValidators.clear();
    this._cachedKnownTaskTools.clear();
    this._cachedRequiredTaskTools.clear();
    for (const tool of tools) {
      if (tool.outputSchema) {
        const toolValidator = this._jsonSchemaValidator.getValidator(tool.outputSchema);
        this._cachedToolOutputValidators.set(tool.name, toolValidator);
      }
      const taskSupport = tool.execution?.taskSupport;
      if (taskSupport === "required" || taskSupport === "optional") {
        this._cachedKnownTaskTools.add(tool.name);
      }
      if (taskSupport === "required") {
        this._cachedRequiredTaskTools.add(tool.name);
      }
    }
  }
  getToolOutputValidator(toolName) {
    return this._cachedToolOutputValidators.get(toolName);
  }
  async listTools(params, options2) {
    const result = await this.request({ method: "tools/list", params }, ListToolsResultSchema, options2);
    this.cacheToolMetadata(result.tools);
    return result;
  }
  _setupListChangedHandler(listType, notificationSchema, options2, fetcher) {
    const parseResult = ListChangedOptionsBaseSchema.safeParse(options2);
    if (!parseResult.success) {
      throw new Error(`Invalid ${listType} listChanged options: ${parseResult.error.message}`);
    }
    if (typeof options2.onChanged !== "function") {
      throw new Error(`Invalid ${listType} listChanged options: onChanged must be a function`);
    }
    const { autoRefresh, debounceMs } = parseResult.data;
    const { onChanged } = options2;
    const refresh = async () => {
      if (!autoRefresh) {
        onChanged(null, null);
        return;
      }
      try {
        const items = await fetcher();
        onChanged(null, items);
      } catch (e) {
        const error49 = e instanceof Error ? e : new Error(String(e));
        onChanged(error49, null);
      }
    };
    const handler = () => {
      if (debounceMs) {
        const existingTimer = this._listChangedDebounceTimers.get(listType);
        if (existingTimer) {
          clearTimeout(existingTimer);
        }
        const timer = setTimeout(refresh, debounceMs);
        this._listChangedDebounceTimers.set(listType, timer);
      } else {
        refresh();
      }
    };
    this.setNotificationHandler(notificationSchema, handler);
  }
  async sendRootsListChanged() {
    return this.notification({ method: "notifications/roots/list_changed" });
  }
}

// node_modules/@modelcontextprotocol/sdk/dist/esm/client/stdio.js
var import_cross_spawn = __toESM(require_cross_spawn(), 1);
import process3 from "process";
import { PassThrough } from "stream";

// node_modules/@modelcontextprotocol/sdk/dist/esm/shared/stdio.js
init_types();

class ReadBuffer {
  append(chunk) {
    this._buffer = this._buffer ? Buffer.concat([this._buffer, chunk]) : chunk;
  }
  readMessage() {
    if (!this._buffer) {
      return null;
    }
    const index = this._buffer.indexOf(`
`);
    if (index === -1) {
      return null;
    }
    const line = this._buffer.toString("utf8", 0, index).replace(/\r$/, "");
    this._buffer = this._buffer.subarray(index + 1);
    return deserializeMessage(line);
  }
  clear() {
    this._buffer = undefined;
  }
}
function deserializeMessage(line) {
  return JSONRPCMessageSchema.parse(JSON.parse(line));
}
function serializeMessage(message) {
  return JSON.stringify(message) + `
`;
}

// node_modules/@modelcontextprotocol/sdk/dist/esm/client/stdio.js
var DEFAULT_INHERITED_ENV_VARS = process3.platform === "win32" ? [
  "APPDATA",
  "HOMEDRIVE",
  "HOMEPATH",
  "LOCALAPPDATA",
  "PATH",
  "PROCESSOR_ARCHITECTURE",
  "SYSTEMDRIVE",
  "SYSTEMROOT",
  "TEMP",
  "USERNAME",
  "USERPROFILE",
  "PROGRAMFILES"
] : ["HOME", "LOGNAME", "PATH", "SHELL", "TERM", "USER"];
function getDefaultEnvironment() {
  const env = {};
  for (const key of DEFAULT_INHERITED_ENV_VARS) {
    const value = process3.env[key];
    if (value === undefined) {
      continue;
    }
    if (value.startsWith("()")) {
      continue;
    }
    env[key] = value;
  }
  return env;
}

class StdioClientTransport {
  constructor(server) {
    this._readBuffer = new ReadBuffer;
    this._stderrStream = null;
    this._serverParams = server;
    if (server.stderr === "pipe" || server.stderr === "overlapped") {
      this._stderrStream = new PassThrough;
    }
  }
  async start() {
    if (this._process) {
      throw new Error("StdioClientTransport already started! If using Client class, note that connect() calls start() automatically.");
    }
    return new Promise((resolve, reject) => {
      this._process = import_cross_spawn.default(this._serverParams.command, this._serverParams.args ?? [], {
        env: {
          ...getDefaultEnvironment(),
          ...this._serverParams.env
        },
        stdio: ["pipe", "pipe", this._serverParams.stderr ?? "inherit"],
        shell: false,
        windowsHide: process3.platform === "win32" && isElectron(),
        cwd: this._serverParams.cwd
      });
      this._process.on("error", (error49) => {
        reject(error49);
        this.onerror?.(error49);
      });
      this._process.on("spawn", () => {
        resolve();
      });
      this._process.on("close", (_code) => {
        this._process = undefined;
        this.onclose?.();
      });
      this._process.stdin?.on("error", (error49) => {
        this.onerror?.(error49);
      });
      this._process.stdout?.on("data", (chunk) => {
        this._readBuffer.append(chunk);
        this.processReadBuffer();
      });
      this._process.stdout?.on("error", (error49) => {
        this.onerror?.(error49);
      });
      if (this._stderrStream && this._process.stderr) {
        this._process.stderr.pipe(this._stderrStream);
      }
    });
  }
  get stderr() {
    if (this._stderrStream) {
      return this._stderrStream;
    }
    return this._process?.stderr ?? null;
  }
  get pid() {
    return this._process?.pid ?? null;
  }
  processReadBuffer() {
    while (true) {
      try {
        const message = this._readBuffer.readMessage();
        if (message === null) {
          break;
        }
        this.onmessage?.(message);
      } catch (error49) {
        this.onerror?.(error49);
      }
    }
  }
  async close() {
    if (this._process) {
      const processToClose = this._process;
      this._process = undefined;
      const closePromise = new Promise((resolve) => {
        processToClose.once("close", () => {
          resolve();
        });
      });
      try {
        processToClose.stdin?.end();
      } catch {}
      await Promise.race([closePromise, new Promise((resolve) => setTimeout(resolve, 2000).unref())]);
      if (processToClose.exitCode === null) {
        try {
          processToClose.kill("SIGTERM");
        } catch {}
        await Promise.race([closePromise, new Promise((resolve) => setTimeout(resolve, 2000).unref())]);
      }
      if (processToClose.exitCode === null) {
        try {
          processToClose.kill("SIGKILL");
        } catch {}
      }
    }
    this._readBuffer.clear();
  }
  send(message) {
    return new Promise((resolve) => {
      if (!this._process?.stdin) {
        throw new Error("Not connected");
      }
      const json2 = serializeMessage(message);
      if (this._process.stdin.write(json2)) {
        resolve();
      } else {
        this._process.stdin.once("drain", resolve);
      }
    });
  }
}
function isElectron() {
  return "type" in process3;
}

// src/services/LangExtractClient.ts
init_defaults();

// src/core/HarvesterCache.ts
import { createHash } from "crypto";
import { existsSync as existsSync6, mkdirSync as mkdirSync3, readFileSync as readFileSync3, writeFileSync as writeFileSync2 } from "fs";
import { join as join7 } from "path";
var log3 = getLogger("HarvesterCache");

class HarvesterCache {
  cacheDir;
  constructor(baseDir = process.cwd()) {
    this.cacheDir = join7(baseDir, ".amalfa/cache/lang-extract");
    if (!existsSync6(this.cacheDir)) {
      mkdirSync3(this.cacheDir, { recursive: true });
    }
  }
  hash(content) {
    return createHash("sha256").update(content).digest("hex");
  }
  get(contentHash) {
    const filePath = join7(this.cacheDir, `${contentHash}.json`);
    if (existsSync6(filePath)) {
      try {
        const raw = readFileSync3(filePath, "utf-8");
        return JSON.parse(raw);
      } catch (err) {
        log3.warn({ err, hash: contentHash }, "Failed to read cache file");
        return null;
      }
    }
    return null;
  }
  set(contentHash, data) {
    const filePath = join7(this.cacheDir, `${contentHash}.json`);
    const tempPath = join7(this.cacheDir, `${contentHash}.tmp`);
    try {
      writeFileSync2(tempPath, JSON.stringify(data, null, 2), "utf-8");
      const rename = Bun.spawnSync(["mv", tempPath, filePath]);
      if (rename.exitCode !== 0) {
        log3.error("Failed to rename atomic cache file");
      }
    } catch (err) {
      log3.error({ err, hash: contentHash }, "Failed to write cache file");
    }
  }
  has(contentHash) {
    return existsSync6(join7(this.cacheDir, `${contentHash}.json`));
  }
}

// src/services/LangExtractClient.ts
init_zod();
var EntitySchema = exports_external.object({
  name: exports_external.string(),
  type: exports_external.string(),
  description: exports_external.string().optional()
});
var RelationshipSchema = exports_external.object({
  source: exports_external.string(),
  target: exports_external.string(),
  type: exports_external.string(),
  description: exports_external.string().optional()
});
var GraphDataSchema = exports_external.object({
  entities: exports_external.array(EntitySchema),
  relationships: exports_external.array(RelationshipSchema)
});

class LangExtractClient {
  client = null;
  transport = null;
  sidecarPath;
  log = getLogger("LangExtractClient");
  settings;
  cache;
  constructor() {
    this.sidecarPath = resolve(process.cwd(), "src/sidecars/lang-extract");
    this.settings = loadSettings();
    this.cache = new HarvesterCache;
  }
  checkCache(text) {
    return this.cache.has(this.cache.hash(text));
  }
  async isAvailable() {
    const uvCheck = Bun.spawnSync(["which", "uv"]);
    if (uvCheck.exitCode !== 0)
      return false;
    if (!existsSync7(this.sidecarPath))
      return false;
    if (!existsSync7(join8(this.sidecarPath, "server.py")))
      return false;
    return true;
  }
  getProvider() {
    if (process.env.LANGEXTRACT_PROVIDER) {
      this.log.info(`Using env provider: ${process.env.LANGEXTRACT_PROVIDER}`);
      return process.env.LANGEXTRACT_PROVIDER;
    }
    if (this.settings.langExtract?.provider) {
      this.log.info(`Using settings provider: ${this.settings.langExtract.provider}`);
      return this.settings.langExtract.provider;
    }
    this.log.info("Using default provider: openrouter");
    return "openrouter";
  }
  checkProviderConfig(provider) {
    if (provider === "gemini" && !process.env.GEMINI_API_KEY) {
      return {
        valid: false,
        error: `${"MISSING_API_KEY" /* MISSING_API_KEY */}: GEMINI_API_KEY not configured`,
        suggestion: "Set GEMINI_API_KEY in .env file"
      };
    }
    if (provider === "openrouter" && !process.env.OPENROUTER_API_KEY) {
      return {
        valid: false,
        error: `${"MISSING_API_KEY" /* MISSING_API_KEY */}: OPENROUTER_API_KEY not configured`,
        suggestion: "Set OPENROUTER_API_KEY in .env file"
      };
    }
    return { valid: true };
  }
  parseSubstrateError(responseText) {
    try {
      const parsed = JSON.parse(responseText);
      if (parsed.error) {
        const errorStr = parsed.error.toLowerCase();
        if (errorStr.includes("api key") && (errorStr.includes("not set") || errorStr.includes("not configured"))) {
          return {
            error: "MISSING_API_KEY" /* MISSING_API_KEY */,
            message: parsed.error,
            suggestion: "Check API key in .env file"
          };
        }
        if (errorStr.includes("api key") && (errorStr.includes("invalid") || errorStr.includes("rejected"))) {
          return {
            error: "INVALID_API_KEY" /* INVALID_API_KEY */,
            message: parsed.error,
            suggestion: "Verify API key is correct and active"
          };
        }
        if (errorStr.includes("credit") || errorStr.includes("quota") || errorStr.includes("limit")) {
          return {
            error: "OUT_OF_CREDIT" /* OUT_OF_CREDIT */,
            message: parsed.error,
            suggestion: "Check billing or switch to another provider"
          };
        }
        if (errorStr.includes("network") || errorStr.includes("connection") || errorStr.includes("timeout")) {
          return {
            error: "NETWORK_ERROR" /* NETWORK_ERROR */,
            message: parsed.error,
            suggestion: "Check network connection and provider status"
          };
        }
        return {
          error: "UNKNOWN_ERROR" /* UNKNOWN */,
          message: parsed.error,
          suggestion: "Check provider documentation for troubleshooting"
        };
      }
    } catch {
      const text = responseText.toLowerCase();
      if (text.includes("api key") && (text.includes("not set") || text.includes("not configured"))) {
        return {
          error: "MISSING_API_KEY" /* MISSING_API_KEY */,
          message: responseText,
          suggestion: "Check API key in .env file"
        };
      }
      return {
        error: "UNKNOWN_ERROR" /* UNKNOWN */,
        message: responseText,
        suggestion: "Check provider documentation for troubleshooting"
      };
    }
    return {
      error: "UNKNOWN_ERROR" /* UNKNOWN */,
      message: responseText,
      suggestion: "Check provider documentation for troubleshooting"
    };
  }
  async connect() {
    if (this.client)
      return;
    const provider = this.getProvider();
    const configCheck = this.checkProviderConfig(provider);
    if (!configCheck.valid) {
      throw new Error(configCheck.error);
    }
    const providerSettings = this.settings.langExtract?.[provider] || {};
    const modelToUse = providerSettings.model || (provider === "openrouter" ? "qwen/qwen-2.5-72b-instruct" : provider === "gemini" ? "gemini-flash-latest" : "qwen2.5:1.5b");
    this.log.info({
      provider,
      model: modelToUse,
      configSource: providerSettings.model ? "settings" : "default"
    }, "Initializing LangExtract sidecar");
    this.transport = new StdioClientTransport({
      command: "uv",
      args: ["run", "server.py"],
      cwd: this.sidecarPath,
      env: {
        ...process.env,
        LANGEXTRACT_PROVIDER: provider,
        GEMINI_API_KEY: process.env.GEMINI_API_KEY || "",
        GEMINI_MODEL: provider === "gemini" ? modelToUse : "gemini-flash-latest",
        OLLAMA_HOST: "http://localhost:11434",
        OLLAMA_MODEL: provider === "ollama" ? modelToUse : "qwen2.5:1.5b",
        OPENROUTER_API_KEY: process.env.OPENROUTER_API_KEY || "",
        OPENROUTER_MODEL: provider === "openrouter" ? modelToUse : "qwen/qwen-2.5-72b-instruct"
      }
    });
    this.client = new Client({ name: "amalfa-host", version: "1.0.0" }, { capabilities: {} });
    await this.client.connect(this.transport);
  }
  async extract(text) {
    if (!this.client) {
      await this.connect();
    }
    const contentHash = this.cache.hash(text);
    const cachedResult = this.cache.get(contentHash);
    if (cachedResult) {
      this.log.debug({ hash: contentHash }, "Harvester Cache Hit");
      return cachedResult;
    }
    this.log.debug({ hash: contentHash, textLength: text.length }, "Harvester Cache Miss - Calling Sidecar");
    const startTime = Date.now();
    try {
      const result = await this.client?.callTool({
        name: "extract_graph",
        arguments: { text }
      });
      if (!result?.content || result.content.length === 0)
        return null;
      const contentBlock = result.content[0];
      if (contentBlock.type !== "text")
        return null;
      const responseText = contentBlock.text;
      if (responseText.startsWith("Error") || responseText.includes('"error"')) {
        const errorInfo = this.parseSubstrateError(responseText);
        this.log.error({
          error: errorInfo.error,
          message: errorInfo.message,
          suggestion: errorInfo.suggestion
        }, "Substrate error");
        throw new Error(`${errorInfo.error}: ${errorInfo.message}${errorInfo.suggestion ? `
Suggestion: ${errorInfo.suggestion}` : ""}`);
      }
      let rawJson;
      try {
        rawJson = JSON.parse(responseText);
      } catch (_e) {
        const cleanText = responseText.replace(/```json\n?|\n?```/g, "").trim();
        try {
          rawJson = JSON.parse(cleanText);
        } catch (_e2) {
          this.log.error({ responseText }, "Failed to parse sidecar JSON");
          return null;
        }
      }
      const parsed = GraphDataSchema.parse(rawJson);
      const duration5 = Date.now() - startTime;
      this.log.info({
        duration: duration5,
        entities: parsed.entities.length,
        relationships: parsed.relationships.length
      }, "Extraction successful");
      this.cache.set(contentHash, parsed);
      return parsed;
    } catch (error49) {
      this.log.error({ err: error49 }, "Sidecar extraction failed");
      throw error49;
    }
  }
  async close() {
    if (this.transport) {
      await this.transport.close();
    }
    this.client = null;
    this.transport = null;
  }
}

// src/utils/StatsLogger.ts
import { appendFileSync, existsSync as existsSync8, writeFileSync as writeFileSync3 } from "fs";
var RUNS_FILE = ".amalfa/runs.jsonl";

class StatsLogger {
  static logRun(stats) {
    if (!stats.timestamp) {
      stats.timestamp = new Date().toISOString();
    }
    if (!existsSync8(RUNS_FILE)) {
      writeFileSync3(RUNS_FILE, "");
    }
    appendFileSync(RUNS_FILE, `${JSON.stringify(stats)}
`);
  }
  static logHarvest(stats) {
    StatsLogger.logRun({
      timestamp: new Date().toISOString(),
      operation: "harvest",
      files_processed: stats.files,
      cache_hits: stats.hits,
      cache_misses: stats.misses,
      skipped: stats.skipped,
      errors: stats.errors,
      duration_ms: stats.duration_ms,
      cost_usd: stats.misses * 0.001
    });
  }
  static logInit(stats) {
    StatsLogger.logRun({
      timestamp: new Date().toISOString(),
      operation: "init",
      files_processed: stats.files,
      nodes: stats.nodes,
      edges: stats.edges,
      duration_ms: stats.duration_ms,
      errors: stats.errors
    });
  }
}

// src/cli/commands/harvest.ts
var log4 = getLogger("CLI:Harvest");
var IGNORE_DIRS = ["node_modules", ".git", ".amalfa", "dist", "out"];
var ALLOW_EXTS = [".ts", ".tsx", ".md"];
var CONCURRENCY = 1;
var MAX_FILE_SIZE = 25 * 1024;
var CIRCUIT_BREAKER_THRESHOLD = 3;
var RATE_LIMIT_DELAY_MS = 100;
async function getFiles(dir) {
  const files = [];
  const entries = await readdir(dir, { withFileTypes: true });
  for (const entry of entries) {
    const fullPath = join9(dir, entry.name);
    if (entry.isDirectory()) {
      if (IGNORE_DIRS.includes(entry.name))
        continue;
      files.push(...await getFiles(fullPath));
    } else if (entry.isFile()) {
      if (ALLOW_EXTS.some((ext) => entry.name.endsWith(ext))) {
        files.push(fullPath);
      }
    }
  }
  return files;
}
async function cmdHarvest(args) {
  let targetDir = process.cwd();
  const dirArg = args[0];
  if (dirArg && !dirArg.startsWith("-"))
    targetDir = dirArg;
  log4.info({ targetDir }, "Starting harvest...");
  try {
    const client = new LangExtractClient;
    if (!await client.isAvailable()) {
      log4.error("LangExtract sidecar not available. Run 'amalfa setup-python' first.");
      process.exit(1);
    }
    let allFiles = [];
    const stat = statSync2(targetDir);
    if (stat.isFile()) {
      allFiles = [targetDir];
    } else {
      allFiles = await getFiles(targetDir);
    }
    log4.info({ count: allFiles.length }, "Found files to harvest");
    const startTime = Date.now();
    let processed = 0;
    let hits = 0;
    let misses = 0;
    let skipped = 0;
    let errors5 = 0;
    let consecutiveErrors = 0;
    let _lastErrorMessage = "";
    const skippedFiles = {
      timeouts: [],
      too_large: [],
      errors: []
    };
    const queue = [...allFiles];
    const workers = Array(CONCURRENCY).fill(null).map(async () => {
      while (queue.length > 0) {
        const filePath = queue.shift();
        if (!filePath)
          break;
        try {
          const stats = statSync2(filePath);
          if (stats.size > MAX_FILE_SIZE) {
            const content2 = readFileSync4(filePath, "utf-8");
            if (client.checkCache(content2)) {
              hits++;
            } else {
              skipped++;
              skippedFiles.too_large.push(filePath);
              log4.warn({ file: filePath, size: stats.size }, "Skipping large file");
              processed++;
              continue;
            }
          }
          const content = readFileSync4(filePath, "utf-8");
          const isCached = client.checkCache(content);
          if (isCached)
            hits++;
          else
            misses++;
          await client.extract(content);
          consecutiveErrors = 0;
          _lastErrorMessage = "";
          processed++;
          if (processed % 10 === 0) {
            process.stdout.write(`\rProgress: ${processed}/${allFiles.length} (Hits: ${hits}, Misses: ${misses})`);
          }
          if (!isCached) {
            await new Promise((resolve2) => setTimeout(resolve2, RATE_LIMIT_DELAY_MS));
          }
        } catch (e) {
          errors5++;
          const errorMsg = e instanceof Error ? e.message : String(e);
          const isTimeout = errorMsg.includes("timeout") || errorMsg.includes("timed out");
          const isRateLimit = errorMsg.includes("401") || errorMsg.includes("429");
          if (isTimeout) {
            skipped++;
            skippedFiles.timeouts.push(filePath);
            log4.warn({ file: filePath, err: e }, "Timeout - skipping file");
            processed++;
            continue;
          }
          if (isRateLimit) {
            consecutiveErrors++;
            _lastErrorMessage = errorMsg;
          } else {
            skippedFiles.errors.push(filePath);
          }
          log4.warn({ file: filePath, err: e }, "Failed to extract");
          if (consecutiveErrors >= CIRCUIT_BREAKER_THRESHOLD) {
            const errorType = errorMsg.includes("401") ? "Authentication/Rate Limit" : errorMsg.includes("429") ? "Rate Limit" : "Unknown";
            console.log("");
            console.log(`
\uD83D\uDEA8 Circuit Breaker Triggered!`);
            console.log(`   Error Type: ${errorType}`);
            console.log(`   Consecutive Failures: ${consecutiveErrors}`);
            console.log(`   Last Error: ${errorMsg.substring(0, 100)}...`);
            console.log(`
\uD83D\uDCA1 Recommendation:`);
            if (errorType.includes("Rate Limit") || errorType.includes("Authentication")) {
              console.log("   - Check OpenRouter dashboard for rate limits or credit balance");
              console.log("   - Verify OPENROUTER_API_KEY is valid");
              console.log("   - Wait a few minutes and retry");
              if (process.env.OPENROUTER_API_KEY) {
                console.log(`
\uD83D\uDD0D Checking OpenRouter account status...`);
                try {
                  const healthCheck = Bun.spawnSync([
                    "curl",
                    "-s",
                    "-H",
                    `Authorization: Bearer ${process.env.OPENROUTER_API_KEY}`,
                    "https://openrouter.ai/api/v1/key"
                  ]);
                  if (healthCheck.exitCode === 0) {
                    const response = JSON.parse(healthCheck.stdout.toString());
                    if (response.data) {
                      console.log(`   Balance: $${response.data.limit?.toFixed(2) || "N/A"}`);
                      console.log(`   Used Today: $${response.data.usage?.toFixed(2) || "N/A"}`);
                      console.log(`   Free Tier: ${response.data.is_free_tier ? "Yes" : "No"}`);
                      if (response.data.rate_limit) {
                        console.log(`   Rate Limit: ${response.data.rate_limit.requests}/${response.data.rate_limit.interval}`);
                      }
                    }
                  }
                } catch (_err) {
                  console.log("   (Could not fetch account status)");
                }
              }
            } else if (errorType === "Timeout") {
              console.log("   - Files may be too large for processing");
              console.log("   - Consider reducing MAX_FILE_SIZE");
            } else {
              console.log("   - Check network connectivity");
              console.log("   - Review error logs above");
            }
            console.log(`
\u23F8\uFE0F  Harvest paused. Progress saved to cache.`);
            console.log(`   Re-run 'amalfa harvest' to resume from where you left off.
`);
            await client.close();
            process.exit(1);
          }
        }
      }
    });
    await Promise.all(workers);
    await client.close();
    const manifestPath = ".amalfa/harvest-skipped.json";
    await writeFile(manifestPath, JSON.stringify(skippedFiles, null, 2));
    const totalSkipped = skippedFiles.timeouts.length + skippedFiles.too_large.length + skippedFiles.errors.length;
    const notificationTitle = "Harvest Complete";
    const notificationMessage = `Processed: ${allFiles.length} | Cached: ${hits} | New: ${misses} | Skipped: ${totalSkipped}`;
    try {
      Bun.spawnSync([
        "osascript",
        "-e",
        `display notification "${notificationMessage}" with title "${notificationTitle}"`
      ]);
    } catch (_err) {}
    console.log("");
    console.log("Harvest Complete:");
    console.log(`  Files Scanned: ${allFiles.length}`);
    console.log(`  Cache Hits: ${hits}`);
    console.log(`  Cache Misses: ${misses} (API Calls)`);
    console.log(`  Skipped: ${skipped} (${skippedFiles.timeouts.length} timeouts, ${skippedFiles.too_large.length} too large)`);
    console.log(`  Errors: ${errors5}`);
    if (totalSkipped > 0) {
      console.log(`
  Skipped files saved to: ${manifestPath}`);
    }
    console.log("");
    const duration_ms = Date.now() - startTime;
    StatsLogger.logHarvest({
      files: allFiles.length,
      hits,
      misses,
      skipped: totalSkipped,
      errors: errors5,
      duration_ms
    });
  } catch (e) {
    log4.error({ err: e }, "Harvest failed");
    process.exit(1);
  } finally {
    process.exit(0);
  }
}

// src/cli/commands/harvest-lexicon.ts
init_defaults();
import { join as join11 } from "path";

// src/core/LexiconHarvester.ts
init_defaults();
import { readdir as readdir2 } from "fs/promises";
import { join as join10 } from "path";

// src/utils/JsonlUtils.ts
import { appendFileSync as appendFileSync2, promises as fsPromises } from "fs";
import { createInterface } from "readline";
import { Readable } from "stream";

class JsonlUtils {
  static append(path2, data) {
    appendFileSync2(path2, `${JSON.stringify(data)}
`, "utf8");
  }
  static async appendAsync(path2, data) {
    await fsPromises.appendFile(path2, `${JSON.stringify(data)}
`, "utf8");
  }
  static async* stream(path2) {
    const file2 = Bun.file(path2);
    if (!await file2.exists())
      return;
    const stream = file2.stream();
    const nodeStream = Readable.fromWeb(stream);
    const rl = createInterface({
      input: nodeStream,
      crlfDelay: Number.POSITIVE_INFINITY
    });
    for await (const line of rl) {
      const trimmed = line.trim();
      if (!trimmed)
        continue;
      try {
        yield JSON.parse(trimmed);
      } catch (_) {}
    }
  }
  static async process(path2, onLine) {
    for await (const item of JsonlUtils.stream(path2)) {
      await onLine(item);
    }
  }
  static async readAll(path2) {
    const results = [];
    for await (const item of JsonlUtils.stream(path2)) {
      results.push(item);
    }
    return results;
  }
}

// src/core/LexiconHarvester.ts
class LexiconHarvester {
  config;
  candidates = new Map;
  stopList = new Set;
  manifest = new Map;
  constructor(config3) {
    this.config = config3;
  }
  async loadStopList() {
    try {
      const file2 = Bun.file(this.config.stopListPath);
      if (await file2.exists()) {
        const content = await file2.json();
        if (Array.isArray(content)) {
          content.forEach((t) => {
            if (typeof t === "string") {
              this.stopList.add(this.normalize(t));
            }
          });
        }
      }
    } catch (_e) {
      console.warn(`\u26A0\uFE0F  Could not load stop-list from ${this.config.stopListPath}`);
    }
  }
  async loadManifest() {
    const manifestPath = join10(AMALFA_DIRS.cache, "manifest.jsonl");
    try {
      if (await Bun.file(manifestPath).exists()) {
        await JsonlUtils.process(manifestPath, async (entry) => {
          if (entry.hash && entry.path) {
            this.manifest.set(entry.hash, entry.path);
          }
        });
        console.log(`\uD83D\uDDFA\uFE0F  Loaded ${this.manifest.size} source mappings.`);
      }
    } catch (_e) {
      console.warn("\u26A0\uFE0F  Could not load manifest.jsonl");
    }
  }
  normalize(term) {
    return term.toLowerCase().trim();
  }
  async harvest() {
    console.log("\uD83C\uDF3E Starting Lexicon Harvest...");
    await this.loadStopList();
    await this.loadManifest();
    const files = (await readdir2(this.config.cacheDir)).filter((f) => f.endsWith(".json") && !f.startsWith("."));
    console.log(`\uD83D\uDCC2 Scanning ${files.length} sidecars...`);
    let processed = 0;
    for (const file2 of files) {
      try {
        const path2 = join10(this.config.cacheDir, file2);
        const content = await Bun.file(path2).json();
        this.processSidecar(content, file2);
        processed++;
      } catch (_e) {}
    }
    console.log(`\u2705 Processed ${processed} files.`);
    console.log(`\uD83D\uDCCA Found ${this.candidates.size} unique candidates.`);
    await this.writeCandidates();
  }
  processSidecar(data, filename) {
    const hash2 = filename.replace(".json", "");
    const sourcePath = this.manifest.get(hash2);
    const sourceId = data.uuid || sourcePath || hash2;
    const terms = [
      ...(data.entities || []).map((e) => ({
        t: e.name || (typeof e === "string" ? e : String(e)),
        type: "entity"
      })),
      ...(data.concepts || []).map((c) => ({
        t: c.name || (typeof c === "string" ? c : String(c)),
        type: "concept"
      }))
    ];
    for (const { t, type } of terms) {
      if (!t || typeof t !== "string")
        continue;
      const normalized = this.normalize(t);
      if (this.stopList.has(normalized))
        continue;
      const existing = this.candidates.get(normalized);
      if (existing) {
        existing.frequency++;
        if (!existing.sources.includes(sourceId)) {
          existing.sources.push(sourceId);
        }
      } else {
        this.candidates.set(normalized, {
          term: normalized,
          frequency: 1,
          sources: [sourceId],
          type,
          status: "candidate"
        });
      }
    }
  }
  async writeCandidates() {
    console.log(`\uD83D\uDCBE Writing candidates to ${this.config.outputPath}...`);
    await Bun.write(this.config.outputPath, "");
    const sorted = Array.from(this.candidates.values()).sort((a, b) => b.frequency - a.frequency);
    for (const candidate of sorted) {
      JsonlUtils.append(this.config.outputPath, candidate);
    }
    console.log("\u2705 Harvest Complete.");
  }
}

// src/cli/commands/harvest-lexicon.ts
async function cmdHarvestLexicon(args) {
  const outputPath = args[0] || join11(AMALFA_DIRS.base, "lexicon-candidates.jsonl");
  const cacheDir = join11(AMALFA_DIRS.cache, "lang-extract");
  const stopListPath = join11(process.cwd(), "stop-list.json");
  console.log(`\uD83D\uDD27 Configuring Harvester:`);
  console.log(`   Cache: ${cacheDir}`);
  console.log(`   StopList: ${stopListPath}`);
  console.log(`   Output: ${outputPath}
`);
  const harvester = new LexiconHarvester({
    cacheDir,
    stopListPath,
    outputPath
  });
  await harvester.harvest();
}

// src/cli/commands/init.ts
init_defaults();
import { existsSync as existsSync12, mkdirSync as mkdirSync5, statSync as statSync4 } from "fs";
import { join as join17 } from "path";

// src/pipeline/AmalfaIngestor.ts
import { join as join14 } from "path";

// src/core/LouvainGate.ts
var LouvainGate = {
  check(db, source, target, threshold = 50) {
    const isSuper = this.isSuperNode(db, target, threshold);
    if (isSuper) {
      const shares = this.sharesNeighbor(db, source, target);
      if (!shares) {
        return {
          allowed: false,
          reason: `Rejected edge ${source} -> ${target} due to low modularity (Target is SuperNode with ${threshold}+ edges and 0 shared neighbors).`
        };
      }
    }
    return { allowed: true };
  },
  isSuperNode(db, id, threshold) {
    const result = db.query("SELECT COUNT(*) as c FROM edges WHERE target = ? OR source = ?").get(id, id);
    return result.c > threshold;
  },
  sharesNeighbor(db, a, b) {
    const result = db.query(`
            SELECT 1 as exists_flag FROM edges e1 
            JOIN edges e2 ON (
                (e1.target = e2.target) OR 
                (e1.source = e2.source) OR 
                (e1.target = e2.source) OR 
                (e1.source = e2.target)
            )
            WHERE 
                (e1.source = ? OR e1.target = ?) AND
                (e2.source = ? OR e2.target = ?)
            LIMIT 1
            `).get(a, a, b, b);
    return !!result;
  }
};

// src/core/EdgeWeaver.ts
class EdgeWeaver {
  db;
  superNodeThreshold = 50;
  lexicon;
  stats = { checked: 0, rejected: 0 };
  constructor(db, context = [], config3) {
    this.db = db;
    this.lexicon = new Map;
    if (config3?.graph?.tuning?.louvain?.superNodeThreshold) {
      this.superNodeThreshold = config3.graph.tuning.louvain.superNodeThreshold;
    }
    if (Array.isArray(context)) {
      for (const item of context) {
        if (!item || !item.id)
          continue;
        const id = item.id;
        this.lexicon.set(id.toLowerCase(), id);
        if (item.title) {
          this.lexicon.set(this.slugify(item.title), id);
        }
        if (item.aliases && Array.isArray(item.aliases)) {
          for (const alias of item.aliases) {
            this.lexicon.set(this.slugify(alias), id);
          }
        }
      }
    }
  }
  weave(sourceNodeId, content) {
    this.processTags(sourceNodeId, content);
    this.processWikiLinks(sourceNodeId, content);
    this.processMetadataTags(sourceNodeId, content);
    this.processMarkdownLinks(sourceNodeId, content);
  }
  processTags(sourceId, content) {
    const explicitMatches = content.matchAll(/\[tag:\s*(.*?)\]/gi);
    for (const match of explicitMatches) {
      if (match[1]) {
        const tagValue = match[1].trim();
        const conceptId = this.lexicon.get(this.slugify(tagValue));
        if (conceptId) {
          this.safeInsertEdge(sourceId, conceptId, "TAGGED_AS");
        }
      }
    }
    const matches = content.matchAll(/\btag-([\w-]+)/g);
    const legacyMatches = Array.from(matches);
    if (legacyMatches.length > 0) {
      console.warn(`\u26A0\uFE0F  Legacy 'tag-slug' format detected in ${sourceId}. Use [tag: Concept] instead.`);
    }
    for (const match of legacyMatches) {
      if (match[1]) {
        const tagStub = match[1].toLowerCase();
        const conceptId = this.lexicon.get(tagStub);
        if (conceptId) {
          this.safeInsertEdge(sourceId, conceptId, "EXEMPLIFIES");
        }
      }
    }
  }
  processMetadataTags(sourceId, content) {
    const tagBlockMatch = content.match(/<!-- tags: (.*?) -->/);
    if (tagBlockMatch?.[1]) {
      const tagString = tagBlockMatch[1];
      const tagRegex = /\[([\w_]+):\s*([^\]]+)\]/g;
      const matches = tagString.matchAll(tagRegex);
      for (const match of matches) {
        if (match[1] && match[2]) {
          const relType = match[1].toLowerCase();
          const targetId = match[2].trim();
          if (relType === "quality" || relType.startsWith("#"))
            continue;
          this.safeInsertEdge(sourceId, targetId, relType.toUpperCase());
        }
      }
    }
  }
  processWikiLinks(sourceId, content) {
    const matches = content.matchAll(/\[\[(.*?)(?:\|.*?)?\]\]/g);
    for (const match of matches) {
      if (!match[1])
        continue;
      const rawTarget = match[1].trim();
      const slugified = this.slugify(rawTarget);
      let conceptId = this.lexicon.get(slugified);
      if (!conceptId) {
        const pathAwareId = this.db.generateId(rawTarget);
        if (this.lexicon.has(pathAwareId)) {
          conceptId = pathAwareId;
        }
      }
      if (conceptId) {
        this.safeInsertEdge(sourceId, conceptId, "CITES");
      }
    }
  }
  processMarkdownLinks(sourceId, content) {
    const matches = content.matchAll(/\[([^\]]+)\]\(([^)]+\.md)\)/g);
    for (const match of matches) {
      if (!match[2])
        continue;
      const linkPath = match[2].trim();
      if (linkPath.startsWith("http://") || linkPath.startsWith("https://")) {
        continue;
      }
      const normalizedPath = linkPath.replace(/^\.\//, "").replace(/^\.\.\//, "");
      const targetId = this.db.generateId(normalizedPath);
      if (this.lexicon.has(targetId)) {
        this.safeInsertEdge(sourceId, targetId, "LINKS_TO");
      }
    }
  }
  safeInsertEdge(source, target, type) {
    const check3 = LouvainGate.check(this.db.getRawDb(), source, target, this.superNodeThreshold);
    this.stats.checked++;
    if (check3.allowed) {
      this.db.insertEdge(source, target, type);
    } else {
      this.stats.rejected++;
    }
  }
  getStats() {
    return { ...this.stats };
  }
  slugify(text) {
    return text.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
  }
}

// src/resonance/services/embedder.ts
import { join as join12 } from "path";
init_esm();

class Embedder {
  static instance;
  nativeEmbedder = null;
  daemonUrl = `http://localhost:${process.env.VECTOR_PORT || "3010"}`;
  useRemote = true;
  currentModel = EmbeddingModel.BGESmallENV15;
  constructor() {
    this.configureModel();
  }
  configureModel() {
    const envModel = process.env.EMBEDDING_MODEL;
    if (envModel) {
      const resolved = this.resolveModel(envModel);
      if (resolved) {
        this.currentModel = resolved;
      } else {
        console.warn(`[Embedder] Warning: Unknown model '${envModel}'. Falling back to default: ${this.currentModel}`);
      }
    }
  }
  resolveModel(modelName) {
    const normalized = modelName.toLowerCase().replace(/[^a-z0-9]/g, "");
    const map3 = {
      allminilml6v2: EmbeddingModel.AllMiniLML6V2,
      bgesmallenv15: EmbeddingModel.BGESmallENV15,
      bgebaseenv15: EmbeddingModel.BGEBaseENV15,
      bgesmallen: EmbeddingModel.BGESmallEN,
      bgebaseen: EmbeddingModel.BGEBaseEN
    };
    return map3[normalized];
  }
  static getInstance() {
    if (!Embedder.instance) {
      Embedder.instance = new Embedder;
    }
    return Embedder.instance;
  }
  async init() {
    if (!this.nativeEmbedder) {
      const cacheDir = join12(process.cwd(), ".amalfa/cache");
      console.log(`[Embedder] Initializing local embedding model: ${this.currentModel}`);
      this.nativeEmbedder = await FlagEmbedding.init({
        model: this.currentModel,
        cacheDir,
        showDownloadProgress: true
      });
    }
  }
  async embed(text, forceLocal = false) {
    if (this.useRemote && !forceLocal) {
      try {
        const response = await fetch(`${this.daemonUrl}/embed`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            text,
            model: this.currentModel
          }),
          signal: AbortSignal.timeout(200)
        });
        if (response.ok) {
          const data = await response.json();
          if (data.vector) {
            const raw2 = new Float32Array(data.vector);
            return new Float32Array(toFafcas(raw2).buffer);
          }
        }
      } catch (_e) {}
    }
    if (!this.nativeEmbedder)
      await this.init();
    const gen = this.nativeEmbedder?.embed([text]);
    if (!gen)
      throw new Error("Failed to initialize embedder");
    const result = await gen.next();
    const val = result.value?.[0];
    if (!val || val.length === 0) {
      throw new Error("Failed to generate embedding");
    }
    const raw = new Float32Array(val);
    return new Float32Array(toFafcas(raw).buffer);
  }
}

// src/resonance/services/simpleTokenizer.ts
class SimpleTokenizerService {
  static instance;
  vocabulary = new Map;
  searchKeys = [];
  constructor() {}
  static getInstance() {
    if (!SimpleTokenizerService.instance) {
      SimpleTokenizerService.instance = new SimpleTokenizerService;
    }
    return SimpleTokenizerService.instance;
  }
  extract(text) {
    const result = {
      people: [],
      places: [],
      organizations: [],
      topics: [],
      money: [],
      protocols: [],
      concepts: []
    };
    const lowerText = text.toLowerCase();
    for (const term of this.searchKeys) {
      if (lowerText.includes(term)) {
        const escaped = term.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        const boundaryRegex = new RegExp(`\\b${escaped}\\b`, "i");
        if (boundaryRegex.test(text)) {
          const tag = this.vocabulary.get(term);
          const match = boundaryRegex.exec(text);
          const realTerm = match ? match[0] : term;
          if (tag === "Protocol") {
            if (!result.protocols?.includes(realTerm))
              result.protocols?.push(realTerm);
          } else if (tag === "Concept") {
            if (!result.concepts?.includes(realTerm))
              result.concepts?.push(realTerm);
          } else if (tag === "Organization") {
            if (!result.organizations.includes(realTerm))
              result.organizations.push(realTerm);
          } else {
            if (!result.concepts?.includes(realTerm))
              result.concepts?.push(realTerm);
          }
        }
      }
    }
    return result;
  }
  loadLexicon(lexicon) {
    this.vocabulary.clear();
    for (const item of lexicon) {
      let tag = "Concept";
      if (item.type === "operational-heuristic")
        tag = "Protocol";
      if (item.category === "Tool")
        tag = "Organization";
      if (item.title) {
        this.vocabulary.set(item.title.toLowerCase(), tag);
      }
      if (item.id) {
        this.vocabulary.set(item.id.toLowerCase(), tag);
        if (item.id.includes("-")) {
          this.vocabulary.set(item.id.toLowerCase().replace(/-/g, " "), tag);
        }
      }
    }
    this.searchKeys = Array.from(this.vocabulary.keys()).sort((a, b) => b.length - a.length);
  }
  extend(_customWords, _customPatterns) {}
}

// src/utils/projectRoot.ts
import { existsSync as existsSync9 } from "fs";
import { dirname, join as join13, resolve as resolve2 } from "path";
var ROOT_MARKERS = [
  "amalfa.config.json",
  "amalfa.config.ts",
  ".git",
  "package.json"
];
var cachedRoot = null;
function detectProjectRoot(startPath = process.cwd()) {
  if (cachedRoot) {
    return cachedRoot;
  }
  let currentDir = resolve2(startPath);
  const rootDir = "/";
  while (currentDir !== rootDir) {
    for (const marker of ROOT_MARKERS) {
      const markerPath = join13(currentDir, marker);
      if (existsSync9(markerPath)) {
        cachedRoot = currentDir;
        return currentDir;
      }
    }
    const parentDir = dirname(currentDir);
    if (parentDir === currentDir) {
      break;
    }
    currentDir = parentDir;
  }
  throw new Error(`Could not detect project root. Searched upward from ${startPath} for: ${ROOT_MARKERS.join(", ")}`);
}
function toRootRelative(absolutePath, projectRoot) {
  const root = projectRoot || detectProjectRoot();
  const absPath = resolve2(absolutePath);
  if (!absPath.startsWith(root)) {
    throw new Error(`Path ${absPath} is outside project root ${root}. Cannot create relative path.`);
  }
  const relativePath = absPath.slice(root.length);
  return relativePath.startsWith("/") ? relativePath.slice(1) : relativePath;
}
function fromRootRelative(relativePath, projectRoot) {
  const root = projectRoot || detectProjectRoot();
  return join13(root, relativePath);
}

// src/pipeline/AmalfaIngestor.ts
var import_gray_matter = __toESM(require_gray_matter(), 1);
var {Glob } = globalThis.Bun;

class AmalfaIngestor {
  config;
  db;
  log = getLogger("AmalfaIngestor");
  sidecar = new LangExtractClient;
  constructor(config3, db) {
    this.config = config3;
    this.db = db;
  }
  async ingestFiles(filePaths) {
    const startTime = performance.now();
    if (filePaths.length === 0) {
      return {
        success: true,
        stats: {
          files: 0,
          nodes: 0,
          edges: 0,
          vectors: 0,
          durationSec: 0
        }
      };
    }
    this.log.info(`\uD83D\uDD04 Incremental ingestion: ${filePaths.length} file${filePaths.length > 1 ? "s" : ""}`);
    try {
      const embedder = Embedder.getInstance();
      const tokenizer = SimpleTokenizerService.getInstance();
      this.db.beginTransaction();
      for (const filePath of filePaths) {
        await this.processFile(filePath, embedder, null, tokenizer);
      }
      this.db.commit();
      const lexicon = this.buildLexicon();
      const weaver = new EdgeWeaver(this.db, lexicon, this.config);
      this.db.beginTransaction();
      for (const filePath of filePaths) {
        try {
          const content = await Bun.file(filePath).text();
          const id = this.extractIdFromPath(filePath);
          weaver.weave(id, content);
        } catch (e) {
          this.log.warn({ file: filePath, err: e }, "\u26A0\uFE0F  Failed to weave edges");
        }
      }
      this.db.commit();
      this.db.getRawDb().run("PRAGMA wal_checkpoint(TRUNCATE);");
      const endTime = performance.now();
      const durationSec = (endTime - startTime) / 1000;
      const stats = this.db.getStats();
      this.log.info({
        files: filePaths.length,
        nodes: stats.nodes,
        edges: stats.edges,
        vectors: stats.vectors,
        durationSec: durationSec.toFixed(2)
      }, "\u2705 Incremental ingestion complete");
      return {
        success: true,
        stats: {
          files: filePaths.length,
          nodes: stats.nodes,
          edges: stats.edges,
          vectors: stats.vectors,
          durationSec
        }
      };
    } catch (e) {
      this.log.error({ err: e }, "\u274C Incremental ingestion failed");
      return {
        success: false,
        stats: {
          files: 0,
          nodes: 0,
          edges: 0,
          vectors: 0,
          durationSec: 0
        }
      };
    }
  }
  async ingest() {
    const startTime = performance.now();
    const sources = this.config.sources || ["./docs"];
    this.log.info(`\uD83D\uDCDA Starting ingestion from: ${sources.join(", ")}`);
    try {
      const embedder = Embedder.getInstance();
      await embedder.embed("init");
      const sidecarReady = await this.sidecar.isAvailable();
      if (sidecarReady) {
        this.log.info("\uD83D\uDC0D LangExtract Sidecar available");
      } else {
        this.log.debug("\uD83D\uDC0D LangExtract Sidecar not detected (skipping advanced extraction)");
      }
      const tokenizer = SimpleTokenizerService.getInstance();
      const files = await this.discoverFiles();
      this.log.info(`\uD83D\uDCC1 Found ${files.length} markdown files`);
      if (files.length === 0) {
        this.log.warn("\u26A0\uFE0F  No markdown files found");
        return {
          success: true,
          stats: {
            files: 0,
            nodes: 0,
            edges: 0,
            vectors: 0,
            durationSec: 0
          }
        };
      }
      const BATCH_SIZE = 10;
      let processedCount = 0;
      for (let i = 0;i < files.length; i++) {
        const filePath = files[i];
        if (!filePath)
          continue;
        if (i % BATCH_SIZE === 0) {
          this.db.beginTransaction();
        }
        await this.processFile(filePath, embedder, null, tokenizer);
        processedCount++;
        if (processedCount % 10 === 0 || processedCount === files.length) {
          const pct = Math.round(processedCount / files.length * 100);
          console.log(`  ${pct}% (${processedCount}/${files.length})`);
        }
        if ((i + 1) % BATCH_SIZE === 0 || i === files.length - 1) {
          this.db.commit();
        }
      }
      const lexicon = this.buildLexicon();
      const weaver = new EdgeWeaver(this.db, lexicon, this.config);
      console.log(`
\uD83D\uDD17 Creating edges...`);
      this.db.beginTransaction();
      for (const filePath of files) {
        if (!filePath)
          continue;
        const content = await Bun.file(filePath).text();
        const id = this.extractIdFromPath(filePath);
        weaver.weave(id, content);
      }
      this.db.commit();
      const louvainStats = weaver.getStats();
      if (louvainStats.rejected > 0) {
        this.log.info(louvainStats, "\uD83D\uDEE1\uFE0F LouvainGate stats: Edges filtered to prevent super-node collapse");
      }
      this.log.info("\uD83D\uDCBE Forcing WAL checkpoint...");
      this.db.getRawDb().run("PRAGMA wal_checkpoint(TRUNCATE);");
      const dbPath = this.db.getRawDb().filename;
      const dbFile = Bun.file(dbPath);
      if (!await dbFile.exists()) {
        throw new Error("OH-104 VIOLATION: Database file missing after checkpoint");
      }
      const finalSize = dbFile.size;
      if (finalSize === 0) {
        throw new Error("OH-104 VIOLATION: Database file is empty after checkpoint");
      }
      this.log.info(`\u2705 Pinch Check: db=${(finalSize / 1024).toFixed(1)}KB`);
      const endTime = performance.now();
      const durationSec = (endTime - startTime) / 1000;
      const stats = this.db.getStats();
      this.log.info({
        files: processedCount,
        nodes: stats.nodes,
        edges: stats.edges,
        vectors: stats.vectors,
        durationSec: durationSec.toFixed(2)
      }, "\u2705 Ingestion complete");
      return {
        success: true,
        stats: {
          files: processedCount,
          nodes: stats.nodes,
          edges: stats.edges,
          vectors: stats.vectors,
          durationSec,
          louvainStats
        }
      };
    } catch (e) {
      this.log.error({ err: e }, "\u274C Ingestion failed");
      return {
        success: false,
        stats: {
          files: 0,
          nodes: 0,
          edges: 0,
          vectors: 0,
          durationSec: 0
        }
      };
    }
  }
  async discoverFiles() {
    const files = [];
    const glob = new Glob("**/*.{md,ts,js}");
    const sources = this.config.sources || ["./docs"];
    for (const source of sources) {
      const sourcePath = join14(process.cwd(), source);
      try {
        for (const file2 of glob.scanSync(sourcePath)) {
          const shouldExclude = this.config.excludePatterns.some((pattern) => file2.includes(pattern));
          if (!shouldExclude) {
            files.push(join14(sourcePath, file2));
          }
        }
      } catch (e) {
        this.log.warn({ source: sourcePath, err: e }, "\u26A0\uFE0F  Failed to scan directory");
      }
    }
    return files;
  }
  extractIdFromPath(filePath) {
    const filename = filePath.split("/").pop() || "unknown";
    return filename.replace(/\.(md|ts|js)$/, "").toLowerCase().replace(/[^a-z0-9-]/g, "-");
  }
  buildLexicon() {
    try {
      const nodes = this.db.getNodes({ excludeContent: true });
      return nodes.map((node) => ({
        id: node.id,
        title: node.label || node.id,
        aliases: []
      }));
    } catch {
      return [];
    }
  }
  async processFile(filePath, embedder, weaver, tokenizer) {
    try {
      const rawContent = await Bun.file(filePath).text();
      const parsed = import_gray_matter.default(rawContent);
      const frontmatter = parsed.data || {};
      const content = parsed.content;
      const relativeFilePath = toRootRelative(filePath);
      const id = this.db.generateId(relativeFilePath);
      const hasher = new Bun.CryptoHasher("md5");
      hasher.update(rawContent.trim());
      const currentHash = hasher.digest("hex");
      const storedHash = this.db.getNodeHash(id);
      if (storedHash === currentHash) {
        return;
      }
      let embedding;
      if (content.length > 50) {
        embedding = await embedder.embed(content);
      }
      const tokens = tokenizer.extract(content);
      const node = {
        id,
        type: "document",
        label: frontmatter.title || relativeFilePath.split("/").pop() || id,
        domain: "knowledge",
        layer: "document",
        embedding,
        hash: currentHash,
        meta: {
          ...frontmatter,
          source: toRootRelative(filePath),
          semantic_tokens: tokens
        }
      };
      this.db.insertNode(node);
      if (weaver) {
        weaver.weave(id, content);
      }
    } catch (e) {
      this.log.warn({ err: e, file: filePath }, "\u26A0\uFE0F  Failed to process file");
    }
  }
}

// src/pipeline/PreFlightAnalyzer.ts
init_defaults();
import {
  existsSync as existsSync10,
  lstatSync,
  readdirSync,
  realpathSync,
  statSync as statSync3,
  writeFileSync as writeFileSync4
} from "fs";
import { join as join15 } from "path";
var log5 = getLogger("PreFlightAnalyzer");
var MAX_FILE_SIZE_MB = 10;
var MIN_FILE_SIZE_BYTES = 50;
var MAX_SYMLINK_DEPTH = 3;
var WARN_TOTAL_FILES = 1000;
var WARN_TOTAL_SIZE_MB = 100;

class PreFlightAnalyzer {
  config;
  visitedPaths = new Set;
  issues = [];
  constructor(config3) {
    this.config = config3;
    initAmalfaDirs();
  }
  async analyze() {
    log5.info("\uD83D\uDD0D Running pre-flight analysis...");
    const sources = this.config.sources || ["./docs"];
    const allFiles = [];
    let totalSize = 0;
    for (const source of sources) {
      const sourcePath = join15(process.cwd(), source);
      if (!existsSync10(sourcePath)) {
        this.issues.push({
          path: source,
          issue: "non_markdown",
          severity: "warning",
          details: `Source directory not found: ${sourcePath}`,
          recommendation: `Create the directory: mkdir -p ${source}`
        });
        continue;
      }
      const files = this.scanDirectory(sourcePath, sourcePath);
      allFiles.push(...files);
    }
    const validFiles = [];
    for (const file2 of allFiles) {
      const validation = this.validateFile(file2);
      if (validation.valid) {
        validFiles.push(file2);
        totalSize += validation.size;
      }
    }
    const report = {
      totalFiles: allFiles.length,
      validFiles: validFiles.length,
      skippedFiles: allFiles.length - validFiles.length,
      totalSizeBytes: totalSize,
      estimatedNodes: validFiles.length,
      issues: this.issues,
      hasErrors: this.issues.some((i) => i.severity === "error"),
      hasWarnings: this.issues.some((i) => i.severity === "warning"),
      timestamp: new Date().toISOString()
    };
    this.checkOverallHealth(report);
    this.writeReport(report);
    return report;
  }
  scanDirectory(dir, rootPath) {
    const files = [];
    try {
      const entries = readdirSync(dir, { withFileTypes: true });
      for (const entry of entries) {
        const fullPath = join15(dir, entry.name);
        if (entry.name.startsWith(".")) {
          continue;
        }
        if (entry.isDirectory()) {
          files.push(...this.scanDirectory(fullPath, rootPath));
        } else if (entry.name.endsWith(".md")) {
          files.push(fullPath);
        }
      }
    } catch (err) {
      log5.error({ dir, err }, "Failed to scan directory");
    }
    return files;
  }
  validateFile(filePath) {
    let size = 0;
    try {
      const lstat = lstatSync(filePath);
      if (lstat.isSymbolicLink()) {
        try {
          const realPath = realpathSync(filePath);
          const depth = this.getSymlinkDepth(filePath, realPath);
          if (depth > MAX_SYMLINK_DEPTH) {
            this.issues.push({
              path: filePath,
              issue: "symlink",
              severity: "warning",
              details: `Symlink depth ${depth} exceeds maximum ${MAX_SYMLINK_DEPTH}`,
              recommendation: "Copy the actual files instead of using symlinks"
            });
            return { valid: false, size: 0 };
          }
          if (this.visitedPaths.has(realPath)) {
            this.issues.push({
              path: filePath,
              issue: "circular_ref",
              severity: "error",
              details: "Circular symlink reference detected",
              recommendation: "Remove circular symlink to prevent infinite loops"
            });
            return { valid: false, size: 0 };
          }
          this.visitedPaths.add(realPath);
        } catch (_err) {
          this.issues.push({
            path: filePath,
            issue: "circular_ref",
            severity: "error",
            details: "Failed to resolve symlink (possible circular reference)",
            recommendation: "Remove problematic symlink"
          });
          return { valid: false, size: 0 };
        }
      }
      const stats = statSync3(filePath);
      size = stats.size;
      if (size === 0) {
        this.issues.push({
          path: filePath,
          issue: "empty",
          severity: "info",
          details: "Empty file (0 bytes)",
          recommendation: "Add content or remove file"
        });
        return { valid: false, size: 0 };
      }
      if (size < MIN_FILE_SIZE_BYTES) {
        this.issues.push({
          path: filePath,
          issue: "too_small",
          severity: "warning",
          details: `Very small file (${size} bytes) - may have minimal content`
        });
      }
      const sizeMB = size / 1024 / 1024;
      if (sizeMB > MAX_FILE_SIZE_MB) {
        this.issues.push({
          path: filePath,
          issue: "too_large",
          severity: "error",
          details: `File too large (${sizeMB.toFixed(1)}MB > ${MAX_FILE_SIZE_MB}MB)`,
          recommendation: [
            `Split into smaller files (< ${MAX_FILE_SIZE_MB}MB each)`,
            "Or wait for AMALFA v1.1 which will auto-split large files"
          ].join(`
`)
        });
        return { valid: false, size: 0 };
      }
      return { valid: true, size };
    } catch (err) {
      log5.error({ file: filePath, err }, "File validation error");
      this.issues.push({
        path: filePath,
        issue: "non_markdown",
        severity: "error",
        details: `Failed to read file: ${err}`
      });
      return { valid: false, size: 0 };
    }
  }
  getSymlinkDepth(symlinkPath, realPath) {
    const symParts = symlinkPath.split("/");
    const realParts = realPath.split("/");
    let commonDepth = 0;
    for (let i = 0;i < Math.min(symParts.length, realParts.length); i++) {
      if (symParts[i] === realParts[i]) {
        commonDepth++;
      } else {
        break;
      }
    }
    const symDepth = symParts.length - commonDepth;
    const realDepth = realParts.length - commonDepth;
    return Math.max(symDepth, realDepth);
  }
  checkOverallHealth(report) {
    if (report.totalFiles > WARN_TOTAL_FILES) {
      this.issues.push({
        path: "(global)",
        issue: "too_large",
        severity: "warning",
        details: `Large corpus: ${report.totalFiles} files`,
        recommendation: [
          "Consider splitting into multiple AMALFA instances",
          "Or use more specific source directories",
          `Initial ingestion may take ${Math.ceil(report.totalFiles / 13)}+ seconds`
        ].join(`
`)
      });
    }
    const totalSizeMB = report.totalSizeBytes / 1024 / 1024;
    if (totalSizeMB > WARN_TOTAL_SIZE_MB) {
      this.issues.push({
        path: "(global)",
        issue: "too_large",
        severity: "warning",
        details: `Large total size: ${totalSizeMB.toFixed(1)}MB`,
        recommendation: "Consider splitting corpus or removing large files"
      });
    }
    if (report.validFiles === 0) {
      this.issues.push({
        path: "(global)",
        issue: "empty",
        severity: "error",
        details: "No valid markdown files found in source directories",
        recommendation: [
          "Check that source directories contain .md files",
          "Verify paths in amalfa.config file"
        ].join(`
`)
      });
    }
  }
  writeReport(report) {
    const logPath = join15(process.cwd(), ".amalfa-pre-flight.log");
    const lines = [
      "===============================================",
      "AMALFA Pre-Flight Analysis Report",
      "===============================================",
      "",
      `Timestamp: ${report.timestamp}`,
      `Total files discovered: ${report.totalFiles}`,
      `Valid files: ${report.validFiles}`,
      `Skipped files: ${report.skippedFiles}`,
      `Total size: ${(report.totalSizeBytes / 1024 / 1024).toFixed(2)} MB`,
      `Estimated nodes: ${report.estimatedNodes}`,
      "",
      "Status:",
      `  Errors: ${report.issues.filter((i) => i.severity === "error").length}`,
      `  Warnings: ${report.issues.filter((i) => i.severity === "warning").length}`,
      `  Info: ${report.issues.filter((i) => i.severity === "info").length}`,
      ""
    ];
    if (report.hasErrors) {
      lines.push("\u274C ERRORS DETECTED - Ingestion will be blocked");
      lines.push("");
    } else if (report.hasWarnings) {
      lines.push("\u26A0\uFE0F  WARNINGS DETECTED - Review recommendations below");
      lines.push("");
    } else {
      lines.push("\u2705 All checks passed");
      lines.push("");
    }
    const errors5 = report.issues.filter((i) => i.severity === "error");
    const warnings = report.issues.filter((i) => i.severity === "warning");
    const info = report.issues.filter((i) => i.severity === "info");
    if (errors5.length > 0) {
      lines.push("===============================================");
      lines.push("ERRORS (Must Fix)");
      lines.push("===============================================");
      for (const issue3 of errors5) {
        lines.push("");
        lines.push(`File: ${issue3.path}`);
        lines.push(`Issue: ${issue3.issue}`);
        lines.push(`Details: ${issue3.details}`);
        if (issue3.recommendation) {
          lines.push(`Fix: ${issue3.recommendation}`);
        }
      }
      lines.push("");
    }
    if (warnings.length > 0) {
      lines.push("===============================================");
      lines.push("WARNINGS (Recommended to Fix)");
      lines.push("===============================================");
      for (const issue3 of warnings) {
        lines.push("");
        lines.push(`File: ${issue3.path}`);
        lines.push(`Issue: ${issue3.issue}`);
        lines.push(`Details: ${issue3.details}`);
        if (issue3.recommendation) {
          lines.push(`Fix: ${issue3.recommendation}`);
        }
      }
      lines.push("");
    }
    if (info.length > 0) {
      lines.push("===============================================");
      lines.push("INFO (Optional to Address)");
      lines.push("===============================================");
      for (const issue3 of info) {
        lines.push("");
        lines.push(`File: ${issue3.path}`);
        lines.push(`Details: ${issue3.details}`);
      }
      lines.push("");
    }
    lines.push("===============================================");
    lines.push("About File Size Limits");
    lines.push("===============================================");
    lines.push("");
    lines.push(`Current limit: ${MAX_FILE_SIZE_MB}MB per file`);
    lines.push("");
    lines.push("Why this limit exists:");
    lines.push("- Prevents excessive memory usage during embedding generation");
    lines.push("- Ensures good search quality (large files = poor granularity)");
    lines.push("- Maintains reasonable graph structure");
    lines.push("");
    lines.push("How to handle large files:");
    lines.push("1. Split into smaller logical sections (recommended)");
    lines.push("2. Use --force flag to override warnings (not errors)");
    lines.push("3. Wait for AMALFA v1.1 with automatic file splitting");
    lines.push("");
    lines.push("===============================================");
    lines.push("End of Report");
    lines.push("===============================================");
    try {
      writeFileSync4(logPath, lines.join(`
`), "utf8");
      log5.info({ path: logPath }, "Pre-flight report written");
    } catch (err) {
      log5.error({ err }, "Failed to write pre-flight report");
    }
  }
}

// src/utils/StatsTracker.ts
init_defaults();
import { existsSync as existsSync11, mkdirSync as mkdirSync4 } from "fs";
import { join as join16 } from "path";

class StatsTracker {
  statsFile;
  constructor() {
    this.statsFile = join16(AMALFA_DIRS.base, "stats-history.json");
  }
  loadHistory() {
    if (!existsSync11(this.statsFile)) {
      return {
        snapshots: [],
        created: new Date().toISOString(),
        lastUpdated: new Date().toISOString()
      };
    }
    try {
      const content = Bun.file(this.statsFile).text();
      return JSON.parse(content);
    } catch {
      return {
        snapshots: [],
        created: new Date().toISOString(),
        lastUpdated: new Date().toISOString()
      };
    }
  }
  async saveHistory(history) {
    if (!existsSync11(AMALFA_DIRS.base)) {
      mkdirSync4(AMALFA_DIRS.base, { recursive: true });
    }
    await Bun.write(this.statsFile, JSON.stringify(history, null, 2));
  }
  async recordSnapshot(snapshot) {
    const history = this.loadHistory();
    if (!snapshot.timestamp) {
      snapshot.timestamp = new Date().toISOString();
    }
    history.snapshots.push(snapshot);
    history.lastUpdated = snapshot.timestamp;
    if (history.snapshots.length > 100) {
      history.snapshots = history.snapshots.slice(-100);
    }
    await this.saveHistory(history);
  }
  getLatestSnapshot() {
    const history = this.loadHistory();
    return history.snapshots.length > 0 ? history.snapshots[history.snapshots.length - 1] ?? null : null;
  }
  getAllSnapshots() {
    const history = this.loadHistory();
    return history.snapshots;
  }
  validate(current) {
    const warnings = [];
    const errors5 = [];
    if (current.nodes === 0) {
      errors5.push("Database has 0 nodes - database is empty");
    }
    if (current.embeddings === 0) {
      errors5.push("Database has 0 embeddings - vector search will not work");
    }
    const latest = this.getLatestSnapshot() ?? null;
    if (latest) {
      if (current.nodes < latest.nodes * 0.8) {
        warnings.push(`Node count decreased significantly: ${latest.nodes} \u2192 ${current.nodes} (-${Math.round((latest.nodes - current.nodes) / latest.nodes * 100)}%)`);
      }
      if (current.edges < latest.edges * 0.8) {
        warnings.push(`Edge count decreased significantly: ${latest.edges} \u2192 ${current.edges} (-${Math.round((latest.edges - current.edges) / latest.edges * 100)}%)`);
      }
      if (current.nodes === latest.nodes && current.edges === latest.edges) {
        warnings.push("No growth in nodes or edges since last snapshot - is documentation being updated?");
      }
    }
    const edgeDensity = current.nodes > 0 ? current.edges / current.nodes : 0;
    if (edgeDensity < 0.1) {
      warnings.push(`Low edge density: ${edgeDensity.toFixed(2)} edges per node - documents may be poorly linked`);
    }
    if (current.embeddings < current.nodes * 0.9) {
      warnings.push(`Only ${Math.round(current.embeddings / current.nodes * 100)}% of nodes have embeddings - some nodes may not be searchable`);
    }
    return {
      valid: errors5.length === 0,
      warnings,
      errors: errors5
    };
  }
  getStatsFilePath() {
    return this.statsFile;
  }
  getSummary() {
    const history = this.loadHistory();
    if (history.snapshots.length === 0) {
      return "No historical data available";
    }
    const latest = history.snapshots[history.snapshots.length - 1] ?? null;
    const oldest = history.snapshots[0] ?? null;
    if (!latest || !oldest) {
      return "Insufficient data for growth summary";
    }
    const nodeGrowth = latest.nodes - oldest.nodes;
    const edgeGrowth = latest.edges - oldest.edges;
    const summary = [
      "\uD83D\uDCC8 Database Growth Summary",
      `   First snapshot: ${new Date(oldest.timestamp).toLocaleString()}`,
      `   Latest snapshot: ${new Date(latest.timestamp).toLocaleString()}`,
      `   Total snapshots: ${history.snapshots.length}`,
      "",
      "\uD83D\uDCCA Current State:",
      `   Nodes: ${latest.nodes} (${nodeGrowth >= 0 ? "+" : ""}${nodeGrowth} from first)`,
      `   Edges: ${latest.edges} (${edgeGrowth >= 0 ? "+" : ""}${edgeGrowth} from first)`,
      `   Embeddings: ${latest.embeddings}`,
      `   Database size: ${latest.dbSizeMB.toFixed(2)} MB`
    ];
    return summary.join(`
`);
  }
}

// src/cli/commands/init.ts
var VERSION = package_default.version;
async function cmdInit(args) {
  console.log(`\uD83D\uDE80 AMALFA Initialization
`);
  const forceMode = args.includes("--force");
  const config3 = await loadConfig();
  const sources = config3.sources || ["./docs"];
  console.log(`\uD83D\uDCC1 Sources: ${sources.join(", ")}`);
  console.log(`\uD83D\uDCBE Database: ${config3.database}`);
  console.log(`\uD83E\uDDE0 Model: ${config3.embeddings.model}
`);
  console.log(`\uD83D\uDD0D Running pre-flight analysis...
`);
  const analyzer = new PreFlightAnalyzer(config3);
  const report = await analyzer.analyze();
  console.log("\uD83D\uDCCA Pre-Flight Summary:");
  console.log(`  Total files: ${report.totalFiles}`);
  console.log(`  Valid files: ${report.validFiles}`);
  console.log(`  Skipped files: ${report.skippedFiles}`);
  console.log(`  Total size: ${(report.totalSizeBytes / 1024 / 1024).toFixed(2)} MB`);
  console.log(`  Estimated nodes: ${report.estimatedNodes}
`);
  if (report.hasErrors) {
    console.error(`\u274C Pre-flight check failed with errors
`);
    console.error("Errors detected:");
    for (const issue3 of report.issues.filter((i) => i.severity === "error")) {
      console.error(`  - ${issue3.path}: ${issue3.details}`);
    }
    console.error(`
See .amalfa/logs/pre-flight.log for details and recommendations`);
    console.error(`
Fix these issues and try again.`);
    process.exit(1);
  }
  if (report.hasWarnings && !forceMode) {
    console.warn(`\u26A0\uFE0F  Pre-flight check completed with warnings
`);
    console.warn("Warnings detected:");
    for (const issue3 of report.issues.filter((i) => i.severity === "warning")) {
      console.warn(`  - ${issue3.path}: ${issue3.details}`);
    }
    console.warn(`
See .amalfa/logs/pre-flight.log for recommendations`);
    console.warn(`
To proceed anyway, use: amalfa init --force`);
    process.exit(1);
  }
  if (report.validFiles === 0) {
    console.error(`
\u274C No valid markdown files found`);
    console.error("See .amalfa/logs/pre-flight.log for details");
    process.exit(1);
  }
  if (forceMode && report.hasWarnings) {
    console.warn(`\u26A0\uFE0F  Proceeding with --force despite warnings
`);
  }
  const amalfaDir = join17(process.cwd(), ".amalfa");
  if (!existsSync12(amalfaDir)) {
    console.log(`\uD83D\uDCC2 Creating directory: ${amalfaDir}`);
    mkdirSync5(amalfaDir, { recursive: true });
  }
  const dbPath = join17(process.cwd(), config3.database);
  console.log(`\uD83D\uDDC4\uFE0F  Initializing database: ${dbPath}
`);
  try {
    const db = new ResonanceDB(dbPath);
    const ingestor = new AmalfaIngestor(config3, db);
    const result = await ingestor.ingest();
    db.close();
    if (result.success) {
      const tracker = new StatsTracker;
      const fileSize = statSync4(dbPath).size;
      const dbSizeMB = fileSize / 1024 / 1024;
      await tracker.recordSnapshot({
        timestamp: new Date().toISOString(),
        nodes: result.stats.nodes,
        edges: result.stats.edges,
        embeddings: result.stats.vectors,
        dbSizeMB,
        version: VERSION
      });
      console.log(`
\u2705 Initialization complete!`);
      console.log(`
\uD83D\uDCCA Summary:`);
      console.log(`  Files processed: ${result.stats.files}`);
      console.log(`  Nodes created: ${result.stats.nodes}`);
      console.log(`  Edges created: ${result.stats.edges}`);
      console.log(`  Embeddings: ${result.stats.vectors}`);
      console.log(`  Duration: ${result.stats.durationSec.toFixed(2)}s
`);
      console.log(`\uD83D\uDCCA Snapshot saved to: .amalfa/stats-history.json
`);
      console.log("Next steps:");
      console.log("  amalfa serve     # Start MCP server");
      console.log("  amalfa daemon    # Watch for file changes (coming soon)");
    } else {
      console.error(`
\u274C Initialization failed`);
      process.exit(1);
    }
  } catch (error49) {
    console.error(`
\u274C Initialization failed:`, error49);
    process.exit(1);
  }
}

// src/cli/commands/inject-tags.ts
import { existsSync as existsSync14 } from "fs";
import { resolve as resolve3 } from "path";

// src/utils/TagInjector.ts
import { existsSync as existsSync13, readFileSync as readFileSync5, writeFileSync as writeFileSync5 } from "fs";
var log6 = getLogger("TagInjector");
function injectTag(filePath, relation, targetId) {
  if (!existsSync13(filePath)) {
    log6.error({ filePath }, "File not found for tag injection");
    return false;
  }
  try {
    let content = readFileSync5(filePath, "utf-8");
    const tagString = `[${relation.toUpperCase()}: ${targetId}]`;
    if (content.includes(tagString)) {
      return true;
    }
    const tagBlockRegex = /<!-- tags: (.*?) -->/;
    const match = content.match(tagBlockRegex);
    if (match) {
      const oldBlock = match[0];
      const innerTags = match[1];
      const newBlock = `<!-- tags: ${innerTags} ${tagString} -->`;
      content = content.replace(oldBlock, newBlock);
    } else {
      const frontmatterRegex = /^---\n[\s\S]*?\n---\n/;
      const fmMatch = content.match(frontmatterRegex);
      const newTagBlock = `
<!-- tags: ${tagString} -->
`;
      if (fmMatch) {
        content = content.replace(fmMatch[0], fmMatch[0] + newTagBlock);
      } else {
        content = newTagBlock + content;
      }
    }
    writeFileSync5(filePath, content, "utf-8");
    return true;
  } catch (error49) {
    log6.error({ error: error49, filePath }, "Failed to inject tag");
    return false;
  }
}

// src/cli/commands/inject-tags.ts
async function cmdInjectTags(args) {
  const filePath = args.find((arg) => !arg.startsWith("--"));
  const tags = args.filter((arg) => !arg.startsWith("--") && arg !== filePath);
  const jsonOutput = args.includes("--json");
  if (!filePath) {
    if (jsonOutput) {
      console.error(JSON.stringify({
        error: "Missing file path argument",
        usage: "amalfa inject-tags <file-path> <tag1> [tag2...] [--json]"
      }));
    } else {
      console.error("\u274C Error: Missing file path argument");
      console.error(`
Usage: amalfa inject-tags <file-path> <tag1> [tag2...] [--json]`);
      console.error(`
Examples:`);
      console.error('  amalfa inject-tags docs/auth.md "authentication" "security"');
      console.error("  amalfa inject-tags playbooks/oauth.md oauth patterns");
      console.error('  amalfa inject-tags docs/auth.md "tutorial" --json');
    }
    process.exit(1);
  }
  if (tags.length === 0) {
    if (jsonOutput) {
      console.error(JSON.stringify({
        error: "No tags provided",
        usage: "amalfa inject-tags <file-path> <tag1> [tag2...]"
      }));
    } else {
      console.error("\u274C Error: No tags provided");
      console.error(`
Provide at least one tag to inject`);
    }
    process.exit(1);
  }
  const absolutePath = resolve3(process.cwd(), filePath);
  if (!existsSync14(absolutePath)) {
    if (jsonOutput) {
      console.error(JSON.stringify({
        error: "File not found",
        path: absolutePath
      }));
    } else {
      console.error(`\u274C File not found: ${absolutePath}`);
    }
    process.exit(1);
  }
  if (!absolutePath.endsWith(".md")) {
    if (jsonOutput) {
      console.error(JSON.stringify({
        error: "Not a markdown file",
        path: absolutePath,
        suggestion: "inject-tags only works with .md files"
      }));
    } else {
      console.error("\u274C Not a markdown file");
      console.error("inject-tags only works with .md files");
    }
    process.exit(1);
  }
  try {
    let successCount = 0;
    for (const tag of tags) {
      const success2 = injectTag(absolutePath, "tag", tag);
      if (success2) {
        successCount++;
      }
    }
    if (jsonOutput) {
      console.log(JSON.stringify({
        success: true,
        file: absolutePath,
        tags_injected: successCount,
        tags
      }));
    } else {
      console.log(`
\u2705 Successfully injected ${successCount} tag(s) into: ${filePath}`);
      console.log(`
Tags:`);
      for (const tag of tags) {
        console.log(`  \u2022 ${tag}`);
      }
      console.log(`
\uD83D\uDCA1 Tip: Re-run 'amalfa init' to index the updated metadata
`);
    }
  } catch (error49) {
    if (jsonOutput) {
      console.error(JSON.stringify({
        error: error49 instanceof Error ? error49.message : String(error49),
        file: absolutePath
      }));
    } else {
      console.error("\u274C Tag injection failed:", error49 instanceof Error ? error49.message : error49);
    }
    process.exit(1);
  }
}

// src/cli/commands/list-sources.ts
init_defaults();
async function cmdListSources(args) {
  const jsonOutput = args.includes("--json");
  try {
    const config3 = await loadConfig();
    const sources = config3.sources || ["./docs"];
    if (jsonOutput) {
      console.log(JSON.stringify({ sources }, null, 2));
    } else {
      console.log(`
\uD83D\uDCC1 Configured Source Directories:
`);
      for (const source of sources) {
        console.log(`  \u2022 ${source}`);
      }
      console.log(`
\uD83D\uDCA1 Sources are defined in amalfa.config.json or defaults to ./docs
`);
    }
  } catch (error49) {
    if (jsonOutput) {
      console.error(JSON.stringify({
        error: error49 instanceof Error ? error49.message : String(error49)
      }));
    } else {
      console.error("\u274C Failed to load config:", error49 instanceof Error ? error49.message : error49);
    }
    process.exit(1);
  }
}

// node_modules/graphology/dist/graphology.mjs
import { EventEmitter } from "events";
function assignPolyfill() {
  const target = arguments[0];
  for (let i = 1, l = arguments.length;i < l; i++) {
    if (!arguments[i])
      continue;
    for (const k in arguments[i])
      target[k] = arguments[i][k];
  }
  return target;
}
var assign = assignPolyfill;
if (typeof Object.assign === "function")
  assign = Object.assign;
function getMatchingEdge(graph, source, target, type) {
  const sourceData = graph._nodes.get(source);
  let edge = null;
  if (!sourceData)
    return edge;
  if (type === "mixed") {
    edge = sourceData.out && sourceData.out[target] || sourceData.undirected && sourceData.undirected[target];
  } else if (type === "directed") {
    edge = sourceData.out && sourceData.out[target];
  } else {
    edge = sourceData.undirected && sourceData.undirected[target];
  }
  return edge;
}
function isPlainObject4(value) {
  return typeof value === "object" && value !== null;
}
function isEmpty(o) {
  let k;
  for (k in o)
    return false;
  return true;
}
function privateProperty(target, name, value) {
  Object.defineProperty(target, name, {
    enumerable: false,
    configurable: false,
    writable: true,
    value
  });
}
function readOnlyProperty(target, name, value) {
  const descriptor = {
    enumerable: true,
    configurable: true
  };
  if (typeof value === "function") {
    descriptor.get = value;
  } else {
    descriptor.value = value;
    descriptor.writable = false;
  }
  Object.defineProperty(target, name, descriptor);
}
function validateHints(hints) {
  if (!isPlainObject4(hints))
    return false;
  if (hints.attributes && !Array.isArray(hints.attributes))
    return false;
  return true;
}
function incrementalIdStartingFromRandomByte() {
  let i = Math.floor(Math.random() * 256) & 255;
  return () => {
    return i++;
  };
}
function chain() {
  const iterables = arguments;
  let current = null;
  let i = -1;
  return {
    [Symbol.iterator]() {
      return this;
    },
    next() {
      let step = null;
      do {
        if (current === null) {
          i++;
          if (i >= iterables.length)
            return { done: true };
          current = iterables[i][Symbol.iterator]();
        }
        step = current.next();
        if (step.done) {
          current = null;
          continue;
        }
        break;
      } while (true);
      return step;
    }
  };
}
function emptyIterator() {
  return {
    [Symbol.iterator]() {
      return this;
    },
    next() {
      return { done: true };
    }
  };
}

class GraphError extends Error {
  constructor(message) {
    super();
    this.name = "GraphError";
    this.message = message;
  }
}

class InvalidArgumentsGraphError extends GraphError {
  constructor(message) {
    super(message);
    this.name = "InvalidArgumentsGraphError";
    if (typeof Error.captureStackTrace === "function")
      Error.captureStackTrace(this, InvalidArgumentsGraphError.prototype.constructor);
  }
}

class NotFoundGraphError extends GraphError {
  constructor(message) {
    super(message);
    this.name = "NotFoundGraphError";
    if (typeof Error.captureStackTrace === "function")
      Error.captureStackTrace(this, NotFoundGraphError.prototype.constructor);
  }
}

class UsageGraphError extends GraphError {
  constructor(message) {
    super(message);
    this.name = "UsageGraphError";
    if (typeof Error.captureStackTrace === "function")
      Error.captureStackTrace(this, UsageGraphError.prototype.constructor);
  }
}
function MixedNodeData(key, attributes) {
  this.key = key;
  this.attributes = attributes;
  this.clear();
}
MixedNodeData.prototype.clear = function() {
  this.inDegree = 0;
  this.outDegree = 0;
  this.undirectedDegree = 0;
  this.undirectedLoops = 0;
  this.directedLoops = 0;
  this.in = {};
  this.out = {};
  this.undirected = {};
};
function DirectedNodeData(key, attributes) {
  this.key = key;
  this.attributes = attributes;
  this.clear();
}
DirectedNodeData.prototype.clear = function() {
  this.inDegree = 0;
  this.outDegree = 0;
  this.directedLoops = 0;
  this.in = {};
  this.out = {};
};
function UndirectedNodeData(key, attributes) {
  this.key = key;
  this.attributes = attributes;
  this.clear();
}
UndirectedNodeData.prototype.clear = function() {
  this.undirectedDegree = 0;
  this.undirectedLoops = 0;
  this.undirected = {};
};
function EdgeData(undirected, key, source, target, attributes) {
  this.key = key;
  this.attributes = attributes;
  this.undirected = undirected;
  this.source = source;
  this.target = target;
}
EdgeData.prototype.attach = function() {
  let outKey = "out";
  let inKey = "in";
  if (this.undirected)
    outKey = inKey = "undirected";
  const source = this.source.key;
  const target = this.target.key;
  this.source[outKey][target] = this;
  if (this.undirected && source === target)
    return;
  this.target[inKey][source] = this;
};
EdgeData.prototype.attachMulti = function() {
  let outKey = "out";
  let inKey = "in";
  const source = this.source.key;
  const target = this.target.key;
  if (this.undirected)
    outKey = inKey = "undirected";
  const adj = this.source[outKey];
  const head = adj[target];
  if (typeof head === "undefined") {
    adj[target] = this;
    if (!(this.undirected && source === target)) {
      this.target[inKey][source] = this;
    }
    return;
  }
  head.previous = this;
  this.next = head;
  adj[target] = this;
  this.target[inKey][source] = this;
};
EdgeData.prototype.detach = function() {
  const source = this.source.key;
  const target = this.target.key;
  let outKey = "out";
  let inKey = "in";
  if (this.undirected)
    outKey = inKey = "undirected";
  delete this.source[outKey][target];
  delete this.target[inKey][source];
};
EdgeData.prototype.detachMulti = function() {
  const source = this.source.key;
  const target = this.target.key;
  let outKey = "out";
  let inKey = "in";
  if (this.undirected)
    outKey = inKey = "undirected";
  if (this.previous === undefined) {
    if (this.next === undefined) {
      delete this.source[outKey][target];
      delete this.target[inKey][source];
    } else {
      this.next.previous = undefined;
      this.source[outKey][target] = this.next;
      this.target[inKey][source] = this.next;
    }
  } else {
    this.previous.next = this.next;
    if (this.next !== undefined) {
      this.next.previous = this.previous;
    }
  }
};
var NODE = 0;
var SOURCE = 1;
var TARGET = 2;
var OPPOSITE = 3;
function findRelevantNodeData(graph, method, mode, nodeOrEdge, nameOrEdge, add1, add2) {
  let nodeData, edgeData, arg1, arg2;
  nodeOrEdge = "" + nodeOrEdge;
  if (mode === NODE) {
    nodeData = graph._nodes.get(nodeOrEdge);
    if (!nodeData)
      throw new NotFoundGraphError(`Graph.${method}: could not find the "${nodeOrEdge}" node in the graph.`);
    arg1 = nameOrEdge;
    arg2 = add1;
  } else if (mode === OPPOSITE) {
    nameOrEdge = "" + nameOrEdge;
    edgeData = graph._edges.get(nameOrEdge);
    if (!edgeData)
      throw new NotFoundGraphError(`Graph.${method}: could not find the "${nameOrEdge}" edge in the graph.`);
    const source = edgeData.source.key;
    const target = edgeData.target.key;
    if (nodeOrEdge === source) {
      nodeData = edgeData.target;
    } else if (nodeOrEdge === target) {
      nodeData = edgeData.source;
    } else {
      throw new NotFoundGraphError(`Graph.${method}: the "${nodeOrEdge}" node is not attached to the "${nameOrEdge}" edge (${source}, ${target}).`);
    }
    arg1 = add1;
    arg2 = add2;
  } else {
    edgeData = graph._edges.get(nodeOrEdge);
    if (!edgeData)
      throw new NotFoundGraphError(`Graph.${method}: could not find the "${nodeOrEdge}" edge in the graph.`);
    if (mode === SOURCE) {
      nodeData = edgeData.source;
    } else {
      nodeData = edgeData.target;
    }
    arg1 = nameOrEdge;
    arg2 = add1;
  }
  return [nodeData, arg1, arg2];
}
function attachNodeAttributeGetter(Class3, method, mode) {
  Class3.prototype[method] = function(nodeOrEdge, nameOrEdge, add1) {
    const [data, name] = findRelevantNodeData(this, method, mode, nodeOrEdge, nameOrEdge, add1);
    return data.attributes[name];
  };
}
function attachNodeAttributesGetter(Class3, method, mode) {
  Class3.prototype[method] = function(nodeOrEdge, nameOrEdge) {
    const [data] = findRelevantNodeData(this, method, mode, nodeOrEdge, nameOrEdge);
    return data.attributes;
  };
}
function attachNodeAttributeChecker(Class3, method, mode) {
  Class3.prototype[method] = function(nodeOrEdge, nameOrEdge, add1) {
    const [data, name] = findRelevantNodeData(this, method, mode, nodeOrEdge, nameOrEdge, add1);
    return data.attributes.hasOwnProperty(name);
  };
}
function attachNodeAttributeSetter(Class3, method, mode) {
  Class3.prototype[method] = function(nodeOrEdge, nameOrEdge, add1, add2) {
    const [data, name, value] = findRelevantNodeData(this, method, mode, nodeOrEdge, nameOrEdge, add1, add2);
    data.attributes[name] = value;
    this.emit("nodeAttributesUpdated", {
      key: data.key,
      type: "set",
      attributes: data.attributes,
      name
    });
    return this;
  };
}
function attachNodeAttributeUpdater(Class3, method, mode) {
  Class3.prototype[method] = function(nodeOrEdge, nameOrEdge, add1, add2) {
    const [data, name, updater] = findRelevantNodeData(this, method, mode, nodeOrEdge, nameOrEdge, add1, add2);
    if (typeof updater !== "function")
      throw new InvalidArgumentsGraphError(`Graph.${method}: updater should be a function.`);
    const attributes = data.attributes;
    const value = updater(attributes[name]);
    attributes[name] = value;
    this.emit("nodeAttributesUpdated", {
      key: data.key,
      type: "set",
      attributes: data.attributes,
      name
    });
    return this;
  };
}
function attachNodeAttributeRemover(Class3, method, mode) {
  Class3.prototype[method] = function(nodeOrEdge, nameOrEdge, add1) {
    const [data, name] = findRelevantNodeData(this, method, mode, nodeOrEdge, nameOrEdge, add1);
    delete data.attributes[name];
    this.emit("nodeAttributesUpdated", {
      key: data.key,
      type: "remove",
      attributes: data.attributes,
      name
    });
    return this;
  };
}
function attachNodeAttributesReplacer(Class3, method, mode) {
  Class3.prototype[method] = function(nodeOrEdge, nameOrEdge, add1) {
    const [data, attributes] = findRelevantNodeData(this, method, mode, nodeOrEdge, nameOrEdge, add1);
    if (!isPlainObject4(attributes))
      throw new InvalidArgumentsGraphError(`Graph.${method}: provided attributes are not a plain object.`);
    data.attributes = attributes;
    this.emit("nodeAttributesUpdated", {
      key: data.key,
      type: "replace",
      attributes: data.attributes
    });
    return this;
  };
}
function attachNodeAttributesMerger(Class3, method, mode) {
  Class3.prototype[method] = function(nodeOrEdge, nameOrEdge, add1) {
    const [data, attributes] = findRelevantNodeData(this, method, mode, nodeOrEdge, nameOrEdge, add1);
    if (!isPlainObject4(attributes))
      throw new InvalidArgumentsGraphError(`Graph.${method}: provided attributes are not a plain object.`);
    assign(data.attributes, attributes);
    this.emit("nodeAttributesUpdated", {
      key: data.key,
      type: "merge",
      attributes: data.attributes,
      data: attributes
    });
    return this;
  };
}
function attachNodeAttributesUpdater(Class3, method, mode) {
  Class3.prototype[method] = function(nodeOrEdge, nameOrEdge, add1) {
    const [data, updater] = findRelevantNodeData(this, method, mode, nodeOrEdge, nameOrEdge, add1);
    if (typeof updater !== "function")
      throw new InvalidArgumentsGraphError(`Graph.${method}: provided updater is not a function.`);
    data.attributes = updater(data.attributes);
    this.emit("nodeAttributesUpdated", {
      key: data.key,
      type: "update",
      attributes: data.attributes
    });
    return this;
  };
}
var NODE_ATTRIBUTES_METHODS = [
  {
    name: (element) => `get${element}Attribute`,
    attacher: attachNodeAttributeGetter
  },
  {
    name: (element) => `get${element}Attributes`,
    attacher: attachNodeAttributesGetter
  },
  {
    name: (element) => `has${element}Attribute`,
    attacher: attachNodeAttributeChecker
  },
  {
    name: (element) => `set${element}Attribute`,
    attacher: attachNodeAttributeSetter
  },
  {
    name: (element) => `update${element}Attribute`,
    attacher: attachNodeAttributeUpdater
  },
  {
    name: (element) => `remove${element}Attribute`,
    attacher: attachNodeAttributeRemover
  },
  {
    name: (element) => `replace${element}Attributes`,
    attacher: attachNodeAttributesReplacer
  },
  {
    name: (element) => `merge${element}Attributes`,
    attacher: attachNodeAttributesMerger
  },
  {
    name: (element) => `update${element}Attributes`,
    attacher: attachNodeAttributesUpdater
  }
];
function attachNodeAttributesMethods(Graph) {
  NODE_ATTRIBUTES_METHODS.forEach(function({ name, attacher }) {
    attacher(Graph, name("Node"), NODE);
    attacher(Graph, name("Source"), SOURCE);
    attacher(Graph, name("Target"), TARGET);
    attacher(Graph, name("Opposite"), OPPOSITE);
  });
}
function attachEdgeAttributeGetter(Class3, method, type) {
  Class3.prototype[method] = function(element, name) {
    let data;
    if (this.type !== "mixed" && type !== "mixed" && type !== this.type)
      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);
    if (arguments.length > 2) {
      if (this.multi)
        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);
      const source = "" + element;
      const target = "" + name;
      name = arguments[2];
      data = getMatchingEdge(this, source, target, type);
      if (!data)
        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`);
    } else {
      if (type !== "mixed")
        throw new UsageGraphError(`Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);
      element = "" + element;
      data = this._edges.get(element);
      if (!data)
        throw new NotFoundGraphError(`Graph.${method}: could not find the "${element}" edge in the graph.`);
    }
    return data.attributes[name];
  };
}
function attachEdgeAttributesGetter(Class3, method, type) {
  Class3.prototype[method] = function(element) {
    let data;
    if (this.type !== "mixed" && type !== "mixed" && type !== this.type)
      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);
    if (arguments.length > 1) {
      if (this.multi)
        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);
      const source = "" + element, target = "" + arguments[1];
      data = getMatchingEdge(this, source, target, type);
      if (!data)
        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`);
    } else {
      if (type !== "mixed")
        throw new UsageGraphError(`Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);
      element = "" + element;
      data = this._edges.get(element);
      if (!data)
        throw new NotFoundGraphError(`Graph.${method}: could not find the "${element}" edge in the graph.`);
    }
    return data.attributes;
  };
}
function attachEdgeAttributeChecker(Class3, method, type) {
  Class3.prototype[method] = function(element, name) {
    let data;
    if (this.type !== "mixed" && type !== "mixed" && type !== this.type)
      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);
    if (arguments.length > 2) {
      if (this.multi)
        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);
      const source = "" + element;
      const target = "" + name;
      name = arguments[2];
      data = getMatchingEdge(this, source, target, type);
      if (!data)
        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`);
    } else {
      if (type !== "mixed")
        throw new UsageGraphError(`Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);
      element = "" + element;
      data = this._edges.get(element);
      if (!data)
        throw new NotFoundGraphError(`Graph.${method}: could not find the "${element}" edge in the graph.`);
    }
    return data.attributes.hasOwnProperty(name);
  };
}
function attachEdgeAttributeSetter(Class3, method, type) {
  Class3.prototype[method] = function(element, name, value) {
    let data;
    if (this.type !== "mixed" && type !== "mixed" && type !== this.type)
      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);
    if (arguments.length > 3) {
      if (this.multi)
        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);
      const source = "" + element;
      const target = "" + name;
      name = arguments[2];
      value = arguments[3];
      data = getMatchingEdge(this, source, target, type);
      if (!data)
        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`);
    } else {
      if (type !== "mixed")
        throw new UsageGraphError(`Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);
      element = "" + element;
      data = this._edges.get(element);
      if (!data)
        throw new NotFoundGraphError(`Graph.${method}: could not find the "${element}" edge in the graph.`);
    }
    data.attributes[name] = value;
    this.emit("edgeAttributesUpdated", {
      key: data.key,
      type: "set",
      attributes: data.attributes,
      name
    });
    return this;
  };
}
function attachEdgeAttributeUpdater(Class3, method, type) {
  Class3.prototype[method] = function(element, name, updater) {
    let data;
    if (this.type !== "mixed" && type !== "mixed" && type !== this.type)
      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);
    if (arguments.length > 3) {
      if (this.multi)
        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);
      const source = "" + element;
      const target = "" + name;
      name = arguments[2];
      updater = arguments[3];
      data = getMatchingEdge(this, source, target, type);
      if (!data)
        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`);
    } else {
      if (type !== "mixed")
        throw new UsageGraphError(`Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);
      element = "" + element;
      data = this._edges.get(element);
      if (!data)
        throw new NotFoundGraphError(`Graph.${method}: could not find the "${element}" edge in the graph.`);
    }
    if (typeof updater !== "function")
      throw new InvalidArgumentsGraphError(`Graph.${method}: updater should be a function.`);
    data.attributes[name] = updater(data.attributes[name]);
    this.emit("edgeAttributesUpdated", {
      key: data.key,
      type: "set",
      attributes: data.attributes,
      name
    });
    return this;
  };
}
function attachEdgeAttributeRemover(Class3, method, type) {
  Class3.prototype[method] = function(element, name) {
    let data;
    if (this.type !== "mixed" && type !== "mixed" && type !== this.type)
      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);
    if (arguments.length > 2) {
      if (this.multi)
        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);
      const source = "" + element;
      const target = "" + name;
      name = arguments[2];
      data = getMatchingEdge(this, source, target, type);
      if (!data)
        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`);
    } else {
      if (type !== "mixed")
        throw new UsageGraphError(`Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);
      element = "" + element;
      data = this._edges.get(element);
      if (!data)
        throw new NotFoundGraphError(`Graph.${method}: could not find the "${element}" edge in the graph.`);
    }
    delete data.attributes[name];
    this.emit("edgeAttributesUpdated", {
      key: data.key,
      type: "remove",
      attributes: data.attributes,
      name
    });
    return this;
  };
}
function attachEdgeAttributesReplacer(Class3, method, type) {
  Class3.prototype[method] = function(element, attributes) {
    let data;
    if (this.type !== "mixed" && type !== "mixed" && type !== this.type)
      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);
    if (arguments.length > 2) {
      if (this.multi)
        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);
      const source = "" + element, target = "" + attributes;
      attributes = arguments[2];
      data = getMatchingEdge(this, source, target, type);
      if (!data)
        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`);
    } else {
      if (type !== "mixed")
        throw new UsageGraphError(`Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);
      element = "" + element;
      data = this._edges.get(element);
      if (!data)
        throw new NotFoundGraphError(`Graph.${method}: could not find the "${element}" edge in the graph.`);
    }
    if (!isPlainObject4(attributes))
      throw new InvalidArgumentsGraphError(`Graph.${method}: provided attributes are not a plain object.`);
    data.attributes = attributes;
    this.emit("edgeAttributesUpdated", {
      key: data.key,
      type: "replace",
      attributes: data.attributes
    });
    return this;
  };
}
function attachEdgeAttributesMerger(Class3, method, type) {
  Class3.prototype[method] = function(element, attributes) {
    let data;
    if (this.type !== "mixed" && type !== "mixed" && type !== this.type)
      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);
    if (arguments.length > 2) {
      if (this.multi)
        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);
      const source = "" + element, target = "" + attributes;
      attributes = arguments[2];
      data = getMatchingEdge(this, source, target, type);
      if (!data)
        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`);
    } else {
      if (type !== "mixed")
        throw new UsageGraphError(`Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);
      element = "" + element;
      data = this._edges.get(element);
      if (!data)
        throw new NotFoundGraphError(`Graph.${method}: could not find the "${element}" edge in the graph.`);
    }
    if (!isPlainObject4(attributes))
      throw new InvalidArgumentsGraphError(`Graph.${method}: provided attributes are not a plain object.`);
    assign(data.attributes, attributes);
    this.emit("edgeAttributesUpdated", {
      key: data.key,
      type: "merge",
      attributes: data.attributes,
      data: attributes
    });
    return this;
  };
}
function attachEdgeAttributesUpdater(Class3, method, type) {
  Class3.prototype[method] = function(element, updater) {
    let data;
    if (this.type !== "mixed" && type !== "mixed" && type !== this.type)
      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);
    if (arguments.length > 2) {
      if (this.multi)
        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);
      const source = "" + element, target = "" + updater;
      updater = arguments[2];
      data = getMatchingEdge(this, source, target, type);
      if (!data)
        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`);
    } else {
      if (type !== "mixed")
        throw new UsageGraphError(`Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);
      element = "" + element;
      data = this._edges.get(element);
      if (!data)
        throw new NotFoundGraphError(`Graph.${method}: could not find the "${element}" edge in the graph.`);
    }
    if (typeof updater !== "function")
      throw new InvalidArgumentsGraphError(`Graph.${method}: provided updater is not a function.`);
    data.attributes = updater(data.attributes);
    this.emit("edgeAttributesUpdated", {
      key: data.key,
      type: "update",
      attributes: data.attributes
    });
    return this;
  };
}
var EDGE_ATTRIBUTES_METHODS = [
  {
    name: (element) => `get${element}Attribute`,
    attacher: attachEdgeAttributeGetter
  },
  {
    name: (element) => `get${element}Attributes`,
    attacher: attachEdgeAttributesGetter
  },
  {
    name: (element) => `has${element}Attribute`,
    attacher: attachEdgeAttributeChecker
  },
  {
    name: (element) => `set${element}Attribute`,
    attacher: attachEdgeAttributeSetter
  },
  {
    name: (element) => `update${element}Attribute`,
    attacher: attachEdgeAttributeUpdater
  },
  {
    name: (element) => `remove${element}Attribute`,
    attacher: attachEdgeAttributeRemover
  },
  {
    name: (element) => `replace${element}Attributes`,
    attacher: attachEdgeAttributesReplacer
  },
  {
    name: (element) => `merge${element}Attributes`,
    attacher: attachEdgeAttributesMerger
  },
  {
    name: (element) => `update${element}Attributes`,
    attacher: attachEdgeAttributesUpdater
  }
];
function attachEdgeAttributesMethods(Graph) {
  EDGE_ATTRIBUTES_METHODS.forEach(function({ name, attacher }) {
    attacher(Graph, name("Edge"), "mixed");
    attacher(Graph, name("DirectedEdge"), "directed");
    attacher(Graph, name("UndirectedEdge"), "undirected");
  });
}
var EDGES_ITERATION = [
  {
    name: "edges",
    type: "mixed"
  },
  {
    name: "inEdges",
    type: "directed",
    direction: "in"
  },
  {
    name: "outEdges",
    type: "directed",
    direction: "out"
  },
  {
    name: "inboundEdges",
    type: "mixed",
    direction: "in"
  },
  {
    name: "outboundEdges",
    type: "mixed",
    direction: "out"
  },
  {
    name: "directedEdges",
    type: "directed"
  },
  {
    name: "undirectedEdges",
    type: "undirected"
  }
];
function forEachSimple(breakable, object5, callback, avoid) {
  let shouldBreak = false;
  for (const k in object5) {
    if (k === avoid)
      continue;
    const edgeData = object5[k];
    shouldBreak = callback(edgeData.key, edgeData.attributes, edgeData.source.key, edgeData.target.key, edgeData.source.attributes, edgeData.target.attributes, edgeData.undirected);
    if (breakable && shouldBreak)
      return edgeData.key;
  }
  return;
}
function forEachMulti(breakable, object5, callback, avoid) {
  let edgeData, source, target;
  let shouldBreak = false;
  for (const k in object5) {
    if (k === avoid)
      continue;
    edgeData = object5[k];
    do {
      source = edgeData.source;
      target = edgeData.target;
      shouldBreak = callback(edgeData.key, edgeData.attributes, source.key, target.key, source.attributes, target.attributes, edgeData.undirected);
      if (breakable && shouldBreak)
        return edgeData.key;
      edgeData = edgeData.next;
    } while (edgeData !== undefined);
  }
  return;
}
function createIterator(object5, avoid) {
  const keys = Object.keys(object5);
  const l = keys.length;
  let edgeData;
  let i = 0;
  return {
    [Symbol.iterator]() {
      return this;
    },
    next() {
      do {
        if (!edgeData) {
          if (i >= l)
            return { done: true };
          const k = keys[i++];
          if (k === avoid) {
            edgeData = undefined;
            continue;
          }
          edgeData = object5[k];
        } else {
          edgeData = edgeData.next;
        }
      } while (!edgeData);
      return {
        done: false,
        value: {
          edge: edgeData.key,
          attributes: edgeData.attributes,
          source: edgeData.source.key,
          target: edgeData.target.key,
          sourceAttributes: edgeData.source.attributes,
          targetAttributes: edgeData.target.attributes,
          undirected: edgeData.undirected
        }
      };
    }
  };
}
function forEachForKeySimple(breakable, object5, k, callback) {
  const edgeData = object5[k];
  if (!edgeData)
    return;
  const sourceData = edgeData.source;
  const targetData = edgeData.target;
  if (callback(edgeData.key, edgeData.attributes, sourceData.key, targetData.key, sourceData.attributes, targetData.attributes, edgeData.undirected) && breakable)
    return edgeData.key;
}
function forEachForKeyMulti(breakable, object5, k, callback) {
  let edgeData = object5[k];
  if (!edgeData)
    return;
  let shouldBreak = false;
  do {
    shouldBreak = callback(edgeData.key, edgeData.attributes, edgeData.source.key, edgeData.target.key, edgeData.source.attributes, edgeData.target.attributes, edgeData.undirected);
    if (breakable && shouldBreak)
      return edgeData.key;
    edgeData = edgeData.next;
  } while (edgeData !== undefined);
  return;
}
function createIteratorForKey(object5, k) {
  let edgeData = object5[k];
  if (edgeData.next !== undefined) {
    return {
      [Symbol.iterator]() {
        return this;
      },
      next() {
        if (!edgeData)
          return { done: true };
        const value = {
          edge: edgeData.key,
          attributes: edgeData.attributes,
          source: edgeData.source.key,
          target: edgeData.target.key,
          sourceAttributes: edgeData.source.attributes,
          targetAttributes: edgeData.target.attributes,
          undirected: edgeData.undirected
        };
        edgeData = edgeData.next;
        return {
          done: false,
          value
        };
      }
    };
  }
  let done = false;
  return {
    [Symbol.iterator]() {
      return this;
    },
    next() {
      if (done === true)
        return { done: true };
      done = true;
      return {
        done: false,
        value: {
          edge: edgeData.key,
          attributes: edgeData.attributes,
          source: edgeData.source.key,
          target: edgeData.target.key,
          sourceAttributes: edgeData.source.attributes,
          targetAttributes: edgeData.target.attributes,
          undirected: edgeData.undirected
        }
      };
    }
  };
}
function createEdgeArray(graph, type) {
  if (graph.size === 0)
    return [];
  if (type === "mixed" || type === graph.type) {
    return Array.from(graph._edges.keys());
  }
  const size = type === "undirected" ? graph.undirectedSize : graph.directedSize;
  const list = new Array(size), mask = type === "undirected";
  const iterator = graph._edges.values();
  let i = 0;
  let step, data;
  while (step = iterator.next(), step.done !== true) {
    data = step.value;
    if (data.undirected === mask)
      list[i++] = data.key;
  }
  return list;
}
function forEachEdge(breakable, graph, type, callback) {
  if (graph.size === 0)
    return;
  const shouldFilter = type !== "mixed" && type !== graph.type;
  const mask = type === "undirected";
  let step, data;
  let shouldBreak = false;
  const iterator = graph._edges.values();
  while (step = iterator.next(), step.done !== true) {
    data = step.value;
    if (shouldFilter && data.undirected !== mask)
      continue;
    const { key, attributes, source, target } = data;
    shouldBreak = callback(key, attributes, source.key, target.key, source.attributes, target.attributes, data.undirected);
    if (breakable && shouldBreak)
      return key;
  }
  return;
}
function createEdgeIterator(graph, type) {
  if (graph.size === 0)
    return emptyIterator();
  const shouldFilter = type !== "mixed" && type !== graph.type;
  const mask = type === "undirected";
  const iterator = graph._edges.values();
  return {
    [Symbol.iterator]() {
      return this;
    },
    next() {
      let step, data;
      while (true) {
        step = iterator.next();
        if (step.done)
          return step;
        data = step.value;
        if (shouldFilter && data.undirected !== mask)
          continue;
        break;
      }
      const value = {
        edge: data.key,
        attributes: data.attributes,
        source: data.source.key,
        target: data.target.key,
        sourceAttributes: data.source.attributes,
        targetAttributes: data.target.attributes,
        undirected: data.undirected
      };
      return { value, done: false };
    }
  };
}
function forEachEdgeForNode(breakable, multi, type, direction, nodeData, callback) {
  const fn = multi ? forEachMulti : forEachSimple;
  let found;
  if (type !== "undirected") {
    if (direction !== "out") {
      found = fn(breakable, nodeData.in, callback);
      if (breakable && found)
        return found;
    }
    if (direction !== "in") {
      found = fn(breakable, nodeData.out, callback, !direction ? nodeData.key : undefined);
      if (breakable && found)
        return found;
    }
  }
  if (type !== "directed") {
    found = fn(breakable, nodeData.undirected, callback);
    if (breakable && found)
      return found;
  }
  return;
}
function createEdgeArrayForNode(multi, type, direction, nodeData) {
  const edges = [];
  forEachEdgeForNode(false, multi, type, direction, nodeData, function(key) {
    edges.push(key);
  });
  return edges;
}
function createEdgeIteratorForNode(type, direction, nodeData) {
  let iterator = emptyIterator();
  if (type !== "undirected") {
    if (direction !== "out" && typeof nodeData.in !== "undefined")
      iterator = chain(iterator, createIterator(nodeData.in));
    if (direction !== "in" && typeof nodeData.out !== "undefined")
      iterator = chain(iterator, createIterator(nodeData.out, !direction ? nodeData.key : undefined));
  }
  if (type !== "directed" && typeof nodeData.undirected !== "undefined") {
    iterator = chain(iterator, createIterator(nodeData.undirected));
  }
  return iterator;
}
function forEachEdgeForPath(breakable, type, multi, direction, sourceData, target, callback) {
  const fn = multi ? forEachForKeyMulti : forEachForKeySimple;
  let found;
  if (type !== "undirected") {
    if (typeof sourceData.in !== "undefined" && direction !== "out") {
      found = fn(breakable, sourceData.in, target, callback);
      if (breakable && found)
        return found;
    }
    if (typeof sourceData.out !== "undefined" && direction !== "in" && (direction || sourceData.key !== target)) {
      found = fn(breakable, sourceData.out, target, callback);
      if (breakable && found)
        return found;
    }
  }
  if (type !== "directed") {
    if (typeof sourceData.undirected !== "undefined") {
      found = fn(breakable, sourceData.undirected, target, callback);
      if (breakable && found)
        return found;
    }
  }
  return;
}
function createEdgeArrayForPath(type, multi, direction, sourceData, target) {
  const edges = [];
  forEachEdgeForPath(false, type, multi, direction, sourceData, target, function(key) {
    edges.push(key);
  });
  return edges;
}
function createEdgeIteratorForPath(type, direction, sourceData, target) {
  let iterator = emptyIterator();
  if (type !== "undirected") {
    if (typeof sourceData.in !== "undefined" && direction !== "out" && target in sourceData.in)
      iterator = chain(iterator, createIteratorForKey(sourceData.in, target));
    if (typeof sourceData.out !== "undefined" && direction !== "in" && target in sourceData.out && (direction || sourceData.key !== target))
      iterator = chain(iterator, createIteratorForKey(sourceData.out, target));
  }
  if (type !== "directed") {
    if (typeof sourceData.undirected !== "undefined" && target in sourceData.undirected)
      iterator = chain(iterator, createIteratorForKey(sourceData.undirected, target));
  }
  return iterator;
}
function attachEdgeArrayCreator(Class3, description) {
  const { name, type, direction } = description;
  Class3.prototype[name] = function(source, target) {
    if (type !== "mixed" && this.type !== "mixed" && type !== this.type)
      return [];
    if (!arguments.length)
      return createEdgeArray(this, type);
    if (arguments.length === 1) {
      source = "" + source;
      const nodeData = this._nodes.get(source);
      if (typeof nodeData === "undefined")
        throw new NotFoundGraphError(`Graph.${name}: could not find the "${source}" node in the graph.`);
      return createEdgeArrayForNode(this.multi, type === "mixed" ? this.type : type, direction, nodeData);
    }
    if (arguments.length === 2) {
      source = "" + source;
      target = "" + target;
      const sourceData = this._nodes.get(source);
      if (!sourceData)
        throw new NotFoundGraphError(`Graph.${name}:  could not find the "${source}" source node in the graph.`);
      if (!this._nodes.has(target))
        throw new NotFoundGraphError(`Graph.${name}:  could not find the "${target}" target node in the graph.`);
      return createEdgeArrayForPath(type, this.multi, direction, sourceData, target);
    }
    throw new InvalidArgumentsGraphError(`Graph.${name}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`);
  };
}
function attachForEachEdge(Class3, description) {
  const { name, type, direction } = description;
  const forEachName = "forEach" + name[0].toUpperCase() + name.slice(1, -1);
  Class3.prototype[forEachName] = function(source, target, callback) {
    if (type !== "mixed" && this.type !== "mixed" && type !== this.type)
      return;
    if (arguments.length === 1) {
      callback = source;
      return forEachEdge(false, this, type, callback);
    }
    if (arguments.length === 2) {
      source = "" + source;
      callback = target;
      const nodeData = this._nodes.get(source);
      if (typeof nodeData === "undefined")
        throw new NotFoundGraphError(`Graph.${forEachName}: could not find the "${source}" node in the graph.`);
      return forEachEdgeForNode(false, this.multi, type === "mixed" ? this.type : type, direction, nodeData, callback);
    }
    if (arguments.length === 3) {
      source = "" + source;
      target = "" + target;
      const sourceData = this._nodes.get(source);
      if (!sourceData)
        throw new NotFoundGraphError(`Graph.${forEachName}:  could not find the "${source}" source node in the graph.`);
      if (!this._nodes.has(target))
        throw new NotFoundGraphError(`Graph.${forEachName}:  could not find the "${target}" target node in the graph.`);
      return forEachEdgeForPath(false, type, this.multi, direction, sourceData, target, callback);
    }
    throw new InvalidArgumentsGraphError(`Graph.${forEachName}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`);
  };
  const mapName = "map" + name[0].toUpperCase() + name.slice(1);
  Class3.prototype[mapName] = function() {
    const args = Array.prototype.slice.call(arguments);
    const callback = args.pop();
    let result;
    if (args.length === 0) {
      let length = 0;
      if (type !== "directed")
        length += this.undirectedSize;
      if (type !== "undirected")
        length += this.directedSize;
      result = new Array(length);
      let i = 0;
      args.push((e, ea, s, t, sa, ta, u) => {
        result[i++] = callback(e, ea, s, t, sa, ta, u);
      });
    } else {
      result = [];
      args.push((e, ea, s, t, sa, ta, u) => {
        result.push(callback(e, ea, s, t, sa, ta, u));
      });
    }
    this[forEachName].apply(this, args);
    return result;
  };
  const filterName = "filter" + name[0].toUpperCase() + name.slice(1);
  Class3.prototype[filterName] = function() {
    const args = Array.prototype.slice.call(arguments);
    const callback = args.pop();
    const result = [];
    args.push((e, ea, s, t, sa, ta, u) => {
      if (callback(e, ea, s, t, sa, ta, u))
        result.push(e);
    });
    this[forEachName].apply(this, args);
    return result;
  };
  const reduceName = "reduce" + name[0].toUpperCase() + name.slice(1);
  Class3.prototype[reduceName] = function() {
    let args = Array.prototype.slice.call(arguments);
    if (args.length < 2 || args.length > 4) {
      throw new InvalidArgumentsGraphError(`Graph.${reduceName}: invalid number of arguments (expecting 2, 3 or 4 and got ${args.length}).`);
    }
    if (typeof args[args.length - 1] === "function" && typeof args[args.length - 2] !== "function") {
      throw new InvalidArgumentsGraphError(`Graph.${reduceName}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`);
    }
    let callback;
    let initialValue;
    if (args.length === 2) {
      callback = args[0];
      initialValue = args[1];
      args = [];
    } else if (args.length === 3) {
      callback = args[1];
      initialValue = args[2];
      args = [args[0]];
    } else if (args.length === 4) {
      callback = args[2];
      initialValue = args[3];
      args = [args[0], args[1]];
    }
    let accumulator = initialValue;
    args.push((e, ea, s, t, sa, ta, u) => {
      accumulator = callback(accumulator, e, ea, s, t, sa, ta, u);
    });
    this[forEachName].apply(this, args);
    return accumulator;
  };
}
function attachFindEdge(Class3, description) {
  const { name, type, direction } = description;
  const findEdgeName = "find" + name[0].toUpperCase() + name.slice(1, -1);
  Class3.prototype[findEdgeName] = function(source, target, callback) {
    if (type !== "mixed" && this.type !== "mixed" && type !== this.type)
      return false;
    if (arguments.length === 1) {
      callback = source;
      return forEachEdge(true, this, type, callback);
    }
    if (arguments.length === 2) {
      source = "" + source;
      callback = target;
      const nodeData = this._nodes.get(source);
      if (typeof nodeData === "undefined")
        throw new NotFoundGraphError(`Graph.${findEdgeName}: could not find the "${source}" node in the graph.`);
      return forEachEdgeForNode(true, this.multi, type === "mixed" ? this.type : type, direction, nodeData, callback);
    }
    if (arguments.length === 3) {
      source = "" + source;
      target = "" + target;
      const sourceData = this._nodes.get(source);
      if (!sourceData)
        throw new NotFoundGraphError(`Graph.${findEdgeName}:  could not find the "${source}" source node in the graph.`);
      if (!this._nodes.has(target))
        throw new NotFoundGraphError(`Graph.${findEdgeName}:  could not find the "${target}" target node in the graph.`);
      return forEachEdgeForPath(true, type, this.multi, direction, sourceData, target, callback);
    }
    throw new InvalidArgumentsGraphError(`Graph.${findEdgeName}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`);
  };
  const someName = "some" + name[0].toUpperCase() + name.slice(1, -1);
  Class3.prototype[someName] = function() {
    const args = Array.prototype.slice.call(arguments);
    const callback = args.pop();
    args.push((e, ea, s, t, sa, ta, u) => {
      return callback(e, ea, s, t, sa, ta, u);
    });
    const found = this[findEdgeName].apply(this, args);
    if (found)
      return true;
    return false;
  };
  const everyName = "every" + name[0].toUpperCase() + name.slice(1, -1);
  Class3.prototype[everyName] = function() {
    const args = Array.prototype.slice.call(arguments);
    const callback = args.pop();
    args.push((e, ea, s, t, sa, ta, u) => {
      return !callback(e, ea, s, t, sa, ta, u);
    });
    const found = this[findEdgeName].apply(this, args);
    if (found)
      return false;
    return true;
  };
}
function attachEdgeIteratorCreator(Class3, description) {
  const { name: originalName, type, direction } = description;
  const name = originalName.slice(0, -1) + "Entries";
  Class3.prototype[name] = function(source, target) {
    if (type !== "mixed" && this.type !== "mixed" && type !== this.type)
      return emptyIterator();
    if (!arguments.length)
      return createEdgeIterator(this, type);
    if (arguments.length === 1) {
      source = "" + source;
      const sourceData = this._nodes.get(source);
      if (!sourceData)
        throw new NotFoundGraphError(`Graph.${name}: could not find the "${source}" node in the graph.`);
      return createEdgeIteratorForNode(type, direction, sourceData);
    }
    if (arguments.length === 2) {
      source = "" + source;
      target = "" + target;
      const sourceData = this._nodes.get(source);
      if (!sourceData)
        throw new NotFoundGraphError(`Graph.${name}:  could not find the "${source}" source node in the graph.`);
      if (!this._nodes.has(target))
        throw new NotFoundGraphError(`Graph.${name}:  could not find the "${target}" target node in the graph.`);
      return createEdgeIteratorForPath(type, direction, sourceData, target);
    }
    throw new InvalidArgumentsGraphError(`Graph.${name}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`);
  };
}
function attachEdgeIterationMethods(Graph) {
  EDGES_ITERATION.forEach((description) => {
    attachEdgeArrayCreator(Graph, description);
    attachForEachEdge(Graph, description);
    attachFindEdge(Graph, description);
    attachEdgeIteratorCreator(Graph, description);
  });
}
var NEIGHBORS_ITERATION = [
  {
    name: "neighbors",
    type: "mixed"
  },
  {
    name: "inNeighbors",
    type: "directed",
    direction: "in"
  },
  {
    name: "outNeighbors",
    type: "directed",
    direction: "out"
  },
  {
    name: "inboundNeighbors",
    type: "mixed",
    direction: "in"
  },
  {
    name: "outboundNeighbors",
    type: "mixed",
    direction: "out"
  },
  {
    name: "directedNeighbors",
    type: "directed"
  },
  {
    name: "undirectedNeighbors",
    type: "undirected"
  }
];
function CompositeSetWrapper() {
  this.A = null;
  this.B = null;
}
CompositeSetWrapper.prototype.wrap = function(set3) {
  if (this.A === null)
    this.A = set3;
  else if (this.B === null)
    this.B = set3;
};
CompositeSetWrapper.prototype.has = function(key) {
  if (this.A !== null && key in this.A)
    return true;
  if (this.B !== null && key in this.B)
    return true;
  return false;
};
function forEachInObjectOnce(breakable, visited, nodeData, object5, callback) {
  for (const k in object5) {
    const edgeData = object5[k];
    const sourceData = edgeData.source;
    const targetData = edgeData.target;
    const neighborData = sourceData === nodeData ? targetData : sourceData;
    if (visited && visited.has(neighborData.key))
      continue;
    const shouldBreak = callback(neighborData.key, neighborData.attributes);
    if (breakable && shouldBreak)
      return neighborData.key;
  }
  return;
}
function forEachNeighbor(breakable, type, direction, nodeData, callback) {
  if (type !== "mixed") {
    if (type === "undirected")
      return forEachInObjectOnce(breakable, null, nodeData, nodeData.undirected, callback);
    if (typeof direction === "string")
      return forEachInObjectOnce(breakable, null, nodeData, nodeData[direction], callback);
  }
  const visited = new CompositeSetWrapper;
  let found;
  if (type !== "undirected") {
    if (direction !== "out") {
      found = forEachInObjectOnce(breakable, null, nodeData, nodeData.in, callback);
      if (breakable && found)
        return found;
      visited.wrap(nodeData.in);
    }
    if (direction !== "in") {
      found = forEachInObjectOnce(breakable, visited, nodeData, nodeData.out, callback);
      if (breakable && found)
        return found;
      visited.wrap(nodeData.out);
    }
  }
  if (type !== "directed") {
    found = forEachInObjectOnce(breakable, visited, nodeData, nodeData.undirected, callback);
    if (breakable && found)
      return found;
  }
  return;
}
function createNeighborArrayForNode(type, direction, nodeData) {
  if (type !== "mixed") {
    if (type === "undirected")
      return Object.keys(nodeData.undirected);
    if (typeof direction === "string")
      return Object.keys(nodeData[direction]);
  }
  const neighbors = [];
  forEachNeighbor(false, type, direction, nodeData, function(key) {
    neighbors.push(key);
  });
  return neighbors;
}
function createDedupedObjectIterator(visited, nodeData, object5) {
  const keys = Object.keys(object5);
  const l = keys.length;
  let i = 0;
  return {
    [Symbol.iterator]() {
      return this;
    },
    next() {
      let neighborData = null;
      do {
        if (i >= l) {
          if (visited)
            visited.wrap(object5);
          return { done: true };
        }
        const edgeData = object5[keys[i++]];
        const sourceData = edgeData.source;
        const targetData = edgeData.target;
        neighborData = sourceData === nodeData ? targetData : sourceData;
        if (visited && visited.has(neighborData.key)) {
          neighborData = null;
          continue;
        }
      } while (neighborData === null);
      return {
        done: false,
        value: { neighbor: neighborData.key, attributes: neighborData.attributes }
      };
    }
  };
}
function createNeighborIterator(type, direction, nodeData) {
  if (type !== "mixed") {
    if (type === "undirected")
      return createDedupedObjectIterator(null, nodeData, nodeData.undirected);
    if (typeof direction === "string")
      return createDedupedObjectIterator(null, nodeData, nodeData[direction]);
  }
  let iterator = emptyIterator();
  const visited = new CompositeSetWrapper;
  if (type !== "undirected") {
    if (direction !== "out") {
      iterator = chain(iterator, createDedupedObjectIterator(visited, nodeData, nodeData.in));
    }
    if (direction !== "in") {
      iterator = chain(iterator, createDedupedObjectIterator(visited, nodeData, nodeData.out));
    }
  }
  if (type !== "directed") {
    iterator = chain(iterator, createDedupedObjectIterator(visited, nodeData, nodeData.undirected));
  }
  return iterator;
}
function attachNeighborArrayCreator(Class3, description) {
  const { name, type, direction } = description;
  Class3.prototype[name] = function(node) {
    if (type !== "mixed" && this.type !== "mixed" && type !== this.type)
      return [];
    node = "" + node;
    const nodeData = this._nodes.get(node);
    if (typeof nodeData === "undefined")
      throw new NotFoundGraphError(`Graph.${name}: could not find the "${node}" node in the graph.`);
    return createNeighborArrayForNode(type === "mixed" ? this.type : type, direction, nodeData);
  };
}
function attachForEachNeighbor(Class3, description) {
  const { name, type, direction } = description;
  const forEachName = "forEach" + name[0].toUpperCase() + name.slice(1, -1);
  Class3.prototype[forEachName] = function(node, callback) {
    if (type !== "mixed" && this.type !== "mixed" && type !== this.type)
      return;
    node = "" + node;
    const nodeData = this._nodes.get(node);
    if (typeof nodeData === "undefined")
      throw new NotFoundGraphError(`Graph.${forEachName}: could not find the "${node}" node in the graph.`);
    forEachNeighbor(false, type === "mixed" ? this.type : type, direction, nodeData, callback);
  };
  const mapName = "map" + name[0].toUpperCase() + name.slice(1);
  Class3.prototype[mapName] = function(node, callback) {
    const result = [];
    this[forEachName](node, (n, a) => {
      result.push(callback(n, a));
    });
    return result;
  };
  const filterName = "filter" + name[0].toUpperCase() + name.slice(1);
  Class3.prototype[filterName] = function(node, callback) {
    const result = [];
    this[forEachName](node, (n, a) => {
      if (callback(n, a))
        result.push(n);
    });
    return result;
  };
  const reduceName = "reduce" + name[0].toUpperCase() + name.slice(1);
  Class3.prototype[reduceName] = function(node, callback, initialValue) {
    if (arguments.length < 3)
      throw new InvalidArgumentsGraphError(`Graph.${reduceName}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`);
    let accumulator = initialValue;
    this[forEachName](node, (n, a) => {
      accumulator = callback(accumulator, n, a);
    });
    return accumulator;
  };
}
function attachFindNeighbor(Class3, description) {
  const { name, type, direction } = description;
  const capitalizedSingular = name[0].toUpperCase() + name.slice(1, -1);
  const findName = "find" + capitalizedSingular;
  Class3.prototype[findName] = function(node, callback) {
    if (type !== "mixed" && this.type !== "mixed" && type !== this.type)
      return;
    node = "" + node;
    const nodeData = this._nodes.get(node);
    if (typeof nodeData === "undefined")
      throw new NotFoundGraphError(`Graph.${findName}: could not find the "${node}" node in the graph.`);
    return forEachNeighbor(true, type === "mixed" ? this.type : type, direction, nodeData, callback);
  };
  const someName = "some" + capitalizedSingular;
  Class3.prototype[someName] = function(node, callback) {
    const found = this[findName](node, callback);
    if (found)
      return true;
    return false;
  };
  const everyName = "every" + capitalizedSingular;
  Class3.prototype[everyName] = function(node, callback) {
    const found = this[findName](node, (n, a) => {
      return !callback(n, a);
    });
    if (found)
      return false;
    return true;
  };
}
function attachNeighborIteratorCreator(Class3, description) {
  const { name, type, direction } = description;
  const iteratorName = name.slice(0, -1) + "Entries";
  Class3.prototype[iteratorName] = function(node) {
    if (type !== "mixed" && this.type !== "mixed" && type !== this.type)
      return emptyIterator();
    node = "" + node;
    const nodeData = this._nodes.get(node);
    if (typeof nodeData === "undefined")
      throw new NotFoundGraphError(`Graph.${iteratorName}: could not find the "${node}" node in the graph.`);
    return createNeighborIterator(type === "mixed" ? this.type : type, direction, nodeData);
  };
}
function attachNeighborIterationMethods(Graph) {
  NEIGHBORS_ITERATION.forEach((description) => {
    attachNeighborArrayCreator(Graph, description);
    attachForEachNeighbor(Graph, description);
    attachFindNeighbor(Graph, description);
    attachNeighborIteratorCreator(Graph, description);
  });
}
function forEachAdjacency(breakable, assymetric, disconnectedNodes, graph, callback) {
  const iterator = graph._nodes.values();
  const type = graph.type;
  let step, sourceData, neighbor, adj, edgeData, targetData, shouldBreak;
  while (step = iterator.next(), step.done !== true) {
    let hasEdges = false;
    sourceData = step.value;
    if (type !== "undirected") {
      adj = sourceData.out;
      for (neighbor in adj) {
        edgeData = adj[neighbor];
        do {
          targetData = edgeData.target;
          hasEdges = true;
          shouldBreak = callback(sourceData.key, targetData.key, sourceData.attributes, targetData.attributes, edgeData.key, edgeData.attributes, edgeData.undirected);
          if (breakable && shouldBreak)
            return edgeData;
          edgeData = edgeData.next;
        } while (edgeData);
      }
    }
    if (type !== "directed") {
      adj = sourceData.undirected;
      for (neighbor in adj) {
        if (assymetric && sourceData.key > neighbor)
          continue;
        edgeData = adj[neighbor];
        do {
          targetData = edgeData.target;
          if (targetData.key !== neighbor)
            targetData = edgeData.source;
          hasEdges = true;
          shouldBreak = callback(sourceData.key, targetData.key, sourceData.attributes, targetData.attributes, edgeData.key, edgeData.attributes, edgeData.undirected);
          if (breakable && shouldBreak)
            return edgeData;
          edgeData = edgeData.next;
        } while (edgeData);
      }
    }
    if (disconnectedNodes && !hasEdges) {
      shouldBreak = callback(sourceData.key, null, sourceData.attributes, null, null, null, null);
      if (breakable && shouldBreak)
        return null;
    }
  }
  return;
}
function serializeNode(key, data) {
  const serialized = { key };
  if (!isEmpty(data.attributes))
    serialized.attributes = assign({}, data.attributes);
  return serialized;
}
function serializeEdge(type, key, data) {
  const serialized = {
    key,
    source: data.source.key,
    target: data.target.key
  };
  if (!isEmpty(data.attributes))
    serialized.attributes = assign({}, data.attributes);
  if (type === "mixed" && data.undirected)
    serialized.undirected = true;
  return serialized;
}
function validateSerializedNode(value) {
  if (!isPlainObject4(value))
    throw new InvalidArgumentsGraphError('Graph.import: invalid serialized node. A serialized node should be a plain object with at least a "key" property.');
  if (!("key" in value))
    throw new InvalidArgumentsGraphError("Graph.import: serialized node is missing its key.");
  if ("attributes" in value && (!isPlainObject4(value.attributes) || value.attributes === null))
    throw new InvalidArgumentsGraphError("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.");
}
function validateSerializedEdge(value) {
  if (!isPlainObject4(value))
    throw new InvalidArgumentsGraphError('Graph.import: invalid serialized edge. A serialized edge should be a plain object with at least a "source" & "target" property.');
  if (!("source" in value))
    throw new InvalidArgumentsGraphError("Graph.import: serialized edge is missing its source.");
  if (!("target" in value))
    throw new InvalidArgumentsGraphError("Graph.import: serialized edge is missing its target.");
  if ("attributes" in value && (!isPlainObject4(value.attributes) || value.attributes === null))
    throw new InvalidArgumentsGraphError("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.");
  if ("undirected" in value && typeof value.undirected !== "boolean")
    throw new InvalidArgumentsGraphError("Graph.import: invalid undirectedness information. Undirected should be boolean or omitted.");
}
var INSTANCE_ID = incrementalIdStartingFromRandomByte();
var TYPES = new Set(["directed", "undirected", "mixed"]);
var EMITTER_PROPS = new Set([
  "domain",
  "_events",
  "_eventsCount",
  "_maxListeners"
]);
var EDGE_ADD_METHODS = [
  {
    name: (verb) => `${verb}Edge`,
    generateKey: true
  },
  {
    name: (verb) => `${verb}DirectedEdge`,
    generateKey: true,
    type: "directed"
  },
  {
    name: (verb) => `${verb}UndirectedEdge`,
    generateKey: true,
    type: "undirected"
  },
  {
    name: (verb) => `${verb}EdgeWithKey`
  },
  {
    name: (verb) => `${verb}DirectedEdgeWithKey`,
    type: "directed"
  },
  {
    name: (verb) => `${verb}UndirectedEdgeWithKey`,
    type: "undirected"
  }
];
var DEFAULTS = {
  allowSelfLoops: true,
  multi: false,
  type: "mixed"
};
function addNode(graph, node, attributes) {
  if (attributes && !isPlainObject4(attributes))
    throw new InvalidArgumentsGraphError(`Graph.addNode: invalid attributes. Expecting an object but got "${attributes}"`);
  node = "" + node;
  attributes = attributes || {};
  if (graph._nodes.has(node))
    throw new UsageGraphError(`Graph.addNode: the "${node}" node already exist in the graph.`);
  const data = new graph.NodeDataClass(node, attributes);
  graph._nodes.set(node, data);
  graph.emit("nodeAdded", {
    key: node,
    attributes
  });
  return data;
}
function unsafeAddNode(graph, node, attributes) {
  const data = new graph.NodeDataClass(node, attributes);
  graph._nodes.set(node, data);
  graph.emit("nodeAdded", {
    key: node,
    attributes
  });
  return data;
}
function addEdge(graph, name, mustGenerateKey, undirected, edge, source, target, attributes) {
  if (!undirected && graph.type === "undirected")
    throw new UsageGraphError(`Graph.${name}: you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.`);
  if (undirected && graph.type === "directed")
    throw new UsageGraphError(`Graph.${name}: you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.`);
  if (attributes && !isPlainObject4(attributes))
    throw new InvalidArgumentsGraphError(`Graph.${name}: invalid attributes. Expecting an object but got "${attributes}"`);
  source = "" + source;
  target = "" + target;
  attributes = attributes || {};
  if (!graph.allowSelfLoops && source === target)
    throw new UsageGraphError(`Graph.${name}: source & target are the same ("${source}"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`);
  const sourceData = graph._nodes.get(source), targetData = graph._nodes.get(target);
  if (!sourceData)
    throw new NotFoundGraphError(`Graph.${name}: source node "${source}" not found.`);
  if (!targetData)
    throw new NotFoundGraphError(`Graph.${name}: target node "${target}" not found.`);
  const eventData = {
    key: null,
    undirected,
    source,
    target,
    attributes
  };
  if (mustGenerateKey) {
    edge = graph._edgeKeyGenerator();
  } else {
    edge = "" + edge;
    if (graph._edges.has(edge))
      throw new UsageGraphError(`Graph.${name}: the "${edge}" edge already exists in the graph.`);
  }
  if (!graph.multi && (undirected ? typeof sourceData.undirected[target] !== "undefined" : typeof sourceData.out[target] !== "undefined")) {
    throw new UsageGraphError(`Graph.${name}: an edge linking "${source}" to "${target}" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option.`);
  }
  const edgeData = new EdgeData(undirected, edge, sourceData, targetData, attributes);
  graph._edges.set(edge, edgeData);
  const isSelfLoop = source === target;
  if (undirected) {
    sourceData.undirectedDegree++;
    targetData.undirectedDegree++;
    if (isSelfLoop) {
      sourceData.undirectedLoops++;
      graph._undirectedSelfLoopCount++;
    }
  } else {
    sourceData.outDegree++;
    targetData.inDegree++;
    if (isSelfLoop) {
      sourceData.directedLoops++;
      graph._directedSelfLoopCount++;
    }
  }
  if (graph.multi)
    edgeData.attachMulti();
  else
    edgeData.attach();
  if (undirected)
    graph._undirectedSize++;
  else
    graph._directedSize++;
  eventData.key = edge;
  graph.emit("edgeAdded", eventData);
  return edge;
}
function mergeEdge(graph, name, mustGenerateKey, undirected, edge, source, target, attributes, asUpdater) {
  if (!undirected && graph.type === "undirected")
    throw new UsageGraphError(`Graph.${name}: you cannot merge/update a directed edge to an undirected graph. Use the #.mergeEdge/#.updateEdge or #.addUndirectedEdge instead.`);
  if (undirected && graph.type === "directed")
    throw new UsageGraphError(`Graph.${name}: you cannot merge/update an undirected edge to a directed graph. Use the #.mergeEdge/#.updateEdge or #.addDirectedEdge instead.`);
  if (attributes) {
    if (asUpdater) {
      if (typeof attributes !== "function")
        throw new InvalidArgumentsGraphError(`Graph.${name}: invalid updater function. Expecting a function but got "${attributes}"`);
    } else {
      if (!isPlainObject4(attributes))
        throw new InvalidArgumentsGraphError(`Graph.${name}: invalid attributes. Expecting an object but got "${attributes}"`);
    }
  }
  source = "" + source;
  target = "" + target;
  let updater;
  if (asUpdater) {
    updater = attributes;
    attributes = undefined;
  }
  if (!graph.allowSelfLoops && source === target)
    throw new UsageGraphError(`Graph.${name}: source & target are the same ("${source}"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`);
  let sourceData = graph._nodes.get(source);
  let targetData = graph._nodes.get(target);
  let edgeData;
  let alreadyExistingEdgeData;
  if (!mustGenerateKey) {
    edgeData = graph._edges.get(edge);
    if (edgeData) {
      if (edgeData.source.key !== source || edgeData.target.key !== target) {
        if (!undirected || edgeData.source.key !== target || edgeData.target.key !== source) {
          throw new UsageGraphError(`Graph.${name}: inconsistency detected when attempting to merge the "${edge}" edge with "${source}" source & "${target}" target vs. ("${edgeData.source.key}", "${edgeData.target.key}").`);
        }
      }
      alreadyExistingEdgeData = edgeData;
    }
  }
  if (!alreadyExistingEdgeData && !graph.multi && sourceData) {
    alreadyExistingEdgeData = undirected ? sourceData.undirected[target] : sourceData.out[target];
  }
  if (alreadyExistingEdgeData) {
    const info = [alreadyExistingEdgeData.key, false, false, false];
    if (asUpdater ? !updater : !attributes)
      return info;
    if (asUpdater) {
      const oldAttributes = alreadyExistingEdgeData.attributes;
      alreadyExistingEdgeData.attributes = updater(oldAttributes);
      graph.emit("edgeAttributesUpdated", {
        type: "replace",
        key: alreadyExistingEdgeData.key,
        attributes: alreadyExistingEdgeData.attributes
      });
    } else {
      assign(alreadyExistingEdgeData.attributes, attributes);
      graph.emit("edgeAttributesUpdated", {
        type: "merge",
        key: alreadyExistingEdgeData.key,
        attributes: alreadyExistingEdgeData.attributes,
        data: attributes
      });
    }
    return info;
  }
  attributes = attributes || {};
  if (asUpdater && updater)
    attributes = updater(attributes);
  const eventData = {
    key: null,
    undirected,
    source,
    target,
    attributes
  };
  if (mustGenerateKey) {
    edge = graph._edgeKeyGenerator();
  } else {
    edge = "" + edge;
    if (graph._edges.has(edge))
      throw new UsageGraphError(`Graph.${name}: the "${edge}" edge already exists in the graph.`);
  }
  let sourceWasAdded = false;
  let targetWasAdded = false;
  if (!sourceData) {
    sourceData = unsafeAddNode(graph, source, {});
    sourceWasAdded = true;
    if (source === target) {
      targetData = sourceData;
      targetWasAdded = true;
    }
  }
  if (!targetData) {
    targetData = unsafeAddNode(graph, target, {});
    targetWasAdded = true;
  }
  edgeData = new EdgeData(undirected, edge, sourceData, targetData, attributes);
  graph._edges.set(edge, edgeData);
  const isSelfLoop = source === target;
  if (undirected) {
    sourceData.undirectedDegree++;
    targetData.undirectedDegree++;
    if (isSelfLoop) {
      sourceData.undirectedLoops++;
      graph._undirectedSelfLoopCount++;
    }
  } else {
    sourceData.outDegree++;
    targetData.inDegree++;
    if (isSelfLoop) {
      sourceData.directedLoops++;
      graph._directedSelfLoopCount++;
    }
  }
  if (graph.multi)
    edgeData.attachMulti();
  else
    edgeData.attach();
  if (undirected)
    graph._undirectedSize++;
  else
    graph._directedSize++;
  eventData.key = edge;
  graph.emit("edgeAdded", eventData);
  return [edge, true, sourceWasAdded, targetWasAdded];
}
function dropEdgeFromData(graph, edgeData) {
  graph._edges.delete(edgeData.key);
  const { source: sourceData, target: targetData, attributes } = edgeData;
  const undirected = edgeData.undirected;
  const isSelfLoop = sourceData === targetData;
  if (undirected) {
    sourceData.undirectedDegree--;
    targetData.undirectedDegree--;
    if (isSelfLoop) {
      sourceData.undirectedLoops--;
      graph._undirectedSelfLoopCount--;
    }
  } else {
    sourceData.outDegree--;
    targetData.inDegree--;
    if (isSelfLoop) {
      sourceData.directedLoops--;
      graph._directedSelfLoopCount--;
    }
  }
  if (graph.multi)
    edgeData.detachMulti();
  else
    edgeData.detach();
  if (undirected)
    graph._undirectedSize--;
  else
    graph._directedSize--;
  graph.emit("edgeDropped", {
    key: edgeData.key,
    attributes,
    source: sourceData.key,
    target: targetData.key,
    undirected
  });
}

class Graph extends EventEmitter {
  constructor(options2) {
    super();
    options2 = assign({}, DEFAULTS, options2);
    if (typeof options2.multi !== "boolean")
      throw new InvalidArgumentsGraphError(`Graph.constructor: invalid 'multi' option. Expecting a boolean but got "${options2.multi}".`);
    if (!TYPES.has(options2.type))
      throw new InvalidArgumentsGraphError(`Graph.constructor: invalid 'type' option. Should be one of "mixed", "directed" or "undirected" but got "${options2.type}".`);
    if (typeof options2.allowSelfLoops !== "boolean")
      throw new InvalidArgumentsGraphError(`Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got "${options2.allowSelfLoops}".`);
    const NodeDataClass = options2.type === "mixed" ? MixedNodeData : options2.type === "directed" ? DirectedNodeData : UndirectedNodeData;
    privateProperty(this, "NodeDataClass", NodeDataClass);
    const instancePrefix = "geid_" + INSTANCE_ID() + "_";
    let edgeId = 0;
    const edgeKeyGenerator = () => {
      let availableEdgeKey;
      do {
        availableEdgeKey = instancePrefix + edgeId++;
      } while (this._edges.has(availableEdgeKey));
      return availableEdgeKey;
    };
    privateProperty(this, "_attributes", {});
    privateProperty(this, "_nodes", new Map);
    privateProperty(this, "_edges", new Map);
    privateProperty(this, "_directedSize", 0);
    privateProperty(this, "_undirectedSize", 0);
    privateProperty(this, "_directedSelfLoopCount", 0);
    privateProperty(this, "_undirectedSelfLoopCount", 0);
    privateProperty(this, "_edgeKeyGenerator", edgeKeyGenerator);
    privateProperty(this, "_options", options2);
    EMITTER_PROPS.forEach((prop) => privateProperty(this, prop, this[prop]));
    readOnlyProperty(this, "order", () => this._nodes.size);
    readOnlyProperty(this, "size", () => this._edges.size);
    readOnlyProperty(this, "directedSize", () => this._directedSize);
    readOnlyProperty(this, "undirectedSize", () => this._undirectedSize);
    readOnlyProperty(this, "selfLoopCount", () => this._directedSelfLoopCount + this._undirectedSelfLoopCount);
    readOnlyProperty(this, "directedSelfLoopCount", () => this._directedSelfLoopCount);
    readOnlyProperty(this, "undirectedSelfLoopCount", () => this._undirectedSelfLoopCount);
    readOnlyProperty(this, "multi", this._options.multi);
    readOnlyProperty(this, "type", this._options.type);
    readOnlyProperty(this, "allowSelfLoops", this._options.allowSelfLoops);
    readOnlyProperty(this, "implementation", () => "graphology");
  }
  _resetInstanceCounters() {
    this._directedSize = 0;
    this._undirectedSize = 0;
    this._directedSelfLoopCount = 0;
    this._undirectedSelfLoopCount = 0;
  }
  hasNode(node) {
    return this._nodes.has("" + node);
  }
  hasDirectedEdge(source, target) {
    if (this.type === "undirected")
      return false;
    if (arguments.length === 1) {
      const edge = "" + source;
      const edgeData = this._edges.get(edge);
      return !!edgeData && !edgeData.undirected;
    } else if (arguments.length === 2) {
      source = "" + source;
      target = "" + target;
      const nodeData = this._nodes.get(source);
      if (!nodeData)
        return false;
      return nodeData.out.hasOwnProperty(target);
    }
    throw new InvalidArgumentsGraphError(`Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`);
  }
  hasUndirectedEdge(source, target) {
    if (this.type === "directed")
      return false;
    if (arguments.length === 1) {
      const edge = "" + source;
      const edgeData = this._edges.get(edge);
      return !!edgeData && edgeData.undirected;
    } else if (arguments.length === 2) {
      source = "" + source;
      target = "" + target;
      const nodeData = this._nodes.get(source);
      if (!nodeData)
        return false;
      return nodeData.undirected.hasOwnProperty(target);
    }
    throw new InvalidArgumentsGraphError(`Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`);
  }
  hasEdge(source, target) {
    if (arguments.length === 1) {
      const edge = "" + source;
      return this._edges.has(edge);
    } else if (arguments.length === 2) {
      source = "" + source;
      target = "" + target;
      const nodeData = this._nodes.get(source);
      if (!nodeData)
        return false;
      return typeof nodeData.out !== "undefined" && nodeData.out.hasOwnProperty(target) || typeof nodeData.undirected !== "undefined" && nodeData.undirected.hasOwnProperty(target);
    }
    throw new InvalidArgumentsGraphError(`Graph.hasEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`);
  }
  directedEdge(source, target) {
    if (this.type === "undirected")
      return;
    source = "" + source;
    target = "" + target;
    if (this.multi)
      throw new UsageGraphError("Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.");
    const sourceData = this._nodes.get(source);
    if (!sourceData)
      throw new NotFoundGraphError(`Graph.directedEdge: could not find the "${source}" source node in the graph.`);
    if (!this._nodes.has(target))
      throw new NotFoundGraphError(`Graph.directedEdge: could not find the "${target}" target node in the graph.`);
    const edgeData = sourceData.out && sourceData.out[target] || undefined;
    if (edgeData)
      return edgeData.key;
  }
  undirectedEdge(source, target) {
    if (this.type === "directed")
      return;
    source = "" + source;
    target = "" + target;
    if (this.multi)
      throw new UsageGraphError("Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.");
    const sourceData = this._nodes.get(source);
    if (!sourceData)
      throw new NotFoundGraphError(`Graph.undirectedEdge: could not find the "${source}" source node in the graph.`);
    if (!this._nodes.has(target))
      throw new NotFoundGraphError(`Graph.undirectedEdge: could not find the "${target}" target node in the graph.`);
    const edgeData = sourceData.undirected && sourceData.undirected[target] || undefined;
    if (edgeData)
      return edgeData.key;
  }
  edge(source, target) {
    if (this.multi)
      throw new UsageGraphError("Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.");
    source = "" + source;
    target = "" + target;
    const sourceData = this._nodes.get(source);
    if (!sourceData)
      throw new NotFoundGraphError(`Graph.edge: could not find the "${source}" source node in the graph.`);
    if (!this._nodes.has(target))
      throw new NotFoundGraphError(`Graph.edge: could not find the "${target}" target node in the graph.`);
    const edgeData = sourceData.out && sourceData.out[target] || sourceData.undirected && sourceData.undirected[target] || undefined;
    if (edgeData)
      return edgeData.key;
  }
  areDirectedNeighbors(node, neighbor) {
    node = "" + node;
    neighbor = "" + neighbor;
    const nodeData = this._nodes.get(node);
    if (!nodeData)
      throw new NotFoundGraphError(`Graph.areDirectedNeighbors: could not find the "${node}" node in the graph.`);
    if (this.type === "undirected")
      return false;
    return neighbor in nodeData.in || neighbor in nodeData.out;
  }
  areOutNeighbors(node, neighbor) {
    node = "" + node;
    neighbor = "" + neighbor;
    const nodeData = this._nodes.get(node);
    if (!nodeData)
      throw new NotFoundGraphError(`Graph.areOutNeighbors: could not find the "${node}" node in the graph.`);
    if (this.type === "undirected")
      return false;
    return neighbor in nodeData.out;
  }
  areInNeighbors(node, neighbor) {
    node = "" + node;
    neighbor = "" + neighbor;
    const nodeData = this._nodes.get(node);
    if (!nodeData)
      throw new NotFoundGraphError(`Graph.areInNeighbors: could not find the "${node}" node in the graph.`);
    if (this.type === "undirected")
      return false;
    return neighbor in nodeData.in;
  }
  areUndirectedNeighbors(node, neighbor) {
    node = "" + node;
    neighbor = "" + neighbor;
    const nodeData = this._nodes.get(node);
    if (!nodeData)
      throw new NotFoundGraphError(`Graph.areUndirectedNeighbors: could not find the "${node}" node in the graph.`);
    if (this.type === "directed")
      return false;
    return neighbor in nodeData.undirected;
  }
  areNeighbors(node, neighbor) {
    node = "" + node;
    neighbor = "" + neighbor;
    const nodeData = this._nodes.get(node);
    if (!nodeData)
      throw new NotFoundGraphError(`Graph.areNeighbors: could not find the "${node}" node in the graph.`);
    if (this.type !== "undirected") {
      if (neighbor in nodeData.in || neighbor in nodeData.out)
        return true;
    }
    if (this.type !== "directed") {
      if (neighbor in nodeData.undirected)
        return true;
    }
    return false;
  }
  areInboundNeighbors(node, neighbor) {
    node = "" + node;
    neighbor = "" + neighbor;
    const nodeData = this._nodes.get(node);
    if (!nodeData)
      throw new NotFoundGraphError(`Graph.areInboundNeighbors: could not find the "${node}" node in the graph.`);
    if (this.type !== "undirected") {
      if (neighbor in nodeData.in)
        return true;
    }
    if (this.type !== "directed") {
      if (neighbor in nodeData.undirected)
        return true;
    }
    return false;
  }
  areOutboundNeighbors(node, neighbor) {
    node = "" + node;
    neighbor = "" + neighbor;
    const nodeData = this._nodes.get(node);
    if (!nodeData)
      throw new NotFoundGraphError(`Graph.areOutboundNeighbors: could not find the "${node}" node in the graph.`);
    if (this.type !== "undirected") {
      if (neighbor in nodeData.out)
        return true;
    }
    if (this.type !== "directed") {
      if (neighbor in nodeData.undirected)
        return true;
    }
    return false;
  }
  inDegree(node) {
    node = "" + node;
    const nodeData = this._nodes.get(node);
    if (!nodeData)
      throw new NotFoundGraphError(`Graph.inDegree: could not find the "${node}" node in the graph.`);
    if (this.type === "undirected")
      return 0;
    return nodeData.inDegree;
  }
  outDegree(node) {
    node = "" + node;
    const nodeData = this._nodes.get(node);
    if (!nodeData)
      throw new NotFoundGraphError(`Graph.outDegree: could not find the "${node}" node in the graph.`);
    if (this.type === "undirected")
      return 0;
    return nodeData.outDegree;
  }
  directedDegree(node) {
    node = "" + node;
    const nodeData = this._nodes.get(node);
    if (!nodeData)
      throw new NotFoundGraphError(`Graph.directedDegree: could not find the "${node}" node in the graph.`);
    if (this.type === "undirected")
      return 0;
    return nodeData.inDegree + nodeData.outDegree;
  }
  undirectedDegree(node) {
    node = "" + node;
    const nodeData = this._nodes.get(node);
    if (!nodeData)
      throw new NotFoundGraphError(`Graph.undirectedDegree: could not find the "${node}" node in the graph.`);
    if (this.type === "directed")
      return 0;
    return nodeData.undirectedDegree;
  }
  inboundDegree(node) {
    node = "" + node;
    const nodeData = this._nodes.get(node);
    if (!nodeData)
      throw new NotFoundGraphError(`Graph.inboundDegree: could not find the "${node}" node in the graph.`);
    let degree = 0;
    if (this.type !== "directed") {
      degree += nodeData.undirectedDegree;
    }
    if (this.type !== "undirected") {
      degree += nodeData.inDegree;
    }
    return degree;
  }
  outboundDegree(node) {
    node = "" + node;
    const nodeData = this._nodes.get(node);
    if (!nodeData)
      throw new NotFoundGraphError(`Graph.outboundDegree: could not find the "${node}" node in the graph.`);
    let degree = 0;
    if (this.type !== "directed") {
      degree += nodeData.undirectedDegree;
    }
    if (this.type !== "undirected") {
      degree += nodeData.outDegree;
    }
    return degree;
  }
  degree(node) {
    node = "" + node;
    const nodeData = this._nodes.get(node);
    if (!nodeData)
      throw new NotFoundGraphError(`Graph.degree: could not find the "${node}" node in the graph.`);
    let degree = 0;
    if (this.type !== "directed") {
      degree += nodeData.undirectedDegree;
    }
    if (this.type !== "undirected") {
      degree += nodeData.inDegree + nodeData.outDegree;
    }
    return degree;
  }
  inDegreeWithoutSelfLoops(node) {
    node = "" + node;
    const nodeData = this._nodes.get(node);
    if (!nodeData)
      throw new NotFoundGraphError(`Graph.inDegreeWithoutSelfLoops: could not find the "${node}" node in the graph.`);
    if (this.type === "undirected")
      return 0;
    return nodeData.inDegree - nodeData.directedLoops;
  }
  outDegreeWithoutSelfLoops(node) {
    node = "" + node;
    const nodeData = this._nodes.get(node);
    if (!nodeData)
      throw new NotFoundGraphError(`Graph.outDegreeWithoutSelfLoops: could not find the "${node}" node in the graph.`);
    if (this.type === "undirected")
      return 0;
    return nodeData.outDegree - nodeData.directedLoops;
  }
  directedDegreeWithoutSelfLoops(node) {
    node = "" + node;
    const nodeData = this._nodes.get(node);
    if (!nodeData)
      throw new NotFoundGraphError(`Graph.directedDegreeWithoutSelfLoops: could not find the "${node}" node in the graph.`);
    if (this.type === "undirected")
      return 0;
    return nodeData.inDegree + nodeData.outDegree - nodeData.directedLoops * 2;
  }
  undirectedDegreeWithoutSelfLoops(node) {
    node = "" + node;
    const nodeData = this._nodes.get(node);
    if (!nodeData)
      throw new NotFoundGraphError(`Graph.undirectedDegreeWithoutSelfLoops: could not find the "${node}" node in the graph.`);
    if (this.type === "directed")
      return 0;
    return nodeData.undirectedDegree - nodeData.undirectedLoops * 2;
  }
  inboundDegreeWithoutSelfLoops(node) {
    node = "" + node;
    const nodeData = this._nodes.get(node);
    if (!nodeData)
      throw new NotFoundGraphError(`Graph.inboundDegreeWithoutSelfLoops: could not find the "${node}" node in the graph.`);
    let degree = 0;
    let loops = 0;
    if (this.type !== "directed") {
      degree += nodeData.undirectedDegree;
      loops += nodeData.undirectedLoops * 2;
    }
    if (this.type !== "undirected") {
      degree += nodeData.inDegree;
      loops += nodeData.directedLoops;
    }
    return degree - loops;
  }
  outboundDegreeWithoutSelfLoops(node) {
    node = "" + node;
    const nodeData = this._nodes.get(node);
    if (!nodeData)
      throw new NotFoundGraphError(`Graph.outboundDegreeWithoutSelfLoops: could not find the "${node}" node in the graph.`);
    let degree = 0;
    let loops = 0;
    if (this.type !== "directed") {
      degree += nodeData.undirectedDegree;
      loops += nodeData.undirectedLoops * 2;
    }
    if (this.type !== "undirected") {
      degree += nodeData.outDegree;
      loops += nodeData.directedLoops;
    }
    return degree - loops;
  }
  degreeWithoutSelfLoops(node) {
    node = "" + node;
    const nodeData = this._nodes.get(node);
    if (!nodeData)
      throw new NotFoundGraphError(`Graph.degreeWithoutSelfLoops: could not find the "${node}" node in the graph.`);
    let degree = 0;
    let loops = 0;
    if (this.type !== "directed") {
      degree += nodeData.undirectedDegree;
      loops += nodeData.undirectedLoops * 2;
    }
    if (this.type !== "undirected") {
      degree += nodeData.inDegree + nodeData.outDegree;
      loops += nodeData.directedLoops * 2;
    }
    return degree - loops;
  }
  source(edge) {
    edge = "" + edge;
    const data = this._edges.get(edge);
    if (!data)
      throw new NotFoundGraphError(`Graph.source: could not find the "${edge}" edge in the graph.`);
    return data.source.key;
  }
  target(edge) {
    edge = "" + edge;
    const data = this._edges.get(edge);
    if (!data)
      throw new NotFoundGraphError(`Graph.target: could not find the "${edge}" edge in the graph.`);
    return data.target.key;
  }
  extremities(edge) {
    edge = "" + edge;
    const edgeData = this._edges.get(edge);
    if (!edgeData)
      throw new NotFoundGraphError(`Graph.extremities: could not find the "${edge}" edge in the graph.`);
    return [edgeData.source.key, edgeData.target.key];
  }
  opposite(node, edge) {
    node = "" + node;
    edge = "" + edge;
    const data = this._edges.get(edge);
    if (!data)
      throw new NotFoundGraphError(`Graph.opposite: could not find the "${edge}" edge in the graph.`);
    const source = data.source.key;
    const target = data.target.key;
    if (node === source)
      return target;
    if (node === target)
      return source;
    throw new NotFoundGraphError(`Graph.opposite: the "${node}" node is not attached to the "${edge}" edge (${source}, ${target}).`);
  }
  hasExtremity(edge, node) {
    edge = "" + edge;
    node = "" + node;
    const data = this._edges.get(edge);
    if (!data)
      throw new NotFoundGraphError(`Graph.hasExtremity: could not find the "${edge}" edge in the graph.`);
    return data.source.key === node || data.target.key === node;
  }
  isUndirected(edge) {
    edge = "" + edge;
    const data = this._edges.get(edge);
    if (!data)
      throw new NotFoundGraphError(`Graph.isUndirected: could not find the "${edge}" edge in the graph.`);
    return data.undirected;
  }
  isDirected(edge) {
    edge = "" + edge;
    const data = this._edges.get(edge);
    if (!data)
      throw new NotFoundGraphError(`Graph.isDirected: could not find the "${edge}" edge in the graph.`);
    return !data.undirected;
  }
  isSelfLoop(edge) {
    edge = "" + edge;
    const data = this._edges.get(edge);
    if (!data)
      throw new NotFoundGraphError(`Graph.isSelfLoop: could not find the "${edge}" edge in the graph.`);
    return data.source === data.target;
  }
  addNode(node, attributes) {
    const nodeData = addNode(this, node, attributes);
    return nodeData.key;
  }
  mergeNode(node, attributes) {
    if (attributes && !isPlainObject4(attributes))
      throw new InvalidArgumentsGraphError(`Graph.mergeNode: invalid attributes. Expecting an object but got "${attributes}"`);
    node = "" + node;
    attributes = attributes || {};
    let data = this._nodes.get(node);
    if (data) {
      if (attributes) {
        assign(data.attributes, attributes);
        this.emit("nodeAttributesUpdated", {
          type: "merge",
          key: node,
          attributes: data.attributes,
          data: attributes
        });
      }
      return [node, false];
    }
    data = new this.NodeDataClass(node, attributes);
    this._nodes.set(node, data);
    this.emit("nodeAdded", {
      key: node,
      attributes
    });
    return [node, true];
  }
  updateNode(node, updater) {
    if (updater && typeof updater !== "function")
      throw new InvalidArgumentsGraphError(`Graph.updateNode: invalid updater function. Expecting a function but got "${updater}"`);
    node = "" + node;
    let data = this._nodes.get(node);
    if (data) {
      if (updater) {
        const oldAttributes = data.attributes;
        data.attributes = updater(oldAttributes);
        this.emit("nodeAttributesUpdated", {
          type: "replace",
          key: node,
          attributes: data.attributes
        });
      }
      return [node, false];
    }
    const attributes = updater ? updater({}) : {};
    data = new this.NodeDataClass(node, attributes);
    this._nodes.set(node, data);
    this.emit("nodeAdded", {
      key: node,
      attributes
    });
    return [node, true];
  }
  dropNode(node) {
    node = "" + node;
    const nodeData = this._nodes.get(node);
    if (!nodeData)
      throw new NotFoundGraphError(`Graph.dropNode: could not find the "${node}" node in the graph.`);
    let edgeData;
    if (this.type !== "undirected") {
      for (const neighbor in nodeData.out) {
        edgeData = nodeData.out[neighbor];
        do {
          dropEdgeFromData(this, edgeData);
          edgeData = edgeData.next;
        } while (edgeData);
      }
      for (const neighbor in nodeData.in) {
        edgeData = nodeData.in[neighbor];
        do {
          dropEdgeFromData(this, edgeData);
          edgeData = edgeData.next;
        } while (edgeData);
      }
    }
    if (this.type !== "directed") {
      for (const neighbor in nodeData.undirected) {
        edgeData = nodeData.undirected[neighbor];
        do {
          dropEdgeFromData(this, edgeData);
          edgeData = edgeData.next;
        } while (edgeData);
      }
    }
    this._nodes.delete(node);
    this.emit("nodeDropped", {
      key: node,
      attributes: nodeData.attributes
    });
  }
  dropEdge(edge) {
    let edgeData;
    if (arguments.length > 1) {
      const source = "" + arguments[0];
      const target = "" + arguments[1];
      edgeData = getMatchingEdge(this, source, target, this.type);
      if (!edgeData)
        throw new NotFoundGraphError(`Graph.dropEdge: could not find the "${source}" -> "${target}" edge in the graph.`);
    } else {
      edge = "" + edge;
      edgeData = this._edges.get(edge);
      if (!edgeData)
        throw new NotFoundGraphError(`Graph.dropEdge: could not find the "${edge}" edge in the graph.`);
    }
    dropEdgeFromData(this, edgeData);
    return this;
  }
  dropDirectedEdge(source, target) {
    if (arguments.length < 2)
      throw new UsageGraphError("Graph.dropDirectedEdge: it does not make sense to try and drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");
    if (this.multi)
      throw new UsageGraphError("Graph.dropDirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");
    source = "" + source;
    target = "" + target;
    const edgeData = getMatchingEdge(this, source, target, "directed");
    if (!edgeData)
      throw new NotFoundGraphError(`Graph.dropDirectedEdge: could not find a "${source}" -> "${target}" edge in the graph.`);
    dropEdgeFromData(this, edgeData);
    return this;
  }
  dropUndirectedEdge(source, target) {
    if (arguments.length < 2)
      throw new UsageGraphError("Graph.dropUndirectedEdge: it does not make sense to drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");
    if (this.multi)
      throw new UsageGraphError("Graph.dropUndirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");
    const edgeData = getMatchingEdge(this, source, target, "undirected");
    if (!edgeData)
      throw new NotFoundGraphError(`Graph.dropUndirectedEdge: could not find a "${source}" -> "${target}" edge in the graph.`);
    dropEdgeFromData(this, edgeData);
    return this;
  }
  clear() {
    this._edges.clear();
    this._nodes.clear();
    this._resetInstanceCounters();
    this.emit("cleared");
  }
  clearEdges() {
    const iterator = this._nodes.values();
    let step;
    while (step = iterator.next(), step.done !== true) {
      step.value.clear();
    }
    this._edges.clear();
    this._resetInstanceCounters();
    this.emit("edgesCleared");
  }
  getAttribute(name) {
    return this._attributes[name];
  }
  getAttributes() {
    return this._attributes;
  }
  hasAttribute(name) {
    return this._attributes.hasOwnProperty(name);
  }
  setAttribute(name, value) {
    this._attributes[name] = value;
    this.emit("attributesUpdated", {
      type: "set",
      attributes: this._attributes,
      name
    });
    return this;
  }
  updateAttribute(name, updater) {
    if (typeof updater !== "function")
      throw new InvalidArgumentsGraphError("Graph.updateAttribute: updater should be a function.");
    const value = this._attributes[name];
    this._attributes[name] = updater(value);
    this.emit("attributesUpdated", {
      type: "set",
      attributes: this._attributes,
      name
    });
    return this;
  }
  removeAttribute(name) {
    delete this._attributes[name];
    this.emit("attributesUpdated", {
      type: "remove",
      attributes: this._attributes,
      name
    });
    return this;
  }
  replaceAttributes(attributes) {
    if (!isPlainObject4(attributes))
      throw new InvalidArgumentsGraphError("Graph.replaceAttributes: provided attributes are not a plain object.");
    this._attributes = attributes;
    this.emit("attributesUpdated", {
      type: "replace",
      attributes: this._attributes
    });
    return this;
  }
  mergeAttributes(attributes) {
    if (!isPlainObject4(attributes))
      throw new InvalidArgumentsGraphError("Graph.mergeAttributes: provided attributes are not a plain object.");
    assign(this._attributes, attributes);
    this.emit("attributesUpdated", {
      type: "merge",
      attributes: this._attributes,
      data: attributes
    });
    return this;
  }
  updateAttributes(updater) {
    if (typeof updater !== "function")
      throw new InvalidArgumentsGraphError("Graph.updateAttributes: provided updater is not a function.");
    this._attributes = updater(this._attributes);
    this.emit("attributesUpdated", {
      type: "update",
      attributes: this._attributes
    });
    return this;
  }
  updateEachNodeAttributes(updater, hints) {
    if (typeof updater !== "function")
      throw new InvalidArgumentsGraphError("Graph.updateEachNodeAttributes: expecting an updater function.");
    if (hints && !validateHints(hints))
      throw new InvalidArgumentsGraphError("Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");
    const iterator = this._nodes.values();
    let step, nodeData;
    while (step = iterator.next(), step.done !== true) {
      nodeData = step.value;
      nodeData.attributes = updater(nodeData.key, nodeData.attributes);
    }
    this.emit("eachNodeAttributesUpdated", {
      hints: hints ? hints : null
    });
  }
  updateEachEdgeAttributes(updater, hints) {
    if (typeof updater !== "function")
      throw new InvalidArgumentsGraphError("Graph.updateEachEdgeAttributes: expecting an updater function.");
    if (hints && !validateHints(hints))
      throw new InvalidArgumentsGraphError("Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");
    const iterator = this._edges.values();
    let step, edgeData, sourceData, targetData;
    while (step = iterator.next(), step.done !== true) {
      edgeData = step.value;
      sourceData = edgeData.source;
      targetData = edgeData.target;
      edgeData.attributes = updater(edgeData.key, edgeData.attributes, sourceData.key, targetData.key, sourceData.attributes, targetData.attributes, edgeData.undirected);
    }
    this.emit("eachEdgeAttributesUpdated", {
      hints: hints ? hints : null
    });
  }
  forEachAdjacencyEntry(callback) {
    if (typeof callback !== "function")
      throw new InvalidArgumentsGraphError("Graph.forEachAdjacencyEntry: expecting a callback.");
    forEachAdjacency(false, false, false, this, callback);
  }
  forEachAdjacencyEntryWithOrphans(callback) {
    if (typeof callback !== "function")
      throw new InvalidArgumentsGraphError("Graph.forEachAdjacencyEntryWithOrphans: expecting a callback.");
    forEachAdjacency(false, false, true, this, callback);
  }
  forEachAssymetricAdjacencyEntry(callback) {
    if (typeof callback !== "function")
      throw new InvalidArgumentsGraphError("Graph.forEachAssymetricAdjacencyEntry: expecting a callback.");
    forEachAdjacency(false, true, false, this, callback);
  }
  forEachAssymetricAdjacencyEntryWithOrphans(callback) {
    if (typeof callback !== "function")
      throw new InvalidArgumentsGraphError("Graph.forEachAssymetricAdjacencyEntryWithOrphans: expecting a callback.");
    forEachAdjacency(false, true, true, this, callback);
  }
  nodes() {
    return Array.from(this._nodes.keys());
  }
  forEachNode(callback) {
    if (typeof callback !== "function")
      throw new InvalidArgumentsGraphError("Graph.forEachNode: expecting a callback.");
    const iterator = this._nodes.values();
    let step, nodeData;
    while (step = iterator.next(), step.done !== true) {
      nodeData = step.value;
      callback(nodeData.key, nodeData.attributes);
    }
  }
  findNode(callback) {
    if (typeof callback !== "function")
      throw new InvalidArgumentsGraphError("Graph.findNode: expecting a callback.");
    const iterator = this._nodes.values();
    let step, nodeData;
    while (step = iterator.next(), step.done !== true) {
      nodeData = step.value;
      if (callback(nodeData.key, nodeData.attributes))
        return nodeData.key;
    }
    return;
  }
  mapNodes(callback) {
    if (typeof callback !== "function")
      throw new InvalidArgumentsGraphError("Graph.mapNode: expecting a callback.");
    const iterator = this._nodes.values();
    let step, nodeData;
    const result = new Array(this.order);
    let i = 0;
    while (step = iterator.next(), step.done !== true) {
      nodeData = step.value;
      result[i++] = callback(nodeData.key, nodeData.attributes);
    }
    return result;
  }
  someNode(callback) {
    if (typeof callback !== "function")
      throw new InvalidArgumentsGraphError("Graph.someNode: expecting a callback.");
    const iterator = this._nodes.values();
    let step, nodeData;
    while (step = iterator.next(), step.done !== true) {
      nodeData = step.value;
      if (callback(nodeData.key, nodeData.attributes))
        return true;
    }
    return false;
  }
  everyNode(callback) {
    if (typeof callback !== "function")
      throw new InvalidArgumentsGraphError("Graph.everyNode: expecting a callback.");
    const iterator = this._nodes.values();
    let step, nodeData;
    while (step = iterator.next(), step.done !== true) {
      nodeData = step.value;
      if (!callback(nodeData.key, nodeData.attributes))
        return false;
    }
    return true;
  }
  filterNodes(callback) {
    if (typeof callback !== "function")
      throw new InvalidArgumentsGraphError("Graph.filterNodes: expecting a callback.");
    const iterator = this._nodes.values();
    let step, nodeData;
    const result = [];
    while (step = iterator.next(), step.done !== true) {
      nodeData = step.value;
      if (callback(nodeData.key, nodeData.attributes))
        result.push(nodeData.key);
    }
    return result;
  }
  reduceNodes(callback, initialValue) {
    if (typeof callback !== "function")
      throw new InvalidArgumentsGraphError("Graph.reduceNodes: expecting a callback.");
    if (arguments.length < 2)
      throw new InvalidArgumentsGraphError("Graph.reduceNodes: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.");
    let accumulator = initialValue;
    const iterator = this._nodes.values();
    let step, nodeData;
    while (step = iterator.next(), step.done !== true) {
      nodeData = step.value;
      accumulator = callback(accumulator, nodeData.key, nodeData.attributes);
    }
    return accumulator;
  }
  nodeEntries() {
    const iterator = this._nodes.values();
    return {
      [Symbol.iterator]() {
        return this;
      },
      next() {
        const step = iterator.next();
        if (step.done)
          return step;
        const data = step.value;
        return {
          value: { node: data.key, attributes: data.attributes },
          done: false
        };
      }
    };
  }
  export() {
    const nodes = new Array(this._nodes.size);
    let i = 0;
    this._nodes.forEach((data, key) => {
      nodes[i++] = serializeNode(key, data);
    });
    const edges = new Array(this._edges.size);
    i = 0;
    this._edges.forEach((data, key) => {
      edges[i++] = serializeEdge(this.type, key, data);
    });
    return {
      options: {
        type: this.type,
        multi: this.multi,
        allowSelfLoops: this.allowSelfLoops
      },
      attributes: this.getAttributes(),
      nodes,
      edges
    };
  }
  import(data, merge3 = false) {
    if (data instanceof Graph) {
      data.forEachNode((n, a) => {
        if (merge3)
          this.mergeNode(n, a);
        else
          this.addNode(n, a);
      });
      data.forEachEdge((e, a, s, t, _sa, _ta, u) => {
        if (merge3) {
          if (u)
            this.mergeUndirectedEdgeWithKey(e, s, t, a);
          else
            this.mergeDirectedEdgeWithKey(e, s, t, a);
        } else {
          if (u)
            this.addUndirectedEdgeWithKey(e, s, t, a);
          else
            this.addDirectedEdgeWithKey(e, s, t, a);
        }
      });
      return this;
    }
    if (!isPlainObject4(data))
      throw new InvalidArgumentsGraphError("Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.");
    if (data.attributes) {
      if (!isPlainObject4(data.attributes))
        throw new InvalidArgumentsGraphError("Graph.import: invalid attributes. Expecting a plain object.");
      if (merge3)
        this.mergeAttributes(data.attributes);
      else
        this.replaceAttributes(data.attributes);
    }
    let i, l, list, node, edge;
    if (data.nodes) {
      list = data.nodes;
      if (!Array.isArray(list))
        throw new InvalidArgumentsGraphError("Graph.import: invalid nodes. Expecting an array.");
      for (i = 0, l = list.length;i < l; i++) {
        node = list[i];
        validateSerializedNode(node);
        const { key, attributes } = node;
        if (merge3)
          this.mergeNode(key, attributes);
        else
          this.addNode(key, attributes);
      }
    }
    if (data.edges) {
      let undirectedByDefault = false;
      if (this.type === "undirected") {
        undirectedByDefault = true;
      }
      list = data.edges;
      if (!Array.isArray(list))
        throw new InvalidArgumentsGraphError("Graph.import: invalid edges. Expecting an array.");
      for (i = 0, l = list.length;i < l; i++) {
        edge = list[i];
        validateSerializedEdge(edge);
        const {
          source,
          target,
          attributes,
          undirected = undirectedByDefault
        } = edge;
        let method;
        if ("key" in edge) {
          method = merge3 ? undirected ? this.mergeUndirectedEdgeWithKey : this.mergeDirectedEdgeWithKey : undirected ? this.addUndirectedEdgeWithKey : this.addDirectedEdgeWithKey;
          method.call(this, edge.key, source, target, attributes);
        } else {
          method = merge3 ? undirected ? this.mergeUndirectedEdge : this.mergeDirectedEdge : undirected ? this.addUndirectedEdge : this.addDirectedEdge;
          method.call(this, source, target, attributes);
        }
      }
    }
    return this;
  }
  nullCopy(options2) {
    const graph = new Graph(assign({}, this._options, options2));
    graph.replaceAttributes(assign({}, this.getAttributes()));
    return graph;
  }
  emptyCopy(options2) {
    const graph = this.nullCopy(options2);
    this._nodes.forEach((nodeData, key) => {
      const attributes = assign({}, nodeData.attributes);
      nodeData = new graph.NodeDataClass(key, attributes);
      graph._nodes.set(key, nodeData);
    });
    return graph;
  }
  copy(options2) {
    options2 = options2 || {};
    if (typeof options2.type === "string" && options2.type !== this.type && options2.type !== "mixed")
      throw new UsageGraphError(`Graph.copy: cannot create an incompatible copy from "${this.type}" type to "${options2.type}" because this would mean losing information about the current graph.`);
    if (typeof options2.multi === "boolean" && options2.multi !== this.multi && options2.multi !== true)
      throw new UsageGraphError("Graph.copy: cannot create an incompatible copy by downgrading a multi graph to a simple one because this would mean losing information about the current graph.");
    if (typeof options2.allowSelfLoops === "boolean" && options2.allowSelfLoops !== this.allowSelfLoops && options2.allowSelfLoops !== true)
      throw new UsageGraphError("Graph.copy: cannot create an incompatible copy from a graph allowing self loops to one that does not because this would mean losing information about the current graph.");
    const graph = this.emptyCopy(options2);
    const iterator = this._edges.values();
    let step, edgeData;
    while (step = iterator.next(), step.done !== true) {
      edgeData = step.value;
      addEdge(graph, "copy", false, edgeData.undirected, edgeData.key, edgeData.source.key, edgeData.target.key, assign({}, edgeData.attributes));
    }
    return graph;
  }
  toJSON() {
    return this.export();
  }
  toString() {
    return "[object Graph]";
  }
  inspect() {
    const nodes = {};
    this._nodes.forEach((data, key) => {
      nodes[key] = data.attributes;
    });
    const edges = {}, multiIndex = {};
    this._edges.forEach((data, key) => {
      const direction = data.undirected ? "--" : "->";
      let label = "";
      let source = data.source.key;
      let target = data.target.key;
      let tmp;
      if (data.undirected && source > target) {
        tmp = source;
        source = target;
        target = tmp;
      }
      const desc2 = `(${source})${direction}(${target})`;
      if (!key.startsWith("geid_")) {
        label += `[${key}]: `;
      } else if (this.multi) {
        if (typeof multiIndex[desc2] === "undefined") {
          multiIndex[desc2] = 0;
        } else {
          multiIndex[desc2]++;
        }
        label += `${multiIndex[desc2]}. `;
      }
      label += desc2;
      edges[label] = data.attributes;
    });
    const dummy = {};
    for (const k in this) {
      if (this.hasOwnProperty(k) && !EMITTER_PROPS.has(k) && typeof this[k] !== "function" && typeof k !== "symbol")
        dummy[k] = this[k];
    }
    dummy.attributes = this._attributes;
    dummy.nodes = nodes;
    dummy.edges = edges;
    privateProperty(dummy, "constructor", this.constructor);
    return dummy;
  }
}
if (typeof Symbol !== "undefined")
  Graph.prototype[Symbol.for("nodejs.util.inspect.custom")] = Graph.prototype.inspect;
EDGE_ADD_METHODS.forEach((method) => {
  ["add", "merge", "update"].forEach((verb) => {
    const name = method.name(verb);
    const fn = verb === "add" ? addEdge : mergeEdge;
    if (method.generateKey) {
      Graph.prototype[name] = function(source, target, attributes) {
        return fn(this, name, true, (method.type || this.type) === "undirected", null, source, target, attributes, verb === "update");
      };
    } else {
      Graph.prototype[name] = function(edge, source, target, attributes) {
        return fn(this, name, false, (method.type || this.type) === "undirected", edge, source, target, attributes, verb === "update");
      };
    }
  });
});
attachNodeAttributesMethods(Graph);
attachEdgeAttributesMethods(Graph);
attachEdgeIterationMethods(Graph);
attachNeighborIterationMethods(Graph);

class DirectedGraph extends Graph {
  constructor(options2) {
    const finalOptions = assign({ type: "directed" }, options2);
    if ("multi" in finalOptions && finalOptions.multi !== false)
      throw new InvalidArgumentsGraphError("DirectedGraph.from: inconsistent indication that the graph should be multi in given options!");
    if (finalOptions.type !== "directed")
      throw new InvalidArgumentsGraphError('DirectedGraph.from: inconsistent "' + finalOptions.type + '" type in given options!');
    super(finalOptions);
  }
}

class UndirectedGraph extends Graph {
  constructor(options2) {
    const finalOptions = assign({ type: "undirected" }, options2);
    if ("multi" in finalOptions && finalOptions.multi !== false)
      throw new InvalidArgumentsGraphError("UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!");
    if (finalOptions.type !== "undirected")
      throw new InvalidArgumentsGraphError('UndirectedGraph.from: inconsistent "' + finalOptions.type + '" type in given options!');
    super(finalOptions);
  }
}

class MultiGraph extends Graph {
  constructor(options2) {
    const finalOptions = assign({ multi: true }, options2);
    if ("multi" in finalOptions && finalOptions.multi !== true)
      throw new InvalidArgumentsGraphError("MultiGraph.from: inconsistent indication that the graph should be simple in given options!");
    super(finalOptions);
  }
}

class MultiDirectedGraph extends Graph {
  constructor(options2) {
    const finalOptions = assign({ type: "directed", multi: true }, options2);
    if ("multi" in finalOptions && finalOptions.multi !== true)
      throw new InvalidArgumentsGraphError("MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!");
    if (finalOptions.type !== "directed")
      throw new InvalidArgumentsGraphError('MultiDirectedGraph.from: inconsistent "' + finalOptions.type + '" type in given options!');
    super(finalOptions);
  }
}

class MultiUndirectedGraph extends Graph {
  constructor(options2) {
    const finalOptions = assign({ type: "undirected", multi: true }, options2);
    if ("multi" in finalOptions && finalOptions.multi !== true)
      throw new InvalidArgumentsGraphError("MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!");
    if (finalOptions.type !== "undirected")
      throw new InvalidArgumentsGraphError('MultiUndirectedGraph.from: inconsistent "' + finalOptions.type + '" type in given options!');
    super(finalOptions);
  }
}
function attachStaticFromMethod(Class3) {
  Class3.from = function(data, options2) {
    const finalOptions = assign({}, data.options, options2);
    const instance = new Class3(finalOptions);
    instance.import(data);
    return instance;
  };
}
attachStaticFromMethod(Graph);
attachStaticFromMethod(DirectedGraph);
attachStaticFromMethod(UndirectedGraph);
attachStaticFromMethod(MultiGraph);
attachStaticFromMethod(MultiDirectedGraph);
attachStaticFromMethod(MultiUndirectedGraph);
Graph.Graph = Graph;
Graph.DirectedGraph = DirectedGraph;
Graph.UndirectedGraph = UndirectedGraph;
Graph.MultiGraph = MultiGraph;
Graph.MultiDirectedGraph = MultiDirectedGraph;
Graph.MultiUndirectedGraph = MultiUndirectedGraph;
Graph.InvalidArgumentsGraphError = InvalidArgumentsGraphError;
Graph.NotFoundGraphError = NotFoundGraphError;
Graph.UsageGraphError = UsageGraphError;

// src/core/GraphEngine.ts
var import_graphology_communities_louvain = __toESM(require_graphology_communities_louvain(), 1);

// node_modules/graphology-components/index.js
var isGraph = require_is_graph();
var copyNode = require_add_node().copyNode;
var copyEdge = require_add_edge().copyEdge;
var DFSStack = require_dfs_stack();
function forEachConnectedComponent(graph, callback) {
  if (!isGraph(graph))
    throw new Error("graphology-components: the given graph is not a valid graphology instance.");
  if (!graph.order)
    return;
  var stack = new DFSStack(graph);
  var push = stack.push.bind(stack);
  stack.forEachNodeYetUnseen(function(node) {
    var component = [];
    stack.push(node);
    var source;
    while (stack.size !== 0) {
      source = stack.pop();
      component.push(source);
      graph.forEachNeighbor(source, push);
    }
    callback(component);
  });
}
function forEachConnectedComponentOrder(graph, callback) {
  if (!isGraph(graph))
    throw new Error("graphology-components: the given graph is not a valid graphology instance.");
  if (!graph.order)
    return;
  var stack = new DFSStack(graph);
  var push = stack.push.bind(stack);
  stack.forEachNodeYetUnseen(function(node) {
    var order = 0;
    stack.push(node);
    var source;
    while (stack.size !== 0) {
      source = stack.pop();
      order++;
      graph.forEachNeighbor(source, push);
    }
    callback(order);
  });
}
function countConnectedComponents(graph) {
  var n = 0;
  forEachConnectedComponentOrder(graph, function() {
    n++;
  });
  return n;
}
function connectedComponents(graph) {
  var components = [];
  forEachConnectedComponent(graph, function(component) {
    components.push(component);
  });
  return components;
}
var $countConnectedComponents = countConnectedComponents;
var $connectedComponents = connectedComponents;

// src/core/GraphEngine.ts
var import_betweenness = __toESM(require_betweenness(), 1);
var import_pagerank = __toESM(require_pagerank(), 1);

// node_modules/graphology-shortest-path/unweighted.js
var isGraph2 = require_is_graph();
var Queue = require_queue();
var extend3 = require_extend();
function bidirectional(graph, source, target) {
  if (!isGraph2(graph))
    throw new Error("graphology-shortest-path: invalid graphology instance.");
  if (arguments.length < 3)
    throw new Error("graphology-shortest-path: invalid number of arguments. Expecting at least 3.");
  if (!graph.hasNode(source))
    throw new Error('graphology-shortest-path: the "' + source + '" source node does not exist in the given graph.');
  if (!graph.hasNode(target))
    throw new Error('graphology-shortest-path: the "' + target + '" target node does not exist in the given graph.');
  source = "" + source;
  target = "" + target;
  if (source === target) {
    return [source];
  }
  var getPredecessors = graph.inboundNeighbors.bind(graph), getSuccessors = graph.outboundNeighbors.bind(graph);
  var predecessor = {}, successor = {};
  predecessor[source] = null;
  successor[target] = null;
  var forwardFringe = [source], reverseFringe = [target], currentFringe, node, neighbors, neighbor, i, j, l, m;
  var found = false;
  outer:
    while (forwardFringe.length && reverseFringe.length) {
      if (forwardFringe.length <= reverseFringe.length) {
        currentFringe = forwardFringe;
        forwardFringe = [];
        for (i = 0, l = currentFringe.length;i < l; i++) {
          node = currentFringe[i];
          neighbors = getSuccessors(node);
          for (j = 0, m = neighbors.length;j < m; j++) {
            neighbor = neighbors[j];
            if (!(neighbor in predecessor)) {
              forwardFringe.push(neighbor);
              predecessor[neighbor] = node;
            }
            if (neighbor in successor) {
              found = true;
              break outer;
            }
          }
        }
      } else {
        currentFringe = reverseFringe;
        reverseFringe = [];
        for (i = 0, l = currentFringe.length;i < l; i++) {
          node = currentFringe[i];
          neighbors = getPredecessors(node);
          for (j = 0, m = neighbors.length;j < m; j++) {
            neighbor = neighbors[j];
            if (!(neighbor in successor)) {
              reverseFringe.push(neighbor);
              successor[neighbor] = node;
            }
            if (neighbor in predecessor) {
              found = true;
              break outer;
            }
          }
        }
      }
    }
  if (!found)
    return null;
  var path2 = [];
  while (neighbor) {
    path2.unshift(neighbor);
    neighbor = predecessor[neighbor];
  }
  neighbor = successor[path2[path2.length - 1]];
  while (neighbor) {
    path2.push(neighbor);
    neighbor = successor[neighbor];
  }
  return path2.length ? path2 : null;
}
function asbtractSingleSourceLength(method, graph, source) {
  if (!isGraph2(graph))
    throw new Error("graphology-shortest-path: invalid graphology instance.");
  if (!graph.hasNode(source))
    throw new Error('graphology-shortest-path: the "' + source + '" source node does not exist in the given graph.');
  source = "" + source;
  var seen = new Set;
  var lengths = {}, level = 0;
  lengths[source] = 0;
  var currentLevel = [source];
  var i, l, node;
  while (currentLevel.length !== 0) {
    var nextLevel = [];
    for (i = 0, l = currentLevel.length;i < l; i++) {
      node = currentLevel[i];
      if (seen.has(node))
        continue;
      seen.add(node);
      extend3(nextLevel, graph[method](node));
      lengths[node] = level;
    }
    level++;
    currentLevel = nextLevel;
  }
  return lengths;
}
var singleSourceLength = asbtractSingleSourceLength.bind(null, "outboundNeighbors");
var undirectedSingleSourceLength = asbtractSingleSourceLength.bind(null, "neighbors");
var $bidirectional = bidirectional;

// node_modules/graphology-traversal/index.js
var bfsModule = require_bfs();
var dfsModule = require_dfs();
var $bfs = bfsModule.bfs;
var $bfsFromNode = bfsModule.bfsFromNode;
var $dfs = dfsModule.dfs;
var $dfsFromNode = dfsModule.dfsFromNode;

// src/core/GraphEngine.ts
var log7 = getLogger("GraphEngine");

class GraphEngine {
  graph;
  constructor() {
    this.graph = new MultiDirectedGraph({ allowSelfLoops: true });
  }
  async load(db) {
    log7.info("Loading graph into memory...");
    const start = Date.now();
    this.graph.clear();
    const nodes = db.query("SELECT id, type, title, domain, layer, date FROM nodes").all();
    for (const node of nodes) {
      this.graph.addNode(node.id, {
        type: node.type,
        title: node.title,
        domain: node.domain,
        layer: node.layer,
        date: node.date
      });
    }
    const edges = db.query("SELECT source, target, type FROM edges").all();
    for (const edge of edges) {
      try {
        if (this.graph.hasNode(edge.source) && this.graph.hasNode(edge.target)) {
          this.graph.addEdge(edge.source, edge.target, {
            type: edge.type
          });
        }
      } catch (err) {
        log7.debug({ source: edge.source, target: edge.target, error: err }, "Failed to add edge");
      }
    }
    log7.info({
      nodes: this.graph.order,
      edges: this.graph.size,
      elapsedMs: Date.now() - start
    }, "Graph loaded successfully");
  }
  getNeighbors(nodeId) {
    if (!this.graph.hasNode(nodeId))
      return [];
    return this.graph.neighbors(nodeId);
  }
  getNodeAttributes(nodeId) {
    if (!this.graph.hasNode(nodeId))
      return null;
    return this.graph.getNodeAttributes(nodeId);
  }
  findShortestPath(sourceId, targetId) {
    if (!this.graph.hasNode(sourceId) || !this.graph.hasNode(targetId)) {
      return null;
    }
    return $bidirectional(this.graph, sourceId, targetId);
  }
  detectCommunities() {
    return import_graphology_communities_louvain.default(this.graph);
  }
  getPagerank() {
    return import_pagerank.default(this.graph);
  }
  getBetweenness() {
    return import_betweenness.default(this.graph);
  }
  getComponents() {
    return $connectedComponents(this.graph);
  }
  getMetrics() {
    const pr = this.getPagerank();
    const bc = this.getBetweenness();
    const communities = this.detectCommunities();
    return {
      pagerank: pr,
      betweenness: bc,
      communities,
      components: this.getComponents().length,
      stats: this.getStats()
    };
  }
  getAdamicAdar(nodeA, nodeB) {
    if (!this.graph.hasNode(nodeA) || !this.graph.hasNode(nodeB))
      return 0;
    if (nodeA === nodeB)
      return 0;
    const neighborsA = new Set(this.graph.neighbors(nodeA));
    const neighborsB = this.graph.neighbors(nodeB);
    let score = 0;
    for (const neighbor of neighborsB) {
      if (neighborsA.has(neighbor)) {
        const degree = this.graph.degree(neighbor);
        if (degree > 1) {
          score += 1 / Math.log(degree);
        }
      }
    }
    return score;
  }
  findStructuralCandidates(limit = 10) {
    const candidates = [];
    const nodes = this.graph.nodes();
    const seen = new Set;
    for (const u of nodes) {
      const neighborsU = new Set(this.graph.neighbors(u));
      const twoHopPotential = new Set;
      for (const w of neighborsU) {
        for (const v of this.graph.neighbors(w)) {
          if (v !== u && !neighborsU.has(v)) {
            twoHopPotential.add(v);
          }
        }
      }
      for (const v of twoHopPotential) {
        const pairId = [u, v].sort().join("|");
        if (seen.has(pairId))
          continue;
        seen.add(pairId);
        const score = this.getAdamicAdar(u, v);
        if (score > 0) {
          candidates.push({ source: u, target: v, score });
        }
      }
    }
    return candidates.sort((a, b) => b.score - a.score).slice(0, limit);
  }
  findPillars(limit = 10) {
    const pr = this.getPagerank();
    const pillars = Object.entries(pr).map(([id, score]) => ({
      id,
      score,
      degree: this.graph.degree(id)
    })).sort((a, b) => b.score - a.score).slice(0, limit);
    return pillars;
  }
  getCommunities() {
    const communities = this.detectCommunities();
    const mapping = {};
    for (const [node, communityId] of Object.entries(communities)) {
      const key = communityId.toString();
      if (!mapping[key])
        mapping[key] = [];
      mapping[key].push(node);
    }
    return mapping;
  }
  getStats() {
    return {
      nodes: this.graph.order,
      edges: this.graph.size,
      density: this.graph.size / (this.graph.order * (this.graph.order - 1) || 1)
    };
  }
  getInternalGraph() {
    return this.graph;
  }
  traverse(startNodeId, maxDepth) {
    if (!this.graph.hasNode(startNodeId))
      return [];
    const visited = [];
    $bfsFromNode(this.graph, startNodeId, (node, _attr, depth) => {
      if (maxDepth !== undefined && depth > maxDepth)
        return true;
      visited.push(node);
      return false;
    });
    return visited;
  }
  validateIntegrity() {
    return {
      selfLoopCount: this.graph.selfLoopCount,
      connectedComponents: $countConnectedComponents(this.graph),
      order: this.graph.order,
      size: this.graph.size
    };
  }
}

// src/core/GraphGardener.ts
var log8 = getLogger("GraphGardener");

class GraphGardener {
  db;
  graph;
  vector;
  constructor(db, graph, vector) {
    this.db = db;
    this.graph = graph;
    this.vector = vector;
  }
  async findGaps(limit = 10, similarityThreshold = 0.82) {
    log8.info("Analyzing graph for semantic gaps...");
    const candidates = this.db.getRawDb().query("SELECT id, embedding FROM nodes WHERE embedding IS NOT NULL LIMIT 100").all();
    const suggestions = [];
    for (const node of candidates) {
      if (!node.embedding)
        continue;
      const queryFloats = new Float32Array(node.embedding.buffer, node.embedding.byteOffset, node.embedding.byteLength / 4);
      const semanticNeighbors = await this.vector.searchByVector(queryFloats, 5);
      const graphNeighbors = new Set(this.graph.getNeighbors(node.id));
      for (const sn of semanticNeighbors) {
        if (sn.id === node.id)
          continue;
        if (sn.score < similarityThreshold)
          continue;
        if (!graphNeighbors.has(sn.id)) {
          if (!suggestions.find((s) => s.sourceId === node.id && s.targetId === sn.id || s.sourceId === sn.id && s.targetId === node.id)) {
            suggestions.push({
              sourceId: node.id,
              targetId: sn.id,
              reason: "Semantic proximity without structural link",
              similarity: sn.score
            });
          }
        }
      }
    }
    return suggestions.sort((a, b) => b.similarity - a.similarity).slice(0, limit);
  }
  findStructuralGaps(limit = 10) {
    log8.info("Analyzing graph for structural gaps (Adamic-Adar)...");
    const candidates = this.graph.findStructuralCandidates(limit);
    return candidates.map((c) => ({
      sourceId: c.source,
      targetId: c.target,
      reason: `Structural Adamic-Adar overlap (score: ${c.score.toFixed(2)})`,
      similarity: c.score
    }));
  }
  analyzeCommunities() {
    const communities = this.graph.detectCommunities();
    const clusters = new Map;
    for (const [nodeId, clusterId] of Object.entries(communities)) {
      if (!clusters.has(clusterId))
        clusters.set(clusterId, []);
      clusters.get(clusterId)?.push(nodeId);
    }
    return Array.from(clusters.entries()).map(([clusterId, nodes]) => ({
      clusterId,
      nodes
    }));
  }
  getClusterRepresentatives(nodes, top = 3) {
    const pr = this.graph.getPagerank();
    return nodes.sort((a, b) => (pr[b] || 0) - (pr[a] || 0)).slice(0, top);
  }
  async findRelated(query, limit = 5) {
    return await this.vector.search(query, limit);
  }
  weaveTimeline() {
    const nodes = this.db.getRawDb().query("SELECT id, date FROM nodes WHERE date IS NOT NULL").all();
    if (nodes.length < 2)
      return [];
    nodes.sort((a, b) => a.date.localeCompare(b.date));
    const clusters = this.analyzeCommunities();
    const nodeToCluster = new Map;
    for (const c of clusters) {
      for (const nodeId of c.nodes) {
        nodeToCluster.set(nodeId, c.clusterId);
      }
    }
    const suggestions = [];
    const lastInCluster = new Map;
    for (const node of nodes) {
      const clusterId = nodeToCluster.get(node.id);
      if (clusterId === undefined)
        continue;
      const last = lastInCluster.get(clusterId);
      if (last) {
        suggestions.push({
          sourceId: last.id,
          targetId: node.id,
          reason: `Temporal sequence (${last.date} -> ${node.date}) in community ${clusterId}`,
          similarity: 1
        });
      }
      lastInCluster.set(clusterId, node);
    }
    return suggestions;
  }
  resolveSource(nodeId) {
    const row = this.db.getRawDb().query("SELECT meta FROM nodes WHERE id = ?").get(nodeId);
    if (row?.meta) {
      try {
        const meta3 = JSON.parse(row.meta);
        if (!meta3.source)
          return null;
        return fromRootRelative(meta3.source);
      } catch {
        return null;
      }
    }
    return null;
  }
  async getContent(nodeId) {
    const row = this.db.getRawDb().query("SELECT summary, meta FROM nodes WHERE id = ?").get(nodeId);
    if (row?.summary) {
      return row.summary;
    }
    if (row?.meta) {
      try {
        const meta3 = JSON.parse(row.meta);
        if (meta3.source) {
          const sourcePath = fromRootRelative(meta3.source);
          return await Bun.file(sourcePath).text();
        }
      } catch {}
    }
    return null;
  }
  identifyHubs(top = 5) {
    const pr = this.graph.getPagerank();
    const bc = this.graph.getBetweenness();
    const nodes = Object.keys(pr).map((id) => ({
      id,
      pagerank: pr[id],
      betweenness: bc[id],
      score: (pr[id] || 0) + (bc[id] || 0)
    }));
    return nodes.sort((a, b) => b.score - a.score).slice(0, top);
  }
}

// src/core/VectorEngine.ts
init_esm();
import { Database as Database4 } from "bun:sqlite";
function toFafcas2(vector) {
  let sum = 0;
  for (let i = 0;i < vector.length; i++) {
    const val = vector[i] || 0;
    sum += val * val;
  }
  const magnitude = Math.sqrt(sum);
  if (magnitude > 0.000001) {
    for (let i = 0;i < vector.length; i++) {
      vector[i] = (vector[i] || 0) / magnitude;
    }
  }
  return new Uint8Array(vector.buffer, vector.byteOffset, vector.byteLength);
}
function magnitude(vec) {
  let sum = 0;
  for (let i = 0;i < vec.length; i++) {
    const val = vec[i] || 0;
    sum += val * val;
  }
  return Math.sqrt(sum);
}
function dotProduct(a, b) {
  const magA = magnitude(a);
  const magB = magnitude(b);
  if (magA < 0.000001 || magB < 0.000001) {
    console.warn("\u26A0\uFE0F  Zero vector detected in dot product, skipping comparison");
    return 0;
  }
  let sum = 0;
  for (let i = 0;i < a.length; i++) {
    sum += (a[i] || 0) * (b[i] || 0);
  }
  return sum;
}

class VectorEngine {
  db;
  modelPromise;
  constructor(dbOrPath) {
    if (typeof dbOrPath === "string") {
      console.warn("\u26A0\uFE0F  DEPRECATED: VectorEngine string path constructor bypasses DatabaseFactory. Pass Database object instead. Will be removed in v2.0.");
      this.db = new Database4(dbOrPath);
      this.db.run("PRAGMA journal_mode = WAL;");
      this.db.run("PRAGMA busy_timeout = 5000;");
      this.db.run("PRAGMA synchronous = NORMAL;");
      this.db.run("PRAGMA mmap_size = 268435456;");
      this.db.run("PRAGMA temp_store = memory;");
    } else {
      this.db = dbOrPath;
    }
    this.modelPromise = FlagEmbedding.init({
      model: EmbeddingModel.BGESmallENV15
    });
  }
  async embed(text) {
    try {
      const model = await this.modelPromise;
      const embeddings = model.embed([text]);
      let vector;
      for await (const batch of embeddings) {
        if (batch && batch.length > 0) {
          vector = new Float32Array(batch[0]);
        }
        break;
      }
      if (!vector)
        return null;
      return toFafcas2(vector);
    } catch (e) {
      console.error("Failed to generate embedding:", e);
      return null;
    }
  }
  saveEmbedding(id, embedding) {
    this.db.prepare("UPDATE nodes SET embedding = ? WHERE id = ?").run(embedding, id);
  }
  async searchByVector(queryFloats, limit = 5) {
    const candidates = this.db.query("SELECT id, embedding FROM nodes WHERE embedding IS NOT NULL").all();
    const scored = [];
    for (const candidate of candidates) {
      const candidateFloats = new Float32Array(candidate.embedding.buffer, candidate.embedding.byteOffset, candidate.embedding.byteLength / 4);
      const score = dotProduct(queryFloats, candidateFloats);
      if (score > 0) {
        scored.push({ id: candidate.id, score });
      }
    }
    const topK = scored.sort((a, b) => b.score - a.score).slice(0, limit);
    const results = [];
    const metaStmt = this.db.prepare("SELECT title, meta, date FROM nodes WHERE id = ?");
    for (const item of topK) {
      const row = metaStmt.get(item.id);
      if (row) {
        let contentPlaceholder = "";
        if (row.meta) {
          try {
            const meta3 = JSON.parse(row.meta);
            contentPlaceholder = `[Hollow Node: ${meta3.source || "no source"}]`;
          } catch {
            contentPlaceholder = "[Hollow Node: parse error]";
          }
        }
        results.push({
          id: item.id,
          score: item.score,
          title: row.title,
          content: contentPlaceholder,
          date: row.date || undefined
        });
      }
    }
    return results;
  }
  async search(query, limit = 5) {
    const queryBlob = await this.embed(query);
    if (!queryBlob)
      return [];
    const queryFloats = new Float32Array(queryBlob.buffer, queryBlob.byteOffset, queryBlob.byteLength / 4);
    return this.searchByVector(queryFloats, limit);
  }
}

// src/cli/commands/read.ts
async function cmdRead(args) {
  const nodeId = args.find((arg) => !arg.startsWith("--"));
  const jsonOutput = args.includes("--json");
  if (!nodeId) {
    if (jsonOutput) {
      console.error(JSON.stringify({
        error: "Missing node ID argument",
        usage: "amalfa read <node-id> [--json]"
      }));
    } else {
      console.error("\u274C Error: Missing node ID argument");
      console.error(`
Usage: amalfa read <node-id> [--json]`);
      console.error(`
Examples:`);
      console.error("  amalfa read docs/README.md");
      console.error('  amalfa read "playbooks/oauth-patterns.md"');
      console.error("  amalfa read docs/README.md --json");
      console.error(`
\uD83D\uDCA1 Tip: Get node IDs from 'amalfa search' results`);
    }
    process.exit(1);
  }
  if (!await checkDatabase()) {
    if (jsonOutput) {
      console.error(JSON.stringify({
        error: "Database not found",
        suggestion: "Run 'amalfa init' first"
      }));
    } else {
      console.error("\u274C Database not found. Run 'amalfa init' first.");
    }
    process.exit(1);
  }
  const dbPath = await getDbPath();
  const db = new ResonanceDB(dbPath);
  const vectorEngine = new VectorEngine(db.getRawDb());
  const graphEngine = new GraphEngine;
  try {
    await graphEngine.load(db.getRawDb());
    const gardener = new GraphGardener(db, graphEngine, vectorEngine);
    const content = await gardener.getContent(nodeId);
    if (!content) {
      if (jsonOutput) {
        console.error(JSON.stringify({
          error: "Node not found",
          node_id: nodeId,
          suggestion: "Check the node ID. Use 'amalfa search' to find documents."
        }));
      } else {
        console.error(`\u274C Node not found: ${nodeId}`);
        console.error(`
\uD83D\uDCA1 Tip: Use 'amalfa search <query>' to find documents`);
      }
      process.exit(1);
    }
    if (jsonOutput) {
      console.log(JSON.stringify({
        id: nodeId,
        content
      }));
    } else {
      console.log(`
\uD83D\uDCC4 ${nodeId}`);
      console.log("\u2500".repeat(80));
      console.log(content);
      console.log("\u2500".repeat(80));
      console.log(`
\uD83D\uDCA1 Tip: Use 'amalfa explore ${nodeId}' to see related documents
`);
    }
  } catch (error49) {
    if (jsonOutput) {
      console.error(JSON.stringify({
        error: error49 instanceof Error ? error49.message : String(error49),
        node_id: nodeId
      }));
    } else {
      console.error("\u274C Read failed:", error49 instanceof Error ? error49.message : error49);
    }
    process.exit(1);
  } finally {
    db.close();
  }
}

// src/core/GrepEngine.ts
var {spawn: spawn2 } = globalThis.Bun;
var log9 = getLogger("GrepEngine");

class GrepEngine {
  hasRipgrep = false;
  db = null;
  initPromise;
  constructor() {
    this.initPromise = this.checkAvailability();
  }
  setDb(db) {
    this.db = db;
  }
  async load(db) {
    this.setDb(db);
  }
  async checkAvailability() {
    try {
      const proc = spawn2(["rg", "--version"], {
        stdout: "pipe",
        stderr: "pipe"
      });
      const exitCode = await proc.exited;
      this.hasRipgrep = exitCode === 0;
    } catch {
      this.hasRipgrep = false;
    }
    log9.info({ hasRipgrep: this.hasRipgrep }, "GrepEngine initialized");
  }
  async search(query, limit = 50) {
    await this.initPromise;
    if (!query || query.length < 3)
      return [];
    if (!this.db) {
      log9.warn("GrepEngine: Database not set, cannot resolve IDs");
      return [];
    }
    const cmd = this.hasRipgrep ? "rg" : "grep";
    const ignores = this.hasRipgrep ? [
      "--glob",
      "!**/node_modules/**",
      "--glob",
      "!**/.git/**",
      "--glob",
      "!**/.amalfa/**"
    ] : [
      "--exclude-dir=node_modules",
      "--exclude-dir=.git",
      "--exclude-dir=.amalfa"
    ];
    const args = this.hasRipgrep ? [
      cmd,
      "-i",
      "-n",
      "--max-count=1",
      "--max-columns=200",
      ...ignores,
      query,
      "."
    ] : [cmd, "-r", "-i", "-n", "-m", "1", ...ignores, query, "."];
    const rawResults = [];
    const start = Date.now();
    try {
      const proc = spawn2(args, {
        stdout: "pipe",
        stderr: "pipe"
      });
      const output = await new Response(proc.stdout).text();
      const lines = output.split(`
`);
      for (const line of lines) {
        if (rawResults.length >= limit)
          break;
        if (!line.trim())
          continue;
        const parts = line.split(":");
        if (parts.length < 3)
          continue;
        const filePath = parts[0];
        const lineNum = parseInt(parts[1], 10);
        const content = parts.slice(2).join(":").trim();
        rawResults.push({ path: filePath, line: lineNum, content });
      }
      const resolved = this.resolveIds(rawResults.map((r) => r.path));
      const results = [];
      for (const r of rawResults) {
        const id = resolved.get(r.path);
        if (id) {
          results.push({
            id,
            path: r.path,
            line: r.line,
            content: r.content,
            score: 1
          });
        }
      }
      log9.info({
        query,
        found: results.length,
        tool: cmd,
        elapsedMs: Date.now() - start
      }, "Grep search complete");
      return results;
    } catch (e) {
      log9.error({ err: e }, "Grep search failed");
      return [];
    }
  }
  resolveIds(paths) {
    const map3 = new Map;
    if (!this.db || paths.length === 0)
      return map3;
    const stmt = this.db.prepare("SELECT id FROM nodes WHERE json_extract(meta, '$.source') = ?");
    for (const p of paths) {
      const row = stmt.get(p);
      if (row) {
        map3.set(p, row.id);
      }
    }
    return map3;
  }
}

// src/utils/ContentHydrator.ts
class ContentHydrator {
  gardener;
  constructor(gardener) {
    this.gardener = gardener;
  }
  async hydrate(result) {
    const content = await this.gardener.getContent(result.id);
    return {
      ...result,
      content: content || `[Content unavailable for ${result.id}]`
    };
  }
  async hydrateMany(results) {
    return Promise.all(results.map((r) => this.hydrate(r)));
  }
  async hydrateTop(results, limit) {
    const topK = results.slice(0, limit);
    const rest = results.slice(limit);
    const hydrated = await this.hydrateMany(topK);
    return [...hydrated, ...rest];
  }
}

// node_modules/@huggingface/transformers/dist/transformers.node.mjs
import * as __WEBPACK_EXTERNAL_MODULE_node_fs_75ed2103__ from "fs";
import * as __WEBPACK_EXTERNAL_MODULE_node_path_02319fef__ from "path";
import * as __WEBPACK_EXTERNAL_MODULE_node_url_da953c0c__ from "url";

// node_modules/onnxruntime-common/dist/esm/index.js
var exports_esm2 = {};
__export(exports_esm2, {
  registerBackend: () => registerBackend,
  env: () => env2,
  Tensor: () => Tensor3,
  TRACE_FUNC_END: () => TRACE_FUNC_END,
  TRACE_FUNC_BEGIN: () => TRACE_FUNC_BEGIN,
  TRACE: () => TRACE,
  InferenceSession: () => InferenceSession3
});

// node_modules/onnxruntime-common/dist/esm/backend-impl.js
var backends = new Map;
var backendsSortedByPriority = [];
var registerBackend = (name, backend, priority) => {
  if (backend && typeof backend.init === "function" && typeof backend.createInferenceSessionHandler === "function") {
    const currentBackend = backends.get(name);
    if (currentBackend === undefined) {
      backends.set(name, { backend, priority });
    } else if (currentBackend.priority > priority) {
      return;
    } else if (currentBackend.priority === priority) {
      if (currentBackend.backend !== backend) {
        throw new Error(`cannot register backend "${name}" using priority ${priority}`);
      }
    }
    if (priority >= 0) {
      const i = backendsSortedByPriority.indexOf(name);
      if (i !== -1) {
        backendsSortedByPriority.splice(i, 1);
      }
      for (let i2 = 0;i2 < backendsSortedByPriority.length; i2++) {
        if (backends.get(backendsSortedByPriority[i2]).priority <= priority) {
          backendsSortedByPriority.splice(i2, 0, name);
          return;
        }
      }
      backendsSortedByPriority.push(name);
    }
    return;
  }
  throw new TypeError("not a valid backend");
};
var tryResolveAndInitializeBackend = async (backendName) => {
  const backendInfo = backends.get(backendName);
  if (!backendInfo) {
    return "backend not found.";
  }
  if (backendInfo.initialized) {
    return backendInfo.backend;
  } else if (backendInfo.aborted) {
    return backendInfo.error;
  } else {
    const isInitializing = !!backendInfo.initPromise;
    try {
      if (!isInitializing) {
        backendInfo.initPromise = backendInfo.backend.init(backendName);
      }
      await backendInfo.initPromise;
      backendInfo.initialized = true;
      return backendInfo.backend;
    } catch (e) {
      if (!isInitializing) {
        backendInfo.error = `${e}`;
        backendInfo.aborted = true;
      }
      return backendInfo.error;
    } finally {
      delete backendInfo.initPromise;
    }
  }
};
var resolveBackendAndExecutionProviders = async (options2) => {
  const eps = options2.executionProviders || [];
  const backendHints = eps.map((i) => typeof i === "string" ? i : i.name);
  const backendNames = backendHints.length === 0 ? backendsSortedByPriority : backendHints;
  let backend;
  const errors5 = [];
  const availableBackendNames = new Set;
  for (const backendName of backendNames) {
    const resolveResult = await tryResolveAndInitializeBackend(backendName);
    if (typeof resolveResult === "string") {
      errors5.push({ name: backendName, err: resolveResult });
    } else {
      if (!backend) {
        backend = resolveResult;
      }
      if (backend === resolveResult) {
        availableBackendNames.add(backendName);
      }
    }
  }
  if (!backend) {
    throw new Error(`no available backend found. ERR: ${errors5.map((e) => `[${e.name}] ${e.err}`).join(", ")}`);
  }
  for (const { name, err } of errors5) {
    if (backendHints.includes(name)) {
      console.warn(`removing requested execution provider "${name}" from session options because it is not available: ${err}`);
    }
  }
  const filteredEps = eps.filter((i) => availableBackendNames.has(typeof i === "string" ? i : i.name));
  return [
    backend,
    new Proxy(options2, {
      get: (target, prop) => {
        if (prop === "executionProviders") {
          return filteredEps;
        }
        return Reflect.get(target, prop);
      }
    })
  ];
};
// node_modules/onnxruntime-common/dist/esm/version.js
var version4 = "1.21.0";

// node_modules/onnxruntime-common/dist/esm/env-impl.js
var logLevelValue = "warning";
var env = {
  wasm: {},
  webgl: {},
  webgpu: {},
  versions: { common: version4 },
  set logLevel(value) {
    if (value === undefined) {
      return;
    }
    if (typeof value !== "string" || ["verbose", "info", "warning", "error", "fatal"].indexOf(value) === -1) {
      throw new Error(`Unsupported logging level: ${value}`);
    }
    logLevelValue = value;
  },
  get logLevel() {
    return logLevelValue;
  }
};
Object.defineProperty(env, "logLevel", { enumerable: true });

// node_modules/onnxruntime-common/dist/esm/env.js
var env2 = env;
// node_modules/onnxruntime-common/dist/esm/tensor-conversion-impl.js
var tensorToDataURL = (tensor, options2) => {
  const canvas = typeof document !== "undefined" ? document.createElement("canvas") : new OffscreenCanvas(1, 1);
  canvas.width = tensor.dims[3];
  canvas.height = tensor.dims[2];
  const pixels2DContext = canvas.getContext("2d");
  if (pixels2DContext != null) {
    let width;
    let height;
    if (options2?.tensorLayout !== undefined && options2.tensorLayout === "NHWC") {
      width = tensor.dims[2];
      height = tensor.dims[3];
    } else {
      width = tensor.dims[3];
      height = tensor.dims[2];
    }
    const inputformat = options2?.format !== undefined ? options2.format : "RGB";
    const norm = options2?.norm;
    let normMean;
    let normBias;
    if (norm === undefined || norm.mean === undefined) {
      normMean = [255, 255, 255, 255];
    } else {
      if (typeof norm.mean === "number") {
        normMean = [norm.mean, norm.mean, norm.mean, norm.mean];
      } else {
        normMean = [norm.mean[0], norm.mean[1], norm.mean[2], 0];
        if (norm.mean[3] !== undefined) {
          normMean[3] = norm.mean[3];
        }
      }
    }
    if (norm === undefined || norm.bias === undefined) {
      normBias = [0, 0, 0, 0];
    } else {
      if (typeof norm.bias === "number") {
        normBias = [norm.bias, norm.bias, norm.bias, norm.bias];
      } else {
        normBias = [norm.bias[0], norm.bias[1], norm.bias[2], 0];
        if (norm.bias[3] !== undefined) {
          normBias[3] = norm.bias[3];
        }
      }
    }
    const stride = height * width;
    let rTensorPointer = 0, gTensorPointer = stride, bTensorPointer = stride * 2, aTensorPointer = -1;
    if (inputformat === "RGBA") {
      rTensorPointer = 0;
      gTensorPointer = stride;
      bTensorPointer = stride * 2;
      aTensorPointer = stride * 3;
    } else if (inputformat === "RGB") {
      rTensorPointer = 0;
      gTensorPointer = stride;
      bTensorPointer = stride * 2;
    } else if (inputformat === "RBG") {
      rTensorPointer = 0;
      bTensorPointer = stride;
      gTensorPointer = stride * 2;
    }
    for (let i = 0;i < height; i++) {
      for (let j = 0;j < width; j++) {
        const R = (tensor.data[rTensorPointer++] - normBias[0]) * normMean[0];
        const G = (tensor.data[gTensorPointer++] - normBias[1]) * normMean[1];
        const B = (tensor.data[bTensorPointer++] - normBias[2]) * normMean[2];
        const A = aTensorPointer === -1 ? 255 : (tensor.data[aTensorPointer++] - normBias[3]) * normMean[3];
        pixels2DContext.fillStyle = "rgba(" + R + "," + G + "," + B + "," + A + ")";
        pixels2DContext.fillRect(j, i, 1, 1);
      }
    }
    if ("toDataURL" in canvas) {
      return canvas.toDataURL();
    } else {
      throw new Error("toDataURL is not supported");
    }
  } else {
    throw new Error("Can not access image data");
  }
};
var tensorToImageData = (tensor, options2) => {
  const pixels2DContext = typeof document !== "undefined" ? document.createElement("canvas").getContext("2d") : new OffscreenCanvas(1, 1).getContext("2d");
  let image;
  if (pixels2DContext != null) {
    let width;
    let height;
    let channels;
    if (options2?.tensorLayout !== undefined && options2.tensorLayout === "NHWC") {
      width = tensor.dims[2];
      height = tensor.dims[1];
      channels = tensor.dims[3];
    } else {
      width = tensor.dims[3];
      height = tensor.dims[2];
      channels = tensor.dims[1];
    }
    const inputformat = options2 !== undefined ? options2.format !== undefined ? options2.format : "RGB" : "RGB";
    const norm = options2?.norm;
    let normMean;
    let normBias;
    if (norm === undefined || norm.mean === undefined) {
      normMean = [255, 255, 255, 255];
    } else {
      if (typeof norm.mean === "number") {
        normMean = [norm.mean, norm.mean, norm.mean, norm.mean];
      } else {
        normMean = [norm.mean[0], norm.mean[1], norm.mean[2], 255];
        if (norm.mean[3] !== undefined) {
          normMean[3] = norm.mean[3];
        }
      }
    }
    if (norm === undefined || norm.bias === undefined) {
      normBias = [0, 0, 0, 0];
    } else {
      if (typeof norm.bias === "number") {
        normBias = [norm.bias, norm.bias, norm.bias, norm.bias];
      } else {
        normBias = [norm.bias[0], norm.bias[1], norm.bias[2], 0];
        if (norm.bias[3] !== undefined) {
          normBias[3] = norm.bias[3];
        }
      }
    }
    const stride = height * width;
    if (options2 !== undefined) {
      if (options2.format !== undefined && channels === 4 && options2.format !== "RGBA" || channels === 3 && options2.format !== "RGB" && options2.format !== "BGR") {
        throw new Error("Tensor format doesn't match input tensor dims");
      }
    }
    const step = 4;
    let rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;
    let rTensorPointer = 0, gTensorPointer = stride, bTensorPointer = stride * 2, aTensorPointer = -1;
    if (inputformat === "RGBA") {
      rTensorPointer = 0;
      gTensorPointer = stride;
      bTensorPointer = stride * 2;
      aTensorPointer = stride * 3;
    } else if (inputformat === "RGB") {
      rTensorPointer = 0;
      gTensorPointer = stride;
      bTensorPointer = stride * 2;
    } else if (inputformat === "RBG") {
      rTensorPointer = 0;
      bTensorPointer = stride;
      gTensorPointer = stride * 2;
    }
    image = pixels2DContext.createImageData(width, height);
    for (let i = 0;i < height * width; rImagePointer += step, gImagePointer += step, bImagePointer += step, aImagePointer += step, i++) {
      image.data[rImagePointer] = (tensor.data[rTensorPointer++] - normBias[0]) * normMean[0];
      image.data[gImagePointer] = (tensor.data[gTensorPointer++] - normBias[1]) * normMean[1];
      image.data[bImagePointer] = (tensor.data[bTensorPointer++] - normBias[2]) * normMean[2];
      image.data[aImagePointer] = aTensorPointer === -1 ? 255 : (tensor.data[aTensorPointer++] - normBias[3]) * normMean[3];
    }
  } else {
    throw new Error("Can not access image data");
  }
  return image;
};

// node_modules/onnxruntime-common/dist/esm/tensor-factory-impl.js
var bufferToTensor = (buffer, options2) => {
  if (buffer === undefined) {
    throw new Error("Image buffer must be defined");
  }
  if (options2.height === undefined || options2.width === undefined) {
    throw new Error("Image height and width must be defined");
  }
  if (options2.tensorLayout === "NHWC") {
    throw new Error("NHWC Tensor layout is not supported yet");
  }
  const { height, width } = options2;
  const norm = options2.norm ?? { mean: 255, bias: 0 };
  let normMean;
  let normBias;
  if (typeof norm.mean === "number") {
    normMean = [norm.mean, norm.mean, norm.mean, norm.mean];
  } else {
    normMean = [norm.mean[0], norm.mean[1], norm.mean[2], norm.mean[3] ?? 255];
  }
  if (typeof norm.bias === "number") {
    normBias = [norm.bias, norm.bias, norm.bias, norm.bias];
  } else {
    normBias = [norm.bias[0], norm.bias[1], norm.bias[2], norm.bias[3] ?? 0];
  }
  const inputformat = options2.format !== undefined ? options2.format : "RGBA";
  const outputformat = options2.tensorFormat !== undefined ? options2.tensorFormat !== undefined ? options2.tensorFormat : "RGB" : "RGB";
  const stride = height * width;
  const float32Data = outputformat === "RGBA" ? new Float32Array(stride * 4) : new Float32Array(stride * 3);
  let step = 4, rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;
  let rTensorPointer = 0, gTensorPointer = stride, bTensorPointer = stride * 2, aTensorPointer = -1;
  if (inputformat === "RGB") {
    step = 3;
    rImagePointer = 0;
    gImagePointer = 1;
    bImagePointer = 2;
    aImagePointer = -1;
  }
  if (outputformat === "RGBA") {
    aTensorPointer = stride * 3;
  } else if (outputformat === "RBG") {
    rTensorPointer = 0;
    bTensorPointer = stride;
    gTensorPointer = stride * 2;
  } else if (outputformat === "BGR") {
    bTensorPointer = 0;
    gTensorPointer = stride;
    rTensorPointer = stride * 2;
  }
  for (let i = 0;i < stride; i++, rImagePointer += step, bImagePointer += step, gImagePointer += step, aImagePointer += step) {
    float32Data[rTensorPointer++] = (buffer[rImagePointer] + normBias[0]) / normMean[0];
    float32Data[gTensorPointer++] = (buffer[gImagePointer] + normBias[1]) / normMean[1];
    float32Data[bTensorPointer++] = (buffer[bImagePointer] + normBias[2]) / normMean[2];
    if (aTensorPointer !== -1 && aImagePointer !== -1) {
      float32Data[aTensorPointer++] = (buffer[aImagePointer] + normBias[3]) / normMean[3];
    }
  }
  const outputTensor = outputformat === "RGBA" ? new Tensor2("float32", float32Data, [1, 4, height, width]) : new Tensor2("float32", float32Data, [1, 3, height, width]);
  return outputTensor;
};
var tensorFromImage = async (image, options2) => {
  const isHTMLImageEle = typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement;
  const isImageDataEle = typeof ImageData !== "undefined" && image instanceof ImageData;
  const isImageBitmap = typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap;
  const isString = typeof image === "string";
  let data;
  let bufferToTensorOptions = options2 ?? {};
  const createCanvas = () => {
    if (typeof document !== "undefined") {
      return document.createElement("canvas");
    } else if (typeof OffscreenCanvas !== "undefined") {
      return new OffscreenCanvas(1, 1);
    } else {
      throw new Error("Canvas is not supported");
    }
  };
  const createCanvasContext = (canvas) => {
    if (typeof HTMLCanvasElement !== "undefined" && canvas instanceof HTMLCanvasElement) {
      return canvas.getContext("2d");
    } else if (canvas instanceof OffscreenCanvas) {
      return canvas.getContext("2d");
    } else {
      return null;
    }
  };
  if (isHTMLImageEle) {
    const canvas = createCanvas();
    canvas.width = image.width;
    canvas.height = image.height;
    const pixels2DContext = createCanvasContext(canvas);
    if (pixels2DContext != null) {
      let height = image.height;
      let width = image.width;
      if (options2 !== undefined && options2.resizedHeight !== undefined && options2.resizedWidth !== undefined) {
        height = options2.resizedHeight;
        width = options2.resizedWidth;
      }
      if (options2 !== undefined) {
        bufferToTensorOptions = options2;
        if (options2.tensorFormat !== undefined) {
          throw new Error("Image input config format must be RGBA for HTMLImageElement");
        } else {
          bufferToTensorOptions.tensorFormat = "RGBA";
        }
        bufferToTensorOptions.height = height;
        bufferToTensorOptions.width = width;
      } else {
        bufferToTensorOptions.tensorFormat = "RGBA";
        bufferToTensorOptions.height = height;
        bufferToTensorOptions.width = width;
      }
      pixels2DContext.drawImage(image, 0, 0);
      data = pixels2DContext.getImageData(0, 0, width, height).data;
    } else {
      throw new Error("Can not access image data");
    }
  } else if (isImageDataEle) {
    let height;
    let width;
    if (options2 !== undefined && options2.resizedWidth !== undefined && options2.resizedHeight !== undefined) {
      height = options2.resizedHeight;
      width = options2.resizedWidth;
    } else {
      height = image.height;
      width = image.width;
    }
    if (options2 !== undefined) {
      bufferToTensorOptions = options2;
    }
    bufferToTensorOptions.format = "RGBA";
    bufferToTensorOptions.height = height;
    bufferToTensorOptions.width = width;
    if (options2 !== undefined) {
      const tempCanvas = createCanvas();
      tempCanvas.width = width;
      tempCanvas.height = height;
      const pixels2DContext = createCanvasContext(tempCanvas);
      if (pixels2DContext != null) {
        pixels2DContext.putImageData(image, 0, 0);
        data = pixels2DContext.getImageData(0, 0, width, height).data;
      } else {
        throw new Error("Can not access image data");
      }
    } else {
      data = image.data;
    }
  } else if (isImageBitmap) {
    if (options2 === undefined) {
      throw new Error("Please provide image config with format for Imagebitmap");
    }
    const canvas = createCanvas();
    canvas.width = image.width;
    canvas.height = image.height;
    const pixels2DContext = createCanvasContext(canvas);
    if (pixels2DContext != null) {
      const height = image.height;
      const width = image.width;
      pixels2DContext.drawImage(image, 0, 0, width, height);
      data = pixels2DContext.getImageData(0, 0, width, height).data;
      bufferToTensorOptions.height = height;
      bufferToTensorOptions.width = width;
      return bufferToTensor(data, bufferToTensorOptions);
    } else {
      throw new Error("Can not access image data");
    }
  } else if (isString) {
    return new Promise((resolve4, reject) => {
      const canvas = createCanvas();
      const context = createCanvasContext(canvas);
      if (!image || !context) {
        return reject();
      }
      const newImage = new Image;
      newImage.crossOrigin = "Anonymous";
      newImage.src = image;
      newImage.onload = () => {
        canvas.width = newImage.width;
        canvas.height = newImage.height;
        context.drawImage(newImage, 0, 0, canvas.width, canvas.height);
        const img = context.getImageData(0, 0, canvas.width, canvas.height);
        bufferToTensorOptions.height = canvas.height;
        bufferToTensorOptions.width = canvas.width;
        resolve4(bufferToTensor(img.data, bufferToTensorOptions));
      };
    });
  } else {
    throw new Error("Input data provided is not supported - aborted tensor creation");
  }
  if (data !== undefined) {
    return bufferToTensor(data, bufferToTensorOptions);
  } else {
    throw new Error("Input data provided is not supported - aborted tensor creation");
  }
};
var tensorFromTexture = (texture, options2) => {
  const { width, height, download, dispose } = options2;
  const dims = [1, height, width, 4];
  return new Tensor2({ location: "texture", type: "float32", texture, dims, download, dispose });
};
var tensorFromGpuBuffer = (gpuBuffer, options2) => {
  const { dataType, dims, download, dispose } = options2;
  return new Tensor2({ location: "gpu-buffer", type: dataType ?? "float32", gpuBuffer, dims, download, dispose });
};
var tensorFromMLTensor = (mlTensor, options2) => {
  const { dataType, dims, download, dispose } = options2;
  return new Tensor2({ location: "ml-tensor", type: dataType ?? "float32", mlTensor, dims, download, dispose });
};
var tensorFromPinnedBuffer = (type, buffer, dims) => new Tensor2({ location: "cpu-pinned", type, data: buffer, dims: dims ?? [buffer.length] });

// node_modules/onnxruntime-common/dist/esm/tensor-impl-type-mapping.js
var NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP = new Map([
  ["float32", Float32Array],
  ["uint8", Uint8Array],
  ["int8", Int8Array],
  ["uint16", Uint16Array],
  ["int16", Int16Array],
  ["int32", Int32Array],
  ["bool", Uint8Array],
  ["float64", Float64Array],
  ["uint32", Uint32Array],
  ["int4", Uint8Array],
  ["uint4", Uint8Array]
]);
var NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP = new Map([
  [Float32Array, "float32"],
  [Uint8Array, "uint8"],
  [Int8Array, "int8"],
  [Uint16Array, "uint16"],
  [Int16Array, "int16"],
  [Int32Array, "int32"],
  [Float64Array, "float64"],
  [Uint32Array, "uint32"]
]);
var isTypedArrayChecked = false;
var checkTypedArray = () => {
  if (!isTypedArrayChecked) {
    isTypedArrayChecked = true;
    const isBigInt64ArrayAvailable = typeof BigInt64Array !== "undefined" && BigInt64Array.from;
    const isBigUint64ArrayAvailable = typeof BigUint64Array !== "undefined" && BigUint64Array.from;
    const Float16Array2 = globalThis.Float16Array;
    const isFloat16ArrayAvailable = typeof Float16Array2 !== "undefined" && Float16Array2.from;
    if (isBigInt64ArrayAvailable) {
      NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("int64", BigInt64Array);
      NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigInt64Array, "int64");
    }
    if (isBigUint64ArrayAvailable) {
      NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("uint64", BigUint64Array);
      NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigUint64Array, "uint64");
    }
    if (isFloat16ArrayAvailable) {
      NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("float16", Float16Array2);
      NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(Float16Array2, "float16");
    } else {
      NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("float16", Uint16Array);
    }
  }
};

// node_modules/onnxruntime-common/dist/esm/tensor-utils-impl.js
var calculateSize = (dims) => {
  let size = 1;
  for (let i = 0;i < dims.length; i++) {
    const dim = dims[i];
    if (typeof dim !== "number" || !Number.isSafeInteger(dim)) {
      throw new TypeError(`dims[${i}] must be an integer, got: ${dim}`);
    }
    if (dim < 0) {
      throw new RangeError(`dims[${i}] must be a non-negative integer, got: ${dim}`);
    }
    size *= dim;
  }
  return size;
};
var tensorReshape = (tensor, dims) => {
  switch (tensor.location) {
    case "cpu":
      return new Tensor2(tensor.type, tensor.data, dims);
    case "cpu-pinned":
      return new Tensor2({
        location: "cpu-pinned",
        data: tensor.data,
        type: tensor.type,
        dims
      });
    case "texture":
      return new Tensor2({
        location: "texture",
        texture: tensor.texture,
        type: tensor.type,
        dims
      });
    case "gpu-buffer":
      return new Tensor2({
        location: "gpu-buffer",
        gpuBuffer: tensor.gpuBuffer,
        type: tensor.type,
        dims
      });
    case "ml-tensor":
      return new Tensor2({
        location: "ml-tensor",
        mlTensor: tensor.mlTensor,
        type: tensor.type,
        dims
      });
    default:
      throw new Error(`tensorReshape: tensor location ${tensor.location} is not supported`);
  }
};

// node_modules/onnxruntime-common/dist/esm/tensor-impl.js
class Tensor2 {
  constructor(arg0, arg1, arg2) {
    checkTypedArray();
    let type;
    let dims;
    if (typeof arg0 === "object" && "location" in arg0) {
      this.dataLocation = arg0.location;
      type = arg0.type;
      dims = arg0.dims;
      switch (arg0.location) {
        case "cpu-pinned": {
          const expectedTypedArrayConstructor = NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(type);
          if (!expectedTypedArrayConstructor) {
            throw new TypeError(`unsupported type "${type}" to create tensor from pinned buffer`);
          }
          if (!(arg0.data instanceof expectedTypedArrayConstructor)) {
            throw new TypeError(`buffer should be of type ${expectedTypedArrayConstructor.name}`);
          }
          this.cpuData = arg0.data;
          break;
        }
        case "texture": {
          if (type !== "float32") {
            throw new TypeError(`unsupported type "${type}" to create tensor from texture`);
          }
          this.gpuTextureData = arg0.texture;
          this.downloader = arg0.download;
          this.disposer = arg0.dispose;
          break;
        }
        case "gpu-buffer": {
          if (type !== "float32" && type !== "float16" && type !== "int32" && type !== "int64" && type !== "uint32" && type !== "uint8" && type !== "bool" && type !== "uint4" && type !== "int4") {
            throw new TypeError(`unsupported type "${type}" to create tensor from gpu buffer`);
          }
          this.gpuBufferData = arg0.gpuBuffer;
          this.downloader = arg0.download;
          this.disposer = arg0.dispose;
          break;
        }
        case "ml-tensor": {
          if (type !== "float32" && type !== "float16" && type !== "int32" && type !== "int64" && type !== "uint32" && type !== "uint64" && type !== "int8" && type !== "uint8" && type !== "bool" && type !== "uint4" && type !== "int4") {
            throw new TypeError(`unsupported type "${type}" to create tensor from MLTensor`);
          }
          this.mlTensorData = arg0.mlTensor;
          this.downloader = arg0.download;
          this.disposer = arg0.dispose;
          break;
        }
        default:
          throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`);
      }
    } else {
      let data;
      let maybeDims;
      if (typeof arg0 === "string") {
        type = arg0;
        maybeDims = arg2;
        if (arg0 === "string") {
          if (!Array.isArray(arg1)) {
            throw new TypeError("A string tensor's data must be a string array.");
          }
          data = arg1;
        } else {
          const typedArrayConstructor = NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(arg0);
          if (typedArrayConstructor === undefined) {
            throw new TypeError(`Unsupported tensor type: ${arg0}.`);
          }
          if (Array.isArray(arg1)) {
            if (arg0 === "float16" && typedArrayConstructor === Uint16Array || arg0 === "uint4" || arg0 === "int4") {
              throw new TypeError(`Creating a ${arg0} tensor from number array is not supported. Please use ${typedArrayConstructor.name} as data.`);
            } else if (arg0 === "uint64" || arg0 === "int64") {
              data = typedArrayConstructor.from(arg1, BigInt);
            } else {
              data = typedArrayConstructor.from(arg1);
            }
          } else if (arg1 instanceof typedArrayConstructor) {
            data = arg1;
          } else if (arg1 instanceof Uint8ClampedArray) {
            if (arg0 === "uint8") {
              data = Uint8Array.from(arg1);
            } else {
              throw new TypeError(`A Uint8ClampedArray tensor's data must be type of uint8`);
            }
          } else if (arg0 === "float16" && arg1 instanceof Uint16Array && typedArrayConstructor !== Uint16Array) {
            data = new globalThis.Float16Array(arg1.buffer, arg1.byteOffset, arg1.length);
          } else {
            throw new TypeError(`A ${type} tensor's data must be type of ${typedArrayConstructor}`);
          }
        }
      } else {
        maybeDims = arg1;
        if (Array.isArray(arg0)) {
          if (arg0.length === 0) {
            throw new TypeError("Tensor type cannot be inferred from an empty array.");
          }
          const firstElementType = typeof arg0[0];
          if (firstElementType === "string") {
            type = "string";
            data = arg0;
          } else if (firstElementType === "boolean") {
            type = "bool";
            data = Uint8Array.from(arg0);
          } else {
            throw new TypeError(`Invalid element type of data array: ${firstElementType}.`);
          }
        } else if (arg0 instanceof Uint8ClampedArray) {
          type = "uint8";
          data = Uint8Array.from(arg0);
        } else {
          const mappedType = NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.get(arg0.constructor);
          if (mappedType === undefined) {
            throw new TypeError(`Unsupported type for tensor data: ${arg0.constructor}.`);
          }
          type = mappedType;
          data = arg0;
        }
      }
      if (maybeDims === undefined) {
        maybeDims = [data.length];
      } else if (!Array.isArray(maybeDims)) {
        throw new TypeError("A tensor's dims must be a number array");
      }
      dims = maybeDims;
      this.cpuData = data;
      this.dataLocation = "cpu";
    }
    const size = calculateSize(dims);
    if (this.cpuData && size !== this.cpuData.length) {
      if ((type === "uint4" || type === "int4") && Math.ceil(size / 2) === this.cpuData.length) {} else {
        throw new Error(`Tensor's size(${size}) does not match data length(${this.cpuData.length}).`);
      }
    }
    this.type = type;
    this.dims = dims;
    this.size = size;
  }
  static async fromImage(image, options2) {
    return tensorFromImage(image, options2);
  }
  static fromTexture(texture, options2) {
    return tensorFromTexture(texture, options2);
  }
  static fromGpuBuffer(gpuBuffer, options2) {
    return tensorFromGpuBuffer(gpuBuffer, options2);
  }
  static fromMLTensor(mlTensor, options2) {
    return tensorFromMLTensor(mlTensor, options2);
  }
  static fromPinnedBuffer(type, buffer, dims) {
    return tensorFromPinnedBuffer(type, buffer, dims);
  }
  toDataURL(options2) {
    return tensorToDataURL(this, options2);
  }
  toImageData(options2) {
    return tensorToImageData(this, options2);
  }
  get data() {
    this.ensureValid();
    if (!this.cpuData) {
      throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, " + "or use `texture` or `gpuBuffer` property to access the GPU data directly.");
    }
    return this.cpuData;
  }
  get location() {
    return this.dataLocation;
  }
  get texture() {
    this.ensureValid();
    if (!this.gpuTextureData) {
      throw new Error("The data is not stored as a WebGL texture.");
    }
    return this.gpuTextureData;
  }
  get gpuBuffer() {
    this.ensureValid();
    if (!this.gpuBufferData) {
      throw new Error("The data is not stored as a WebGPU buffer.");
    }
    return this.gpuBufferData;
  }
  get mlTensor() {
    this.ensureValid();
    if (!this.mlTensorData) {
      throw new Error("The data is not stored as a WebNN MLTensor.");
    }
    return this.mlTensorData;
  }
  async getData(releaseData) {
    this.ensureValid();
    switch (this.dataLocation) {
      case "cpu":
      case "cpu-pinned":
        return this.data;
      case "texture":
      case "gpu-buffer":
      case "ml-tensor": {
        if (!this.downloader) {
          throw new Error("The current tensor is not created with a specified data downloader.");
        }
        if (this.isDownloading) {
          throw new Error("The current tensor is being downloaded.");
        }
        try {
          this.isDownloading = true;
          const data = await this.downloader();
          this.downloader = undefined;
          this.dataLocation = "cpu";
          this.cpuData = data;
          if (releaseData && this.disposer) {
            this.disposer();
            this.disposer = undefined;
          }
          return data;
        } finally {
          this.isDownloading = false;
        }
      }
      default:
        throw new Error(`cannot get data from location: ${this.dataLocation}`);
    }
  }
  dispose() {
    if (this.isDownloading) {
      throw new Error("The current tensor is being downloaded.");
    }
    if (this.disposer) {
      this.disposer();
      this.disposer = undefined;
    }
    this.cpuData = undefined;
    this.gpuTextureData = undefined;
    this.gpuBufferData = undefined;
    this.mlTensorData = undefined;
    this.downloader = undefined;
    this.isDownloading = undefined;
    this.dataLocation = "none";
  }
  ensureValid() {
    if (this.dataLocation === "none") {
      throw new Error("The tensor is disposed.");
    }
  }
  reshape(dims) {
    this.ensureValid();
    if (this.downloader || this.disposer) {
      throw new Error("Cannot reshape a tensor that owns GPU resource.");
    }
    return tensorReshape(this, dims);
  }
}

// node_modules/onnxruntime-common/dist/esm/tensor.js
var Tensor3 = Tensor2;

// node_modules/onnxruntime-common/dist/esm/trace.js
var TRACE = (deviceType, label) => {
  if (typeof env.trace === "undefined" ? !env.wasm.trace : !env.trace) {
    return;
  }
  console.timeStamp(`${deviceType}::ORT::${label}`);
};
var TRACE_FUNC = (msg, extraMsg) => {
  const stack = new Error().stack?.split(/\r\n|\r|\n/g) || [];
  let hasTraceFunc = false;
  for (let i = 0;i < stack.length; i++) {
    if (hasTraceFunc && !stack[i].includes("TRACE_FUNC")) {
      let label = `FUNC_${msg}::${stack[i].trim().split(" ")[1]}`;
      if (extraMsg) {
        label += `::${extraMsg}`;
      }
      TRACE("CPU", label);
      return;
    }
    if (stack[i].includes("TRACE_FUNC")) {
      hasTraceFunc = true;
    }
  }
};
var TRACE_FUNC_BEGIN = (extraMsg) => {
  if (typeof env.trace === "undefined" ? !env.wasm.trace : !env.trace) {
    return;
  }
  TRACE_FUNC("BEGIN", extraMsg);
};
var TRACE_FUNC_END = (extraMsg) => {
  if (typeof env.trace === "undefined" ? !env.wasm.trace : !env.trace) {
    return;
  }
  TRACE_FUNC("END", extraMsg);
};

// node_modules/onnxruntime-common/dist/esm/inference-session-impl.js
class InferenceSession2 {
  constructor(handler) {
    this.handler = handler;
  }
  async run(feeds, arg1, arg2) {
    TRACE_FUNC_BEGIN();
    const fetches = {};
    let options2 = {};
    if (typeof feeds !== "object" || feeds === null || feeds instanceof Tensor3 || Array.isArray(feeds)) {
      throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");
    }
    let isFetchesEmpty = true;
    if (typeof arg1 === "object") {
      if (arg1 === null) {
        throw new TypeError("Unexpected argument[1]: cannot be null.");
      }
      if (arg1 instanceof Tensor3) {
        throw new TypeError("'fetches' cannot be a Tensor");
      }
      if (Array.isArray(arg1)) {
        if (arg1.length === 0) {
          throw new TypeError("'fetches' cannot be an empty array.");
        }
        isFetchesEmpty = false;
        for (const name of arg1) {
          if (typeof name !== "string") {
            throw new TypeError("'fetches' must be a string array or an object.");
          }
          if (this.outputNames.indexOf(name) === -1) {
            throw new RangeError(`'fetches' contains invalid output name: ${name}.`);
          }
          fetches[name] = null;
        }
        if (typeof arg2 === "object" && arg2 !== null) {
          options2 = arg2;
        } else if (typeof arg2 !== "undefined") {
          throw new TypeError("'options' must be an object.");
        }
      } else {
        let isFetches = false;
        const arg1Keys = Object.getOwnPropertyNames(arg1);
        for (const name of this.outputNames) {
          if (arg1Keys.indexOf(name) !== -1) {
            const v = arg1[name];
            if (v === null || v instanceof Tensor3) {
              isFetches = true;
              isFetchesEmpty = false;
              fetches[name] = v;
            }
          }
        }
        if (isFetches) {
          if (typeof arg2 === "object" && arg2 !== null) {
            options2 = arg2;
          } else if (typeof arg2 !== "undefined") {
            throw new TypeError("'options' must be an object.");
          }
        } else {
          options2 = arg1;
        }
      }
    } else if (typeof arg1 !== "undefined") {
      throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");
    }
    for (const name of this.inputNames) {
      if (typeof feeds[name] === "undefined") {
        throw new Error(`input '${name}' is missing in 'feeds'.`);
      }
    }
    if (isFetchesEmpty) {
      for (const name of this.outputNames) {
        fetches[name] = null;
      }
    }
    const results = await this.handler.run(feeds, fetches, options2);
    const returnValue = {};
    for (const key in results) {
      if (Object.hasOwnProperty.call(results, key)) {
        const result = results[key];
        if (result instanceof Tensor3) {
          returnValue[key] = result;
        } else {
          returnValue[key] = new Tensor3(result.type, result.data, result.dims);
        }
      }
    }
    TRACE_FUNC_END();
    return returnValue;
  }
  async release() {
    return this.handler.dispose();
  }
  static async create(arg0, arg1, arg2, arg3) {
    TRACE_FUNC_BEGIN();
    let filePathOrUint8Array;
    let options2 = {};
    if (typeof arg0 === "string") {
      filePathOrUint8Array = arg0;
      if (typeof arg1 === "object" && arg1 !== null) {
        options2 = arg1;
      } else if (typeof arg1 !== "undefined") {
        throw new TypeError("'options' must be an object.");
      }
    } else if (arg0 instanceof Uint8Array) {
      filePathOrUint8Array = arg0;
      if (typeof arg1 === "object" && arg1 !== null) {
        options2 = arg1;
      } else if (typeof arg1 !== "undefined") {
        throw new TypeError("'options' must be an object.");
      }
    } else if (arg0 instanceof ArrayBuffer || typeof SharedArrayBuffer !== "undefined" && arg0 instanceof SharedArrayBuffer) {
      const buffer = arg0;
      let byteOffset = 0;
      let byteLength = arg0.byteLength;
      if (typeof arg1 === "object" && arg1 !== null) {
        options2 = arg1;
      } else if (typeof arg1 === "number") {
        byteOffset = arg1;
        if (!Number.isSafeInteger(byteOffset)) {
          throw new RangeError("'byteOffset' must be an integer.");
        }
        if (byteOffset < 0 || byteOffset >= buffer.byteLength) {
          throw new RangeError(`'byteOffset' is out of range [0, ${buffer.byteLength}).`);
        }
        byteLength = arg0.byteLength - byteOffset;
        if (typeof arg2 === "number") {
          byteLength = arg2;
          if (!Number.isSafeInteger(byteLength)) {
            throw new RangeError("'byteLength' must be an integer.");
          }
          if (byteLength <= 0 || byteOffset + byteLength > buffer.byteLength) {
            throw new RangeError(`'byteLength' is out of range (0, ${buffer.byteLength - byteOffset}].`);
          }
          if (typeof arg3 === "object" && arg3 !== null) {
            options2 = arg3;
          } else if (typeof arg3 !== "undefined") {
            throw new TypeError("'options' must be an object.");
          }
        } else if (typeof arg2 !== "undefined") {
          throw new TypeError("'byteLength' must be a number.");
        }
      } else if (typeof arg1 !== "undefined") {
        throw new TypeError("'options' must be an object.");
      }
      filePathOrUint8Array = new Uint8Array(buffer, byteOffset, byteLength);
    } else {
      throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");
    }
    const [backend, optionsWithValidatedEPs] = await resolveBackendAndExecutionProviders(options2);
    const handler = await backend.createInferenceSessionHandler(filePathOrUint8Array, optionsWithValidatedEPs);
    TRACE_FUNC_END();
    return new InferenceSession2(handler);
  }
  startProfiling() {
    this.handler.startProfiling();
  }
  endProfiling() {
    this.handler.endProfiling();
  }
  get inputNames() {
    return this.handler.inputNames;
  }
  get outputNames() {
    return this.handler.outputNames;
  }
}

// node_modules/onnxruntime-common/dist/esm/inference-session.js
var InferenceSession3 = InferenceSession2;
// node_modules/@huggingface/transformers/dist/transformers.node.mjs
var __WEBPACK_EXTERNAL_MODULE_onnxruntime_node_6a60201e__ = __toESM(require_dist(), 1);
var __WEBPACK_EXTERNAL_MODULE_sharp__ = __toESM(require_lib(), 1);
var __dirname = "/Users/petersmith/Dev/GitHub/amalfa/node_modules/@huggingface/transformers/dist";
var __webpack_modules__ = {
  "node:fs": (module) => {
    /*!**************************!*\
      !*** external "node:fs" ***!
      \**************************/
    module.exports = __WEBPACK_EXTERNAL_MODULE_node_fs_75ed2103__;
  },
  "node:path": (module) => {
    /*!****************************!*\
      !*** external "node:path" ***!
      \****************************/
    module.exports = __WEBPACK_EXTERNAL_MODULE_node_path_02319fef__;
  },
  "node:url": (module) => {
    /*!***************************!*\
      !*** external "node:url" ***!
      \***************************/
    module.exports = __WEBPACK_EXTERNAL_MODULE_node_url_da953c0c__;
  },
  "onnxruntime-common": (module) => {
    /*!*************************************!*\
      !*** external "onnxruntime-common" ***!
      \*************************************/
    module.exports = exports_esm2;
  },
  "onnxruntime-node": (module) => {
    /*!***********************************!*\
      !*** external "onnxruntime-node" ***!
      \***********************************/
    module.exports = __WEBPACK_EXTERNAL_MODULE_onnxruntime_node_6a60201e__;
  },
  sharp: (module) => {
    /*!************************!*\
      !*** external "sharp" ***!
      \************************/
    module.exports = __WEBPACK_EXTERNAL_MODULE_sharp__;
  },
  "?8b6b": () => {
    /*!*********************************!*\
      !*** onnxruntime-web (ignored) ***!
      \*********************************/
  },
  "./node_modules/@huggingface/jinja/dist/index.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!*******************************************************!*\
      !*** ./node_modules/@huggingface/jinja/dist/index.js ***!
      \*******************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      Environment: () => Environment,
      Interpreter: () => Interpreter,
      Template: () => Template,
      parse: () => parse11,
      tokenize: () => tokenize
    });
    var TOKEN_TYPES = Object.freeze({
      Text: "Text",
      NumericLiteral: "NumericLiteral",
      StringLiteral: "StringLiteral",
      Identifier: "Identifier",
      Equals: "Equals",
      OpenParen: "OpenParen",
      CloseParen: "CloseParen",
      OpenStatement: "OpenStatement",
      CloseStatement: "CloseStatement",
      OpenExpression: "OpenExpression",
      CloseExpression: "CloseExpression",
      OpenSquareBracket: "OpenSquareBracket",
      CloseSquareBracket: "CloseSquareBracket",
      OpenCurlyBracket: "OpenCurlyBracket",
      CloseCurlyBracket: "CloseCurlyBracket",
      Comma: "Comma",
      Dot: "Dot",
      Colon: "Colon",
      Pipe: "Pipe",
      CallOperator: "CallOperator",
      AdditiveBinaryOperator: "AdditiveBinaryOperator",
      MultiplicativeBinaryOperator: "MultiplicativeBinaryOperator",
      ComparisonBinaryOperator: "ComparisonBinaryOperator",
      UnaryOperator: "UnaryOperator",
      Comment: "Comment"
    });
    var Token = class {
      constructor(value, type) {
        this.value = value;
        this.type = type;
      }
    };
    function isWord(char) {
      return /\w/.test(char);
    }
    function isInteger(char) {
      return /[0-9]/.test(char);
    }
    function isWhitespace(char) {
      return /\s/.test(char);
    }
    var ORDERED_MAPPING_TABLE = [
      ["{%", TOKEN_TYPES.OpenStatement],
      ["%}", TOKEN_TYPES.CloseStatement],
      ["{{", TOKEN_TYPES.OpenExpression],
      ["}}", TOKEN_TYPES.CloseExpression],
      ["(", TOKEN_TYPES.OpenParen],
      [")", TOKEN_TYPES.CloseParen],
      ["{", TOKEN_TYPES.OpenCurlyBracket],
      ["}", TOKEN_TYPES.CloseCurlyBracket],
      ["[", TOKEN_TYPES.OpenSquareBracket],
      ["]", TOKEN_TYPES.CloseSquareBracket],
      [",", TOKEN_TYPES.Comma],
      [".", TOKEN_TYPES.Dot],
      [":", TOKEN_TYPES.Colon],
      ["|", TOKEN_TYPES.Pipe],
      ["<=", TOKEN_TYPES.ComparisonBinaryOperator],
      [">=", TOKEN_TYPES.ComparisonBinaryOperator],
      ["==", TOKEN_TYPES.ComparisonBinaryOperator],
      ["!=", TOKEN_TYPES.ComparisonBinaryOperator],
      ["<", TOKEN_TYPES.ComparisonBinaryOperator],
      [">", TOKEN_TYPES.ComparisonBinaryOperator],
      ["+", TOKEN_TYPES.AdditiveBinaryOperator],
      ["-", TOKEN_TYPES.AdditiveBinaryOperator],
      ["~", TOKEN_TYPES.AdditiveBinaryOperator],
      ["*", TOKEN_TYPES.MultiplicativeBinaryOperator],
      ["/", TOKEN_TYPES.MultiplicativeBinaryOperator],
      ["%", TOKEN_TYPES.MultiplicativeBinaryOperator],
      ["=", TOKEN_TYPES.Equals]
    ];
    var ESCAPE_CHARACTERS = /* @__PURE__ */ new Map([
      ["n", `
`],
      ["t", "\t"],
      ["r", "\r"],
      ["b", "\b"],
      ["f", "\f"],
      ["v", "\v"],
      ["'", "'"],
      ['"', '"'],
      ["\\", "\\"]
    ]);
    function preprocess3(template, options2 = {}) {
      if (template.endsWith(`
`)) {
        template = template.slice(0, -1);
      }
      if (options2.lstrip_blocks) {
        template = template.replace(/^[ \t]*({[#%-])/gm, "$1");
      }
      if (options2.trim_blocks) {
        template = template.replace(/([#%-]})\n/g, "$1");
      }
      return template.replace(/{%\s*(end)?generation\s*%}/gs, "");
    }
    function tokenize(source, options2 = {}) {
      const tokens = [];
      const src = preprocess3(source, options2);
      let cursorPosition = 0;
      let curlyBracketDepth = 0;
      const consumeWhile = (predicate) => {
        let str2 = "";
        while (predicate(src[cursorPosition])) {
          if (src[cursorPosition] === "\\") {
            ++cursorPosition;
            if (cursorPosition >= src.length)
              throw new SyntaxError("Unexpected end of input");
            const escaped = src[cursorPosition++];
            const unescaped = ESCAPE_CHARACTERS.get(escaped);
            if (unescaped === undefined) {
              throw new SyntaxError(`Unexpected escaped character: ${escaped}`);
            }
            str2 += unescaped;
            continue;
          }
          str2 += src[cursorPosition++];
          if (cursorPosition >= src.length)
            throw new SyntaxError("Unexpected end of input");
        }
        return str2;
      };
      const stripTrailingWhitespace = () => {
        const lastToken = tokens.at(-1);
        if (lastToken && lastToken.type === TOKEN_TYPES.Text) {
          lastToken.value = lastToken.value.trimEnd();
          if (lastToken.value === "") {
            tokens.pop();
          }
        }
      };
      const skipLeadingWhitespace = () => {
        while (cursorPosition < src.length && isWhitespace(src[cursorPosition])) {
          ++cursorPosition;
        }
      };
      main:
        while (cursorPosition < src.length) {
          const lastTokenType = tokens.at(-1)?.type;
          if (lastTokenType === undefined || lastTokenType === TOKEN_TYPES.CloseStatement || lastTokenType === TOKEN_TYPES.CloseExpression || lastTokenType === TOKEN_TYPES.Comment) {
            let text = "";
            while (cursorPosition < src.length && !(src[cursorPosition] === "{" && (src[cursorPosition + 1] === "%" || src[cursorPosition + 1] === "{" || src[cursorPosition + 1] === "#"))) {
              text += src[cursorPosition++];
            }
            if (text.length > 0) {
              tokens.push(new Token(text, TOKEN_TYPES.Text));
              continue;
            }
          }
          if (src[cursorPosition] === "{" && src[cursorPosition + 1] === "#") {
            cursorPosition += 2;
            const stripBefore = src[cursorPosition] === "-";
            if (stripBefore) {
              ++cursorPosition;
            }
            let comment = "";
            while (src[cursorPosition] !== "#" || src[cursorPosition + 1] !== "}") {
              if (cursorPosition + 2 >= src.length) {
                throw new SyntaxError("Missing end of comment tag");
              }
              comment += src[cursorPosition++];
            }
            const stripAfter = comment.endsWith("-");
            if (stripAfter) {
              comment = comment.slice(0, -1);
            }
            if (stripBefore) {
              stripTrailingWhitespace();
            }
            tokens.push(new Token(comment, TOKEN_TYPES.Comment));
            cursorPosition += 2;
            if (stripAfter) {
              skipLeadingWhitespace();
            }
            continue;
          }
          if (src.slice(cursorPosition, cursorPosition + 3) === "{%-") {
            stripTrailingWhitespace();
            tokens.push(new Token("{%", TOKEN_TYPES.OpenStatement));
            cursorPosition += 3;
            continue;
          }
          if (src.slice(cursorPosition, cursorPosition + 3) === "{{-") {
            stripTrailingWhitespace();
            tokens.push(new Token("{{", TOKEN_TYPES.OpenExpression));
            curlyBracketDepth = 0;
            cursorPosition += 3;
            continue;
          }
          consumeWhile(isWhitespace);
          if (src.slice(cursorPosition, cursorPosition + 3) === "-%}") {
            tokens.push(new Token("%}", TOKEN_TYPES.CloseStatement));
            cursorPosition += 3;
            skipLeadingWhitespace();
            continue;
          }
          if (src.slice(cursorPosition, cursorPosition + 3) === "-}}") {
            tokens.push(new Token("}}", TOKEN_TYPES.CloseExpression));
            cursorPosition += 3;
            skipLeadingWhitespace();
            continue;
          }
          const char = src[cursorPosition];
          if (char === "-" || char === "+") {
            const lastTokenType2 = tokens.at(-1)?.type;
            if (lastTokenType2 === TOKEN_TYPES.Text || lastTokenType2 === undefined) {
              throw new SyntaxError(`Unexpected character: ${char}`);
            }
            switch (lastTokenType2) {
              case TOKEN_TYPES.Identifier:
              case TOKEN_TYPES.NumericLiteral:
              case TOKEN_TYPES.StringLiteral:
              case TOKEN_TYPES.CloseParen:
              case TOKEN_TYPES.CloseSquareBracket:
                break;
              default: {
                ++cursorPosition;
                const num = consumeWhile(isInteger);
                tokens.push(new Token(`${char}${num}`, num.length > 0 ? TOKEN_TYPES.NumericLiteral : TOKEN_TYPES.UnaryOperator));
                continue;
              }
            }
          }
          for (const [seq, type] of ORDERED_MAPPING_TABLE) {
            if (seq === "}}" && curlyBracketDepth > 0) {
              continue;
            }
            const slice22 = src.slice(cursorPosition, cursorPosition + seq.length);
            if (slice22 === seq) {
              tokens.push(new Token(seq, type));
              if (type === TOKEN_TYPES.OpenExpression) {
                curlyBracketDepth = 0;
              } else if (type === TOKEN_TYPES.OpenCurlyBracket) {
                ++curlyBracketDepth;
              } else if (type === TOKEN_TYPES.CloseCurlyBracket) {
                --curlyBracketDepth;
              }
              cursorPosition += seq.length;
              continue main;
            }
          }
          if (char === "'" || char === '"') {
            ++cursorPosition;
            const str2 = consumeWhile((c) => c !== char);
            tokens.push(new Token(str2, TOKEN_TYPES.StringLiteral));
            ++cursorPosition;
            continue;
          }
          if (isInteger(char)) {
            let num = consumeWhile(isInteger);
            if (src[cursorPosition] === "." && isInteger(src[cursorPosition + 1])) {
              ++cursorPosition;
              const frac = consumeWhile(isInteger);
              num = `${num}.${frac}`;
            }
            tokens.push(new Token(num, TOKEN_TYPES.NumericLiteral));
            continue;
          }
          if (isWord(char)) {
            const word = consumeWhile(isWord);
            tokens.push(new Token(word, TOKEN_TYPES.Identifier));
            continue;
          }
          throw new SyntaxError(`Unexpected character: ${char}`);
        }
      return tokens;
    }
    var Statement = class {
      type = "Statement";
    };
    var Program = class extends Statement {
      constructor(body) {
        super();
        this.body = body;
      }
      type = "Program";
    };
    var If = class extends Statement {
      constructor(test, body, alternate) {
        super();
        this.test = test;
        this.body = body;
        this.alternate = alternate;
      }
      type = "If";
    };
    var For = class extends Statement {
      constructor(loopvar, iterable, body, defaultBlock) {
        super();
        this.loopvar = loopvar;
        this.iterable = iterable;
        this.body = body;
        this.defaultBlock = defaultBlock;
      }
      type = "For";
    };
    var Break = class extends Statement {
      type = "Break";
    };
    var Continue = class extends Statement {
      type = "Continue";
    };
    var SetStatement = class extends Statement {
      constructor(assignee, value, body) {
        super();
        this.assignee = assignee;
        this.value = value;
        this.body = body;
      }
      type = "Set";
    };
    var Macro = class extends Statement {
      constructor(name, args, body) {
        super();
        this.name = name;
        this.args = args;
        this.body = body;
      }
      type = "Macro";
    };
    var Comment = class extends Statement {
      constructor(value) {
        super();
        this.value = value;
      }
      type = "Comment";
    };
    var Expression = class extends Statement {
      type = "Expression";
    };
    var MemberExpression = class extends Expression {
      constructor(object5, property, computed) {
        super();
        this.object = object5;
        this.property = property;
        this.computed = computed;
      }
      type = "MemberExpression";
    };
    var CallExpression = class extends Expression {
      constructor(callee, args) {
        super();
        this.callee = callee;
        this.args = args;
      }
      type = "CallExpression";
    };
    var Identifier = class extends Expression {
      constructor(value) {
        super();
        this.value = value;
      }
      type = "Identifier";
    };
    var Literal = class extends Expression {
      constructor(value) {
        super();
        this.value = value;
      }
      type = "Literal";
    };
    var IntegerLiteral = class extends Literal {
      type = "IntegerLiteral";
    };
    var FloatLiteral = class extends Literal {
      type = "FloatLiteral";
    };
    var StringLiteral = class extends Literal {
      type = "StringLiteral";
    };
    var ArrayLiteral = class extends Literal {
      type = "ArrayLiteral";
    };
    var TupleLiteral = class extends Literal {
      type = "TupleLiteral";
    };
    var ObjectLiteral = class extends Literal {
      type = "ObjectLiteral";
    };
    var BinaryExpression = class extends Expression {
      constructor(operator, left, right) {
        super();
        this.operator = operator;
        this.left = left;
        this.right = right;
      }
      type = "BinaryExpression";
    };
    var FilterExpression = class extends Expression {
      constructor(operand, filter) {
        super();
        this.operand = operand;
        this.filter = filter;
      }
      type = "FilterExpression";
    };
    var FilterStatement = class extends Statement {
      constructor(filter, body) {
        super();
        this.filter = filter;
        this.body = body;
      }
      type = "FilterStatement";
    };
    var SelectExpression = class extends Expression {
      constructor(lhs, test) {
        super();
        this.lhs = lhs;
        this.test = test;
      }
      type = "SelectExpression";
    };
    var TestExpression = class extends Expression {
      constructor(operand, negate, test) {
        super();
        this.operand = operand;
        this.negate = negate;
        this.test = test;
      }
      type = "TestExpression";
    };
    var UnaryExpression = class extends Expression {
      constructor(operator, argument) {
        super();
        this.operator = operator;
        this.argument = argument;
      }
      type = "UnaryExpression";
    };
    var SliceExpression = class extends Expression {
      constructor(start = undefined, stop = undefined, step = undefined) {
        super();
        this.start = start;
        this.stop = stop;
        this.step = step;
      }
      type = "SliceExpression";
    };
    var KeywordArgumentExpression = class extends Expression {
      constructor(key, value) {
        super();
        this.key = key;
        this.value = value;
      }
      type = "KeywordArgumentExpression";
    };
    var SpreadExpression = class extends Expression {
      constructor(argument) {
        super();
        this.argument = argument;
      }
      type = "SpreadExpression";
    };
    var CallStatement = class extends Statement {
      constructor(call, callerArgs, body) {
        super();
        this.call = call;
        this.callerArgs = callerArgs;
        this.body = body;
      }
      type = "CallStatement";
    };
    var Ternary = class extends Expression {
      constructor(condition, trueExpr, falseExpr) {
        super();
        this.condition = condition;
        this.trueExpr = trueExpr;
        this.falseExpr = falseExpr;
      }
      type = "Ternary";
    };
    function parse11(tokens) {
      const program = new Program([]);
      let current = 0;
      function expect(type, error49) {
        const prev = tokens[current++];
        if (!prev || prev.type !== type) {
          throw new Error(`Parser Error: ${error49}. ${prev.type} !== ${type}.`);
        }
        return prev;
      }
      function expectIdentifier(name) {
        if (!isIdentifier(name)) {
          throw new SyntaxError(`Expected ${name}`);
        }
        ++current;
      }
      function parseAny() {
        switch (tokens[current].type) {
          case TOKEN_TYPES.Comment:
            return new Comment(tokens[current++].value);
          case TOKEN_TYPES.Text:
            return parseText();
          case TOKEN_TYPES.OpenStatement:
            return parseJinjaStatement();
          case TOKEN_TYPES.OpenExpression:
            return parseJinjaExpression();
          default:
            throw new SyntaxError(`Unexpected token type: ${tokens[current].type}`);
        }
      }
      function is2(...types) {
        return current + types.length <= tokens.length && types.every((type, i) => type === tokens[current + i].type);
      }
      function isStatement(...names) {
        return tokens[current]?.type === TOKEN_TYPES.OpenStatement && tokens[current + 1]?.type === TOKEN_TYPES.Identifier && names.includes(tokens[current + 1]?.value);
      }
      function isIdentifier(...names) {
        return current + names.length <= tokens.length && names.every((name, i) => tokens[current + i].type === "Identifier" && name === tokens[current + i].value);
      }
      function parseText() {
        return new StringLiteral(expect(TOKEN_TYPES.Text, "Expected text token").value);
      }
      function parseJinjaStatement() {
        expect(TOKEN_TYPES.OpenStatement, "Expected opening statement token");
        if (tokens[current].type !== TOKEN_TYPES.Identifier) {
          throw new SyntaxError(`Unknown statement, got ${tokens[current].type}`);
        }
        const name = tokens[current].value;
        let result;
        switch (name) {
          case "set":
            ++current;
            result = parseSetStatement();
            break;
          case "if":
            ++current;
            result = parseIfStatement();
            expect(TOKEN_TYPES.OpenStatement, "Expected {% token");
            expectIdentifier("endif");
            expect(TOKEN_TYPES.CloseStatement, "Expected %} token");
            break;
          case "macro":
            ++current;
            result = parseMacroStatement();
            expect(TOKEN_TYPES.OpenStatement, "Expected {% token");
            expectIdentifier("endmacro");
            expect(TOKEN_TYPES.CloseStatement, "Expected %} token");
            break;
          case "for":
            ++current;
            result = parseForStatement();
            expect(TOKEN_TYPES.OpenStatement, "Expected {% token");
            expectIdentifier("endfor");
            expect(TOKEN_TYPES.CloseStatement, "Expected %} token");
            break;
          case "call": {
            ++current;
            let callerArgs = null;
            if (is2(TOKEN_TYPES.OpenParen)) {
              callerArgs = parseArgs();
            }
            const callee = parsePrimaryExpression();
            if (callee.type !== "Identifier") {
              throw new SyntaxError(`Expected identifier following call statement`);
            }
            const callArgs = parseArgs();
            expect(TOKEN_TYPES.CloseStatement, "Expected closing statement token");
            const body = [];
            while (!isStatement("endcall")) {
              body.push(parseAny());
            }
            expect(TOKEN_TYPES.OpenStatement, "Expected '{%'");
            expectIdentifier("endcall");
            expect(TOKEN_TYPES.CloseStatement, "Expected closing statement token");
            const callExpr = new CallExpression(callee, callArgs);
            result = new CallStatement(callExpr, callerArgs, body);
            break;
          }
          case "break":
            ++current;
            expect(TOKEN_TYPES.CloseStatement, "Expected closing statement token");
            result = new Break;
            break;
          case "continue":
            ++current;
            expect(TOKEN_TYPES.CloseStatement, "Expected closing statement token");
            result = new Continue;
            break;
          case "filter": {
            ++current;
            let filterNode = parsePrimaryExpression();
            if (filterNode instanceof Identifier && is2(TOKEN_TYPES.OpenParen)) {
              filterNode = parseCallExpression(filterNode);
            }
            expect(TOKEN_TYPES.CloseStatement, "Expected closing statement token");
            const filterBody = [];
            while (!isStatement("endfilter")) {
              filterBody.push(parseAny());
            }
            expect(TOKEN_TYPES.OpenStatement, "Expected '{%'");
            expectIdentifier("endfilter");
            expect(TOKEN_TYPES.CloseStatement, "Expected '%}'");
            result = new FilterStatement(filterNode, filterBody);
            break;
          }
          default:
            throw new SyntaxError(`Unknown statement type: ${name}`);
        }
        return result;
      }
      function parseJinjaExpression() {
        expect(TOKEN_TYPES.OpenExpression, "Expected opening expression token");
        const result = parseExpression();
        expect(TOKEN_TYPES.CloseExpression, "Expected closing expression token");
        return result;
      }
      function parseSetStatement() {
        const left = parseExpressionSequence();
        let value = null;
        const body = [];
        if (is2(TOKEN_TYPES.Equals)) {
          ++current;
          value = parseExpressionSequence();
        } else {
          expect(TOKEN_TYPES.CloseStatement, "Expected %} token");
          while (!isStatement("endset")) {
            body.push(parseAny());
          }
          expect(TOKEN_TYPES.OpenStatement, "Expected {% token");
          expectIdentifier("endset");
        }
        expect(TOKEN_TYPES.CloseStatement, "Expected closing statement token");
        return new SetStatement(left, value, body);
      }
      function parseIfStatement() {
        const test = parseExpression();
        expect(TOKEN_TYPES.CloseStatement, "Expected closing statement token");
        const body = [];
        const alternate = [];
        while (!isStatement("elif", "else", "endif")) {
          body.push(parseAny());
        }
        if (isStatement("elif")) {
          ++current;
          ++current;
          const result = parseIfStatement();
          alternate.push(result);
        } else if (isStatement("else")) {
          ++current;
          ++current;
          expect(TOKEN_TYPES.CloseStatement, "Expected closing statement token");
          while (!isStatement("endif")) {
            alternate.push(parseAny());
          }
        }
        return new If(test, body, alternate);
      }
      function parseMacroStatement() {
        const name = parsePrimaryExpression();
        if (name.type !== "Identifier") {
          throw new SyntaxError(`Expected identifier following macro statement`);
        }
        const args = parseArgs();
        expect(TOKEN_TYPES.CloseStatement, "Expected closing statement token");
        const body = [];
        while (!isStatement("endmacro")) {
          body.push(parseAny());
        }
        return new Macro(name, args, body);
      }
      function parseExpressionSequence(primary = false) {
        const fn = primary ? parsePrimaryExpression : parseExpression;
        const expressions = [fn()];
        const isTuple = is2(TOKEN_TYPES.Comma);
        while (isTuple) {
          ++current;
          expressions.push(fn());
          if (!is2(TOKEN_TYPES.Comma)) {
            break;
          }
        }
        return isTuple ? new TupleLiteral(expressions) : expressions[0];
      }
      function parseForStatement() {
        const loopVariable = parseExpressionSequence(true);
        if (!(loopVariable instanceof Identifier || loopVariable instanceof TupleLiteral)) {
          throw new SyntaxError(`Expected identifier/tuple for the loop variable, got ${loopVariable.type} instead`);
        }
        if (!isIdentifier("in")) {
          throw new SyntaxError("Expected `in` keyword following loop variable");
        }
        ++current;
        const iterable = parseExpression();
        expect(TOKEN_TYPES.CloseStatement, "Expected closing statement token");
        const body = [];
        while (!isStatement("endfor", "else")) {
          body.push(parseAny());
        }
        const alternative = [];
        if (isStatement("else")) {
          ++current;
          ++current;
          expect(TOKEN_TYPES.CloseStatement, "Expected closing statement token");
          while (!isStatement("endfor")) {
            alternative.push(parseAny());
          }
        }
        return new For(loopVariable, iterable, body, alternative);
      }
      function parseExpression() {
        return parseIfExpression();
      }
      function parseIfExpression() {
        const a = parseLogicalOrExpression();
        if (isIdentifier("if")) {
          ++current;
          const test = parseLogicalOrExpression();
          if (isIdentifier("else")) {
            ++current;
            const falseExpr = parseIfExpression();
            return new Ternary(test, a, falseExpr);
          } else {
            return new SelectExpression(a, test);
          }
        }
        return a;
      }
      function parseLogicalOrExpression() {
        let left = parseLogicalAndExpression();
        while (isIdentifier("or")) {
          const operator = tokens[current];
          ++current;
          const right = parseLogicalAndExpression();
          left = new BinaryExpression(operator, left, right);
        }
        return left;
      }
      function parseLogicalAndExpression() {
        let left = parseLogicalNegationExpression();
        while (isIdentifier("and")) {
          const operator = tokens[current];
          ++current;
          const right = parseLogicalNegationExpression();
          left = new BinaryExpression(operator, left, right);
        }
        return left;
      }
      function parseLogicalNegationExpression() {
        let right;
        while (isIdentifier("not")) {
          const operator = tokens[current];
          ++current;
          const arg = parseLogicalNegationExpression();
          right = new UnaryExpression(operator, arg);
        }
        return right ?? parseComparisonExpression();
      }
      function parseComparisonExpression() {
        let left = parseAdditiveExpression();
        while (true) {
          let operator;
          if (isIdentifier("not", "in")) {
            operator = new Token("not in", TOKEN_TYPES.Identifier);
            current += 2;
          } else if (isIdentifier("in")) {
            operator = tokens[current++];
          } else if (is2(TOKEN_TYPES.ComparisonBinaryOperator)) {
            operator = tokens[current++];
          } else {
            break;
          }
          const right = parseAdditiveExpression();
          left = new BinaryExpression(operator, left, right);
        }
        return left;
      }
      function parseAdditiveExpression() {
        let left = parseMultiplicativeExpression();
        while (is2(TOKEN_TYPES.AdditiveBinaryOperator)) {
          const operator = tokens[current];
          ++current;
          const right = parseMultiplicativeExpression();
          left = new BinaryExpression(operator, left, right);
        }
        return left;
      }
      function parseCallMemberExpression() {
        const member = parseMemberExpression(parsePrimaryExpression());
        if (is2(TOKEN_TYPES.OpenParen)) {
          return parseCallExpression(member);
        }
        return member;
      }
      function parseCallExpression(callee) {
        let expression = new CallExpression(callee, parseArgs());
        expression = parseMemberExpression(expression);
        if (is2(TOKEN_TYPES.OpenParen)) {
          expression = parseCallExpression(expression);
        }
        return expression;
      }
      function parseArgs() {
        expect(TOKEN_TYPES.OpenParen, "Expected opening parenthesis for arguments list");
        const args = parseArgumentsList();
        expect(TOKEN_TYPES.CloseParen, "Expected closing parenthesis for arguments list");
        return args;
      }
      function parseArgumentsList() {
        const args = [];
        while (!is2(TOKEN_TYPES.CloseParen)) {
          let argument;
          if (tokens[current].type === TOKEN_TYPES.MultiplicativeBinaryOperator && tokens[current].value === "*") {
            ++current;
            const expr = parseExpression();
            argument = new SpreadExpression(expr);
          } else {
            argument = parseExpression();
            if (is2(TOKEN_TYPES.Equals)) {
              ++current;
              if (!(argument instanceof Identifier)) {
                throw new SyntaxError(`Expected identifier for keyword argument`);
              }
              const value = parseExpression();
              argument = new KeywordArgumentExpression(argument, value);
            }
          }
          args.push(argument);
          if (is2(TOKEN_TYPES.Comma)) {
            ++current;
          }
        }
        return args;
      }
      function parseMemberExpressionArgumentsList() {
        const slices = [];
        let isSlice = false;
        while (!is2(TOKEN_TYPES.CloseSquareBracket)) {
          if (is2(TOKEN_TYPES.Colon)) {
            slices.push(undefined);
            ++current;
            isSlice = true;
          } else {
            slices.push(parseExpression());
            if (is2(TOKEN_TYPES.Colon)) {
              ++current;
              isSlice = true;
            }
          }
        }
        if (slices.length === 0) {
          throw new SyntaxError(`Expected at least one argument for member/slice expression`);
        }
        if (isSlice) {
          if (slices.length > 3) {
            throw new SyntaxError(`Expected 0-3 arguments for slice expression`);
          }
          return new SliceExpression(...slices);
        }
        return slices[0];
      }
      function parseMemberExpression(object5) {
        while (is2(TOKEN_TYPES.Dot) || is2(TOKEN_TYPES.OpenSquareBracket)) {
          const operator = tokens[current];
          ++current;
          let property;
          const computed = operator.type === TOKEN_TYPES.OpenSquareBracket;
          if (computed) {
            property = parseMemberExpressionArgumentsList();
            expect(TOKEN_TYPES.CloseSquareBracket, "Expected closing square bracket");
          } else {
            property = parsePrimaryExpression();
            if (property.type !== "Identifier") {
              throw new SyntaxError(`Expected identifier following dot operator`);
            }
          }
          object5 = new MemberExpression(object5, property, computed);
        }
        return object5;
      }
      function parseMultiplicativeExpression() {
        let left = parseTestExpression();
        while (is2(TOKEN_TYPES.MultiplicativeBinaryOperator)) {
          const operator = tokens[current++];
          const right = parseTestExpression();
          left = new BinaryExpression(operator, left, right);
        }
        return left;
      }
      function parseTestExpression() {
        let operand = parseFilterExpression();
        while (isIdentifier("is")) {
          ++current;
          const negate = isIdentifier("not");
          if (negate) {
            ++current;
          }
          const filter = parsePrimaryExpression();
          if (!(filter instanceof Identifier)) {
            throw new SyntaxError(`Expected identifier for the test`);
          }
          operand = new TestExpression(operand, negate, filter);
        }
        return operand;
      }
      function parseFilterExpression() {
        let operand = parseCallMemberExpression();
        while (is2(TOKEN_TYPES.Pipe)) {
          ++current;
          let filter = parsePrimaryExpression();
          if (!(filter instanceof Identifier)) {
            throw new SyntaxError(`Expected identifier for the filter`);
          }
          if (is2(TOKEN_TYPES.OpenParen)) {
            filter = parseCallExpression(filter);
          }
          operand = new FilterExpression(operand, filter);
        }
        return operand;
      }
      function parsePrimaryExpression() {
        const token = tokens[current++];
        switch (token.type) {
          case TOKEN_TYPES.NumericLiteral: {
            const num = token.value;
            return num.includes(".") ? new FloatLiteral(Number(num)) : new IntegerLiteral(Number(num));
          }
          case TOKEN_TYPES.StringLiteral: {
            let value = token.value;
            while (is2(TOKEN_TYPES.StringLiteral)) {
              value += tokens[current++].value;
            }
            return new StringLiteral(value);
          }
          case TOKEN_TYPES.Identifier:
            return new Identifier(token.value);
          case TOKEN_TYPES.OpenParen: {
            const expression = parseExpressionSequence();
            expect(TOKEN_TYPES.CloseParen, "Expected closing parenthesis, got ${tokens[current].type} instead.");
            return expression;
          }
          case TOKEN_TYPES.OpenSquareBracket: {
            const values = [];
            while (!is2(TOKEN_TYPES.CloseSquareBracket)) {
              values.push(parseExpression());
              if (is2(TOKEN_TYPES.Comma)) {
                ++current;
              }
            }
            ++current;
            return new ArrayLiteral(values);
          }
          case TOKEN_TYPES.OpenCurlyBracket: {
            const values = /* @__PURE__ */ new Map;
            while (!is2(TOKEN_TYPES.CloseCurlyBracket)) {
              const key = parseExpression();
              expect(TOKEN_TYPES.Colon, "Expected colon between key and value in object literal");
              const value = parseExpression();
              values.set(key, value);
              if (is2(TOKEN_TYPES.Comma)) {
                ++current;
              }
            }
            ++current;
            return new ObjectLiteral(values);
          }
          default:
            throw new SyntaxError(`Unexpected token: ${token.type}`);
        }
      }
      while (current < tokens.length) {
        program.body.push(parseAny());
      }
      return program;
    }
    function range(start, stop, step = 1) {
      if (stop === undefined) {
        stop = start;
        start = 0;
      }
      const result = [];
      for (let i = start;i < stop; i += step) {
        result.push(i);
      }
      return result;
    }
    function slice2(array4, start, stop, step = 1) {
      const direction = Math.sign(step);
      if (direction >= 0) {
        start = (start ??= 0) < 0 ? Math.max(array4.length + start, 0) : Math.min(start, array4.length);
        stop = (stop ??= array4.length) < 0 ? Math.max(array4.length + stop, 0) : Math.min(stop, array4.length);
      } else {
        start = (start ??= array4.length - 1) < 0 ? Math.max(array4.length + start, -1) : Math.min(start, array4.length - 1);
        stop = (stop ??= -1) < -1 ? Math.max(array4.length + stop, -1) : Math.min(stop, array4.length - 1);
      }
      const result = [];
      for (let i = start;direction * i < direction * stop; i += step) {
        result.push(array4[i]);
      }
      return result;
    }
    function titleCase(value) {
      return value.replace(/\b\w/g, (c) => c.toUpperCase());
    }
    function strftime_now(format2) {
      return strftime(/* @__PURE__ */ new Date, format2);
    }
    function strftime(date8, format2) {
      const monthFormatterLong = new Intl.DateTimeFormat(undefined, { month: "long" });
      const monthFormatterShort = new Intl.DateTimeFormat(undefined, { month: "short" });
      const pad2 = (n) => n < 10 ? "0" + n : n.toString();
      return format2.replace(/%[YmdbBHM%]/g, (token) => {
        switch (token) {
          case "%Y":
            return date8.getFullYear().toString();
          case "%m":
            return pad2(date8.getMonth() + 1);
          case "%d":
            return pad2(date8.getDate());
          case "%b":
            return monthFormatterShort.format(date8);
          case "%B":
            return monthFormatterLong.format(date8);
          case "%H":
            return pad2(date8.getHours());
          case "%M":
            return pad2(date8.getMinutes());
          case "%%":
            return "%";
          default:
            return token;
        }
      });
    }
    function escapeRegExp(s) {
      return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    function replace2(str2, oldvalue, newvalue, count) {
      if (count === 0)
        return str2;
      let remaining = count == null || count < 0 ? Infinity : count;
      const pattern = oldvalue.length === 0 ? new RegExp("(?=)", "gu") : new RegExp(escapeRegExp(oldvalue), "gu");
      return str2.replaceAll(pattern, (match) => {
        if (remaining > 0) {
          --remaining;
          return newvalue;
        }
        return match;
      });
    }
    var BreakControl = class extends Error {
    };
    var ContinueControl = class extends Error {
    };
    var RuntimeValue = class {
      type = "RuntimeValue";
      value;
      builtins = /* @__PURE__ */ new Map;
      constructor(value = undefined) {
        this.value = value;
      }
      __bool__() {
        return new BooleanValue(!!this.value);
      }
      toString() {
        return String(this.value);
      }
    };
    var IntegerValue = class extends RuntimeValue {
      type = "IntegerValue";
    };
    var FloatValue = class extends RuntimeValue {
      type = "FloatValue";
      toString() {
        return this.value % 1 === 0 ? this.value.toFixed(1) : this.value.toString();
      }
    };
    var StringValue = class extends RuntimeValue {
      type = "StringValue";
      builtins = /* @__PURE__ */ new Map([
        [
          "upper",
          new FunctionValue(() => {
            return new StringValue(this.value.toUpperCase());
          })
        ],
        [
          "lower",
          new FunctionValue(() => {
            return new StringValue(this.value.toLowerCase());
          })
        ],
        [
          "strip",
          new FunctionValue(() => {
            return new StringValue(this.value.trim());
          })
        ],
        [
          "title",
          new FunctionValue(() => {
            return new StringValue(titleCase(this.value));
          })
        ],
        [
          "capitalize",
          new FunctionValue(() => {
            return new StringValue(this.value.charAt(0).toUpperCase() + this.value.slice(1));
          })
        ],
        ["length", new IntegerValue(this.value.length)],
        [
          "rstrip",
          new FunctionValue(() => {
            return new StringValue(this.value.trimEnd());
          })
        ],
        [
          "lstrip",
          new FunctionValue(() => {
            return new StringValue(this.value.trimStart());
          })
        ],
        [
          "startswith",
          new FunctionValue((args) => {
            if (args.length === 0) {
              throw new Error("startswith() requires at least one argument");
            }
            const pattern = args[0];
            if (pattern instanceof StringValue) {
              return new BooleanValue(this.value.startsWith(pattern.value));
            } else if (pattern instanceof ArrayValue) {
              for (const item of pattern.value) {
                if (!(item instanceof StringValue)) {
                  throw new Error("startswith() tuple elements must be strings");
                }
                if (this.value.startsWith(item.value)) {
                  return new BooleanValue(true);
                }
              }
              return new BooleanValue(false);
            }
            throw new Error("startswith() argument must be a string or tuple of strings");
          })
        ],
        [
          "endswith",
          new FunctionValue((args) => {
            if (args.length === 0) {
              throw new Error("endswith() requires at least one argument");
            }
            const pattern = args[0];
            if (pattern instanceof StringValue) {
              return new BooleanValue(this.value.endsWith(pattern.value));
            } else if (pattern instanceof ArrayValue) {
              for (const item of pattern.value) {
                if (!(item instanceof StringValue)) {
                  throw new Error("endswith() tuple elements must be strings");
                }
                if (this.value.endsWith(item.value)) {
                  return new BooleanValue(true);
                }
              }
              return new BooleanValue(false);
            }
            throw new Error("endswith() argument must be a string or tuple of strings");
          })
        ],
        [
          "split",
          new FunctionValue((args) => {
            const sep = args[0] ?? new NullValue;
            if (!(sep instanceof StringValue || sep instanceof NullValue)) {
              throw new Error("sep argument must be a string or null");
            }
            const maxsplit = args[1] ?? new IntegerValue(-1);
            if (!(maxsplit instanceof IntegerValue)) {
              throw new Error("maxsplit argument must be a number");
            }
            let result = [];
            if (sep instanceof NullValue) {
              const text = this.value.trimStart();
              for (const { 0: match, index } of text.matchAll(/\S+/g)) {
                if (maxsplit.value !== -1 && result.length >= maxsplit.value && index !== undefined) {
                  result.push(match + text.slice(index + match.length));
                  break;
                }
                result.push(match);
              }
            } else {
              if (sep.value === "") {
                throw new Error("empty separator");
              }
              result = this.value.split(sep.value);
              if (maxsplit.value !== -1 && result.length > maxsplit.value) {
                result.push(result.splice(maxsplit.value).join(sep.value));
              }
            }
            return new ArrayValue(result.map((part) => new StringValue(part)));
          })
        ],
        [
          "replace",
          new FunctionValue((args) => {
            if (args.length < 2) {
              throw new Error("replace() requires at least two arguments");
            }
            const oldValue = args[0];
            const newValue = args[1];
            if (!(oldValue instanceof StringValue && newValue instanceof StringValue)) {
              throw new Error("replace() arguments must be strings");
            }
            let count;
            if (args.length > 2) {
              if (args[2].type === "KeywordArgumentsValue") {
                count = args[2].value.get("count") ?? new NullValue;
              } else {
                count = args[2];
              }
            } else {
              count = new NullValue;
            }
            if (!(count instanceof IntegerValue || count instanceof NullValue)) {
              throw new Error("replace() count argument must be a number or null");
            }
            return new StringValue(replace2(this.value, oldValue.value, newValue.value, count.value));
          })
        ]
      ]);
    };
    var BooleanValue = class extends RuntimeValue {
      type = "BooleanValue";
    };
    function toJSON(input, indent, depth, convertUndefinedToNull = true) {
      const currentDepth = depth ?? 0;
      switch (input.type) {
        case "NullValue":
          return "null";
        case "UndefinedValue":
          return convertUndefinedToNull ? "null" : "undefined";
        case "IntegerValue":
        case "FloatValue":
        case "StringValue":
        case "BooleanValue":
          return JSON.stringify(input.value);
        case "ArrayValue":
        case "ObjectValue": {
          const indentValue = indent ? " ".repeat(indent) : "";
          const basePadding = `
` + indentValue.repeat(currentDepth);
          const childrenPadding = basePadding + indentValue;
          if (input.type === "ArrayValue") {
            const core3 = input.value.map((x) => toJSON(x, indent, currentDepth + 1, convertUndefinedToNull));
            return indent ? `[${childrenPadding}${core3.join(`,${childrenPadding}`)}${basePadding}]` : `[${core3.join(", ")}]`;
          } else {
            const core3 = Array.from(input.value.entries()).map(([key, value]) => {
              const v = `"${key}": ${toJSON(value, indent, currentDepth + 1, convertUndefinedToNull)}`;
              return indent ? `${childrenPadding}${v}` : v;
            });
            return indent ? `{${core3.join(",")}${basePadding}}` : `{${core3.join(", ")}}`;
          }
        }
        default:
          throw new Error(`Cannot convert to JSON: ${input.type}`);
      }
    }
    var ObjectValue = class extends RuntimeValue {
      type = "ObjectValue";
      __bool__() {
        return new BooleanValue(this.value.size > 0);
      }
      builtins = /* @__PURE__ */ new Map([
        [
          "get",
          new FunctionValue(([key, defaultValue]) => {
            if (!(key instanceof StringValue)) {
              throw new Error(`Object key must be a string: got ${key.type}`);
            }
            return this.value.get(key.value) ?? defaultValue ?? new NullValue;
          })
        ],
        ["items", new FunctionValue(() => this.items())],
        ["keys", new FunctionValue(() => this.keys())],
        ["values", new FunctionValue(() => this.values())],
        [
          "dictsort",
          new FunctionValue((args) => {
            let kwargs = /* @__PURE__ */ new Map;
            const positionalArgs = args.filter((arg) => {
              if (arg instanceof KeywordArgumentsValue) {
                kwargs = arg.value;
                return false;
              }
              return true;
            });
            const caseSensitive = positionalArgs.at(0) ?? kwargs.get("case_sensitive") ?? new BooleanValue(false);
            if (!(caseSensitive instanceof BooleanValue)) {
              throw new Error("case_sensitive must be a boolean");
            }
            const by = positionalArgs.at(1) ?? kwargs.get("by") ?? new StringValue("key");
            if (!(by instanceof StringValue)) {
              throw new Error("by must be a string");
            }
            if (!["key", "value"].includes(by.value)) {
              throw new Error("by must be either 'key' or 'value'");
            }
            const reverse = positionalArgs.at(2) ?? kwargs.get("reverse") ?? new BooleanValue(false);
            if (!(reverse instanceof BooleanValue)) {
              throw new Error("reverse must be a boolean");
            }
            const items = Array.from(this.value.entries()).map(([key, value]) => new ArrayValue([new StringValue(key), value])).sort((a, b) => {
              const index = by.value === "key" ? 0 : 1;
              const aVal = a.value[index];
              const bVal = b.value[index];
              const result = compareRuntimeValues(aVal, bVal, caseSensitive.value);
              return reverse.value ? -result : result;
            });
            return new ArrayValue(items);
          })
        ]
      ]);
      items() {
        return new ArrayValue(Array.from(this.value.entries()).map(([key, value]) => new ArrayValue([new StringValue(key), value])));
      }
      keys() {
        return new ArrayValue(Array.from(this.value.keys()).map((key) => new StringValue(key)));
      }
      values() {
        return new ArrayValue(Array.from(this.value.values()));
      }
      toString() {
        return toJSON(this, null, 0, false);
      }
    };
    var KeywordArgumentsValue = class extends ObjectValue {
      type = "KeywordArgumentsValue";
    };
    var ArrayValue = class extends RuntimeValue {
      type = "ArrayValue";
      builtins = /* @__PURE__ */ new Map([["length", new IntegerValue(this.value.length)]]);
      __bool__() {
        return new BooleanValue(this.value.length > 0);
      }
      toString() {
        return toJSON(this, null, 0, false);
      }
    };
    var TupleValue = class extends ArrayValue {
      type = "TupleValue";
    };
    var FunctionValue = class extends RuntimeValue {
      type = "FunctionValue";
    };
    var NullValue = class extends RuntimeValue {
      type = "NullValue";
    };
    var UndefinedValue = class extends RuntimeValue {
      type = "UndefinedValue";
    };
    var Environment = class {
      constructor(parent) {
        this.parent = parent;
      }
      variables = /* @__PURE__ */ new Map([
        [
          "namespace",
          new FunctionValue((args) => {
            if (args.length === 0) {
              return new ObjectValue(/* @__PURE__ */ new Map);
            }
            if (args.length !== 1 || !(args[0] instanceof ObjectValue)) {
              throw new Error("`namespace` expects either zero arguments or a single object argument");
            }
            return args[0];
          })
        ]
      ]);
      tests = /* @__PURE__ */ new Map([
        ["boolean", (operand) => operand.type === "BooleanValue"],
        ["callable", (operand) => operand instanceof FunctionValue],
        [
          "odd",
          (operand) => {
            if (!(operand instanceof IntegerValue)) {
              throw new Error(`cannot odd on ${operand.type}`);
            }
            return operand.value % 2 !== 0;
          }
        ],
        [
          "even",
          (operand) => {
            if (!(operand instanceof IntegerValue)) {
              throw new Error(`cannot even on ${operand.type}`);
            }
            return operand.value % 2 === 0;
          }
        ],
        ["false", (operand) => operand.type === "BooleanValue" && !operand.value],
        ["true", (operand) => operand.type === "BooleanValue" && operand.value],
        ["none", (operand) => operand.type === "NullValue"],
        ["string", (operand) => operand.type === "StringValue"],
        ["number", (operand) => operand instanceof IntegerValue || operand instanceof FloatValue],
        ["integer", (operand) => operand instanceof IntegerValue],
        ["iterable", (operand) => operand.type === "ArrayValue" || operand.type === "StringValue"],
        ["mapping", (operand) => operand.type === "ObjectValue"],
        [
          "lower",
          (operand) => {
            const str2 = operand.value;
            return operand.type === "StringValue" && str2 === str2.toLowerCase();
          }
        ],
        [
          "upper",
          (operand) => {
            const str2 = operand.value;
            return operand.type === "StringValue" && str2 === str2.toUpperCase();
          }
        ],
        ["none", (operand) => operand.type === "NullValue"],
        ["defined", (operand) => operand.type !== "UndefinedValue"],
        ["undefined", (operand) => operand.type === "UndefinedValue"],
        ["equalto", (a, b) => a.value === b.value],
        ["eq", (a, b) => a.value === b.value]
      ]);
      set(name, value) {
        return this.declareVariable(name, convertToRuntimeValues(value));
      }
      declareVariable(name, value) {
        if (this.variables.has(name)) {
          throw new SyntaxError(`Variable already declared: ${name}`);
        }
        this.variables.set(name, value);
        return value;
      }
      setVariable(name, value) {
        this.variables.set(name, value);
        return value;
      }
      resolve(name) {
        if (this.variables.has(name)) {
          return this;
        }
        if (this.parent) {
          return this.parent.resolve(name);
        }
        throw new Error(`Unknown variable: ${name}`);
      }
      lookupVariable(name) {
        try {
          return this.resolve(name).variables.get(name) ?? new UndefinedValue;
        } catch {
          return new UndefinedValue;
        }
      }
    };
    function setupGlobals(env4) {
      env4.set("false", false);
      env4.set("true", true);
      env4.set("none", null);
      env4.set("raise_exception", (args) => {
        throw new Error(args);
      });
      env4.set("range", range);
      env4.set("strftime_now", strftime_now);
      env4.set("True", true);
      env4.set("False", false);
      env4.set("None", null);
    }
    function getAttributeValue(item, attributePath) {
      const parts = attributePath.split(".");
      let value = item;
      for (const part of parts) {
        if (value instanceof ObjectValue) {
          value = value.value.get(part) ?? new UndefinedValue;
        } else if (value instanceof ArrayValue) {
          const index = parseInt(part, 10);
          if (!isNaN(index) && index >= 0 && index < value.value.length) {
            value = value.value[index];
          } else {
            return new UndefinedValue;
          }
        } else {
          return new UndefinedValue;
        }
      }
      return value;
    }
    function compareRuntimeValues(a, b, caseSensitive = false) {
      if (a instanceof NullValue && b instanceof NullValue) {
        return 0;
      }
      if (a instanceof NullValue || b instanceof NullValue) {
        throw new Error(`Cannot compare ${a.type} with ${b.type}`);
      }
      if (a instanceof UndefinedValue && b instanceof UndefinedValue) {
        return 0;
      }
      if (a instanceof UndefinedValue || b instanceof UndefinedValue) {
        throw new Error(`Cannot compare ${a.type} with ${b.type}`);
      }
      const isNumericLike = (v) => v instanceof IntegerValue || v instanceof FloatValue || v instanceof BooleanValue;
      const getNumericValue = (v) => {
        if (v instanceof BooleanValue) {
          return v.value ? 1 : 0;
        }
        return v.value;
      };
      if (isNumericLike(a) && isNumericLike(b)) {
        const aNum = getNumericValue(a);
        const bNum = getNumericValue(b);
        return aNum < bNum ? -1 : aNum > bNum ? 1 : 0;
      }
      if (a.type !== b.type) {
        throw new Error(`Cannot compare different types: ${a.type} and ${b.type}`);
      }
      switch (a.type) {
        case "StringValue": {
          let aStr = a.value;
          let bStr = b.value;
          if (!caseSensitive) {
            aStr = aStr.toLowerCase();
            bStr = bStr.toLowerCase();
          }
          return aStr < bStr ? -1 : aStr > bStr ? 1 : 0;
        }
        default:
          throw new Error(`Cannot compare type: ${a.type}`);
      }
    }
    var Interpreter = class {
      global;
      constructor(env4) {
        this.global = env4 ?? new Environment;
      }
      run(program) {
        return this.evaluate(program, this.global);
      }
      evaluateBinaryExpression(node, environment) {
        const left = this.evaluate(node.left, environment);
        switch (node.operator.value) {
          case "and":
            return left.__bool__().value ? this.evaluate(node.right, environment) : left;
          case "or":
            return left.__bool__().value ? left : this.evaluate(node.right, environment);
        }
        const right = this.evaluate(node.right, environment);
        switch (node.operator.value) {
          case "==":
            return new BooleanValue(left.value == right.value);
          case "!=":
            return new BooleanValue(left.value != right.value);
        }
        if (left instanceof UndefinedValue || right instanceof UndefinedValue) {
          if (right instanceof UndefinedValue && ["in", "not in"].includes(node.operator.value)) {
            return new BooleanValue(node.operator.value === "not in");
          }
          throw new Error(`Cannot perform operation ${node.operator.value} on undefined values`);
        } else if (left instanceof NullValue || right instanceof NullValue) {
          throw new Error("Cannot perform operation on null values");
        } else if (node.operator.value === "~") {
          return new StringValue(left.value.toString() + right.value.toString());
        } else if ((left instanceof IntegerValue || left instanceof FloatValue) && (right instanceof IntegerValue || right instanceof FloatValue)) {
          const a = left.value, b = right.value;
          switch (node.operator.value) {
            case "+":
            case "-":
            case "*": {
              const res = node.operator.value === "+" ? a + b : node.operator.value === "-" ? a - b : a * b;
              const isFloat = left instanceof FloatValue || right instanceof FloatValue;
              return isFloat ? new FloatValue(res) : new IntegerValue(res);
            }
            case "/":
              return new FloatValue(a / b);
            case "%": {
              const rem = a % b;
              const isFloat = left instanceof FloatValue || right instanceof FloatValue;
              return isFloat ? new FloatValue(rem) : new IntegerValue(rem);
            }
            case "<":
              return new BooleanValue(a < b);
            case ">":
              return new BooleanValue(a > b);
            case ">=":
              return new BooleanValue(a >= b);
            case "<=":
              return new BooleanValue(a <= b);
          }
        } else if (left instanceof ArrayValue && right instanceof ArrayValue) {
          switch (node.operator.value) {
            case "+":
              return new ArrayValue(left.value.concat(right.value));
          }
        } else if (right instanceof ArrayValue) {
          const member = right.value.find((x) => x.value === left.value) !== undefined;
          switch (node.operator.value) {
            case "in":
              return new BooleanValue(member);
            case "not in":
              return new BooleanValue(!member);
          }
        }
        if (left instanceof StringValue || right instanceof StringValue) {
          switch (node.operator.value) {
            case "+":
              return new StringValue(left.value.toString() + right.value.toString());
          }
        }
        if (left instanceof StringValue && right instanceof StringValue) {
          switch (node.operator.value) {
            case "in":
              return new BooleanValue(right.value.includes(left.value));
            case "not in":
              return new BooleanValue(!right.value.includes(left.value));
          }
        }
        if (left instanceof StringValue && right instanceof ObjectValue) {
          switch (node.operator.value) {
            case "in":
              return new BooleanValue(right.value.has(left.value));
            case "not in":
              return new BooleanValue(!right.value.has(left.value));
          }
        }
        throw new SyntaxError(`Unknown operator "${node.operator.value}" between ${left.type} and ${right.type}`);
      }
      evaluateArguments(args, environment) {
        const positionalArguments = [];
        const keywordArguments = /* @__PURE__ */ new Map;
        for (const argument of args) {
          if (argument.type === "SpreadExpression") {
            const spreadNode = argument;
            const val = this.evaluate(spreadNode.argument, environment);
            if (!(val instanceof ArrayValue)) {
              throw new Error(`Cannot unpack non-iterable type: ${val.type}`);
            }
            for (const item of val.value) {
              positionalArguments.push(item);
            }
          } else if (argument.type === "KeywordArgumentExpression") {
            const kwarg = argument;
            keywordArguments.set(kwarg.key.value, this.evaluate(kwarg.value, environment));
          } else {
            if (keywordArguments.size > 0) {
              throw new Error("Positional arguments must come before keyword arguments");
            }
            positionalArguments.push(this.evaluate(argument, environment));
          }
        }
        return [positionalArguments, keywordArguments];
      }
      applyFilter(operand, filterNode, environment) {
        if (filterNode.type === "Identifier") {
          const filter = filterNode;
          if (filter.value === "tojson") {
            return new StringValue(toJSON(operand));
          }
          if (operand instanceof ArrayValue) {
            switch (filter.value) {
              case "list":
                return operand;
              case "first":
                return operand.value[0];
              case "last":
                return operand.value[operand.value.length - 1];
              case "length":
                return new IntegerValue(operand.value.length);
              case "reverse":
                return new ArrayValue(operand.value.slice().reverse());
              case "sort": {
                return new ArrayValue(operand.value.slice().sort((a, b) => compareRuntimeValues(a, b, false)));
              }
              case "join":
                return new StringValue(operand.value.map((x) => x.value).join(""));
              case "string":
                return new StringValue(toJSON(operand, null, 0, false));
              case "unique": {
                const seen = /* @__PURE__ */ new Set;
                const output = [];
                for (const item of operand.value) {
                  if (!seen.has(item.value)) {
                    seen.add(item.value);
                    output.push(item);
                  }
                }
                return new ArrayValue(output);
              }
              default:
                throw new Error(`Unknown ArrayValue filter: ${filter.value}`);
            }
          } else if (operand instanceof StringValue) {
            switch (filter.value) {
              case "length":
              case "upper":
              case "lower":
              case "title":
              case "capitalize": {
                const builtin = operand.builtins.get(filter.value);
                if (builtin instanceof FunctionValue) {
                  return builtin.value([], environment);
                } else if (builtin instanceof IntegerValue) {
                  return builtin;
                } else {
                  throw new Error(`Unknown StringValue filter: ${filter.value}`);
                }
              }
              case "trim":
                return new StringValue(operand.value.trim());
              case "indent":
                return new StringValue(operand.value.split(`
`).map((x, i) => i === 0 || x.length === 0 ? x : "    " + x).join(`
`));
              case "join":
              case "string":
                return operand;
              case "int": {
                const val = parseInt(operand.value, 10);
                return new IntegerValue(isNaN(val) ? 0 : val);
              }
              case "float": {
                const val = parseFloat(operand.value);
                return new FloatValue(isNaN(val) ? 0 : val);
              }
              default:
                throw new Error(`Unknown StringValue filter: ${filter.value}`);
            }
          } else if (operand instanceof IntegerValue || operand instanceof FloatValue) {
            switch (filter.value) {
              case "abs":
                return operand instanceof IntegerValue ? new IntegerValue(Math.abs(operand.value)) : new FloatValue(Math.abs(operand.value));
              case "int":
                return new IntegerValue(Math.floor(operand.value));
              case "float":
                return new FloatValue(operand.value);
              default:
                throw new Error(`Unknown NumericValue filter: ${filter.value}`);
            }
          } else if (operand instanceof ObjectValue) {
            switch (filter.value) {
              case "items":
                return new ArrayValue(Array.from(operand.value.entries()).map(([key, value]) => new ArrayValue([new StringValue(key), value])));
              case "length":
                return new IntegerValue(operand.value.size);
              default: {
                const builtin = operand.builtins.get(filter.value);
                if (builtin) {
                  if (builtin instanceof FunctionValue) {
                    return builtin.value([], environment);
                  }
                  return builtin;
                }
                throw new Error(`Unknown ObjectValue filter: ${filter.value}`);
              }
            }
          } else if (operand instanceof BooleanValue) {
            switch (filter.value) {
              case "bool":
                return new BooleanValue(operand.value);
              case "int":
                return new IntegerValue(operand.value ? 1 : 0);
              case "float":
                return new FloatValue(operand.value ? 1 : 0);
              case "string":
                return new StringValue(operand.value ? "true" : "false");
              default:
                throw new Error(`Unknown BooleanValue filter: ${filter.value}`);
            }
          }
          throw new Error(`Cannot apply filter "${filter.value}" to type: ${operand.type}`);
        } else if (filterNode.type === "CallExpression") {
          const filter = filterNode;
          if (filter.callee.type !== "Identifier") {
            throw new Error(`Unknown filter: ${filter.callee.type}`);
          }
          const filterName = filter.callee.value;
          if (filterName === "tojson") {
            const [, kwargs] = this.evaluateArguments(filter.args, environment);
            const indent = kwargs.get("indent") ?? new NullValue;
            if (!(indent instanceof IntegerValue || indent instanceof NullValue)) {
              throw new Error("If set, indent must be a number");
            }
            return new StringValue(toJSON(operand, indent.value));
          } else if (filterName === "join") {
            let value;
            if (operand instanceof StringValue) {
              value = Array.from(operand.value);
            } else if (operand instanceof ArrayValue) {
              value = operand.value.map((x) => x.value);
            } else {
              throw new Error(`Cannot apply filter "${filterName}" to type: ${operand.type}`);
            }
            const [args, kwargs] = this.evaluateArguments(filter.args, environment);
            const separator = args.at(0) ?? kwargs.get("separator") ?? new StringValue("");
            if (!(separator instanceof StringValue)) {
              throw new Error("separator must be a string");
            }
            return new StringValue(value.join(separator.value));
          } else if (filterName === "int" || filterName === "float") {
            const [args, kwargs] = this.evaluateArguments(filter.args, environment);
            const defaultValue = args.at(0) ?? kwargs.get("default") ?? (filterName === "int" ? new IntegerValue(0) : new FloatValue(0));
            if (operand instanceof StringValue) {
              const val = filterName === "int" ? parseInt(operand.value, 10) : parseFloat(operand.value);
              return isNaN(val) ? defaultValue : filterName === "int" ? new IntegerValue(val) : new FloatValue(val);
            } else if (operand instanceof IntegerValue || operand instanceof FloatValue) {
              return operand;
            } else if (operand instanceof BooleanValue) {
              return filterName === "int" ? new IntegerValue(operand.value ? 1 : 0) : new FloatValue(operand.value ? 1 : 0);
            } else {
              throw new Error(`Cannot apply filter "${filterName}" to type: ${operand.type}`);
            }
          } else if (filterName === "default") {
            const [args, kwargs] = this.evaluateArguments(filter.args, environment);
            const defaultValue = args[0] ?? new StringValue("");
            const booleanValue = args[1] ?? kwargs.get("boolean") ?? new BooleanValue(false);
            if (!(booleanValue instanceof BooleanValue)) {
              throw new Error("`default` filter flag must be a boolean");
            }
            if (operand instanceof UndefinedValue || booleanValue.value && !operand.__bool__().value) {
              return defaultValue;
            }
            return operand;
          }
          if (operand instanceof ArrayValue) {
            switch (filterName) {
              case "sort": {
                const [args, kwargs] = this.evaluateArguments(filter.args, environment);
                const reverse = args.at(0) ?? kwargs.get("reverse") ?? new BooleanValue(false);
                if (!(reverse instanceof BooleanValue)) {
                  throw new Error("reverse must be a boolean");
                }
                const caseSensitive = args.at(1) ?? kwargs.get("case_sensitive") ?? new BooleanValue(false);
                if (!(caseSensitive instanceof BooleanValue)) {
                  throw new Error("case_sensitive must be a boolean");
                }
                const attribute = args.at(2) ?? kwargs.get("attribute") ?? new NullValue;
                if (!(attribute instanceof StringValue || attribute instanceof IntegerValue || attribute instanceof NullValue)) {
                  throw new Error("attribute must be a string, integer, or null");
                }
                const getSortValue = (item) => {
                  if (attribute instanceof NullValue) {
                    return item;
                  }
                  const attrPath = attribute instanceof IntegerValue ? String(attribute.value) : attribute.value;
                  return getAttributeValue(item, attrPath);
                };
                return new ArrayValue(operand.value.slice().sort((a, b) => {
                  const aVal = getSortValue(a);
                  const bVal = getSortValue(b);
                  const result = compareRuntimeValues(aVal, bVal, caseSensitive.value);
                  return reverse.value ? -result : result;
                }));
              }
              case "selectattr":
              case "rejectattr": {
                const select = filterName === "selectattr";
                if (operand.value.some((x) => !(x instanceof ObjectValue))) {
                  throw new Error(`\`${filterName}\` can only be applied to array of objects`);
                }
                if (filter.args.some((x) => x.type !== "StringLiteral")) {
                  throw new Error(`arguments of \`${filterName}\` must be strings`);
                }
                const [attr, testName, value] = filter.args.map((x) => this.evaluate(x, environment));
                let testFunction;
                if (testName) {
                  const test = environment.tests.get(testName.value);
                  if (!test) {
                    throw new Error(`Unknown test: ${testName.value}`);
                  }
                  testFunction = test;
                } else {
                  testFunction = (...x) => x[0].__bool__().value;
                }
                const filtered = operand.value.filter((item) => {
                  const a = item.value.get(attr.value);
                  const result = a ? testFunction(a, value) : false;
                  return select ? result : !result;
                });
                return new ArrayValue(filtered);
              }
              case "map": {
                const [, kwargs] = this.evaluateArguments(filter.args, environment);
                if (kwargs.has("attribute")) {
                  const attr = kwargs.get("attribute");
                  if (!(attr instanceof StringValue)) {
                    throw new Error("attribute must be a string");
                  }
                  const defaultValue = kwargs.get("default");
                  const mapped = operand.value.map((item) => {
                    if (!(item instanceof ObjectValue)) {
                      throw new Error("items in map must be an object");
                    }
                    const value = getAttributeValue(item, attr.value);
                    return value instanceof UndefinedValue ? defaultValue ?? new UndefinedValue : value;
                  });
                  return new ArrayValue(mapped);
                } else {
                  throw new Error("`map` expressions without `attribute` set are not currently supported.");
                }
              }
            }
            throw new Error(`Unknown ArrayValue filter: ${filterName}`);
          } else if (operand instanceof StringValue) {
            switch (filterName) {
              case "indent": {
                const [args, kwargs] = this.evaluateArguments(filter.args, environment);
                const width = args.at(0) ?? kwargs.get("width") ?? new IntegerValue(4);
                if (!(width instanceof IntegerValue)) {
                  throw new Error("width must be a number");
                }
                const first = args.at(1) ?? kwargs.get("first") ?? new BooleanValue(false);
                const blank = args.at(2) ?? kwargs.get("blank") ?? new BooleanValue(false);
                const lines = operand.value.split(`
`);
                const indent = " ".repeat(width.value);
                const indented = lines.map((x, i) => !first.value && i === 0 || !blank.value && x.length === 0 ? x : indent + x);
                return new StringValue(indented.join(`
`));
              }
              case "replace": {
                const replaceFn = operand.builtins.get("replace");
                if (!(replaceFn instanceof FunctionValue)) {
                  throw new Error("replace filter not available");
                }
                const [args, kwargs] = this.evaluateArguments(filter.args, environment);
                return replaceFn.value([...args, new KeywordArgumentsValue(kwargs)], environment);
              }
            }
            throw new Error(`Unknown StringValue filter: ${filterName}`);
          } else if (operand instanceof ObjectValue) {
            const builtin = operand.builtins.get(filterName);
            if (builtin && builtin instanceof FunctionValue) {
              const [args, kwargs] = this.evaluateArguments(filter.args, environment);
              if (kwargs.size > 0) {
                args.push(new KeywordArgumentsValue(kwargs));
              }
              return builtin.value(args, environment);
            }
            throw new Error(`Unknown ObjectValue filter: ${filterName}`);
          } else {
            throw new Error(`Cannot apply filter "${filterName}" to type: ${operand.type}`);
          }
        }
        throw new Error(`Unknown filter: ${filterNode.type}`);
      }
      evaluateFilterExpression(node, environment) {
        const operand = this.evaluate(node.operand, environment);
        return this.applyFilter(operand, node.filter, environment);
      }
      evaluateTestExpression(node, environment) {
        const operand = this.evaluate(node.operand, environment);
        const test = environment.tests.get(node.test.value);
        if (!test) {
          throw new Error(`Unknown test: ${node.test.value}`);
        }
        const result = test(operand);
        return new BooleanValue(node.negate ? !result : result);
      }
      evaluateSelectExpression(node, environment) {
        const predicate = this.evaluate(node.test, environment);
        if (!predicate.__bool__().value) {
          return new UndefinedValue;
        }
        return this.evaluate(node.lhs, environment);
      }
      evaluateUnaryExpression(node, environment) {
        const argument = this.evaluate(node.argument, environment);
        switch (node.operator.value) {
          case "not":
            return new BooleanValue(!argument.value);
          default:
            throw new SyntaxError(`Unknown operator: ${node.operator.value}`);
        }
      }
      evaluateTernaryExpression(node, environment) {
        const cond = this.evaluate(node.condition, environment);
        return cond.__bool__().value ? this.evaluate(node.trueExpr, environment) : this.evaluate(node.falseExpr, environment);
      }
      evalProgram(program, environment) {
        return this.evaluateBlock(program.body, environment);
      }
      evaluateBlock(statements, environment) {
        let result = "";
        for (const statement of statements) {
          const lastEvaluated = this.evaluate(statement, environment);
          if (lastEvaluated.type !== "NullValue" && lastEvaluated.type !== "UndefinedValue") {
            result += lastEvaluated.toString();
          }
        }
        return new StringValue(result);
      }
      evaluateIdentifier(node, environment) {
        return environment.lookupVariable(node.value);
      }
      evaluateCallExpression(expr, environment) {
        const [args, kwargs] = this.evaluateArguments(expr.args, environment);
        if (kwargs.size > 0) {
          args.push(new KeywordArgumentsValue(kwargs));
        }
        const fn = this.evaluate(expr.callee, environment);
        if (fn.type !== "FunctionValue") {
          throw new Error(`Cannot call something that is not a function: got ${fn.type}`);
        }
        return fn.value(args, environment);
      }
      evaluateSliceExpression(object5, expr, environment) {
        if (!(object5 instanceof ArrayValue || object5 instanceof StringValue)) {
          throw new Error("Slice object must be an array or string");
        }
        const start = this.evaluate(expr.start, environment);
        const stop = this.evaluate(expr.stop, environment);
        const step = this.evaluate(expr.step, environment);
        if (!(start instanceof IntegerValue || start instanceof UndefinedValue)) {
          throw new Error("Slice start must be numeric or undefined");
        }
        if (!(stop instanceof IntegerValue || stop instanceof UndefinedValue)) {
          throw new Error("Slice stop must be numeric or undefined");
        }
        if (!(step instanceof IntegerValue || step instanceof UndefinedValue)) {
          throw new Error("Slice step must be numeric or undefined");
        }
        if (object5 instanceof ArrayValue) {
          return new ArrayValue(slice2(object5.value, start.value, stop.value, step.value));
        } else {
          return new StringValue(slice2(Array.from(object5.value), start.value, stop.value, step.value).join(""));
        }
      }
      evaluateMemberExpression(expr, environment) {
        const object5 = this.evaluate(expr.object, environment);
        let property;
        if (expr.computed) {
          if (expr.property.type === "SliceExpression") {
            return this.evaluateSliceExpression(object5, expr.property, environment);
          } else {
            property = this.evaluate(expr.property, environment);
          }
        } else {
          property = new StringValue(expr.property.value);
        }
        let value;
        if (object5 instanceof ObjectValue) {
          if (!(property instanceof StringValue)) {
            throw new Error(`Cannot access property with non-string: got ${property.type}`);
          }
          value = object5.value.get(property.value) ?? object5.builtins.get(property.value);
        } else if (object5 instanceof ArrayValue || object5 instanceof StringValue) {
          if (property instanceof IntegerValue) {
            value = object5.value.at(property.value);
            if (object5 instanceof StringValue) {
              value = new StringValue(object5.value.at(property.value));
            }
          } else if (property instanceof StringValue) {
            value = object5.builtins.get(property.value);
          } else {
            throw new Error(`Cannot access property with non-string/non-number: got ${property.type}`);
          }
        } else {
          if (!(property instanceof StringValue)) {
            throw new Error(`Cannot access property with non-string: got ${property.type}`);
          }
          value = object5.builtins.get(property.value);
        }
        return value instanceof RuntimeValue ? value : new UndefinedValue;
      }
      evaluateSet(node, environment) {
        const rhs = node.value ? this.evaluate(node.value, environment) : this.evaluateBlock(node.body, environment);
        if (node.assignee.type === "Identifier") {
          const variableName = node.assignee.value;
          environment.setVariable(variableName, rhs);
        } else if (node.assignee.type === "TupleLiteral") {
          const tuple3 = node.assignee;
          if (!(rhs instanceof ArrayValue)) {
            throw new Error(`Cannot unpack non-iterable type in set: ${rhs.type}`);
          }
          const arr = rhs.value;
          if (arr.length !== tuple3.value.length) {
            throw new Error(`Too ${tuple3.value.length > arr.length ? "few" : "many"} items to unpack in set`);
          }
          for (let i = 0;i < tuple3.value.length; ++i) {
            const elem = tuple3.value[i];
            if (elem.type !== "Identifier") {
              throw new Error(`Cannot unpack to non-identifier in set: ${elem.type}`);
            }
            environment.setVariable(elem.value, arr[i]);
          }
        } else if (node.assignee.type === "MemberExpression") {
          const member = node.assignee;
          const object5 = this.evaluate(member.object, environment);
          if (!(object5 instanceof ObjectValue)) {
            throw new Error("Cannot assign to member of non-object");
          }
          if (member.property.type !== "Identifier") {
            throw new Error("Cannot assign to member with non-identifier property");
          }
          object5.value.set(member.property.value, rhs);
        } else {
          throw new Error(`Invalid LHS inside assignment expression: ${JSON.stringify(node.assignee)}`);
        }
        return new NullValue;
      }
      evaluateIf(node, environment) {
        const test = this.evaluate(node.test, environment);
        return this.evaluateBlock(test.__bool__().value ? node.body : node.alternate, environment);
      }
      evaluateFor(node, environment) {
        const scope = new Environment(environment);
        let test, iterable;
        if (node.iterable.type === "SelectExpression") {
          const select = node.iterable;
          iterable = this.evaluate(select.lhs, scope);
          test = select.test;
        } else {
          iterable = this.evaluate(node.iterable, scope);
        }
        if (!(iterable instanceof ArrayValue || iterable instanceof ObjectValue)) {
          throw new Error(`Expected iterable or object type in for loop: got ${iterable.type}`);
        }
        if (iterable instanceof ObjectValue) {
          iterable = iterable.keys();
        }
        const items = [];
        const scopeUpdateFunctions = [];
        for (let i = 0;i < iterable.value.length; ++i) {
          const loopScope = new Environment(scope);
          const current = iterable.value[i];
          let scopeUpdateFunction;
          if (node.loopvar.type === "Identifier") {
            scopeUpdateFunction = (scope2) => scope2.setVariable(node.loopvar.value, current);
          } else if (node.loopvar.type === "TupleLiteral") {
            const loopvar = node.loopvar;
            if (current.type !== "ArrayValue") {
              throw new Error(`Cannot unpack non-iterable type: ${current.type}`);
            }
            const c = current;
            if (loopvar.value.length !== c.value.length) {
              throw new Error(`Too ${loopvar.value.length > c.value.length ? "few" : "many"} items to unpack`);
            }
            scopeUpdateFunction = (scope2) => {
              for (let j = 0;j < loopvar.value.length; ++j) {
                if (loopvar.value[j].type !== "Identifier") {
                  throw new Error(`Cannot unpack non-identifier type: ${loopvar.value[j].type}`);
                }
                scope2.setVariable(loopvar.value[j].value, c.value[j]);
              }
            };
          } else {
            throw new Error(`Invalid loop variable(s): ${node.loopvar.type}`);
          }
          if (test) {
            scopeUpdateFunction(loopScope);
            const testValue = this.evaluate(test, loopScope);
            if (!testValue.__bool__().value) {
              continue;
            }
          }
          items.push(current);
          scopeUpdateFunctions.push(scopeUpdateFunction);
        }
        let result = "";
        let noIteration = true;
        for (let i = 0;i < items.length; ++i) {
          const loop = /* @__PURE__ */ new Map([
            ["index", new IntegerValue(i + 1)],
            ["index0", new IntegerValue(i)],
            ["revindex", new IntegerValue(items.length - i)],
            ["revindex0", new IntegerValue(items.length - i - 1)],
            ["first", new BooleanValue(i === 0)],
            ["last", new BooleanValue(i === items.length - 1)],
            ["length", new IntegerValue(items.length)],
            ["previtem", i > 0 ? items[i - 1] : new UndefinedValue],
            ["nextitem", i < items.length - 1 ? items[i + 1] : new UndefinedValue]
          ]);
          scope.setVariable("loop", new ObjectValue(loop));
          scopeUpdateFunctions[i](scope);
          try {
            const evaluated = this.evaluateBlock(node.body, scope);
            result += evaluated.value;
          } catch (err) {
            if (err instanceof ContinueControl) {
              continue;
            }
            if (err instanceof BreakControl) {
              break;
            }
            throw err;
          }
          noIteration = false;
        }
        if (noIteration) {
          const defaultEvaluated = this.evaluateBlock(node.defaultBlock, scope);
          result += defaultEvaluated.value;
        }
        return new StringValue(result);
      }
      evaluateMacro(node, environment) {
        environment.setVariable(node.name.value, new FunctionValue((args, scope) => {
          const macroScope = new Environment(scope);
          args = args.slice();
          let kwargs;
          if (args.at(-1)?.type === "KeywordArgumentsValue") {
            kwargs = args.pop();
          }
          for (let i = 0;i < node.args.length; ++i) {
            const nodeArg = node.args[i];
            const passedArg = args[i];
            if (nodeArg.type === "Identifier") {
              const identifier = nodeArg;
              if (!passedArg) {
                throw new Error(`Missing positional argument: ${identifier.value}`);
              }
              macroScope.setVariable(identifier.value, passedArg);
            } else if (nodeArg.type === "KeywordArgumentExpression") {
              const kwarg = nodeArg;
              const value = passedArg ?? kwargs?.value.get(kwarg.key.value) ?? this.evaluate(kwarg.value, macroScope);
              macroScope.setVariable(kwarg.key.value, value);
            } else {
              throw new Error(`Unknown argument type: ${nodeArg.type}`);
            }
          }
          return this.evaluateBlock(node.body, macroScope);
        }));
        return new NullValue;
      }
      evaluateCallStatement(node, environment) {
        const callerFn = new FunctionValue((callerArgs, callerEnv) => {
          const callBlockEnv = new Environment(callerEnv);
          if (node.callerArgs) {
            for (let i = 0;i < node.callerArgs.length; ++i) {
              const param = node.callerArgs[i];
              if (param.type !== "Identifier") {
                throw new Error(`Caller parameter must be an identifier, got ${param.type}`);
              }
              callBlockEnv.setVariable(param.value, callerArgs[i] ?? new UndefinedValue);
            }
          }
          return this.evaluateBlock(node.body, callBlockEnv);
        });
        const [macroArgs, macroKwargs] = this.evaluateArguments(node.call.args, environment);
        macroArgs.push(new KeywordArgumentsValue(macroKwargs));
        const fn = this.evaluate(node.call.callee, environment);
        if (fn.type !== "FunctionValue") {
          throw new Error(`Cannot call something that is not a function: got ${fn.type}`);
        }
        const newEnv = new Environment(environment);
        newEnv.setVariable("caller", callerFn);
        return fn.value(macroArgs, newEnv);
      }
      evaluateFilterStatement(node, environment) {
        const rendered = this.evaluateBlock(node.body, environment);
        return this.applyFilter(rendered, node.filter, environment);
      }
      evaluate(statement, environment) {
        if (!statement)
          return new UndefinedValue;
        switch (statement.type) {
          case "Program":
            return this.evalProgram(statement, environment);
          case "Set":
            return this.evaluateSet(statement, environment);
          case "If":
            return this.evaluateIf(statement, environment);
          case "For":
            return this.evaluateFor(statement, environment);
          case "Macro":
            return this.evaluateMacro(statement, environment);
          case "CallStatement":
            return this.evaluateCallStatement(statement, environment);
          case "Break":
            throw new BreakControl;
          case "Continue":
            throw new ContinueControl;
          case "IntegerLiteral":
            return new IntegerValue(statement.value);
          case "FloatLiteral":
            return new FloatValue(statement.value);
          case "StringLiteral":
            return new StringValue(statement.value);
          case "ArrayLiteral":
            return new ArrayValue(statement.value.map((x) => this.evaluate(x, environment)));
          case "TupleLiteral":
            return new TupleValue(statement.value.map((x) => this.evaluate(x, environment)));
          case "ObjectLiteral": {
            const mapping = /* @__PURE__ */ new Map;
            for (const [key, value] of statement.value) {
              const evaluatedKey = this.evaluate(key, environment);
              if (!(evaluatedKey instanceof StringValue)) {
                throw new Error(`Object keys must be strings: got ${evaluatedKey.type}`);
              }
              mapping.set(evaluatedKey.value, this.evaluate(value, environment));
            }
            return new ObjectValue(mapping);
          }
          case "Identifier":
            return this.evaluateIdentifier(statement, environment);
          case "CallExpression":
            return this.evaluateCallExpression(statement, environment);
          case "MemberExpression":
            return this.evaluateMemberExpression(statement, environment);
          case "UnaryExpression":
            return this.evaluateUnaryExpression(statement, environment);
          case "BinaryExpression":
            return this.evaluateBinaryExpression(statement, environment);
          case "FilterExpression":
            return this.evaluateFilterExpression(statement, environment);
          case "FilterStatement":
            return this.evaluateFilterStatement(statement, environment);
          case "TestExpression":
            return this.evaluateTestExpression(statement, environment);
          case "SelectExpression":
            return this.evaluateSelectExpression(statement, environment);
          case "Ternary":
            return this.evaluateTernaryExpression(statement, environment);
          case "Comment":
            return new NullValue;
          default:
            throw new SyntaxError(`Unknown node type: ${statement.type}`);
        }
      }
    };
    function convertToRuntimeValues(input) {
      switch (typeof input) {
        case "number":
          return Number.isInteger(input) ? new IntegerValue(input) : new FloatValue(input);
        case "string":
          return new StringValue(input);
        case "boolean":
          return new BooleanValue(input);
        case "undefined":
          return new UndefinedValue;
        case "object":
          if (input === null) {
            return new NullValue;
          } else if (Array.isArray(input)) {
            return new ArrayValue(input.map(convertToRuntimeValues));
          } else {
            return new ObjectValue(new Map(Object.entries(input).map(([key, value]) => [key, convertToRuntimeValues(value)])));
          }
        case "function":
          return new FunctionValue((args, _scope) => {
            const result = input(...args.map((x) => x.value)) ?? null;
            return convertToRuntimeValues(result);
          });
        default:
          throw new Error(`Cannot convert to runtime value: ${input}`);
      }
    }
    var NEWLINE = `
`;
    var OPEN_STATEMENT = "{%- ";
    var CLOSE_STATEMENT = " -%}";
    function getBinaryOperatorPrecedence(expr) {
      switch (expr.operator.type) {
        case "MultiplicativeBinaryOperator":
          return 4;
        case "AdditiveBinaryOperator":
          return 3;
        case "ComparisonBinaryOperator":
          return 2;
        case "Identifier":
          if (expr.operator.value === "and")
            return 1;
          if (expr.operator.value === "in" || expr.operator.value === "not in")
            return 2;
          return 0;
      }
      return 0;
    }
    function format(program, indent = "\t") {
      const indentStr = typeof indent === "number" ? " ".repeat(indent) : indent;
      const body = formatStatements(program.body, 0, indentStr);
      return body.replace(/\n$/, "");
    }
    function createStatement(...text) {
      return OPEN_STATEMENT + text.join(" ") + CLOSE_STATEMENT;
    }
    function formatStatements(stmts, depth, indentStr) {
      return stmts.map((stmt) => formatStatement(stmt, depth, indentStr)).join(NEWLINE);
    }
    function formatStatement(node, depth, indentStr) {
      const pad = indentStr.repeat(depth);
      switch (node.type) {
        case "Program":
          return formatStatements(node.body, depth, indentStr);
        case "If":
          return formatIf(node, depth, indentStr);
        case "For":
          return formatFor(node, depth, indentStr);
        case "Set":
          return formatSet(node, depth, indentStr);
        case "Macro":
          return formatMacro(node, depth, indentStr);
        case "Break":
          return pad + createStatement("break");
        case "Continue":
          return pad + createStatement("continue");
        case "CallStatement":
          return formatCallStatement(node, depth, indentStr);
        case "FilterStatement":
          return formatFilterStatement(node, depth, indentStr);
        case "Comment":
          return pad + "{# " + node.value + " #}";
        default:
          return pad + "{{- " + formatExpression(node) + " -}}";
      }
    }
    function formatIf(node, depth, indentStr) {
      const pad = indentStr.repeat(depth);
      const clauses = [];
      let current = node;
      while (current) {
        clauses.push({ test: current.test, body: current.body });
        if (current.alternate.length === 1 && current.alternate[0].type === "If") {
          current = current.alternate[0];
        } else {
          break;
        }
      }
      let out = pad + createStatement("if", formatExpression(clauses[0].test)) + NEWLINE + formatStatements(clauses[0].body, depth + 1, indentStr);
      for (let i = 1;i < clauses.length; ++i) {
        out += NEWLINE + pad + createStatement("elif", formatExpression(clauses[i].test)) + NEWLINE + formatStatements(clauses[i].body, depth + 1, indentStr);
      }
      if (current && current.alternate.length > 0) {
        out += NEWLINE + pad + createStatement("else") + NEWLINE + formatStatements(current.alternate, depth + 1, indentStr);
      }
      out += NEWLINE + pad + createStatement("endif");
      return out;
    }
    function formatFor(node, depth, indentStr) {
      const pad = indentStr.repeat(depth);
      let formattedIterable = "";
      if (node.iterable.type === "SelectExpression") {
        const n = node.iterable;
        formattedIterable = `${formatExpression(n.lhs)} if ${formatExpression(n.test)}`;
      } else {
        formattedIterable = formatExpression(node.iterable);
      }
      let out = pad + createStatement("for", formatExpression(node.loopvar), "in", formattedIterable) + NEWLINE + formatStatements(node.body, depth + 1, indentStr);
      if (node.defaultBlock.length > 0) {
        out += NEWLINE + pad + createStatement("else") + NEWLINE + formatStatements(node.defaultBlock, depth + 1, indentStr);
      }
      out += NEWLINE + pad + createStatement("endfor");
      return out;
    }
    function formatSet(node, depth, indentStr) {
      const pad = indentStr.repeat(depth);
      const left = formatExpression(node.assignee);
      const right = node.value ? formatExpression(node.value) : "";
      const value = pad + createStatement("set", `${left}${node.value ? " = " + right : ""}`);
      if (node.body.length === 0) {
        return value;
      }
      return value + NEWLINE + formatStatements(node.body, depth + 1, indentStr) + NEWLINE + pad + createStatement("endset");
    }
    function formatMacro(node, depth, indentStr) {
      const pad = indentStr.repeat(depth);
      const args = node.args.map(formatExpression).join(", ");
      return pad + createStatement("macro", `${node.name.value}(${args})`) + NEWLINE + formatStatements(node.body, depth + 1, indentStr) + NEWLINE + pad + createStatement("endmacro");
    }
    function formatCallStatement(node, depth, indentStr) {
      const pad = indentStr.repeat(depth);
      const params = node.callerArgs && node.callerArgs.length > 0 ? `(${node.callerArgs.map(formatExpression).join(", ")})` : "";
      const callExpr = formatExpression(node.call);
      let out = pad + createStatement(`call${params}`, callExpr) + NEWLINE;
      out += formatStatements(node.body, depth + 1, indentStr) + NEWLINE;
      out += pad + createStatement("endcall");
      return out;
    }
    function formatFilterStatement(node, depth, indentStr) {
      const pad = indentStr.repeat(depth);
      const spec = node.filter.type === "Identifier" ? node.filter.value : formatExpression(node.filter);
      let out = pad + createStatement("filter", spec) + NEWLINE;
      out += formatStatements(node.body, depth + 1, indentStr) + NEWLINE;
      out += pad + createStatement("endfilter");
      return out;
    }
    function formatExpression(node, parentPrec = -1) {
      switch (node.type) {
        case "SpreadExpression": {
          const n = node;
          return `*${formatExpression(n.argument)}`;
        }
        case "Identifier":
          return node.value;
        case "IntegerLiteral":
          return `${node.value}`;
        case "FloatLiteral":
          return `${node.value}`;
        case "StringLiteral":
          return JSON.stringify(node.value);
        case "BinaryExpression": {
          const n = node;
          const thisPrecedence = getBinaryOperatorPrecedence(n);
          const left = formatExpression(n.left, thisPrecedence);
          const right = formatExpression(n.right, thisPrecedence + 1);
          const expr = `${left} ${n.operator.value} ${right}`;
          return thisPrecedence < parentPrec ? `(${expr})` : expr;
        }
        case "UnaryExpression": {
          const n = node;
          const val = n.operator.value + (n.operator.value === "not" ? " " : "") + formatExpression(n.argument, Infinity);
          return val;
        }
        case "CallExpression": {
          const n = node;
          const args = n.args.map(formatExpression).join(", ");
          return `${formatExpression(n.callee)}(${args})`;
        }
        case "MemberExpression": {
          const n = node;
          let obj = formatExpression(n.object);
          if (![
            "Identifier",
            "MemberExpression",
            "CallExpression",
            "StringLiteral",
            "IntegerLiteral",
            "FloatLiteral",
            "ArrayLiteral",
            "TupleLiteral",
            "ObjectLiteral"
          ].includes(n.object.type)) {
            obj = `(${obj})`;
          }
          let prop = formatExpression(n.property);
          if (!n.computed && n.property.type !== "Identifier") {
            prop = `(${prop})`;
          }
          return n.computed ? `${obj}[${prop}]` : `${obj}.${prop}`;
        }
        case "FilterExpression": {
          const n = node;
          const operand = formatExpression(n.operand, Infinity);
          if (n.filter.type === "CallExpression") {
            return `${operand} | ${formatExpression(n.filter)}`;
          }
          return `${operand} | ${n.filter.value}`;
        }
        case "SelectExpression": {
          const n = node;
          return `${formatExpression(n.lhs)} if ${formatExpression(n.test)}`;
        }
        case "TestExpression": {
          const n = node;
          return `${formatExpression(n.operand)} is${n.negate ? " not" : ""} ${n.test.value}`;
        }
        case "ArrayLiteral":
        case "TupleLiteral": {
          const elems = node.value.map(formatExpression);
          const brackets = node.type === "ArrayLiteral" ? "[]" : "()";
          return `${brackets[0]}${elems.join(", ")}${brackets[1]}`;
        }
        case "ObjectLiteral": {
          const entries = Array.from(node.value.entries()).map(([k, v]) => `${formatExpression(k)}: ${formatExpression(v)}`);
          return `{${entries.join(", ")}}`;
        }
        case "SliceExpression": {
          const n = node;
          const s = n.start ? formatExpression(n.start) : "";
          const t = n.stop ? formatExpression(n.stop) : "";
          const st = n.step ? `:${formatExpression(n.step)}` : "";
          return `${s}:${t}${st}`;
        }
        case "KeywordArgumentExpression": {
          const n = node;
          return `${n.key.value}=${formatExpression(n.value)}`;
        }
        case "Ternary": {
          const n = node;
          const expr = `${formatExpression(n.trueExpr)} if ${formatExpression(n.condition, 0)} else ${formatExpression(n.falseExpr)}`;
          return parentPrec > -1 ? `(${expr})` : expr;
        }
        default:
          throw new Error(`Unknown expression type: ${node.type}`);
      }
    }
    var Template = class {
      parsed;
      constructor(template) {
        const tokens = tokenize(template, {
          lstrip_blocks: true,
          trim_blocks: true
        });
        this.parsed = parse11(tokens);
      }
      render(items) {
        const env4 = new Environment;
        setupGlobals(env4);
        if (items) {
          for (const [key, value] of Object.entries(items)) {
            env4.set(key, value);
          }
        }
        const interpreter = new Interpreter(env4);
        const result = interpreter.run(this.parsed);
        return result.value;
      }
      format(options2) {
        return format(this.parsed, options2?.indent || "\t");
      }
    };
  },
  "./src/backends/onnx.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!******************************!*\
      !*** ./src/backends/onnx.js ***!
      \******************************/
    var onnxruntime_web__WEBPACK_IMPORTED_MODULE_2___namespace_cache;
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      Tensor: () => onnxruntime_common__WEBPACK_IMPORTED_MODULE_3__.Tensor,
      createInferenceSession: () => createInferenceSession,
      deviceToExecutionProviders: () => deviceToExecutionProviders,
      isONNXProxy: () => isONNXProxy,
      isONNXTensor: () => isONNXTensor,
      runInferenceSession: () => runInferenceSession
    });
    var _env_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/env.js");
    /*! ../env.js */
    var onnxruntime_node__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("onnxruntime-node");
    /*! onnxruntime-node */
    var onnxruntime_web__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("?8b6b");
    /*! onnxruntime-web */
    var onnxruntime_common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("onnxruntime-common");
    /*! onnxruntime-common */
    const DEVICE_TO_EXECUTION_PROVIDER_MAPPING = Object.freeze({
      auto: null,
      gpu: null,
      cpu: "cpu",
      wasm: "wasm",
      webgpu: "webgpu",
      cuda: "cuda",
      dml: "dml",
      webnn: { name: "webnn", deviceType: "cpu" },
      "webnn-npu": { name: "webnn", deviceType: "npu" },
      "webnn-gpu": { name: "webnn", deviceType: "gpu" },
      "webnn-cpu": { name: "webnn", deviceType: "cpu" }
    });
    const supportedDevices = [];
    let defaultDevices;
    let ONNX;
    const ORT_SYMBOL = Symbol.for("onnxruntime");
    if (ORT_SYMBOL in globalThis) {
      ONNX = globalThis[ORT_SYMBOL];
    } else if (_env_js__WEBPACK_IMPORTED_MODULE_0__.apis.IS_NODE_ENV) {
      ONNX = onnxruntime_node__WEBPACK_IMPORTED_MODULE_1__["default"] ?? onnxruntime_node__WEBPACK_IMPORTED_MODULE_1__;
      switch (process.platform) {
        case "win32":
          supportedDevices.push("dml");
          break;
        case "linux":
          if (process.arch === "x64") {
            supportedDevices.push("cuda");
          }
          break;
        case "darwin":
          break;
      }
      supportedDevices.push("cpu");
      defaultDevices = ["cpu"];
    } else {
      ONNX = onnxruntime_web__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (onnxruntime_web__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(onnxruntime_web__WEBPACK_IMPORTED_MODULE_2__, 2));
      if (_env_js__WEBPACK_IMPORTED_MODULE_0__.apis.IS_WEBNN_AVAILABLE) {
        supportedDevices.push("webnn-npu", "webnn-gpu", "webnn-cpu", "webnn");
      }
      if (_env_js__WEBPACK_IMPORTED_MODULE_0__.apis.IS_WEBGPU_AVAILABLE) {
        supportedDevices.push("webgpu");
      }
      supportedDevices.push("wasm");
      defaultDevices = ["wasm"];
    }
    const InferenceSession4 = ONNX.InferenceSession;
    function deviceToExecutionProviders(device = null) {
      if (!device)
        return defaultDevices;
      switch (device) {
        case "auto":
          return supportedDevices;
        case "gpu":
          return supportedDevices.filter((x) => ["webgpu", "cuda", "dml", "webnn-gpu"].includes(x));
      }
      if (supportedDevices.includes(device)) {
        return [DEVICE_TO_EXECUTION_PROVIDER_MAPPING[device] ?? device];
      }
      throw new Error(`Unsupported device: "${device}". Should be one of: ${supportedDevices.join(", ")}.`);
    }
    let wasmInitPromise = null;
    async function createInferenceSession(buffer_or_path, session_options, session_config) {
      if (wasmInitPromise) {
        await wasmInitPromise;
      }
      const sessionPromise = InferenceSession4.create(buffer_or_path, session_options);
      wasmInitPromise ??= sessionPromise;
      const session = await sessionPromise;
      session.config = session_config;
      return session;
    }
    let webInferenceChain = Promise.resolve();
    const IS_WEB_ENV = _env_js__WEBPACK_IMPORTED_MODULE_0__.apis.IS_BROWSER_ENV || _env_js__WEBPACK_IMPORTED_MODULE_0__.apis.IS_WEBWORKER_ENV;
    async function runInferenceSession(session, ortFeed) {
      const run = () => session.run(ortFeed);
      const output = await (IS_WEB_ENV ? webInferenceChain = webInferenceChain.then(run) : run());
      return output;
    }
    function isONNXTensor(x) {
      return x instanceof ONNX.Tensor;
    }
    const ONNX_ENV = ONNX?.env;
    if (ONNX_ENV?.wasm) {
      if (!(typeof ServiceWorkerGlobalScope !== "undefined" && self instanceof ServiceWorkerGlobalScope) && !ONNX_ENV.wasm.wasmPaths) {
        ONNX_ENV.wasm.wasmPaths = `https://cdn.jsdelivr.net/npm/@huggingface/transformers@${_env_js__WEBPACK_IMPORTED_MODULE_0__.env.version}/dist/`;
      }
      ONNX_ENV.wasm.proxy = false;
    }
    if (ONNX_ENV?.webgpu) {
      ONNX_ENV.webgpu.powerPreference = "high-performance";
    }
    function isONNXProxy() {
      return ONNX_ENV?.wasm?.proxy;
    }
    _env_js__WEBPACK_IMPORTED_MODULE_0__.env.backends.onnx = ONNX_ENV;
  },
  "./src/base/feature_extraction_utils.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!**********************************************!*\
      !*** ./src/base/feature_extraction_utils.js ***!
      \**********************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      FeatureExtractor: () => FeatureExtractor,
      validate_audio_inputs: () => validate_audio_inputs
    });
    var _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/utils/constants.js");
    /*! ../utils/constants.js */
    var _utils_generic_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/utils/generic.js");
    /*! ../utils/generic.js */
    var _utils_hub_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/utils/hub.js");
    /*! ../utils/hub.js */

    class FeatureExtractor extends _utils_generic_js__WEBPACK_IMPORTED_MODULE_1__.Callable {
      constructor(config3) {
        super();
        this.config = config3;
      }
      static async from_pretrained(pretrained_model_name_or_path, options2 = {}) {
        const config3 = await (0, _utils_hub_js__WEBPACK_IMPORTED_MODULE_2__.getModelJSON)(pretrained_model_name_or_path, _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.FEATURE_EXTRACTOR_NAME, true, options2);
        return new this(config3);
      }
    }
    function validate_audio_inputs(audio, feature_extractor) {
      if (!(audio instanceof Float32Array || audio instanceof Float64Array)) {
        throw new Error(`${feature_extractor} expects input to be a Float32Array or a Float64Array, but got ${audio?.constructor?.name ?? typeof audio} instead. ` + `If using the feature extractor directly, remember to use \`read_audio(url, sampling_rate)\` to obtain the raw audio data of the file/url.`);
      }
    }
  },
  "./src/base/image_processors_utils.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!********************************************!*\
      !*** ./src/base/image_processors_utils.js ***!
      \********************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      ImageProcessor: () => ImageProcessor,
      center_to_corners_format: () => center_to_corners_format,
      post_process_instance_segmentation: () => post_process_instance_segmentation,
      post_process_object_detection: () => post_process_object_detection,
      post_process_panoptic_segmentation: () => post_process_panoptic_segmentation,
      post_process_semantic_segmentation: () => post_process_semantic_segmentation
    });
    var _utils_generic_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/utils/generic.js");
    /*! ../utils/generic.js */
    var _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/utils/tensor.js");
    /*! ../utils/tensor.js */
    var _utils_maths_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/utils/maths.js");
    /*! ../utils/maths.js */
    var _utils_image_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/utils/image.js");
    /*! ../utils/image.js */
    var _utils_core_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./src/utils/core.js");
    /*! ../utils/core.js */
    var _utils_hub_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./src/utils/hub.js");
    /*! ../utils/hub.js */
    var _utils_constants_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./src/utils/constants.js");
    /*! ../utils/constants.js */
    function constraint_to_multiple_of(val, multiple, minVal = 0, maxVal = null) {
      const a = val / multiple;
      let x = (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.bankers_round)(a) * multiple;
      if (maxVal !== null && x > maxVal) {
        x = Math.floor(a) * multiple;
      }
      if (x < minVal) {
        x = Math.ceil(a) * multiple;
      }
      return x;
    }
    function enforce_size_divisibility([width, height], divisor) {
      return [
        Math.max(Math.floor(width / divisor), 1) * divisor,
        Math.max(Math.floor(height / divisor), 1) * divisor
      ];
    }
    function center_to_corners_format([centerX, centerY, width, height]) {
      return [
        centerX - width / 2,
        centerY - height / 2,
        centerX + width / 2,
        centerY + height / 2
      ];
    }
    function post_process_object_detection(outputs, threshold = 0.5, target_sizes = null, is_zero_shot = false) {
      const out_logits = outputs.logits;
      const out_bbox = outputs.pred_boxes;
      const [batch_size, num_boxes, num_classes] = out_logits.dims;
      if (target_sizes !== null && target_sizes.length !== batch_size) {
        throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");
      }
      let toReturn = [];
      for (let i = 0;i < batch_size; ++i) {
        let target_size = target_sizes !== null ? target_sizes[i] : null;
        let info = {
          boxes: [],
          classes: [],
          scores: []
        };
        let logits = out_logits[i];
        let bbox = out_bbox[i];
        for (let j = 0;j < num_boxes; ++j) {
          let logit = logits[j];
          let indices = [];
          let probs;
          if (is_zero_shot) {
            probs = logit.sigmoid().data;
            for (let k = 0;k < probs.length; ++k) {
              if (probs[k] > threshold) {
                indices.push(k);
              }
            }
          } else {
            let maxIndex = (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.max)(logit.data)[1];
            if (maxIndex === num_classes - 1) {
              continue;
            }
            probs = (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.softmax)(logit.data);
            if (probs[maxIndex] < threshold) {
              continue;
            }
            indices.push(maxIndex);
          }
          for (const index of indices) {
            let box = bbox[j].data;
            box = center_to_corners_format(box);
            if (target_size !== null) {
              box = box.map((x, i2) => x * target_size[(i2 + 1) % 2]);
            }
            info.boxes.push(box);
            info.classes.push(index);
            info.scores.push(probs[index]);
          }
        }
        toReturn.push(info);
      }
      return toReturn;
    }
    function post_process_semantic_segmentation(outputs, target_sizes = null) {
      const logits = outputs.logits;
      const batch_size = logits.dims[0];
      if (target_sizes !== null && target_sizes.length !== batch_size) {
        throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");
      }
      const toReturn = [];
      for (let i = 0;i < batch_size; ++i) {
        const target_size = target_sizes !== null ? target_sizes[i] : null;
        let data = logits[i];
        if (target_size !== null) {
          data = (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__.interpolate)(data, target_size, "bilinear", false);
        }
        const [height, width] = target_size ?? data.dims.slice(-2);
        const segmentation = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__.Tensor("int32", new Int32Array(height * width), [height, width]);
        const buffer = data[0].data;
        const segmentation_data = segmentation.data;
        for (let j = 1;j < data.dims[0]; ++j) {
          const row = data[j].data;
          for (let k = 0;k < row.length; ++k) {
            if (row[k] > buffer[k]) {
              buffer[k] = row[k];
              segmentation_data[k] = j;
            }
          }
        }
        const hasLabel = new Array(data.dims[0]);
        for (let j = 0;j < segmentation_data.length; ++j) {
          const index = segmentation_data[j];
          hasLabel[index] = index;
        }
        const labels = hasLabel.filter((x) => x !== undefined);
        toReturn.push({ segmentation, labels });
      }
      return toReturn;
    }
    function remove_low_and_no_objects(class_logits, mask_logits, object_mask_threshold, num_labels) {
      const mask_probs_item = [];
      const pred_scores_item = [];
      const pred_labels_item = [];
      for (let j = 0;j < class_logits.dims[0]; ++j) {
        const cls = class_logits[j];
        const mask = mask_logits[j];
        const pred_label = (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.max)(cls.data)[1];
        if (pred_label === num_labels) {
          continue;
        }
        const scores = (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.softmax)(cls.data);
        const pred_score = scores[pred_label];
        if (pred_score > object_mask_threshold) {
          mask_probs_item.push(mask);
          pred_scores_item.push(pred_score);
          pred_labels_item.push(pred_label);
        }
      }
      return [mask_probs_item, pred_scores_item, pred_labels_item];
    }
    function check_segment_validity(mask_labels, mask_probs, k, mask_threshold = 0.5, overlap_mask_area_threshold = 0.8) {
      const mask_k = [];
      let mask_k_area = 0;
      let original_area = 0;
      const mask_probs_k_data = mask_probs[k].data;
      for (let i = 0;i < mask_labels.length; ++i) {
        if (mask_labels[i] === k) {
          mask_k.push(i);
          ++mask_k_area;
        }
        if (mask_probs_k_data[i] >= mask_threshold) {
          ++original_area;
        }
      }
      let mask_exists = mask_k_area > 0 && original_area > 0;
      if (mask_exists) {
        let area_ratio = mask_k_area / original_area;
        mask_exists = area_ratio > overlap_mask_area_threshold;
      }
      return [mask_exists, mask_k];
    }
    function compute_segments(mask_probs, pred_scores, pred_labels, mask_threshold, overlap_mask_area_threshold, label_ids_to_fuse = null, target_size = null) {
      const [height, width] = target_size ?? mask_probs[0].dims;
      const segmentation = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__.Tensor("int32", new Int32Array(height * width), [height, width]);
      const segments = [];
      if (target_size !== null) {
        for (let i = 0;i < mask_probs.length; ++i) {
          mask_probs[i] = (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__.interpolate)(mask_probs[i], target_size, "bilinear", false);
        }
      }
      const mask_labels = new Int32Array(mask_probs[0].data.length);
      const bestScores = new Float32Array(mask_probs[0].data.length);
      for (let i = 0;i < mask_probs.length; ++i) {
        let score = pred_scores[i];
        const mask_probs_i_data = mask_probs[i].data;
        for (let j = 0;j < mask_probs_i_data.length; ++j) {
          mask_probs_i_data[j] *= score;
          if (mask_probs_i_data[j] > bestScores[j]) {
            mask_labels[j] = i;
            bestScores[j] = mask_probs_i_data[j];
          }
        }
      }
      let current_segment_id = 0;
      const segmentation_data = segmentation.data;
      for (let k = 0;k < pred_labels.length; ++k) {
        const pred_class = pred_labels[k];
        const [mask_exists, mask_k] = check_segment_validity(mask_labels, mask_probs, k, mask_threshold, overlap_mask_area_threshold);
        if (!mask_exists) {
          continue;
        }
        ++current_segment_id;
        for (const index of mask_k) {
          segmentation_data[index] = current_segment_id;
        }
        segments.push({
          id: current_segment_id,
          label_id: pred_class,
          score: pred_scores[k]
        });
      }
      return [segmentation, segments];
    }
    function smart_resize(height, width, factor = 28, min_pixels = 56 * 56, max_pixels = 14 * 14 * 4 * 1280) {
      if (height < factor || width < factor) {
        throw new Error(`height:${height} or width:${width} must be larger than factor:${factor}`);
      } else if (Math.max(height, width) / Math.min(height, width) > 200) {
        throw new Error(`absolute aspect ratio must be smaller than 200, got ${Math.max(height, width) / Math.min(height, width)}`);
      }
      let h_bar = Math.round(height / factor) * factor;
      let w_bar = Math.round(width / factor) * factor;
      if (h_bar * w_bar > max_pixels) {
        const beta = Math.sqrt(height * width / max_pixels);
        h_bar = Math.floor(height / beta / factor) * factor;
        w_bar = Math.floor(width / beta / factor) * factor;
      } else if (h_bar * w_bar < min_pixels) {
        const beta = Math.sqrt(min_pixels / (height * width));
        h_bar = Math.ceil(height * beta / factor) * factor;
        w_bar = Math.ceil(width * beta / factor) * factor;
      }
      return [h_bar, w_bar];
    }
    function post_process_panoptic_segmentation(outputs, threshold = 0.5, mask_threshold = 0.5, overlap_mask_area_threshold = 0.8, label_ids_to_fuse = null, target_sizes = null) {
      if (label_ids_to_fuse === null) {
        console.warn("`label_ids_to_fuse` unset. No instance will be fused.");
        label_ids_to_fuse = new Set;
      }
      const class_queries_logits = outputs.class_queries_logits ?? outputs.logits;
      const masks_queries_logits = outputs.masks_queries_logits ?? outputs.pred_masks;
      const mask_probs = masks_queries_logits.sigmoid();
      let [batch_size, num_queries, num_labels] = class_queries_logits.dims;
      num_labels -= 1;
      if (target_sizes !== null && target_sizes.length !== batch_size) {
        throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");
      }
      let toReturn = [];
      for (let i = 0;i < batch_size; ++i) {
        let target_size = target_sizes !== null ? target_sizes[i] : null;
        let class_logits = class_queries_logits[i];
        let mask_logits = mask_probs[i];
        let [mask_probs_item, pred_scores_item, pred_labels_item] = remove_low_and_no_objects(class_logits, mask_logits, threshold, num_labels);
        if (pred_labels_item.length === 0) {
          let [height, width] = target_size ?? mask_logits.dims.slice(-2);
          let segmentation2 = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__.Tensor("int32", new Int32Array(height * width).fill(-1), [height, width]);
          toReturn.push({
            segmentation: segmentation2,
            segments_info: []
          });
          continue;
        }
        let [segmentation, segments] = compute_segments(mask_probs_item, pred_scores_item, pred_labels_item, mask_threshold, overlap_mask_area_threshold, label_ids_to_fuse, target_size);
        toReturn.push({
          segmentation,
          segments_info: segments
        });
      }
      return toReturn;
    }
    function post_process_instance_segmentation(outputs, threshold = 0.5, target_sizes = null) {
      throw new Error("`post_process_instance_segmentation` is not yet implemented.");
    }

    class ImageProcessor extends _utils_generic_js__WEBPACK_IMPORTED_MODULE_0__.Callable {
      constructor(config3) {
        super();
        this.image_mean = config3.image_mean ?? config3.mean;
        this.image_std = config3.image_std ?? config3.std;
        this.resample = config3.resample ?? 2;
        this.do_rescale = config3.do_rescale ?? true;
        this.rescale_factor = config3.rescale_factor ?? 1 / 255;
        this.do_normalize = config3.do_normalize;
        this.do_thumbnail = config3.do_thumbnail;
        this.size = config3.size ?? config3.image_size;
        this.do_resize = config3.do_resize ?? this.size !== undefined;
        this.size_divisibility = config3.size_divisibility ?? config3.size_divisor;
        this.do_center_crop = config3.do_center_crop;
        this.crop_size = config3.crop_size;
        this.do_convert_rgb = config3.do_convert_rgb ?? true;
        this.do_crop_margin = config3.do_crop_margin;
        this.pad_size = config3.pad_size;
        this.do_pad = config3.do_pad;
        this.min_pixels = config3.min_pixels;
        this.max_pixels = config3.max_pixels;
        if (this.do_pad && !this.pad_size && this.size && this.size.width !== undefined && this.size.height !== undefined) {
          this.pad_size = this.size;
        }
        this.do_flip_channel_order = config3.do_flip_channel_order ?? false;
        this.config = config3;
      }
      async thumbnail(image, size, resample = 2) {
        const input_height = image.height;
        const input_width = image.width;
        const output_height = size.height;
        const output_width = size.width;
        let height = Math.min(input_height, output_height);
        let width = Math.min(input_width, output_width);
        if (height === input_height && width === input_width) {
          return image;
        }
        if (input_height > input_width) {
          width = Math.floor(input_width * height / input_height);
        } else if (input_width > input_height) {
          height = Math.floor(input_height * width / input_width);
        }
        return await image.resize(width, height, { resample });
      }
      async crop_margin(image, gray_threshold = 200) {
        const gray_image = image.clone().grayscale();
        const minValue = (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.min)(gray_image.data)[0];
        const maxValue = (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.max)(gray_image.data)[0];
        const diff = maxValue - minValue;
        if (diff === 0) {
          return image;
        }
        const threshold = gray_threshold / 255;
        let { width: x_min, height: y_min } = gray_image, x_max = 0, y_max = 0;
        const gray_image_data = gray_image.data;
        for (let j = 0;j < gray_image.height; ++j) {
          const row = j * gray_image.width;
          for (let i = 0;i < gray_image.width; ++i) {
            if ((gray_image_data[row + i] - minValue) / diff < threshold) {
              x_min = Math.min(x_min, i);
              y_min = Math.min(y_min, j);
              x_max = Math.max(x_max, i);
              y_max = Math.max(y_max, j);
            }
          }
        }
        image = await image.crop([x_min, y_min, x_max, y_max]);
        return image;
      }
      pad_image(pixelData, imgDims, padSize, {
        mode = "constant",
        center = false,
        constant_values = 0
      } = {}) {
        const [imageHeight, imageWidth, imageChannels] = imgDims;
        let paddedImageWidth, paddedImageHeight;
        if (typeof padSize === "number") {
          paddedImageWidth = padSize;
          paddedImageHeight = padSize;
        } else if (padSize === "square") {
          paddedImageWidth = paddedImageHeight = Math.max(imageHeight, imageWidth);
        } else {
          paddedImageWidth = padSize.width;
          paddedImageHeight = padSize.height;
        }
        if (paddedImageWidth !== imageWidth || paddedImageHeight !== imageHeight) {
          const paddedPixelData = new Float32Array(paddedImageWidth * paddedImageHeight * imageChannels);
          if (Array.isArray(constant_values)) {
            for (let i = 0;i < paddedPixelData.length; ++i) {
              paddedPixelData[i] = constant_values[i % imageChannels];
            }
          } else if (constant_values !== 0) {
            paddedPixelData.fill(constant_values);
          }
          const [left, top] = center ? [Math.floor((paddedImageWidth - imageWidth) / 2), Math.floor((paddedImageHeight - imageHeight) / 2)] : [0, 0];
          for (let i = 0;i < imageHeight; ++i) {
            const a = (i + top) * paddedImageWidth;
            const b = i * imageWidth;
            for (let j = 0;j < imageWidth; ++j) {
              const c = (a + j + left) * imageChannels;
              const d = (b + j) * imageChannels;
              for (let k = 0;k < imageChannels; ++k) {
                paddedPixelData[c + k] = pixelData[d + k];
              }
            }
          }
          if (mode === "symmetric") {
            if (center) {
              throw new Error("`center` padding is not supported when `mode` is set to `symmetric`.");
            }
            const h1 = imageHeight - 1;
            const w1 = imageWidth - 1;
            for (let i = 0;i < paddedImageHeight; ++i) {
              const a = i * paddedImageWidth;
              const b = (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_4__.calculateReflectOffset)(i, h1) * imageWidth;
              for (let j = 0;j < paddedImageWidth; ++j) {
                if (i < imageHeight && j < imageWidth)
                  continue;
                const c = (a + j) * imageChannels;
                const d = (b + (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_4__.calculateReflectOffset)(j, w1)) * imageChannels;
                for (let k = 0;k < imageChannels; ++k) {
                  paddedPixelData[c + k] = pixelData[d + k];
                }
              }
            }
          }
          pixelData = paddedPixelData;
          imgDims = [paddedImageHeight, paddedImageWidth, imageChannels];
        }
        return [pixelData, imgDims];
      }
      rescale(pixelData) {
        for (let i = 0;i < pixelData.length; ++i) {
          pixelData[i] = this.rescale_factor * pixelData[i];
        }
      }
      get_resize_output_image_size(image, size) {
        const [srcWidth, srcHeight] = image.size;
        let shortest_edge;
        let longest_edge;
        if (this.do_thumbnail) {
          const { height, width } = size;
          shortest_edge = Math.min(height, width);
        } else if (Number.isInteger(size)) {
          shortest_edge = size;
          longest_edge = this.config.max_size ?? shortest_edge;
        } else if (size !== undefined) {
          shortest_edge = size.shortest_edge;
          longest_edge = size.longest_edge;
        }
        if (shortest_edge !== undefined || longest_edge !== undefined) {
          const shortResizeFactor = shortest_edge === undefined ? 1 : Math.max(shortest_edge / srcWidth, shortest_edge / srcHeight);
          const newWidth = srcWidth * shortResizeFactor;
          const newHeight = srcHeight * shortResizeFactor;
          const longResizeFactor = longest_edge === undefined ? 1 : Math.min(longest_edge / newWidth, longest_edge / newHeight);
          let finalWidth = Math.floor(Number((newWidth * longResizeFactor).toFixed(2)));
          let finalHeight = Math.floor(Number((newHeight * longResizeFactor).toFixed(2)));
          if (this.size_divisibility !== undefined) {
            [finalWidth, finalHeight] = enforce_size_divisibility([finalWidth, finalHeight], this.size_divisibility);
          }
          return [finalWidth, finalHeight];
        } else if (size !== undefined && size.width !== undefined && size.height !== undefined) {
          let newWidth = size.width;
          let newHeight = size.height;
          if (this.config.keep_aspect_ratio && this.config.ensure_multiple_of) {
            let scale_height = newHeight / srcHeight;
            let scale_width = newWidth / srcWidth;
            if (Math.abs(1 - scale_width) < Math.abs(1 - scale_height)) {
              scale_height = scale_width;
            } else {
              scale_width = scale_height;
            }
            newHeight = constraint_to_multiple_of(scale_height * srcHeight, this.config.ensure_multiple_of);
            newWidth = constraint_to_multiple_of(scale_width * srcWidth, this.config.ensure_multiple_of);
          }
          return [newWidth, newHeight];
        } else if (this.size_divisibility !== undefined) {
          return enforce_size_divisibility([srcWidth, srcHeight], this.size_divisibility);
        } else if (this.min_pixels !== undefined && this.max_pixels !== undefined) {
          const factor = this.config.patch_size * this.config.merge_size;
          return smart_resize(srcHeight, srcWidth, factor, this.min_pixels, this.max_pixels);
        } else {
          throw new Error(`Could not resize image due to unsupported \`this.size\` option in config: ${JSON.stringify(size)}`);
        }
      }
      async resize(image) {
        const [newWidth, newHeight] = this.get_resize_output_image_size(image, this.size);
        return await image.resize(newWidth, newHeight, {
          resample: this.resample
        });
      }
      async preprocess(image, {
        do_normalize = null,
        do_pad = null,
        do_convert_rgb = null,
        do_convert_grayscale = null,
        do_flip_channel_order = null
      } = {}) {
        if (this.do_crop_margin) {
          image = await this.crop_margin(image);
        }
        const [srcWidth, srcHeight] = image.size;
        if (do_convert_rgb ?? this.do_convert_rgb) {
          image = image.rgb();
        } else if (do_convert_grayscale) {
          image = image.grayscale();
        }
        if (this.do_resize) {
          image = await this.resize(image);
        }
        if (this.do_thumbnail) {
          image = await this.thumbnail(image, this.size, this.resample);
        }
        if (this.do_center_crop) {
          let crop_width;
          let crop_height;
          if (Number.isInteger(this.crop_size)) {
            crop_width = this.crop_size;
            crop_height = this.crop_size;
          } else {
            crop_width = this.crop_size.width;
            crop_height = this.crop_size.height;
          }
          image = await image.center_crop(crop_width, crop_height);
        }
        const reshaped_input_size = [image.height, image.width];
        let pixelData = Float32Array.from(image.data);
        let imgDims = [image.height, image.width, image.channels];
        if (this.do_rescale) {
          this.rescale(pixelData);
        }
        if (do_normalize ?? this.do_normalize) {
          let image_mean = this.image_mean;
          if (!Array.isArray(this.image_mean)) {
            image_mean = new Array(image.channels).fill(image_mean);
          }
          let image_std = this.image_std;
          if (!Array.isArray(this.image_std)) {
            image_std = new Array(image.channels).fill(image_std);
          }
          if (image_mean.length !== image.channels || image_std.length !== image.channels) {
            throw new Error(`When set to arrays, the length of \`image_mean\` (${image_mean.length}) and \`image_std\` (${image_std.length}) must match the number of channels in the image (${image.channels}).`);
          }
          for (let i = 0;i < pixelData.length; i += image.channels) {
            for (let j = 0;j < image.channels; ++j) {
              pixelData[i + j] = (pixelData[i + j] - image_mean[j]) / image_std[j];
            }
          }
        }
        if (do_pad ?? this.do_pad) {
          if (this.pad_size) {
            const padded = this.pad_image(pixelData, [image.height, image.width, image.channels], this.pad_size);
            [pixelData, imgDims] = padded;
          } else if (this.size_divisibility) {
            const [paddedWidth, paddedHeight] = enforce_size_divisibility([imgDims[1], imgDims[0]], this.size_divisibility);
            [pixelData, imgDims] = this.pad_image(pixelData, imgDims, { width: paddedWidth, height: paddedHeight });
          }
        }
        if (do_flip_channel_order ?? this.do_flip_channel_order) {
          if (imgDims[2] !== 3) {
            throw new Error("Flipping channel order is only supported for RGB images.");
          }
          for (let i = 0;i < pixelData.length; i += 3) {
            const temp = pixelData[i];
            pixelData[i] = pixelData[i + 2];
            pixelData[i + 2] = temp;
          }
        }
        const pixel_values = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__.Tensor("float32", pixelData, imgDims).permute(2, 0, 1);
        return {
          original_size: [srcHeight, srcWidth],
          reshaped_input_size,
          pixel_values
        };
      }
      async _call(images, ...args) {
        if (!Array.isArray(images)) {
          images = [images];
        }
        const imageData = await Promise.all(images.map((x) => this.preprocess(x)));
        const pixel_values = (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__.stack)(imageData.map((x) => x.pixel_values), 0);
        return {
          pixel_values,
          original_sizes: imageData.map((x) => x.original_size),
          reshaped_input_sizes: imageData.map((x) => x.reshaped_input_size)
        };
      }
      static async from_pretrained(pretrained_model_name_or_path, options2 = {}) {
        const preprocessorConfig = await (0, _utils_hub_js__WEBPACK_IMPORTED_MODULE_5__.getModelJSON)(pretrained_model_name_or_path, _utils_constants_js__WEBPACK_IMPORTED_MODULE_6__.IMAGE_PROCESSOR_NAME, true, options2);
        return new this(preprocessorConfig);
      }
    }
  },
  "./src/base/processing_utils.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!**************************************!*\
      !*** ./src/base/processing_utils.js ***!
      \**************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      Processor: () => Processor2
    });
    var _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/utils/constants.js");
    /*! ../utils/constants.js */
    var _utils_generic_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/utils/generic.js");
    /*! ../utils/generic.js */
    var _utils_hub_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/utils/hub.js");
    /*! ../utils/hub.js */

    class Processor2 extends _utils_generic_js__WEBPACK_IMPORTED_MODULE_1__.Callable {
      static classes = [
        "image_processor_class",
        "tokenizer_class",
        "feature_extractor_class"
      ];
      static uses_processor_config = false;
      static uses_chat_template_file = false;
      constructor(config3, components, chat_template) {
        super();
        this.config = config3;
        this.components = components;
        this.chat_template = chat_template;
      }
      get image_processor() {
        return this.components.image_processor;
      }
      get tokenizer() {
        return this.components.tokenizer;
      }
      get feature_extractor() {
        return this.components.feature_extractor;
      }
      apply_chat_template(messages, options2 = {}) {
        if (!this.tokenizer) {
          throw new Error("Unable to apply chat template without a tokenizer.");
        }
        return this.tokenizer.apply_chat_template(messages, {
          tokenize: false,
          chat_template: this.chat_template ?? undefined,
          ...options2
        });
      }
      batch_decode(...args) {
        if (!this.tokenizer) {
          throw new Error("Unable to decode without a tokenizer.");
        }
        return this.tokenizer.batch_decode(...args);
      }
      decode(...args) {
        if (!this.tokenizer) {
          throw new Error("Unable to decode without a tokenizer.");
        }
        return this.tokenizer.decode(...args);
      }
      async _call(input, ...args) {
        for (const item of [this.image_processor, this.feature_extractor, this.tokenizer]) {
          if (item) {
            return item(input, ...args);
          }
        }
        throw new Error("No image processor, feature extractor, or tokenizer found.");
      }
      static async from_pretrained(pretrained_model_name_or_path, options2 = {}) {
        const [config3, components, chat_template] = await Promise.all([
          this.uses_processor_config ? (0, _utils_hub_js__WEBPACK_IMPORTED_MODULE_2__.getModelJSON)(pretrained_model_name_or_path, _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.PROCESSOR_NAME, true, options2) : {},
          Promise.all(this.classes.filter((cls) => (cls in this)).map(async (cls) => {
            const component = await this[cls].from_pretrained(pretrained_model_name_or_path, options2);
            return [cls.replace(/_class$/, ""), component];
          })).then(Object.fromEntries),
          this.uses_chat_template_file ? (0, _utils_hub_js__WEBPACK_IMPORTED_MODULE_2__.getModelText)(pretrained_model_name_or_path, _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.CHAT_TEMPLATE_NAME, true, options2) : null
        ]);
        return new this(config3, components, chat_template);
      }
    }
  },
  "./src/configs.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!************************!*\
      !*** ./src/configs.js ***!
      \************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      AutoConfig: () => AutoConfig,
      PretrainedConfig: () => PretrainedConfig,
      getCacheShapes: () => getCacheShapes
    });
    var _utils_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/utils/core.js");
    /*! ./utils/core.js */
    var _utils_hub_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/utils/hub.js");
    /*! ./utils/hub.js */
    async function loadConfig2(pretrained_model_name_or_path, options2) {
      return await (0, _utils_hub_js__WEBPACK_IMPORTED_MODULE_1__.getModelJSON)(pretrained_model_name_or_path, "config.json", true, options2);
    }
    function getNormalizedConfig(config3) {
      const mapping = {};
      let init_normalized_config = {};
      switch (config3.model_type) {
        case "llava":
        case "paligemma":
        case "gemma3":
        case "florence2":
        case "llava_onevision":
        case "idefics3":
        case "ultravox":
        case "voxtral":
        case "smolvlm":
        case "gemma3n":
        case "mistral3":
          init_normalized_config = getNormalizedConfig(config3.text_config);
          break;
        case "moondream1":
          init_normalized_config = getNormalizedConfig(config3.phi_config);
          break;
        case "musicgen":
          init_normalized_config = getNormalizedConfig(config3.decoder);
          break;
        case "multi_modality":
          init_normalized_config = getNormalizedConfig(config3.language_config);
          break;
        case "gpt2":
        case "gptj":
        case "jais":
        case "codegen":
        case "gpt_bigcode":
          mapping["num_heads"] = "n_head";
          mapping["num_layers"] = "n_layer";
          mapping["hidden_size"] = "n_embd";
          break;
        case "gpt_neox":
        case "stablelm":
        case "opt":
        case "falcon":
        case "modernbert-decoder":
          mapping["num_heads"] = "num_attention_heads";
          mapping["num_layers"] = "num_hidden_layers";
          mapping["hidden_size"] = "hidden_size";
          break;
        case "llama":
        case "llama4_text":
        case "nanochat":
        case "arcee":
        case "lfm2":
        case "smollm3":
        case "olmo":
        case "olmo2":
        case "mobilellm":
        case "granite":
        case "granitemoehybrid":
        case "cohere":
        case "mistral":
        case "starcoder2":
        case "qwen2":
        case "qwen2_vl":
        case "phi":
        case "phi3":
        case "phi3_v":
        case "llava_qwen2":
          mapping["num_heads"] = "num_key_value_heads";
          mapping["num_layers"] = "num_hidden_layers";
          mapping["hidden_size"] = "hidden_size";
          mapping["num_attention_heads"] = "num_attention_heads";
          mapping["dim_kv"] = "head_dim";
          break;
        case "qwen3":
        case "gemma":
        case "gemma2":
        case "vaultgemma":
        case "gemma3_text":
        case "gemma3n_text":
        case "glm":
        case "helium":
        case "ernie4_5":
        case "ministral":
        case "ministral3":
          mapping["num_heads"] = "num_key_value_heads";
          mapping["num_layers"] = "num_hidden_layers";
          mapping["dim_kv"] = "head_dim";
          break;
        case "openelm":
          mapping["num_heads"] = "num_kv_heads";
          mapping["num_layers"] = "num_transformer_layers";
          mapping["dim_kv"] = "head_dim";
          break;
        case "gpt_neo":
        case "donut-swin":
          mapping["num_heads"] = "num_heads";
          mapping["num_layers"] = "num_layers";
          mapping["hidden_size"] = "hidden_size";
          break;
        case "bloom":
          mapping["num_heads"] = "n_head";
          mapping["num_layers"] = "n_layer";
          mapping["hidden_size"] = "hidden_size";
          break;
        case "mpt":
          mapping["num_heads"] = "n_heads";
          mapping["num_layers"] = "n_layers";
          mapping["hidden_size"] = "d_model";
          break;
        case "exaone":
          mapping["num_heads"] = "num_key_value_heads";
          mapping["num_layers"] = "num_layers";
          mapping["dim_kv"] = "head_dim";
          mapping["num_attention_heads"] = "num_attention_heads";
          break;
        case "t5":
        case "mt5":
        case "longt5":
          mapping["num_decoder_layers"] = "num_decoder_layers";
          mapping["num_decoder_heads"] = "num_heads";
          mapping["decoder_dim_kv"] = "d_kv";
          mapping["num_encoder_layers"] = "num_layers";
          mapping["num_encoder_heads"] = "num_heads";
          mapping["encoder_dim_kv"] = "d_kv";
          break;
        case "bart":
        case "mbart":
        case "marian":
        case "whisper":
        case "lite-whisper":
        case "m2m_100":
        case "blenderbot":
        case "blenderbot-small":
        case "florence2_language":
          mapping["num_decoder_layers"] = "decoder_layers";
          mapping["num_decoder_heads"] = "decoder_attention_heads";
          mapping["decoder_hidden_size"] = "d_model";
          mapping["num_encoder_layers"] = "encoder_layers";
          mapping["num_encoder_heads"] = "encoder_attention_heads";
          mapping["encoder_hidden_size"] = "d_model";
          break;
        case "speecht5":
          mapping["num_decoder_layers"] = "decoder_layers";
          mapping["num_decoder_heads"] = "decoder_attention_heads";
          mapping["decoder_hidden_size"] = "hidden_size";
          mapping["num_encoder_layers"] = "encoder_layers";
          mapping["num_encoder_heads"] = "encoder_attention_heads";
          mapping["encoder_hidden_size"] = "hidden_size";
          break;
        case "trocr":
          mapping["num_encoder_layers"] = mapping["num_decoder_layers"] = "decoder_layers";
          mapping["num_encoder_heads"] = mapping["num_decoder_heads"] = "decoder_attention_heads";
          mapping["encoder_hidden_size"] = mapping["decoder_hidden_size"] = "d_model";
          break;
        case "musicgen_decoder":
          mapping["num_encoder_layers"] = mapping["num_decoder_layers"] = "num_hidden_layers";
          mapping["num_encoder_heads"] = mapping["num_decoder_heads"] = "num_attention_heads";
          mapping["encoder_hidden_size"] = mapping["decoder_hidden_size"] = "hidden_size";
          break;
        case "moonshine":
          mapping["num_decoder_layers"] = "decoder_num_hidden_layers";
          mapping["num_decoder_heads"] = "decoder_num_key_value_heads";
          mapping["num_encoder_layers"] = "encoder_num_hidden_layers";
          mapping["num_encoder_heads"] = "encoder_num_key_value_heads";
          mapping["encoder_hidden_size"] = mapping["decoder_hidden_size"] = "hidden_size";
          break;
        case "vision-encoder-decoder":
          const decoderConfig = getNormalizedConfig(config3.decoder);
          const add_encoder_pkv = "num_decoder_layers" in decoderConfig;
          const result = (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_0__.pick)(config3, ["model_type", "is_encoder_decoder"]);
          if (add_encoder_pkv) {
            result.num_decoder_layers = decoderConfig.num_decoder_layers;
            result.num_decoder_heads = decoderConfig.num_decoder_heads;
            result.decoder_hidden_size = decoderConfig.decoder_hidden_size;
            result.num_encoder_layers = decoderConfig.num_encoder_layers;
            result.num_encoder_heads = decoderConfig.num_encoder_heads;
            result.encoder_hidden_size = decoderConfig.encoder_hidden_size;
          } else {
            result.num_layers = decoderConfig.num_layers;
            result.num_heads = decoderConfig.num_heads;
            result.hidden_size = decoderConfig.hidden_size;
          }
          return result;
      }
      const normalized_config = {
        ...init_normalized_config,
        ...(0, _utils_core_js__WEBPACK_IMPORTED_MODULE_0__.pick)(config3, ["model_type", "multi_query", "is_encoder_decoder"])
      };
      for (const key in mapping) {
        normalized_config[key] = config3[mapping[key]];
      }
      return normalized_config;
    }
    function getCacheShapes(config3, options2) {
      if (config3.model_type === "lfm2") {
        const pkv_prefix = options2?.prefix ?? "past_key_values";
        const conv_prefix = pkv_prefix === "present" ? "present" : "past";
        const cache_values = {};
        const { layer_types, num_attention_heads, num_key_value_heads, hidden_size, conv_L_cache } = config3;
        const head_dim = hidden_size / num_attention_heads;
        const batch_size = options2?.batch_size ?? 1;
        for (let i = 0;i < layer_types.length; ++i) {
          if (layer_types[i] === "full_attention") {
            for (const kv of ["key", "value"]) {
              cache_values[`${pkv_prefix}.${i}.${kv}`] = [batch_size, num_key_value_heads, 0, head_dim];
            }
          } else if (layer_types[i] === "conv") {
            cache_values[`${conv_prefix}_conv.${i}`] = [batch_size, hidden_size, conv_L_cache];
          } else {
            throw new Error(`Unsupported layer type: ${layer_types[i]}`);
          }
        }
        return cache_values;
      }
      return getKeyValueShapes(config3, options2);
    }
    function getKeyValueShapes(config3, {
      prefix = "past_key_values",
      batch_size = 1
    } = {}) {
      const decoderFeeds = {};
      const normalized_config = config3.normalized_config;
      if (normalized_config.is_encoder_decoder && (("num_encoder_heads" in normalized_config) && ("num_decoder_heads" in normalized_config))) {
        const encoder_dim_kv = normalized_config.encoder_dim_kv ?? normalized_config.encoder_hidden_size / normalized_config.num_encoder_heads;
        const decoder_dim_kv = normalized_config.decoder_dim_kv ?? normalized_config.decoder_hidden_size / normalized_config.num_decoder_heads;
        const encoder_dims = [batch_size, normalized_config.num_encoder_heads, 0, encoder_dim_kv];
        const decoder_dims = [batch_size, normalized_config.num_decoder_heads, 0, decoder_dim_kv];
        for (let i = 0;i < normalized_config.num_decoder_layers; ++i) {
          decoderFeeds[`${prefix}.${i}.encoder.key`] = encoder_dims;
          decoderFeeds[`${prefix}.${i}.encoder.value`] = encoder_dims;
          decoderFeeds[`${prefix}.${i}.decoder.key`] = decoder_dims;
          decoderFeeds[`${prefix}.${i}.decoder.value`] = decoder_dims;
        }
      } else {
        const num_heads = normalized_config.num_heads;
        const num_layers = normalized_config.num_layers;
        const dim_kv = normalized_config.dim_kv ?? normalized_config.hidden_size / (normalized_config.num_attention_heads ?? num_heads);
        if (normalized_config.model_type === "falcon") {
          const dims = [batch_size * num_heads, 0, dim_kv];
          for (let i = 0;i < num_layers; ++i) {
            decoderFeeds[`${prefix}.${i}.key`] = dims;
            decoderFeeds[`${prefix}.${i}.value`] = dims;
          }
        } else if (normalized_config.multi_query) {
          const dims = [batch_size * num_heads, 0, 2 * dim_kv];
          for (let i = 0;i < num_layers; ++i) {
            decoderFeeds[`${prefix}.${i}.key_value`] = dims;
          }
        } else if (normalized_config.model_type === "bloom") {
          const keyDims = [batch_size * num_heads, dim_kv, 0];
          const valueDims = [batch_size * num_heads, 0, dim_kv];
          for (let i = 0;i < num_layers; ++i) {
            decoderFeeds[`${prefix}.${i}.key`] = keyDims;
            decoderFeeds[`${prefix}.${i}.value`] = valueDims;
          }
        } else if (normalized_config.model_type === "openelm") {
          for (let i = 0;i < num_layers; ++i) {
            const dims = [batch_size, num_heads[i], 0, dim_kv];
            decoderFeeds[`${prefix}.${i}.key`] = dims;
            decoderFeeds[`${prefix}.${i}.value`] = dims;
          }
        } else {
          const dims = [batch_size, num_heads, 0, dim_kv];
          for (let i = 0;i < num_layers; ++i) {
            decoderFeeds[`${prefix}.${i}.key`] = dims;
            decoderFeeds[`${prefix}.${i}.value`] = dims;
          }
        }
      }
      return decoderFeeds;
    }

    class PretrainedConfig {
      model_type = null;
      is_encoder_decoder = false;
      max_position_embeddings;
      "transformers.js_config";
      constructor(configJSON) {
        Object.assign(this, configJSON);
        this.normalized_config = getNormalizedConfig(this);
      }
      static async from_pretrained(pretrained_model_name_or_path, {
        progress_callback = null,
        config: config3 = null,
        cache_dir = null,
        local_files_only = false,
        revision = "main"
      } = {}) {
        if (config3 && !(config3 instanceof PretrainedConfig)) {
          config3 = new PretrainedConfig(config3);
        }
        const data = config3 ?? await loadConfig2(pretrained_model_name_or_path, {
          progress_callback,
          config: config3,
          cache_dir,
          local_files_only,
          revision
        });
        return new this(data);
      }
    }

    class AutoConfig {
      static async from_pretrained(...args) {
        return PretrainedConfig.from_pretrained(...args);
      }
    }
  },
  "./src/env.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!********************!*\
      !*** ./src/env.js ***!
      \********************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      apis: () => apis,
      env: () => env4
    });
    var node_fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("node:fs");
    /*! node:fs */
    var node_path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("node:path");
    /*! node:path */
    var node_url__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("node:url");
    /*! node:url */
    const VERSION2 = "3.8.1";
    const IS_BROWSER_ENV = typeof window !== "undefined" && typeof window.document !== "undefined";
    const IS_WEBWORKER_ENV = typeof self !== "undefined" && ["DedicatedWorkerGlobalScope", "ServiceWorkerGlobalScope", "SharedWorkerGlobalScope"].includes(self.constructor?.name);
    const IS_WEB_CACHE_AVAILABLE = typeof self !== "undefined" && "caches" in self;
    const IS_WEBGPU_AVAILABLE = typeof navigator !== "undefined" && "gpu" in navigator;
    const IS_WEBNN_AVAILABLE = typeof navigator !== "undefined" && "ml" in navigator;
    const IS_PROCESS_AVAILABLE = typeof process !== "undefined";
    const IS_NODE_ENV = IS_PROCESS_AVAILABLE && process?.release?.name === "node";
    const IS_FS_AVAILABLE = !isEmpty2(node_fs__WEBPACK_IMPORTED_MODULE_0__["default"]);
    const IS_PATH_AVAILABLE = !isEmpty2(node_path__WEBPACK_IMPORTED_MODULE_1__["default"]);
    const IS_DENO_RUNTIME = typeof globalThis.Deno !== "undefined";
    const IS_BUN_RUNTIME = typeof globalThis.Bun !== "undefined";
    const apis = Object.freeze({
      IS_BROWSER_ENV,
      IS_WEBWORKER_ENV,
      IS_WEB_CACHE_AVAILABLE,
      IS_WEBGPU_AVAILABLE,
      IS_WEBNN_AVAILABLE,
      IS_PROCESS_AVAILABLE,
      IS_NODE_ENV,
      IS_FS_AVAILABLE,
      IS_PATH_AVAILABLE
    });
    const RUNNING_LOCALLY = IS_FS_AVAILABLE && IS_PATH_AVAILABLE;
    let dirname__ = "./";
    if (RUNNING_LOCALLY) {
      const _import_meta_url = Object(import.meta).url;
      if (_import_meta_url) {
        dirname__ = node_path__WEBPACK_IMPORTED_MODULE_1__["default"].dirname(node_path__WEBPACK_IMPORTED_MODULE_1__["default"].dirname(node_url__WEBPACK_IMPORTED_MODULE_2__["default"].fileURLToPath(_import_meta_url)));
      } else if (typeof __dirname !== "undefined") {
        dirname__ = node_path__WEBPACK_IMPORTED_MODULE_1__["default"].dirname(__dirname);
      }
    }
    const DEFAULT_CACHE_DIR = RUNNING_LOCALLY ? node_path__WEBPACK_IMPORTED_MODULE_1__["default"].join(dirname__, "/.cache/") : null;
    const DEFAULT_LOCAL_MODEL_PATH = "/models/";
    const localModelPath = RUNNING_LOCALLY ? node_path__WEBPACK_IMPORTED_MODULE_1__["default"].join(dirname__, DEFAULT_LOCAL_MODEL_PATH) : DEFAULT_LOCAL_MODEL_PATH;
    const env4 = {
      version: VERSION2,
      backends: {
        onnx: {}
      },
      allowRemoteModels: true,
      remoteHost: "https://huggingface.co/",
      remotePathTemplate: "{model}/resolve/{revision}/",
      allowLocalModels: !(IS_BROWSER_ENV || IS_WEBWORKER_ENV),
      localModelPath,
      useFS: IS_FS_AVAILABLE,
      useBrowserCache: IS_WEB_CACHE_AVAILABLE && !IS_DENO_RUNTIME,
      useFSCache: IS_FS_AVAILABLE,
      cacheDir: DEFAULT_CACHE_DIR,
      useCustomCache: false,
      customCache: null
    };
    function isEmpty2(obj) {
      return Object.keys(obj).length === 0;
    }
  },
  "./src/generation/configuration_utils.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!***********************************************!*\
      !*** ./src/generation/configuration_utils.js ***!
      \***********************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      GenerationConfig: () => GenerationConfig
    });
    var _utils_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/utils/core.js");
    /*! ../utils/core.js */

    class GenerationConfig {
      max_length = 20;
      max_new_tokens = null;
      min_length = 0;
      min_new_tokens = null;
      early_stopping = false;
      max_time = null;
      do_sample = false;
      num_beams = 1;
      num_beam_groups = 1;
      penalty_alpha = null;
      use_cache = true;
      temperature = 1;
      top_k = 50;
      top_p = 1;
      typical_p = 1;
      epsilon_cutoff = 0;
      eta_cutoff = 0;
      diversity_penalty = 0;
      repetition_penalty = 1;
      encoder_repetition_penalty = 1;
      length_penalty = 1;
      no_repeat_ngram_size = 0;
      bad_words_ids = null;
      force_words_ids = null;
      renormalize_logits = false;
      constraints = null;
      forced_bos_token_id = null;
      forced_eos_token_id = null;
      remove_invalid_values = false;
      exponential_decay_length_penalty = null;
      suppress_tokens = null;
      streamer = null;
      begin_suppress_tokens = null;
      forced_decoder_ids = null;
      guidance_scale = null;
      num_return_sequences = 1;
      output_attentions = false;
      output_hidden_states = false;
      output_scores = false;
      return_dict_in_generate = false;
      pad_token_id = null;
      bos_token_id = null;
      eos_token_id = null;
      encoder_no_repeat_ngram_size = 0;
      decoder_start_token_id = null;
      generation_kwargs = {};
      constructor(config3) {
        Object.assign(this, (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_0__.pick)(config3, Object.getOwnPropertyNames(this)));
      }
    }
  },
  "./src/generation/logits_process.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!******************************************!*\
      !*** ./src/generation/logits_process.js ***!
      \******************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      ClassifierFreeGuidanceLogitsProcessor: () => ClassifierFreeGuidanceLogitsProcessor,
      ForcedBOSTokenLogitsProcessor: () => ForcedBOSTokenLogitsProcessor,
      ForcedEOSTokenLogitsProcessor: () => ForcedEOSTokenLogitsProcessor,
      LogitsProcessor: () => LogitsProcessor,
      LogitsProcessorList: () => LogitsProcessorList,
      LogitsWarper: () => LogitsWarper,
      MinLengthLogitsProcessor: () => MinLengthLogitsProcessor,
      MinNewTokensLengthLogitsProcessor: () => MinNewTokensLengthLogitsProcessor,
      NoBadWordsLogitsProcessor: () => NoBadWordsLogitsProcessor,
      NoRepeatNGramLogitsProcessor: () => NoRepeatNGramLogitsProcessor,
      RepetitionPenaltyLogitsProcessor: () => RepetitionPenaltyLogitsProcessor,
      SuppressTokensAtBeginLogitsProcessor: () => SuppressTokensAtBeginLogitsProcessor,
      TemperatureLogitsWarper: () => TemperatureLogitsWarper,
      TopKLogitsWarper: () => TopKLogitsWarper,
      TopPLogitsWarper: () => TopPLogitsWarper,
      WhisperTimeStampLogitsProcessor: () => WhisperTimeStampLogitsProcessor
    });
    var _utils_generic_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/utils/generic.js");
    /*! ../utils/generic.js */
    var _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/utils/tensor.js");
    /*! ../utils/tensor.js */
    var _utils_maths_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/utils/maths.js");
    /*! ../utils/maths.js */

    class LogitsProcessor extends _utils_generic_js__WEBPACK_IMPORTED_MODULE_0__.Callable {
      _call(input_ids, logits) {
        throw Error("`_call` should be implemented in a subclass");
      }
    }

    class LogitsWarper extends _utils_generic_js__WEBPACK_IMPORTED_MODULE_0__.Callable {
      _call(input_ids, logits) {
        throw Error("`_call` should be implemented in a subclass");
      }
    }

    class LogitsProcessorList extends _utils_generic_js__WEBPACK_IMPORTED_MODULE_0__.Callable {
      constructor() {
        super();
        this.processors = [];
      }
      push(item) {
        this.processors.push(item);
      }
      extend(items) {
        this.processors.push(...items);
      }
      _call(input_ids, logits) {
        let toReturn = logits;
        for (const processor of this.processors) {
          toReturn = processor(input_ids, toReturn);
        }
        return toReturn;
      }
      [Symbol.iterator]() {
        return this.processors.values();
      }
    }

    class ForcedBOSTokenLogitsProcessor extends LogitsProcessor {
      constructor(bos_token_id) {
        super();
        this.bos_token_id = bos_token_id;
      }
      _call(input_ids, logits) {
        for (let i = 0;i < input_ids.length; ++i) {
          if (input_ids[i].length === 1) {
            const batch_logits_data = logits[i].data;
            batch_logits_data.fill(-Infinity);
            batch_logits_data[this.bos_token_id] = 0;
          }
        }
        return logits;
      }
    }

    class ForcedEOSTokenLogitsProcessor extends LogitsProcessor {
      constructor(max_length, eos_token_id) {
        super();
        this.max_length = max_length;
        this.eos_token_id = Array.isArray(eos_token_id) ? eos_token_id : [eos_token_id];
      }
      _call(input_ids, logits) {
        for (let i = 0;i < input_ids.length; ++i) {
          if (input_ids[i].length === this.max_length - 1) {
            const batch_logits_data = logits[i].data;
            batch_logits_data.fill(-Infinity);
            for (const eos_token of this.eos_token_id) {
              batch_logits_data[eos_token] = 0;
            }
          }
        }
        return logits;
      }
    }

    class SuppressTokensAtBeginLogitsProcessor extends LogitsProcessor {
      constructor(begin_suppress_tokens, begin_index) {
        super();
        this.begin_suppress_tokens = begin_suppress_tokens;
        this.begin_index = begin_index;
      }
      _call(input_ids, logits) {
        for (let i = 0;i < input_ids.length; ++i) {
          if (input_ids[i].length === this.begin_index) {
            const batch_logits_data = logits[i].data;
            for (const token_id of this.begin_suppress_tokens) {
              batch_logits_data[token_id] = -Infinity;
            }
          }
        }
        return logits;
      }
    }

    class WhisperTimeStampLogitsProcessor extends LogitsProcessor {
      constructor(generate_config, init_tokens) {
        super();
        this.eos_token_id = Array.isArray(generate_config.eos_token_id) ? generate_config.eos_token_id[0] : generate_config.eos_token_id;
        this.no_timestamps_token_id = generate_config.no_timestamps_token_id;
        this.timestamp_begin = this.no_timestamps_token_id + 1;
        this.begin_index = init_tokens.length;
        if (init_tokens.at(-1) === this.no_timestamps_token_id) {
          this.begin_index -= 1;
        }
        this.max_initial_timestamp_index = generate_config.max_initial_timestamp_index;
      }
      _call(input_ids, logits) {
        for (let i = 0;i < input_ids.length; ++i) {
          const batch_logits_data = logits[i].data;
          batch_logits_data[this.no_timestamps_token_id] = -Infinity;
          if (input_ids[i].length === this.begin_index - 1) {
            batch_logits_data.fill(-Infinity);
            batch_logits_data[this.timestamp_begin] = 0;
            continue;
          }
          const seq = input_ids[i].slice(this.begin_index);
          const last_was_timestamp = seq.length >= 1 && seq[seq.length - 1] >= this.timestamp_begin;
          const penultimate_was_timestamp = seq.length < 2 || seq[seq.length - 2] >= this.timestamp_begin;
          if (last_was_timestamp) {
            if (penultimate_was_timestamp) {
              batch_logits_data.subarray(this.timestamp_begin).fill(-Infinity);
            } else {
              batch_logits_data.subarray(0, this.eos_token_id).fill(-Infinity);
            }
          }
          if (input_ids[i].length === this.begin_index && this.max_initial_timestamp_index !== null) {
            const last_allowed = this.timestamp_begin + this.max_initial_timestamp_index;
            batch_logits_data.subarray(last_allowed + 1).fill(-Infinity);
          }
          const logprobs = (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.log_softmax)(batch_logits_data);
          const timestamp_logprob = Math.log(logprobs.subarray(this.timestamp_begin).map(Math.exp).reduce((a, b) => a + b));
          const max_text_token_logprob = (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.max)(logprobs.subarray(0, this.timestamp_begin))[0];
          if (timestamp_logprob > max_text_token_logprob) {
            batch_logits_data.subarray(0, this.timestamp_begin).fill(-Infinity);
          }
        }
        return logits;
      }
    }

    class NoRepeatNGramLogitsProcessor extends LogitsProcessor {
      constructor(no_repeat_ngram_size) {
        super();
        this.no_repeat_ngram_size = no_repeat_ngram_size;
      }
      getNgrams(prevInputIds) {
        const curLen = prevInputIds.length;
        const ngrams = [];
        for (let j = 0;j < curLen + 1 - this.no_repeat_ngram_size; ++j) {
          const ngram = [];
          for (let k = 0;k < this.no_repeat_ngram_size; ++k) {
            ngram.push(prevInputIds[j + k]);
          }
          ngrams.push(ngram.map(Number));
        }
        const generatedNgram = new Map;
        for (const ngram of ngrams) {
          const prevNgram = ngram.slice(0, ngram.length - 1);
          const prevNgramKey = JSON.stringify(prevNgram);
          const prevNgramValue = generatedNgram.get(prevNgramKey) ?? [];
          prevNgramValue.push(ngram[ngram.length - 1]);
          generatedNgram.set(prevNgramKey, prevNgramValue);
        }
        return generatedNgram;
      }
      getGeneratedNgrams(bannedNgrams, prevInputIds) {
        const ngramIdx = prevInputIds.slice(prevInputIds.length + 1 - this.no_repeat_ngram_size, prevInputIds.length);
        const banned = bannedNgrams.get(JSON.stringify(ngramIdx.map(Number))) ?? [];
        return banned;
      }
      calcBannedNgramTokens(prevInputIds) {
        const bannedTokens = [];
        if (prevInputIds.length + 1 < this.no_repeat_ngram_size) {
          return bannedTokens;
        } else {
          const generatedNgrams = this.getNgrams(prevInputIds);
          const bannedTokens2 = this.getGeneratedNgrams(generatedNgrams, prevInputIds);
          return bannedTokens2;
        }
      }
      _call(input_ids, logits) {
        for (let i = 0;i < input_ids.length; ++i) {
          const batch_logits_data = logits[i].data;
          const bannedTokens = this.calcBannedNgramTokens(input_ids[i]);
          for (const token of bannedTokens) {
            batch_logits_data[token] = -Infinity;
          }
        }
        return logits;
      }
    }

    class RepetitionPenaltyLogitsProcessor extends LogitsProcessor {
      constructor(penalty) {
        super();
        this.penalty = penalty;
      }
      _call(input_ids, logits) {
        for (let i = 0;i < input_ids.length; ++i) {
          const batch_logits_data = logits[i].data;
          for (const input_id of new Set(input_ids[i])) {
            const token = Number(input_id);
            if (batch_logits_data[token] < 0) {
              batch_logits_data[token] *= this.penalty;
            } else {
              batch_logits_data[token] /= this.penalty;
            }
          }
        }
        return logits;
      }
    }

    class MinLengthLogitsProcessor extends LogitsProcessor {
      constructor(min_length, eos_token_id) {
        super();
        this.min_length = min_length;
        this.eos_token_id = Array.isArray(eos_token_id) ? eos_token_id : [eos_token_id];
      }
      _call(input_ids, logits) {
        for (let i = 0;i < input_ids.length; ++i) {
          if (input_ids[i].length < this.min_length) {
            const batch_logits_data = logits[i].data;
            for (const eos_token of this.eos_token_id) {
              batch_logits_data[eos_token] = -Infinity;
            }
          }
        }
        return logits;
      }
    }

    class MinNewTokensLengthLogitsProcessor extends LogitsProcessor {
      constructor(prompt_length_to_skip, min_new_tokens, eos_token_id) {
        super();
        this.prompt_length_to_skip = prompt_length_to_skip;
        this.min_new_tokens = min_new_tokens;
        this.eos_token_id = Array.isArray(eos_token_id) ? eos_token_id : [eos_token_id];
      }
      _call(input_ids, logits) {
        for (let i = 0;i < input_ids.length; ++i) {
          const new_tokens_length = input_ids[i].length - this.prompt_length_to_skip;
          if (new_tokens_length < this.min_new_tokens) {
            const batch_logits_data = logits[i].data;
            for (const eos_token of this.eos_token_id) {
              batch_logits_data[eos_token] = -Infinity;
            }
          }
        }
        return logits;
      }
    }

    class NoBadWordsLogitsProcessor extends LogitsProcessor {
      constructor(bad_words_ids, eos_token_id) {
        super();
        this.bad_words_ids = bad_words_ids;
        this.eos_token_id = Array.isArray(eos_token_id) ? eos_token_id : [eos_token_id];
      }
      _call(input_ids, logits) {
        for (let i = 0;i < input_ids.length; ++i) {
          const batch_logits_data = logits[i].data;
          const ids = input_ids[i];
          for (const bad_word_ids of this.bad_words_ids) {
            if (ids.length < bad_word_ids.length - 1)
              continue;
            let mark = true;
            for (let j = 1;j <= bad_word_ids.length - 1; ++j) {
              if (bad_word_ids.at(-j - 1) != ids.at(-j)) {
                mark = false;
                break;
              }
            }
            if (mark) {
              batch_logits_data[bad_word_ids.at(-1)] = -Infinity;
            }
          }
        }
        return logits;
      }
    }

    class ClassifierFreeGuidanceLogitsProcessor extends LogitsProcessor {
      constructor(guidance_scale) {
        super();
        if (guidance_scale <= 1) {
          throw new Error(`Require guidance scale >1 to use the classifier free guidance processor, got guidance scale ${guidance_scale}.`);
        }
        this.guidance_scale = guidance_scale;
      }
      _call(input_ids, logits) {
        if (logits.dims[0] !== 2 * input_ids.length) {
          throw new Error(`Logits should have twice the batch size of the input ids, the first half of batches corresponding to ` + `the conditional inputs, and the second half of batches corresponding to the unconditional inputs. Got ` + `batch size ${logits.dims[0]} for the logits and ${input_ids.length} for the input ids.`);
        }
        const unguided_bsz = input_ids.length;
        const cond_logits = logits.slice([0, unguided_bsz], null);
        const uncond_logits = logits.slice([unguided_bsz, logits.dims[0]], null);
        for (let i = 0;i < uncond_logits.data.length; ++i) {
          uncond_logits.data[i] += (cond_logits.data[i] - uncond_logits.data[i]) * this.guidance_scale;
        }
        return uncond_logits;
      }
    }

    class TemperatureLogitsWarper extends LogitsWarper {
      constructor(temperature) {
        super();
        if (typeof temperature !== "number" || temperature <= 0) {
          let errorMessage = `\`temperature\` (=${temperature}) must be a strictly positive float, otherwise your next token scores will be invalid.`;
          if (temperature === 0) {
            errorMessage += " If you're looking for greedy decoding strategies, set `do_sample=false`.";
          }
        }
        this.temperature = temperature;
      }
      _call(input_ids, logits) {
        const batch_logits_data = logits.data;
        for (let i = 0;i < batch_logits_data.length; ++i) {
          batch_logits_data[i] /= this.temperature;
        }
        return logits;
      }
    }

    class TopPLogitsWarper extends LogitsWarper {
      constructor(top_p, {
        filter_value = -Infinity,
        min_tokens_to_keep = 1
      } = {}) {
        super();
        if (top_p < 0 || top_p > 1) {
          throw new Error(`\`top_p\` must be a float > 0 and < 1, but is ${top_p}`);
        }
        if (!Number.isInteger(min_tokens_to_keep) || min_tokens_to_keep < 1) {
          throw new Error(`\`min_tokens_to_keep\` must be a positive integer, but is ${min_tokens_to_keep}`);
        }
        this.top_p = top_p;
        this.filter_value = filter_value;
        this.min_tokens_to_keep = min_tokens_to_keep;
      }
    }

    class TopKLogitsWarper extends LogitsWarper {
      constructor(top_k, {
        filter_value = -Infinity,
        min_tokens_to_keep = 1
      } = {}) {
        super();
        if (!Number.isInteger(top_k) || top_k < 0) {
          throw new Error(`\`top_k\` must be a positive integer, but is ${top_k}`);
        }
        this.top_k = Math.max(top_k, min_tokens_to_keep);
        this.filter_value = filter_value;
      }
    }
  },
  "./src/generation/logits_sampler.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!******************************************!*\
      !*** ./src/generation/logits_sampler.js ***!
      \******************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      LogitsSampler: () => LogitsSampler
    });
    var _utils_generic_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/utils/generic.js");
    /*! ../utils/generic.js */
    var _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/utils/tensor.js");
    /*! ../utils/tensor.js */
    var _utils_maths_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/utils/maths.js");
    /*! ../utils/maths.js */
    var _generation_configuration_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/generation/configuration_utils.js");
    /*! ../generation/configuration_utils.js */

    class LogitsSampler extends _utils_generic_js__WEBPACK_IMPORTED_MODULE_0__.Callable {
      constructor(generation_config) {
        super();
        this.generation_config = generation_config;
      }
      async _call(logits) {
        return this.sample(logits);
      }
      async sample(logits) {
        throw Error("sample should be implemented in subclasses.");
      }
      getLogits(logits, index) {
        let vocabSize = logits.dims.at(-1);
        let logs = logits.data;
        if (index === -1) {
          logs = logs.slice(-vocabSize);
        } else {
          let startIndex = index * vocabSize;
          logs = logs.slice(startIndex, startIndex + vocabSize);
        }
        return logs;
      }
      randomSelect(probabilities) {
        let sumProbabilities = 0;
        for (let i = 0;i < probabilities.length; ++i) {
          sumProbabilities += probabilities[i];
        }
        let r = Math.random() * sumProbabilities;
        for (let i = 0;i < probabilities.length; ++i) {
          r -= probabilities[i];
          if (r <= 0) {
            return i;
          }
        }
        return 0;
      }
      static getSampler(generation_config) {
        if (generation_config.do_sample) {
          return new MultinomialSampler(generation_config);
        } else if (generation_config.num_beams > 1) {
          return new BeamSearchSampler(generation_config);
        } else {
          if (generation_config.num_return_sequences > 1) {
            throw Error(`num_return_sequences has to be 1 when doing greedy search, but is ${generation_config.num_return_sequences}.`);
          }
          return new GreedySampler(generation_config);
        }
      }
    }

    class GreedySampler extends LogitsSampler {
      async sample(logits) {
        const argmax = (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.max)(logits.data)[1];
        return [
          [BigInt(argmax), 0]
        ];
      }
    }

    class MultinomialSampler extends LogitsSampler {
      async sample(logits) {
        let k = logits.dims.at(-1);
        if (this.generation_config.top_k > 0) {
          k = Math.min(this.generation_config.top_k, k);
        }
        const [v, i] = await (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__.topk)(logits, k);
        const probabilities = (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.softmax)(v.data);
        return Array.from({ length: this.generation_config.num_beams }, () => {
          const sampledIndex = this.randomSelect(probabilities);
          return [
            i.data[sampledIndex],
            Math.log(probabilities[sampledIndex])
          ];
        });
      }
    }

    class BeamSearchSampler extends LogitsSampler {
      async sample(logits) {
        let k = logits.dims.at(-1);
        if (this.generation_config.top_k > 0) {
          k = Math.min(this.generation_config.top_k, k);
        }
        const [v, i] = await (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__.topk)(logits, k);
        const probabilities = (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.softmax)(v.data);
        return Array.from({ length: this.generation_config.num_beams }, (_, x) => {
          return [
            i.data[x],
            Math.log(probabilities[x])
          ];
        });
      }
    }
  },
  "./src/generation/stopping_criteria.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!*********************************************!*\
      !*** ./src/generation/stopping_criteria.js ***!
      \*********************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      EosTokenCriteria: () => EosTokenCriteria,
      InterruptableStoppingCriteria: () => InterruptableStoppingCriteria,
      MaxLengthCriteria: () => MaxLengthCriteria,
      StoppingCriteria: () => StoppingCriteria,
      StoppingCriteriaList: () => StoppingCriteriaList
    });
    var _utils_generic_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/utils/generic.js");
    /*! ../utils/generic.js */

    class StoppingCriteria extends _utils_generic_js__WEBPACK_IMPORTED_MODULE_0__.Callable {
      _call(input_ids, scores) {
        throw Error("StoppingCriteria needs to be subclassed");
      }
    }

    class StoppingCriteriaList extends _utils_generic_js__WEBPACK_IMPORTED_MODULE_0__.Callable {
      constructor() {
        super();
        this.criteria = [];
      }
      push(item) {
        this.criteria.push(item);
      }
      extend(items) {
        if (items instanceof StoppingCriteriaList) {
          items = items.criteria;
        } else if (items instanceof StoppingCriteria) {
          items = [items];
        }
        this.criteria.push(...items);
      }
      _call(input_ids, scores) {
        const is_done = new Array(input_ids.length).fill(false);
        for (const criterion of this.criteria) {
          const criterion_done = criterion(input_ids, scores);
          for (let i = 0;i < is_done.length; ++i) {
            is_done[i] ||= criterion_done[i];
          }
        }
        return is_done;
      }
      [Symbol.iterator]() {
        return this.criteria.values();
      }
    }

    class MaxLengthCriteria extends StoppingCriteria {
      constructor(max_length, max_position_embeddings = null) {
        super();
        this.max_length = max_length;
        this.max_position_embeddings = max_position_embeddings;
      }
      _call(input_ids) {
        return input_ids.map((ids) => ids.length >= this.max_length);
      }
    }

    class EosTokenCriteria extends StoppingCriteria {
      constructor(eos_token_id) {
        super();
        if (!Array.isArray(eos_token_id)) {
          eos_token_id = [eos_token_id];
        }
        this.eos_token_id = eos_token_id;
      }
      _call(input_ids, scores) {
        return input_ids.map((ids) => {
          const last = ids.at(-1);
          return this.eos_token_id.some((eos_id) => last == eos_id);
        });
      }
    }

    class InterruptableStoppingCriteria extends StoppingCriteria {
      constructor() {
        super();
        this.interrupted = false;
      }
      interrupt() {
        this.interrupted = true;
      }
      reset() {
        this.interrupted = false;
      }
      _call(input_ids, scores) {
        return new Array(input_ids.length).fill(this.interrupted);
      }
    }
  },
  "./src/generation/streamers.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!*************************************!*\
      !*** ./src/generation/streamers.js ***!
      \*************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      BaseStreamer: () => BaseStreamer,
      TextStreamer: () => TextStreamer,
      WhisperTextStreamer: () => WhisperTextStreamer
    });
    var _utils_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/utils/core.js");
    /*! ../utils/core.js */
    var _tokenizers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/tokenizers.js");
    /*! ../tokenizers.js */
    var _env_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/env.js");
    /*! ../env.js */

    class BaseStreamer {
      put(value) {
        throw Error("Not implemented");
      }
      end() {
        throw Error("Not implemented");
      }
    }
    const stdout_write = _env_js__WEBPACK_IMPORTED_MODULE_2__.apis.IS_PROCESS_AVAILABLE ? (x) => process.stdout.write(x) : (x) => console.log(x);

    class TextStreamer extends BaseStreamer {
      constructor(tokenizer, {
        skip_prompt = false,
        callback_function = null,
        token_callback_function = null,
        skip_special_tokens = true,
        decode_kwargs = {},
        ...kwargs
      } = {}) {
        super();
        this.tokenizer = tokenizer;
        this.skip_prompt = skip_prompt;
        this.callback_function = callback_function ?? stdout_write;
        this.token_callback_function = token_callback_function;
        this.decode_kwargs = { skip_special_tokens, ...decode_kwargs, ...kwargs };
        this.token_cache = [];
        this.print_len = 0;
        this.next_tokens_are_prompt = true;
      }
      put(value) {
        if (value.length > 1) {
          throw Error("TextStreamer only supports batch size of 1");
        }
        const is_prompt = this.next_tokens_are_prompt;
        if (is_prompt) {
          this.next_tokens_are_prompt = false;
          if (this.skip_prompt)
            return;
        }
        const tokens = value[0];
        this.token_callback_function?.(tokens);
        this.token_cache = (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(this.token_cache, tokens);
        const text = this.tokenizer.decode(this.token_cache, this.decode_kwargs);
        let printable_text;
        if (is_prompt || text.endsWith(`
`)) {
          printable_text = text.slice(this.print_len);
          this.token_cache = [];
          this.print_len = 0;
        } else if (text.length > 0 && (0, _tokenizers_js__WEBPACK_IMPORTED_MODULE_1__.is_chinese_char)(text.charCodeAt(text.length - 1))) {
          printable_text = text.slice(this.print_len);
          this.print_len += printable_text.length;
        } else {
          printable_text = text.slice(this.print_len, text.lastIndexOf(" ") + 1);
          this.print_len += printable_text.length;
        }
        this.on_finalized_text(printable_text, false);
      }
      end() {
        let printable_text;
        if (this.token_cache.length > 0) {
          const text = this.tokenizer.decode(this.token_cache, this.decode_kwargs);
          printable_text = text.slice(this.print_len);
          this.token_cache = [];
          this.print_len = 0;
        } else {
          printable_text = "";
        }
        this.next_tokens_are_prompt = true;
        this.on_finalized_text(printable_text, true);
      }
      on_finalized_text(text, stream_end) {
        if (text.length > 0) {
          this.callback_function?.(text);
        }
        if (stream_end && this.callback_function === stdout_write && _env_js__WEBPACK_IMPORTED_MODULE_2__.apis.IS_PROCESS_AVAILABLE) {
          this.callback_function?.(`
`);
        }
      }
    }

    class WhisperTextStreamer extends TextStreamer {
      constructor(tokenizer, {
        skip_prompt = false,
        callback_function = null,
        token_callback_function = null,
        on_chunk_start = null,
        on_chunk_end = null,
        on_finalize = null,
        time_precision = 0.02,
        skip_special_tokens = true,
        decode_kwargs = {}
      } = {}) {
        super(tokenizer, {
          skip_prompt,
          skip_special_tokens,
          callback_function,
          token_callback_function,
          decode_kwargs
        });
        this.timestamp_begin = tokenizer.timestamp_begin;
        this.on_chunk_start = on_chunk_start;
        this.on_chunk_end = on_chunk_end;
        this.on_finalize = on_finalize;
        this.time_precision = time_precision;
        this.waiting_for_timestamp = false;
      }
      put(value) {
        if (value.length > 1) {
          throw Error("WhisperTextStreamer only supports batch size of 1");
        }
        const tokens = value[0];
        if (tokens.length === 1) {
          const offset = Number(tokens[0]) - this.timestamp_begin;
          if (offset >= 0) {
            const time5 = offset * this.time_precision;
            if (this.waiting_for_timestamp) {
              this.on_chunk_end?.(time5);
            } else {
              this.on_chunk_start?.(time5);
            }
            this.waiting_for_timestamp = !this.waiting_for_timestamp;
            this.token_callback_function?.(tokens);
            return;
          }
        }
        return super.put(value);
      }
      end() {
        super.end();
        this.on_finalize?.();
      }
    }
  },
  "./src/models.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!***********************!*\
      !*** ./src/models.js ***!
      \***********************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      ASTForAudioClassification: () => ASTForAudioClassification,
      ASTModel: () => ASTModel,
      ASTPreTrainedModel: () => ASTPreTrainedModel,
      AlbertForMaskedLM: () => AlbertForMaskedLM,
      AlbertForQuestionAnswering: () => AlbertForQuestionAnswering,
      AlbertForSequenceClassification: () => AlbertForSequenceClassification,
      AlbertModel: () => AlbertModel,
      AlbertPreTrainedModel: () => AlbertPreTrainedModel,
      ArceeForCausalLM: () => ArceeForCausalLM,
      ArceeModel: () => ArceeModel,
      ArceePreTrainedModel: () => ArceePreTrainedModel,
      AutoModel: () => AutoModel,
      AutoModelForAudioClassification: () => AutoModelForAudioClassification,
      AutoModelForAudioFrameClassification: () => AutoModelForAudioFrameClassification,
      AutoModelForAudioTextToText: () => AutoModelForAudioTextToText,
      AutoModelForCTC: () => AutoModelForCTC,
      AutoModelForCausalLM: () => AutoModelForCausalLM,
      AutoModelForDepthEstimation: () => AutoModelForDepthEstimation,
      AutoModelForDocumentQuestionAnswering: () => AutoModelForDocumentQuestionAnswering,
      AutoModelForImageClassification: () => AutoModelForImageClassification,
      AutoModelForImageFeatureExtraction: () => AutoModelForImageFeatureExtraction,
      AutoModelForImageMatting: () => AutoModelForImageMatting,
      AutoModelForImageSegmentation: () => AutoModelForImageSegmentation,
      AutoModelForImageTextToText: () => AutoModelForImageTextToText,
      AutoModelForImageToImage: () => AutoModelForImageToImage,
      AutoModelForMaskGeneration: () => AutoModelForMaskGeneration,
      AutoModelForMaskedLM: () => AutoModelForMaskedLM,
      AutoModelForNormalEstimation: () => AutoModelForNormalEstimation,
      AutoModelForObjectDetection: () => AutoModelForObjectDetection,
      AutoModelForPoseEstimation: () => AutoModelForPoseEstimation,
      AutoModelForQuestionAnswering: () => AutoModelForQuestionAnswering,
      AutoModelForSemanticSegmentation: () => AutoModelForSemanticSegmentation,
      AutoModelForSeq2SeqLM: () => AutoModelForSeq2SeqLM,
      AutoModelForSequenceClassification: () => AutoModelForSequenceClassification,
      AutoModelForSpeechSeq2Seq: () => AutoModelForSpeechSeq2Seq,
      AutoModelForTextToSpectrogram: () => AutoModelForTextToSpectrogram,
      AutoModelForTextToWaveform: () => AutoModelForTextToWaveform,
      AutoModelForTokenClassification: () => AutoModelForTokenClassification,
      AutoModelForUniversalSegmentation: () => AutoModelForUniversalSegmentation,
      AutoModelForVision2Seq: () => AutoModelForVision2Seq,
      AutoModelForXVector: () => AutoModelForXVector,
      AutoModelForZeroShotObjectDetection: () => AutoModelForZeroShotObjectDetection,
      BartForConditionalGeneration: () => BartForConditionalGeneration,
      BartForSequenceClassification: () => BartForSequenceClassification,
      BartModel: () => BartModel,
      BartPretrainedModel: () => BartPretrainedModel,
      BaseModelOutput: () => BaseModelOutput,
      BeitForImageClassification: () => BeitForImageClassification,
      BeitModel: () => BeitModel,
      BeitPreTrainedModel: () => BeitPreTrainedModel,
      BertForMaskedLM: () => BertForMaskedLM,
      BertForQuestionAnswering: () => BertForQuestionAnswering,
      BertForSequenceClassification: () => BertForSequenceClassification,
      BertForTokenClassification: () => BertForTokenClassification,
      BertModel: () => BertModel,
      BertPreTrainedModel: () => BertPreTrainedModel,
      BlenderbotForConditionalGeneration: () => BlenderbotForConditionalGeneration,
      BlenderbotModel: () => BlenderbotModel,
      BlenderbotPreTrainedModel: () => BlenderbotPreTrainedModel,
      BlenderbotSmallForConditionalGeneration: () => BlenderbotSmallForConditionalGeneration,
      BlenderbotSmallModel: () => BlenderbotSmallModel,
      BlenderbotSmallPreTrainedModel: () => BlenderbotSmallPreTrainedModel,
      BloomForCausalLM: () => BloomForCausalLM,
      BloomModel: () => BloomModel,
      BloomPreTrainedModel: () => BloomPreTrainedModel,
      CLIPModel: () => CLIPModel,
      CLIPPreTrainedModel: () => CLIPPreTrainedModel,
      CLIPSegForImageSegmentation: () => CLIPSegForImageSegmentation,
      CLIPSegModel: () => CLIPSegModel,
      CLIPSegPreTrainedModel: () => CLIPSegPreTrainedModel,
      CLIPTextModel: () => CLIPTextModel,
      CLIPTextModelWithProjection: () => CLIPTextModelWithProjection,
      CLIPVisionModel: () => CLIPVisionModel,
      CLIPVisionModelWithProjection: () => CLIPVisionModelWithProjection,
      CamembertForMaskedLM: () => CamembertForMaskedLM,
      CamembertForQuestionAnswering: () => CamembertForQuestionAnswering,
      CamembertForSequenceClassification: () => CamembertForSequenceClassification,
      CamembertForTokenClassification: () => CamembertForTokenClassification,
      CamembertModel: () => CamembertModel,
      CamembertPreTrainedModel: () => CamembertPreTrainedModel,
      CausalLMOutput: () => CausalLMOutput,
      CausalLMOutputWithPast: () => CausalLMOutputWithPast,
      ChineseCLIPModel: () => ChineseCLIPModel,
      ChineseCLIPPreTrainedModel: () => ChineseCLIPPreTrainedModel,
      ClapAudioModelWithProjection: () => ClapAudioModelWithProjection,
      ClapModel: () => ClapModel,
      ClapPreTrainedModel: () => ClapPreTrainedModel,
      ClapTextModelWithProjection: () => ClapTextModelWithProjection,
      CodeGenForCausalLM: () => CodeGenForCausalLM,
      CodeGenModel: () => CodeGenModel,
      CodeGenPreTrainedModel: () => CodeGenPreTrainedModel,
      CohereForCausalLM: () => CohereForCausalLM,
      CohereModel: () => CohereModel,
      CoherePreTrainedModel: () => CoherePreTrainedModel,
      ConvBertForMaskedLM: () => ConvBertForMaskedLM,
      ConvBertForQuestionAnswering: () => ConvBertForQuestionAnswering,
      ConvBertForSequenceClassification: () => ConvBertForSequenceClassification,
      ConvBertForTokenClassification: () => ConvBertForTokenClassification,
      ConvBertModel: () => ConvBertModel,
      ConvBertPreTrainedModel: () => ConvBertPreTrainedModel,
      ConvNextForImageClassification: () => ConvNextForImageClassification,
      ConvNextModel: () => ConvNextModel,
      ConvNextPreTrainedModel: () => ConvNextPreTrainedModel,
      ConvNextV2ForImageClassification: () => ConvNextV2ForImageClassification,
      ConvNextV2Model: () => ConvNextV2Model,
      ConvNextV2PreTrainedModel: () => ConvNextV2PreTrainedModel,
      DFineForObjectDetection: () => DFineForObjectDetection,
      DFineModel: () => DFineModel,
      DFinePreTrainedModel: () => DFinePreTrainedModel,
      DINOv3ConvNextModel: () => DINOv3ConvNextModel,
      DINOv3ConvNextPreTrainedModel: () => DINOv3ConvNextPreTrainedModel,
      DINOv3ViTModel: () => DINOv3ViTModel,
      DINOv3ViTPreTrainedModel: () => DINOv3ViTPreTrainedModel,
      DPTForDepthEstimation: () => DPTForDepthEstimation,
      DPTModel: () => DPTModel,
      DPTPreTrainedModel: () => DPTPreTrainedModel,
      DacDecoderModel: () => DacDecoderModel,
      DacDecoderOutput: () => DacDecoderOutput,
      DacEncoderModel: () => DacEncoderModel,
      DacEncoderOutput: () => DacEncoderOutput,
      DacModel: () => DacModel,
      DacPreTrainedModel: () => DacPreTrainedModel,
      DebertaForMaskedLM: () => DebertaForMaskedLM,
      DebertaForQuestionAnswering: () => DebertaForQuestionAnswering,
      DebertaForSequenceClassification: () => DebertaForSequenceClassification,
      DebertaForTokenClassification: () => DebertaForTokenClassification,
      DebertaModel: () => DebertaModel,
      DebertaPreTrainedModel: () => DebertaPreTrainedModel,
      DebertaV2ForMaskedLM: () => DebertaV2ForMaskedLM,
      DebertaV2ForQuestionAnswering: () => DebertaV2ForQuestionAnswering,
      DebertaV2ForSequenceClassification: () => DebertaV2ForSequenceClassification,
      DebertaV2ForTokenClassification: () => DebertaV2ForTokenClassification,
      DebertaV2Model: () => DebertaV2Model,
      DebertaV2PreTrainedModel: () => DebertaV2PreTrainedModel,
      DecisionTransformerModel: () => DecisionTransformerModel,
      DecisionTransformerPreTrainedModel: () => DecisionTransformerPreTrainedModel,
      DeiTForImageClassification: () => DeiTForImageClassification,
      DeiTModel: () => DeiTModel,
      DeiTPreTrainedModel: () => DeiTPreTrainedModel,
      DepthAnythingForDepthEstimation: () => DepthAnythingForDepthEstimation,
      DepthAnythingPreTrainedModel: () => DepthAnythingPreTrainedModel,
      DepthProForDepthEstimation: () => DepthProForDepthEstimation,
      DepthProPreTrainedModel: () => DepthProPreTrainedModel,
      DetrForObjectDetection: () => DetrForObjectDetection,
      DetrForSegmentation: () => DetrForSegmentation,
      DetrModel: () => DetrModel,
      DetrObjectDetectionOutput: () => DetrObjectDetectionOutput,
      DetrPreTrainedModel: () => DetrPreTrainedModel,
      DetrSegmentationOutput: () => DetrSegmentationOutput,
      Dinov2ForImageClassification: () => Dinov2ForImageClassification,
      Dinov2Model: () => Dinov2Model,
      Dinov2PreTrainedModel: () => Dinov2PreTrainedModel,
      Dinov2WithRegistersForImageClassification: () => Dinov2WithRegistersForImageClassification,
      Dinov2WithRegistersModel: () => Dinov2WithRegistersModel,
      Dinov2WithRegistersPreTrainedModel: () => Dinov2WithRegistersPreTrainedModel,
      DistilBertForMaskedLM: () => DistilBertForMaskedLM,
      DistilBertForQuestionAnswering: () => DistilBertForQuestionAnswering,
      DistilBertForSequenceClassification: () => DistilBertForSequenceClassification,
      DistilBertForTokenClassification: () => DistilBertForTokenClassification,
      DistilBertModel: () => DistilBertModel,
      DistilBertPreTrainedModel: () => DistilBertPreTrainedModel,
      DonutSwinModel: () => DonutSwinModel,
      DonutSwinPreTrainedModel: () => DonutSwinPreTrainedModel,
      EdgeTamModel: () => EdgeTamModel,
      EfficientNetForImageClassification: () => EfficientNetForImageClassification,
      EfficientNetModel: () => EfficientNetModel,
      EfficientNetPreTrainedModel: () => EfficientNetPreTrainedModel,
      ElectraForMaskedLM: () => ElectraForMaskedLM,
      ElectraForQuestionAnswering: () => ElectraForQuestionAnswering,
      ElectraForSequenceClassification: () => ElectraForSequenceClassification,
      ElectraForTokenClassification: () => ElectraForTokenClassification,
      ElectraModel: () => ElectraModel,
      ElectraPreTrainedModel: () => ElectraPreTrainedModel,
      Ernie4_5ForCausalLM: () => Ernie4_5ForCausalLM,
      Ernie4_5Model: () => Ernie4_5Model,
      Ernie4_5PreTrainedModel: () => Ernie4_5PreTrainedModel,
      EsmForMaskedLM: () => EsmForMaskedLM,
      EsmForSequenceClassification: () => EsmForSequenceClassification,
      EsmForTokenClassification: () => EsmForTokenClassification,
      EsmModel: () => EsmModel,
      EsmPreTrainedModel: () => EsmPreTrainedModel,
      ExaoneForCausalLM: () => ExaoneForCausalLM,
      ExaoneModel: () => ExaoneModel,
      ExaonePreTrainedModel: () => ExaonePreTrainedModel,
      FalconForCausalLM: () => FalconForCausalLM,
      FalconModel: () => FalconModel,
      FalconPreTrainedModel: () => FalconPreTrainedModel,
      FastViTForImageClassification: () => FastViTForImageClassification,
      FastViTModel: () => FastViTModel,
      FastViTPreTrainedModel: () => FastViTPreTrainedModel,
      Florence2ForConditionalGeneration: () => Florence2ForConditionalGeneration,
      Florence2PreTrainedModel: () => Florence2PreTrainedModel,
      GLPNForDepthEstimation: () => GLPNForDepthEstimation,
      GLPNModel: () => GLPNModel,
      GLPNPreTrainedModel: () => GLPNPreTrainedModel,
      GPT2LMHeadModel: () => GPT2LMHeadModel,
      GPT2Model: () => GPT2Model,
      GPT2PreTrainedModel: () => GPT2PreTrainedModel,
      GPTBigCodeForCausalLM: () => GPTBigCodeForCausalLM,
      GPTBigCodeModel: () => GPTBigCodeModel,
      GPTBigCodePreTrainedModel: () => GPTBigCodePreTrainedModel,
      GPTJForCausalLM: () => GPTJForCausalLM,
      GPTJModel: () => GPTJModel,
      GPTJPreTrainedModel: () => GPTJPreTrainedModel,
      GPTNeoForCausalLM: () => GPTNeoForCausalLM,
      GPTNeoModel: () => GPTNeoModel,
      GPTNeoPreTrainedModel: () => GPTNeoPreTrainedModel,
      GPTNeoXForCausalLM: () => GPTNeoXForCausalLM,
      GPTNeoXModel: () => GPTNeoXModel,
      GPTNeoXPreTrainedModel: () => GPTNeoXPreTrainedModel,
      Gemma2ForCausalLM: () => Gemma2ForCausalLM,
      Gemma2Model: () => Gemma2Model,
      Gemma2PreTrainedModel: () => Gemma2PreTrainedModel,
      Gemma3ForCausalLM: () => Gemma3ForCausalLM,
      Gemma3Model: () => Gemma3Model,
      Gemma3PreTrainedModel: () => Gemma3PreTrainedModel,
      Gemma3nForConditionalGeneration: () => Gemma3nForConditionalGeneration,
      Gemma3nPreTrainedModel: () => Gemma3nPreTrainedModel,
      GemmaForCausalLM: () => GemmaForCausalLM,
      GemmaModel: () => GemmaModel,
      GemmaPreTrainedModel: () => GemmaPreTrainedModel,
      GlmForCausalLM: () => GlmForCausalLM,
      GlmModel: () => GlmModel,
      GlmPreTrainedModel: () => GlmPreTrainedModel,
      GraniteForCausalLM: () => GraniteForCausalLM,
      GraniteModel: () => GraniteModel,
      GraniteMoeHybridForCausalLM: () => GraniteMoeHybridForCausalLM,
      GraniteMoeHybridModel: () => GraniteMoeHybridModel,
      GraniteMoeHybridPreTrainedModel: () => GraniteMoeHybridPreTrainedModel,
      GranitePreTrainedModel: () => GranitePreTrainedModel,
      GroundingDinoForObjectDetection: () => GroundingDinoForObjectDetection,
      GroundingDinoPreTrainedModel: () => GroundingDinoPreTrainedModel,
      GroupViTModel: () => GroupViTModel,
      GroupViTPreTrainedModel: () => GroupViTPreTrainedModel,
      HeliumForCausalLM: () => HeliumForCausalLM,
      HeliumModel: () => HeliumModel,
      HeliumPreTrainedModel: () => HeliumPreTrainedModel,
      HieraForImageClassification: () => HieraForImageClassification,
      HieraModel: () => HieraModel,
      HieraPreTrainedModel: () => HieraPreTrainedModel,
      HubertForCTC: () => HubertForCTC,
      HubertForSequenceClassification: () => HubertForSequenceClassification,
      HubertModel: () => HubertModel,
      HubertPreTrainedModel: () => HubertPreTrainedModel,
      IJepaForImageClassification: () => IJepaForImageClassification,
      IJepaModel: () => IJepaModel,
      IJepaPreTrainedModel: () => IJepaPreTrainedModel,
      Idefics3ForConditionalGeneration: () => Idefics3ForConditionalGeneration,
      Idefics3PreTrainedModel: () => Idefics3PreTrainedModel,
      ImageMattingOutput: () => ImageMattingOutput,
      JAISLMHeadModel: () => JAISLMHeadModel,
      JAISModel: () => JAISModel,
      JAISPreTrainedModel: () => JAISPreTrainedModel,
      JinaCLIPModel: () => JinaCLIPModel,
      JinaCLIPPreTrainedModel: () => JinaCLIPPreTrainedModel,
      JinaCLIPTextModel: () => JinaCLIPTextModel,
      JinaCLIPVisionModel: () => JinaCLIPVisionModel,
      Lfm2ForCausalLM: () => Lfm2ForCausalLM,
      Lfm2Model: () => Lfm2Model,
      Lfm2PreTrainedModel: () => Lfm2PreTrainedModel,
      LiteWhisperForConditionalGeneration: () => LiteWhisperForConditionalGeneration,
      Llama4ForCausalLM: () => Llama4ForCausalLM,
      Llama4PreTrainedModel: () => Llama4PreTrainedModel,
      LlamaForCausalLM: () => LlamaForCausalLM,
      LlamaModel: () => LlamaModel,
      LlamaPreTrainedModel: () => LlamaPreTrainedModel,
      LlavaForConditionalGeneration: () => LlavaForConditionalGeneration,
      LlavaOnevisionForConditionalGeneration: () => LlavaOnevisionForConditionalGeneration,
      LlavaPreTrainedModel: () => LlavaPreTrainedModel,
      LlavaQwen2ForCausalLM: () => LlavaQwen2ForCausalLM,
      LongT5ForConditionalGeneration: () => LongT5ForConditionalGeneration,
      LongT5Model: () => LongT5Model,
      LongT5PreTrainedModel: () => LongT5PreTrainedModel,
      M2M100ForConditionalGeneration: () => M2M100ForConditionalGeneration,
      M2M100Model: () => M2M100Model,
      M2M100PreTrainedModel: () => M2M100PreTrainedModel,
      MBartForCausalLM: () => MBartForCausalLM,
      MBartForConditionalGeneration: () => MBartForConditionalGeneration,
      MBartForSequenceClassification: () => MBartForSequenceClassification,
      MBartModel: () => MBartModel,
      MBartPreTrainedModel: () => MBartPreTrainedModel,
      MPNetForMaskedLM: () => MPNetForMaskedLM,
      MPNetForQuestionAnswering: () => MPNetForQuestionAnswering,
      MPNetForSequenceClassification: () => MPNetForSequenceClassification,
      MPNetForTokenClassification: () => MPNetForTokenClassification,
      MPNetModel: () => MPNetModel,
      MPNetPreTrainedModel: () => MPNetPreTrainedModel,
      MT5ForConditionalGeneration: () => MT5ForConditionalGeneration,
      MT5Model: () => MT5Model,
      MT5PreTrainedModel: () => MT5PreTrainedModel,
      MarianMTModel: () => MarianMTModel,
      MarianModel: () => MarianModel,
      MarianPreTrainedModel: () => MarianPreTrainedModel,
      MaskFormerForInstanceSegmentation: () => MaskFormerForInstanceSegmentation,
      MaskFormerModel: () => MaskFormerModel,
      MaskFormerPreTrainedModel: () => MaskFormerPreTrainedModel,
      MaskedLMOutput: () => MaskedLMOutput,
      Metric3DForDepthEstimation: () => Metric3DForDepthEstimation,
      Metric3DPreTrainedModel: () => Metric3DPreTrainedModel,
      Metric3Dv2ForDepthEstimation: () => Metric3Dv2ForDepthEstimation,
      Metric3Dv2PreTrainedModel: () => Metric3Dv2PreTrainedModel,
      MgpstrForSceneTextRecognition: () => MgpstrForSceneTextRecognition,
      MgpstrModelOutput: () => MgpstrModelOutput,
      MgpstrPreTrainedModel: () => MgpstrPreTrainedModel,
      MimiDecoderModel: () => MimiDecoderModel,
      MimiDecoderOutput: () => MimiDecoderOutput,
      MimiEncoderModel: () => MimiEncoderModel,
      MimiEncoderOutput: () => MimiEncoderOutput,
      MimiModel: () => MimiModel,
      MimiPreTrainedModel: () => MimiPreTrainedModel,
      Ministral3ForCausalLM: () => Ministral3ForCausalLM,
      Ministral3Model: () => Ministral3Model,
      Ministral3PreTrainedModel: () => Ministral3PreTrainedModel,
      MinistralForCausalLM: () => MinistralForCausalLM,
      MinistralModel: () => MinistralModel,
      MinistralPreTrainedModel: () => MinistralPreTrainedModel,
      Mistral3ForConditionalGeneration: () => Mistral3ForConditionalGeneration,
      MistralForCausalLM: () => MistralForCausalLM,
      MistralModel: () => MistralModel,
      MistralPreTrainedModel: () => MistralPreTrainedModel,
      MobileBertForMaskedLM: () => MobileBertForMaskedLM,
      MobileBertForQuestionAnswering: () => MobileBertForQuestionAnswering,
      MobileBertForSequenceClassification: () => MobileBertForSequenceClassification,
      MobileBertModel: () => MobileBertModel,
      MobileBertPreTrainedModel: () => MobileBertPreTrainedModel,
      MobileLLMForCausalLM: () => MobileLLMForCausalLM,
      MobileLLMModel: () => MobileLLMModel,
      MobileLLMPreTrainedModel: () => MobileLLMPreTrainedModel,
      MobileNetV1ForImageClassification: () => MobileNetV1ForImageClassification,
      MobileNetV1ForSemanticSegmentation: () => MobileNetV1ForSemanticSegmentation,
      MobileNetV1Model: () => MobileNetV1Model,
      MobileNetV1PreTrainedModel: () => MobileNetV1PreTrainedModel,
      MobileNetV2ForImageClassification: () => MobileNetV2ForImageClassification,
      MobileNetV2ForSemanticSegmentation: () => MobileNetV2ForSemanticSegmentation,
      MobileNetV2Model: () => MobileNetV2Model,
      MobileNetV2PreTrainedModel: () => MobileNetV2PreTrainedModel,
      MobileNetV3ForImageClassification: () => MobileNetV3ForImageClassification,
      MobileNetV3ForSemanticSegmentation: () => MobileNetV3ForSemanticSegmentation,
      MobileNetV3Model: () => MobileNetV3Model,
      MobileNetV3PreTrainedModel: () => MobileNetV3PreTrainedModel,
      MobileNetV4ForImageClassification: () => MobileNetV4ForImageClassification,
      MobileNetV4ForSemanticSegmentation: () => MobileNetV4ForSemanticSegmentation,
      MobileNetV4Model: () => MobileNetV4Model,
      MobileNetV4PreTrainedModel: () => MobileNetV4PreTrainedModel,
      MobileViTForImageClassification: () => MobileViTForImageClassification,
      MobileViTModel: () => MobileViTModel,
      MobileViTPreTrainedModel: () => MobileViTPreTrainedModel,
      MobileViTV2ForImageClassification: () => MobileViTV2ForImageClassification,
      MobileViTV2Model: () => MobileViTV2Model,
      MobileViTV2PreTrainedModel: () => MobileViTV2PreTrainedModel,
      ModelOutput: () => ModelOutput,
      ModernBertDecoderForCausalLM: () => ModernBertDecoderForCausalLM,
      ModernBertDecoderModel: () => ModernBertDecoderModel,
      ModernBertDecoderPreTrainedModel: () => ModernBertDecoderPreTrainedModel,
      ModernBertForMaskedLM: () => ModernBertForMaskedLM,
      ModernBertForSequenceClassification: () => ModernBertForSequenceClassification,
      ModernBertForTokenClassification: () => ModernBertForTokenClassification,
      ModernBertModel: () => ModernBertModel,
      ModernBertPreTrainedModel: () => ModernBertPreTrainedModel,
      Moondream1ForConditionalGeneration: () => Moondream1ForConditionalGeneration,
      MoonshineForConditionalGeneration: () => MoonshineForConditionalGeneration,
      MoonshineModel: () => MoonshineModel,
      MoonshinePreTrainedModel: () => MoonshinePreTrainedModel,
      MptForCausalLM: () => MptForCausalLM,
      MptModel: () => MptModel,
      MptPreTrainedModel: () => MptPreTrainedModel,
      MultiModalityCausalLM: () => MultiModalityCausalLM,
      MultiModalityPreTrainedModel: () => MultiModalityPreTrainedModel,
      MusicgenForCausalLM: () => MusicgenForCausalLM,
      MusicgenForConditionalGeneration: () => MusicgenForConditionalGeneration,
      MusicgenModel: () => MusicgenModel,
      MusicgenPreTrainedModel: () => MusicgenPreTrainedModel,
      NanoChatForCausalLM: () => NanoChatForCausalLM,
      NanoChatModel: () => NanoChatModel,
      NanoChatPreTrainedModel: () => NanoChatPreTrainedModel,
      NeoBertForMaskedLM: () => NeoBertForMaskedLM,
      NeoBertForQuestionAnswering: () => NeoBertForQuestionAnswering,
      NeoBertForSequenceClassification: () => NeoBertForSequenceClassification,
      NeoBertForTokenClassification: () => NeoBertForTokenClassification,
      NeoBertModel: () => NeoBertModel,
      NeoBertPreTrainedModel: () => NeoBertPreTrainedModel,
      NomicBertModel: () => NomicBertModel,
      NomicBertPreTrainedModel: () => NomicBertPreTrainedModel,
      OPTForCausalLM: () => OPTForCausalLM,
      OPTModel: () => OPTModel,
      OPTPreTrainedModel: () => OPTPreTrainedModel,
      Olmo2ForCausalLM: () => Olmo2ForCausalLM,
      Olmo2Model: () => Olmo2Model,
      Olmo2PreTrainedModel: () => Olmo2PreTrainedModel,
      OlmoForCausalLM: () => OlmoForCausalLM,
      OlmoModel: () => OlmoModel,
      OlmoPreTrainedModel: () => OlmoPreTrainedModel,
      OpenELMForCausalLM: () => OpenELMForCausalLM,
      OpenELMModel: () => OpenELMModel,
      OpenELMPreTrainedModel: () => OpenELMPreTrainedModel,
      OwlViTForObjectDetection: () => OwlViTForObjectDetection,
      OwlViTModel: () => OwlViTModel,
      OwlViTPreTrainedModel: () => OwlViTPreTrainedModel,
      Owlv2ForObjectDetection: () => Owlv2ForObjectDetection,
      Owlv2Model: () => Owlv2Model,
      Owlv2PreTrainedModel: () => Owlv2PreTrainedModel,
      PaliGemmaForConditionalGeneration: () => PaliGemmaForConditionalGeneration,
      PaliGemmaPreTrainedModel: () => PaliGemmaPreTrainedModel,
      ParakeetForCTC: () => ParakeetForCTC,
      ParakeetPreTrainedModel: () => ParakeetPreTrainedModel,
      PatchTSMixerForPrediction: () => PatchTSMixerForPrediction,
      PatchTSMixerModel: () => PatchTSMixerModel,
      PatchTSMixerPreTrainedModel: () => PatchTSMixerPreTrainedModel,
      PatchTSTForPrediction: () => PatchTSTForPrediction,
      PatchTSTModel: () => PatchTSTModel,
      PatchTSTPreTrainedModel: () => PatchTSTPreTrainedModel,
      Phi3ForCausalLM: () => Phi3ForCausalLM,
      Phi3Model: () => Phi3Model,
      Phi3PreTrainedModel: () => Phi3PreTrainedModel,
      Phi3VForCausalLM: () => Phi3VForCausalLM,
      Phi3VPreTrainedModel: () => Phi3VPreTrainedModel,
      PhiForCausalLM: () => PhiForCausalLM,
      PhiModel: () => PhiModel,
      PhiPreTrainedModel: () => PhiPreTrainedModel,
      PreTrainedModel: () => PreTrainedModel,
      PretrainedMixin: () => PretrainedMixin,
      PvtForImageClassification: () => PvtForImageClassification,
      PvtModel: () => PvtModel,
      PvtPreTrainedModel: () => PvtPreTrainedModel,
      PyAnnoteForAudioFrameClassification: () => PyAnnoteForAudioFrameClassification,
      PyAnnoteModel: () => PyAnnoteModel,
      PyAnnotePreTrainedModel: () => PyAnnotePreTrainedModel,
      QuestionAnsweringModelOutput: () => QuestionAnsweringModelOutput,
      Qwen2ForCausalLM: () => Qwen2ForCausalLM,
      Qwen2Model: () => Qwen2Model,
      Qwen2PreTrainedModel: () => Qwen2PreTrainedModel,
      Qwen2VLForConditionalGeneration: () => Qwen2VLForConditionalGeneration,
      Qwen2VLPreTrainedModel: () => Qwen2VLPreTrainedModel,
      Qwen3ForCausalLM: () => Qwen3ForCausalLM,
      Qwen3Model: () => Qwen3Model,
      Qwen3PreTrainedModel: () => Qwen3PreTrainedModel,
      RFDetrForObjectDetection: () => RFDetrForObjectDetection,
      RFDetrModel: () => RFDetrModel,
      RFDetrObjectDetectionOutput: () => RFDetrObjectDetectionOutput,
      RFDetrPreTrainedModel: () => RFDetrPreTrainedModel,
      RTDetrForObjectDetection: () => RTDetrForObjectDetection,
      RTDetrModel: () => RTDetrModel,
      RTDetrObjectDetectionOutput: () => RTDetrObjectDetectionOutput,
      RTDetrPreTrainedModel: () => RTDetrPreTrainedModel,
      RTDetrV2ForObjectDetection: () => RTDetrV2ForObjectDetection,
      RTDetrV2Model: () => RTDetrV2Model,
      RTDetrV2ObjectDetectionOutput: () => RTDetrV2ObjectDetectionOutput,
      RTDetrV2PreTrainedModel: () => RTDetrV2PreTrainedModel,
      ResNetForImageClassification: () => ResNetForImageClassification,
      ResNetModel: () => ResNetModel,
      ResNetPreTrainedModel: () => ResNetPreTrainedModel,
      RoFormerForMaskedLM: () => RoFormerForMaskedLM,
      RoFormerForQuestionAnswering: () => RoFormerForQuestionAnswering,
      RoFormerForSequenceClassification: () => RoFormerForSequenceClassification,
      RoFormerForTokenClassification: () => RoFormerForTokenClassification,
      RoFormerModel: () => RoFormerModel,
      RoFormerPreTrainedModel: () => RoFormerPreTrainedModel,
      RobertaForMaskedLM: () => RobertaForMaskedLM,
      RobertaForQuestionAnswering: () => RobertaForQuestionAnswering,
      RobertaForSequenceClassification: () => RobertaForSequenceClassification,
      RobertaForTokenClassification: () => RobertaForTokenClassification,
      RobertaModel: () => RobertaModel,
      RobertaPreTrainedModel: () => RobertaPreTrainedModel,
      Sam2ImageSegmentationOutput: () => Sam2ImageSegmentationOutput,
      Sam2Model: () => Sam2Model,
      Sam2PreTrainedModel: () => Sam2PreTrainedModel,
      Sam3TrackerModel: () => Sam3TrackerModel,
      SamImageSegmentationOutput: () => SamImageSegmentationOutput,
      SamModel: () => SamModel,
      SamPreTrainedModel: () => SamPreTrainedModel,
      SapiensForDepthEstimation: () => SapiensForDepthEstimation,
      SapiensForNormalEstimation: () => SapiensForNormalEstimation,
      SapiensForSemanticSegmentation: () => SapiensForSemanticSegmentation,
      SapiensPreTrainedModel: () => SapiensPreTrainedModel,
      SegformerForImageClassification: () => SegformerForImageClassification,
      SegformerForSemanticSegmentation: () => SegformerForSemanticSegmentation,
      SegformerModel: () => SegformerModel,
      SegformerPreTrainedModel: () => SegformerPreTrainedModel,
      Seq2SeqLMOutput: () => Seq2SeqLMOutput,
      SequenceClassifierOutput: () => SequenceClassifierOutput,
      SiglipModel: () => SiglipModel,
      SiglipPreTrainedModel: () => SiglipPreTrainedModel,
      SiglipTextModel: () => SiglipTextModel,
      SiglipVisionModel: () => SiglipVisionModel,
      SmolLM3ForCausalLM: () => SmolLM3ForCausalLM,
      SmolLM3Model: () => SmolLM3Model,
      SmolLM3PreTrainedModel: () => SmolLM3PreTrainedModel,
      SmolVLMForConditionalGeneration: () => SmolVLMForConditionalGeneration,
      SnacDecoderModel: () => SnacDecoderModel,
      SnacEncoderModel: () => SnacEncoderModel,
      SnacModel: () => SnacModel,
      SnacPreTrainedModel: () => SnacPreTrainedModel,
      SpeechT5ForSpeechToText: () => SpeechT5ForSpeechToText,
      SpeechT5ForTextToSpeech: () => SpeechT5ForTextToSpeech,
      SpeechT5HifiGan: () => SpeechT5HifiGan,
      SpeechT5Model: () => SpeechT5Model,
      SpeechT5PreTrainedModel: () => SpeechT5PreTrainedModel,
      SqueezeBertForMaskedLM: () => SqueezeBertForMaskedLM,
      SqueezeBertForQuestionAnswering: () => SqueezeBertForQuestionAnswering,
      SqueezeBertForSequenceClassification: () => SqueezeBertForSequenceClassification,
      SqueezeBertModel: () => SqueezeBertModel,
      SqueezeBertPreTrainedModel: () => SqueezeBertPreTrainedModel,
      StableLmForCausalLM: () => StableLmForCausalLM,
      StableLmModel: () => StableLmModel,
      StableLmPreTrainedModel: () => StableLmPreTrainedModel,
      Starcoder2ForCausalLM: () => Starcoder2ForCausalLM,
      Starcoder2Model: () => Starcoder2Model,
      Starcoder2PreTrainedModel: () => Starcoder2PreTrainedModel,
      StyleTextToSpeech2Model: () => StyleTextToSpeech2Model,
      StyleTextToSpeech2PreTrainedModel: () => StyleTextToSpeech2PreTrainedModel,
      SupertonicForConditionalGeneration: () => SupertonicForConditionalGeneration,
      SupertonicPreTrainedModel: () => SupertonicPreTrainedModel,
      Swin2SRForImageSuperResolution: () => Swin2SRForImageSuperResolution,
      Swin2SRModel: () => Swin2SRModel,
      Swin2SRPreTrainedModel: () => Swin2SRPreTrainedModel,
      SwinForImageClassification: () => SwinForImageClassification,
      SwinForSemanticSegmentation: () => SwinForSemanticSegmentation,
      SwinModel: () => SwinModel,
      SwinPreTrainedModel: () => SwinPreTrainedModel,
      T5ForConditionalGeneration: () => T5ForConditionalGeneration,
      T5Model: () => T5Model,
      T5PreTrainedModel: () => T5PreTrainedModel,
      TableTransformerForObjectDetection: () => TableTransformerForObjectDetection,
      TableTransformerModel: () => TableTransformerModel,
      TableTransformerObjectDetectionOutput: () => TableTransformerObjectDetectionOutput,
      TableTransformerPreTrainedModel: () => TableTransformerPreTrainedModel,
      TokenClassifierOutput: () => TokenClassifierOutput,
      TrOCRForCausalLM: () => TrOCRForCausalLM,
      TrOCRPreTrainedModel: () => TrOCRPreTrainedModel,
      UltravoxModel: () => UltravoxModel,
      UltravoxPreTrainedModel: () => UltravoxPreTrainedModel,
      UniSpeechForCTC: () => UniSpeechForCTC,
      UniSpeechForSequenceClassification: () => UniSpeechForSequenceClassification,
      UniSpeechModel: () => UniSpeechModel,
      UniSpeechPreTrainedModel: () => UniSpeechPreTrainedModel,
      UniSpeechSatForAudioFrameClassification: () => UniSpeechSatForAudioFrameClassification,
      UniSpeechSatForCTC: () => UniSpeechSatForCTC,
      UniSpeechSatForSequenceClassification: () => UniSpeechSatForSequenceClassification,
      UniSpeechSatModel: () => UniSpeechSatModel,
      UniSpeechSatPreTrainedModel: () => UniSpeechSatPreTrainedModel,
      VaultGemmaForCausalLM: () => VaultGemmaForCausalLM,
      VaultGemmaModel: () => VaultGemmaModel,
      VaultGemmaPreTrainedModel: () => VaultGemmaPreTrainedModel,
      ViTForImageClassification: () => ViTForImageClassification,
      ViTMAEModel: () => ViTMAEModel,
      ViTMAEPreTrainedModel: () => ViTMAEPreTrainedModel,
      ViTMSNForImageClassification: () => ViTMSNForImageClassification,
      ViTMSNModel: () => ViTMSNModel,
      ViTMSNPreTrainedModel: () => ViTMSNPreTrainedModel,
      ViTModel: () => ViTModel,
      ViTPreTrainedModel: () => ViTPreTrainedModel,
      VisionEncoderDecoderModel: () => VisionEncoderDecoderModel,
      VitMatteForImageMatting: () => VitMatteForImageMatting,
      VitMattePreTrainedModel: () => VitMattePreTrainedModel,
      VitPoseForPoseEstimation: () => VitPoseForPoseEstimation,
      VitPosePreTrainedModel: () => VitPosePreTrainedModel,
      VitsModel: () => VitsModel,
      VitsModelOutput: () => VitsModelOutput,
      VitsPreTrainedModel: () => VitsPreTrainedModel,
      VoxtralForConditionalGeneration: () => VoxtralForConditionalGeneration,
      Wav2Vec2BertForCTC: () => Wav2Vec2BertForCTC,
      Wav2Vec2BertForSequenceClassification: () => Wav2Vec2BertForSequenceClassification,
      Wav2Vec2BertModel: () => Wav2Vec2BertModel,
      Wav2Vec2BertPreTrainedModel: () => Wav2Vec2BertPreTrainedModel,
      Wav2Vec2ForAudioFrameClassification: () => Wav2Vec2ForAudioFrameClassification,
      Wav2Vec2ForCTC: () => Wav2Vec2ForCTC,
      Wav2Vec2ForSequenceClassification: () => Wav2Vec2ForSequenceClassification,
      Wav2Vec2Model: () => Wav2Vec2Model,
      Wav2Vec2PreTrainedModel: () => Wav2Vec2PreTrainedModel,
      WavLMForAudioFrameClassification: () => WavLMForAudioFrameClassification,
      WavLMForCTC: () => WavLMForCTC,
      WavLMForSequenceClassification: () => WavLMForSequenceClassification,
      WavLMForXVector: () => WavLMForXVector,
      WavLMModel: () => WavLMModel,
      WavLMPreTrainedModel: () => WavLMPreTrainedModel,
      WeSpeakerResNetModel: () => WeSpeakerResNetModel,
      WeSpeakerResNetPreTrainedModel: () => WeSpeakerResNetPreTrainedModel,
      WhisperForConditionalGeneration: () => WhisperForConditionalGeneration,
      WhisperModel: () => WhisperModel,
      WhisperPreTrainedModel: () => WhisperPreTrainedModel,
      XLMForQuestionAnswering: () => XLMForQuestionAnswering,
      XLMForSequenceClassification: () => XLMForSequenceClassification,
      XLMForTokenClassification: () => XLMForTokenClassification,
      XLMModel: () => XLMModel,
      XLMPreTrainedModel: () => XLMPreTrainedModel,
      XLMRobertaForMaskedLM: () => XLMRobertaForMaskedLM,
      XLMRobertaForQuestionAnswering: () => XLMRobertaForQuestionAnswering,
      XLMRobertaForSequenceClassification: () => XLMRobertaForSequenceClassification,
      XLMRobertaForTokenClassification: () => XLMRobertaForTokenClassification,
      XLMRobertaModel: () => XLMRobertaModel,
      XLMRobertaPreTrainedModel: () => XLMRobertaPreTrainedModel,
      XLMWithLMHeadModel: () => XLMWithLMHeadModel,
      XVectorOutput: () => XVectorOutput,
      YolosForObjectDetection: () => YolosForObjectDetection,
      YolosModel: () => YolosModel,
      YolosObjectDetectionOutput: () => YolosObjectDetectionOutput,
      YolosPreTrainedModel: () => YolosPreTrainedModel
    });
    var _configs_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/configs.js");
    /*! ./configs.js */
    var _backends_onnx_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/backends/onnx.js");
    /*! ./backends/onnx.js */
    var _utils_dtypes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/utils/dtypes.js");
    /*! ./utils/dtypes.js */
    var _utils_generic_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/utils/generic.js");
    /*! ./utils/generic.js */
    var _utils_core_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./src/utils/core.js");
    /*! ./utils/core.js */
    var _utils_hub_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./src/utils/hub.js");
    /*! ./utils/hub.js */
    var _utils_constants_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./src/utils/constants.js");
    /*! ./utils/constants.js */
    var _generation_logits_process_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./src/generation/logits_process.js");
    /*! ./generation/logits_process.js */
    var _generation_configuration_utils_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./src/generation/configuration_utils.js");
    /*! ./generation/configuration_utils.js */
    var _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./src/utils/tensor.js");
    /*! ./utils/tensor.js */
    var _utils_image_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./src/utils/image.js");
    /*! ./utils/image.js */
    var _utils_maths_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./src/utils/maths.js");
    /*! ./utils/maths.js */
    var _generation_stopping_criteria_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./src/generation/stopping_criteria.js");
    /*! ./generation/stopping_criteria.js */
    var _generation_logits_sampler_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./src/generation/logits_sampler.js");
    /*! ./generation/logits_sampler.js */
    var _env_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("./src/env.js");
    /*! ./env.js */
    var _models_whisper_generation_whisper_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__("./src/models/whisper/generation_whisper.js");
    /*! ./models/whisper/generation_whisper.js */
    var _models_whisper_common_whisper_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__("./src/models/whisper/common_whisper.js");
    /*! ./models/whisper/common_whisper.js */
    const MODEL_TYPES = {
      EncoderOnly: 0,
      EncoderDecoder: 1,
      Seq2Seq: 2,
      Vision2Seq: 3,
      DecoderOnly: 4,
      MaskGeneration: 5,
      ImageTextToText: 6,
      Musicgen: 7,
      MultiModality: 8,
      Phi3V: 9,
      AudioTextToText: 10,
      AutoEncoder: 11,
      ImageAudioTextToText: 12,
      Supertonic: 13
    };
    const MODEL_TYPE_MAPPING = new Map;
    const MODEL_NAME_TO_CLASS_MAPPING = new Map;
    const MODEL_CLASS_TO_NAME_MAPPING = new Map;
    async function getSession(pretrained_model_name_or_path, fileName, options2) {
      let custom_config = options2.config?.["transformers.js_config"] ?? {};
      let device = options2.device ?? custom_config.device;
      if (device && typeof device !== "string") {
        if (device.hasOwnProperty(fileName)) {
          device = device[fileName];
        } else {
          console.warn(`device not specified for "${fileName}". Using the default device.`);
          device = null;
        }
      }
      const selectedDevice = device ?? (_env_js__WEBPACK_IMPORTED_MODULE_14__.apis.IS_NODE_ENV ? "cpu" : "wasm");
      const executionProviders = (0, _backends_onnx_js__WEBPACK_IMPORTED_MODULE_1__.deviceToExecutionProviders)(selectedDevice);
      const device_config = custom_config.device_config ?? {};
      if (device_config.hasOwnProperty(selectedDevice)) {
        custom_config = {
          ...custom_config,
          ...device_config[selectedDevice]
        };
      }
      let dtype = options2.dtype ?? custom_config.dtype;
      if (typeof dtype !== "string") {
        if (dtype && dtype.hasOwnProperty(fileName)) {
          dtype = dtype[fileName];
        } else {
          dtype = _utils_dtypes_js__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_DEVICE_DTYPE_MAPPING[selectedDevice] ?? _utils_dtypes_js__WEBPACK_IMPORTED_MODULE_2__.DATA_TYPES.fp32;
          console.warn(`dtype not specified for "${fileName}". Using the default dtype (${dtype}) for this device (${selectedDevice}).`);
        }
      }
      if (dtype === _utils_dtypes_js__WEBPACK_IMPORTED_MODULE_2__.DATA_TYPES.auto) {
        let config_dtype = custom_config.dtype;
        if (typeof config_dtype !== "string") {
          config_dtype = config_dtype?.[fileName];
        }
        if (config_dtype && config_dtype !== _utils_dtypes_js__WEBPACK_IMPORTED_MODULE_2__.DATA_TYPES.auto && _utils_dtypes_js__WEBPACK_IMPORTED_MODULE_2__.DATA_TYPES.hasOwnProperty(config_dtype)) {
          dtype = config_dtype;
        } else {
          dtype = _utils_dtypes_js__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_DEVICE_DTYPE_MAPPING[selectedDevice] ?? _utils_dtypes_js__WEBPACK_IMPORTED_MODULE_2__.DATA_TYPES.fp32;
        }
      }
      const selectedDtype = dtype;
      if (!_utils_dtypes_js__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_DTYPE_SUFFIX_MAPPING.hasOwnProperty(selectedDtype)) {
        throw new Error(`Invalid dtype: ${selectedDtype}. Should be one of: ${Object.keys(_utils_dtypes_js__WEBPACK_IMPORTED_MODULE_2__.DATA_TYPES).join(", ")}`);
      } else if (selectedDtype === _utils_dtypes_js__WEBPACK_IMPORTED_MODULE_2__.DATA_TYPES.fp16 && selectedDevice === "webgpu" && !await (0, _utils_dtypes_js__WEBPACK_IMPORTED_MODULE_2__.isWebGpuFp16Supported)()) {
        throw new Error(`The device (${selectedDevice}) does not support fp16.`);
      }
      const kv_cache_dtype_config = custom_config.kv_cache_dtype;
      const kv_cache_dtype = kv_cache_dtype_config ? typeof kv_cache_dtype_config === "string" ? kv_cache_dtype_config : kv_cache_dtype_config[selectedDtype] ?? "float32" : undefined;
      if (kv_cache_dtype && !["float32", "float16"].includes(kv_cache_dtype)) {
        throw new Error(`Invalid kv_cache_dtype: ${kv_cache_dtype}. Should be one of: float32, float16`);
      }
      const session_config = {
        dtype: selectedDtype,
        kv_cache_dtype,
        device: selectedDevice
      };
      const suffix = _utils_dtypes_js__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_DTYPE_SUFFIX_MAPPING[selectedDtype];
      const baseName = `${fileName}${suffix}.onnx`;
      const modelFileName = `${options2.subfolder ?? ""}/${baseName}`;
      const session_options = { ...options2.session_options };
      session_options.executionProviders ??= executionProviders;
      const free_dimension_overrides = custom_config.free_dimension_overrides;
      if (free_dimension_overrides) {
        session_options.freeDimensionOverrides ??= free_dimension_overrides;
      } else if (selectedDevice.startsWith("webnn") && !session_options.freeDimensionOverrides) {
        console.warn(`WebNN does not currently support dynamic shapes and requires 'free_dimension_overrides' to be set in config.json, preferably as a field within config["transformers.js_config"]["device_config"]["${selectedDevice}"]. ` + `When 'free_dimension_overrides' is not set, you may experience significant performance degradation.`);
      }
      const return_path = _env_js__WEBPACK_IMPORTED_MODULE_14__.apis.IS_NODE_ENV && _env_js__WEBPACK_IMPORTED_MODULE_14__.env.useFSCache;
      const bufferOrPathPromise = (0, _utils_hub_js__WEBPACK_IMPORTED_MODULE_5__.getModelFile)(pretrained_model_name_or_path, modelFileName, true, options2, return_path);
      const use_external_data_format = options2.use_external_data_format ?? custom_config.use_external_data_format;
      let externalDataPromises = [];
      if (use_external_data_format) {
        let external_data_format;
        if (typeof use_external_data_format === "object") {
          if (use_external_data_format.hasOwnProperty(baseName)) {
            external_data_format = use_external_data_format[baseName];
          } else if (use_external_data_format.hasOwnProperty(fileName)) {
            external_data_format = use_external_data_format[fileName];
          } else {
            external_data_format = false;
          }
        } else {
          external_data_format = use_external_data_format;
        }
        const num_chunks = +external_data_format;
        if (num_chunks > _utils_hub_js__WEBPACK_IMPORTED_MODULE_5__.MAX_EXTERNAL_DATA_CHUNKS) {
          throw new Error(`The number of external data chunks (${num_chunks}) exceeds the maximum allowed value (${_utils_hub_js__WEBPACK_IMPORTED_MODULE_5__.MAX_EXTERNAL_DATA_CHUNKS}).`);
        }
        for (let i = 0;i < num_chunks; ++i) {
          const path2 = `${baseName}_data${i === 0 ? "" : "_" + i}`;
          const fullPath = `${options2.subfolder ?? ""}/${path2}`;
          externalDataPromises.push(new Promise(async (resolve4, reject) => {
            const data = await (0, _utils_hub_js__WEBPACK_IMPORTED_MODULE_5__.getModelFile)(pretrained_model_name_or_path, fullPath, true, options2, return_path);
            resolve4(data instanceof Uint8Array ? { path: path2, data } : path2);
          }));
        }
      } else if (session_options.externalData !== undefined) {
        externalDataPromises = session_options.externalData.map(async (ext) => {
          if (typeof ext.data === "string") {
            const ext_buffer = await (0, _utils_hub_js__WEBPACK_IMPORTED_MODULE_5__.getModelFile)(pretrained_model_name_or_path, ext.data, true, options2);
            return { ...ext, data: ext_buffer };
          }
          return ext;
        });
      }
      if (externalDataPromises.length > 0) {
        const externalData = await Promise.all(externalDataPromises);
        if (!_env_js__WEBPACK_IMPORTED_MODULE_14__.apis.IS_NODE_ENV) {
          session_options.externalData = externalData;
        }
      }
      if (selectedDevice === "webgpu") {
        const shapes = (0, _configs_js__WEBPACK_IMPORTED_MODULE_0__.getCacheShapes)(options2.config, {
          prefix: "present"
        });
        if (Object.keys(shapes).length > 0 && !(0, _backends_onnx_js__WEBPACK_IMPORTED_MODULE_1__.isONNXProxy)()) {
          const preferredOutputLocation = {};
          for (const key in shapes) {
            preferredOutputLocation[key] = "gpu-buffer";
          }
          session_options.preferredOutputLocation = preferredOutputLocation;
        }
      }
      const buffer_or_path = await bufferOrPathPromise;
      return { buffer_or_path, session_options, session_config };
    }
    async function constructSessions(pretrained_model_name_or_path, names, options2) {
      return Object.fromEntries(await Promise.all(Object.keys(names).map(async (name) => {
        const { buffer_or_path, session_options, session_config } = await getSession(pretrained_model_name_or_path, names[name], options2);
        const session = await (0, _backends_onnx_js__WEBPACK_IMPORTED_MODULE_1__.createInferenceSession)(buffer_or_path, session_options, session_config);
        return [name, session];
      })));
    }
    async function getOptionalConfigs(pretrained_model_name_or_path, names, options2) {
      return Object.fromEntries(await Promise.all(Object.keys(names).map(async (name) => {
        const config3 = await (0, _utils_hub_js__WEBPACK_IMPORTED_MODULE_5__.getModelJSON)(pretrained_model_name_or_path, names[name], false, options2);
        return [name, config3];
      })));
    }
    function validateInputs(session, inputs) {
      const checkedInputs = Object.create(null);
      const missingInputs = [];
      for (const inputName of session.inputNames) {
        const tensor2 = inputs[inputName];
        if (!(tensor2 instanceof _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.Tensor)) {
          missingInputs.push(inputName);
          continue;
        }
        checkedInputs[inputName] = (0, _backends_onnx_js__WEBPACK_IMPORTED_MODULE_1__.isONNXProxy)() ? tensor2.clone() : tensor2;
      }
      if (missingInputs.length > 0) {
        throw new Error(`An error occurred during model execution: "Missing the following inputs: ${missingInputs.join(", ")}.`);
      }
      const numInputsProvided = Object.keys(inputs).length;
      const numInputsNeeded = session.inputNames.length;
      if (numInputsProvided > numInputsNeeded) {
        let ignored = Object.keys(inputs).filter((inputName) => !session.inputNames.includes(inputName));
        console.warn(`WARNING: Too many inputs were provided (${numInputsProvided} > ${numInputsNeeded}). The following inputs will be ignored: "${ignored.join(", ")}".`);
      }
      return checkedInputs;
    }
    async function sessionRun(session, inputs) {
      const checkedInputs = validateInputs(session, inputs);
      try {
        const ortFeed = Object.fromEntries(Object.entries(checkedInputs).map(([k, v]) => [k, v.ort_tensor]));
        const output = await (0, _backends_onnx_js__WEBPACK_IMPORTED_MODULE_1__.runInferenceSession)(session, ortFeed);
        return replaceTensors(output);
      } catch (e) {
        const formatted = Object.fromEntries(Object.entries(checkedInputs).map(([k, tensor2]) => {
          const unpacked = {
            type: tensor2.type,
            dims: tensor2.dims,
            location: tensor2.location
          };
          if (unpacked.location !== "gpu-buffer") {
            unpacked.data = tensor2.data;
          }
          return [k, unpacked];
        }));
        console.error(`An error occurred during model execution: "${e}".`);
        console.error("Inputs given to model:", formatted);
        throw e;
      }
    }
    function replaceTensors(obj) {
      for (let prop in obj) {
        if ((0, _backends_onnx_js__WEBPACK_IMPORTED_MODULE_1__.isONNXTensor)(obj[prop])) {
          obj[prop] = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.Tensor(obj[prop]);
        } else if (typeof obj[prop] === "object") {
          replaceTensors(obj[prop]);
        }
      }
      return obj;
    }
    function toI64Tensor(items) {
      if (items instanceof _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.Tensor) {
        return items;
      }
      if (items.length === 0) {
        throw Error("items must be non-empty");
      }
      if (Array.isArray(items[0])) {
        if (items.some((x) => x.length !== items[0].length)) {
          throw Error("Unable to create tensor, you should probably activate truncation and/or padding with 'padding=True' and/or 'truncation=True' to have batched tensors with the same length.");
        }
        return new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.Tensor("int64", BigInt64Array.from(items.flat().map((x) => BigInt(x))), [items.length, items[0].length]);
      } else {
        return new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.Tensor("int64", BigInt64Array.from(items.map((x) => BigInt(x))), [1, items.length]);
      }
    }
    function boolTensor(value) {
      return new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.Tensor("bool", [value], [1]);
    }
    async function seq2seqForward(self2, model_inputs) {
      let { encoder_outputs, input_ids, decoder_input_ids, ...other_decoder_inputs } = model_inputs;
      if (!encoder_outputs) {
        const encoder_inputs = (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_4__.pick)(model_inputs, self2.sessions["model"].inputNames);
        encoder_outputs = (await encoderForward(self2, encoder_inputs)).last_hidden_state;
      }
      other_decoder_inputs.input_ids = decoder_input_ids;
      other_decoder_inputs.encoder_hidden_states = encoder_outputs;
      if (self2.sessions["decoder_model_merged"].inputNames.includes("encoder_attention_mask")) {
        other_decoder_inputs.encoder_attention_mask = model_inputs.attention_mask;
      }
      const decoderResults = await decoderForward(self2, other_decoder_inputs, true);
      return decoderResults;
    }
    async function encoderForward(self2, model_inputs) {
      const session = self2.sessions["model"];
      const encoderFeeds = (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_4__.pick)(model_inputs, session.inputNames);
      if (session.inputNames.includes("inputs_embeds") && !encoderFeeds.inputs_embeds) {
        if (!model_inputs.input_ids) {
          throw new Error("Both `input_ids` and `inputs_embeds` are missing in the model inputs.");
        }
        encoderFeeds.inputs_embeds = await self2.encode_text({ input_ids: model_inputs.input_ids });
      }
      if (session.inputNames.includes("token_type_ids") && !encoderFeeds.token_type_ids) {
        if (!encoderFeeds.input_ids) {
          throw new Error("Both `input_ids` and `token_type_ids` are missing in the model inputs.");
        }
        encoderFeeds.token_type_ids = (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.zeros_like)(encoderFeeds.input_ids);
      }
      if (session.inputNames.includes("pixel_mask") && !encoderFeeds.pixel_mask) {
        if (!encoderFeeds.pixel_values) {
          throw new Error("Both `pixel_values` and `pixel_mask` are missing in the model inputs.");
        }
        const dims = encoderFeeds.pixel_values.dims;
        encoderFeeds.pixel_mask = (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.ones)([dims[0], dims[2], dims[3]]);
      }
      return await sessionRun(session, encoderFeeds);
    }
    async function autoEncoderForward(self2, model_inputs) {
      const encoded = await self2.encode(model_inputs);
      const decoded = await self2.decode(encoded);
      return decoded;
    }
    async function decoderForward(self2, model_inputs, is_encoder_decoder = false) {
      const session = self2.sessions[is_encoder_decoder ? "decoder_model_merged" : "model"];
      const { past_key_values, ...new_model_inputs } = model_inputs;
      if (session.inputNames.includes("use_cache_branch")) {
        new_model_inputs.use_cache_branch = boolTensor(!!past_key_values);
      }
      if (session.inputNames.includes("position_ids") && new_model_inputs.attention_mask && !new_model_inputs.position_ids) {
        const start_index = ["paligemma", "gemma3_text", "gemma3"].includes(self2.config.model_type) ? 1 : 0;
        new_model_inputs.position_ids = createPositionIds(new_model_inputs, past_key_values, start_index);
      }
      self2.addPastKeyValues(new_model_inputs, past_key_values);
      const fixed = (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_4__.pick)(new_model_inputs, session.inputNames);
      return await sessionRun(session, fixed);
    }
    function default_merge_input_ids_with_features({
      modality_token_id,
      inputs_embeds,
      modality_features,
      input_ids,
      attention_mask
    }) {
      const token_positions = input_ids.tolist().map((ids) => ids.reduce((acc, x, idx) => {
        if (x == modality_token_id)
          acc.push(idx);
        return acc;
      }, []));
      const n_tokens = token_positions.reduce((acc, x) => acc + x.length, 0);
      const n_features = modality_features.dims[0];
      if (n_tokens !== n_features) {
        throw new Error(`Number of tokens and features do not match: tokens: ${n_tokens}, features ${n_features}`);
      }
      let img = 0;
      for (let i = 0;i < token_positions.length; ++i) {
        const tokens = token_positions[i];
        const embeds = inputs_embeds[i];
        for (let j = 0;j < tokens.length; ++j) {
          embeds[tokens[j]].data.set(modality_features[img++].data);
        }
      }
      return { inputs_embeds, attention_mask };
    }
    function default_merge_input_ids_with_image_features({
      image_token_id,
      inputs_embeds,
      image_features,
      input_ids,
      attention_mask
    }) {
      return default_merge_input_ids_with_features({
        modality_token_id: image_token_id,
        inputs_embeds,
        modality_features: image_features,
        input_ids,
        attention_mask
      });
    }
    function default_merge_input_ids_with_audio_features({
      audio_token_id,
      inputs_embeds,
      audio_features,
      input_ids,
      attention_mask
    }) {
      return default_merge_input_ids_with_features({
        modality_token_id: audio_token_id,
        inputs_embeds,
        modality_features: audio_features,
        input_ids,
        attention_mask
      });
    }
    async function genericTextToTextForward(self2, {
      encode_function,
      merge_function,
      modality_input_name,
      modality_output_name,
      input_ids = null,
      attention_mask = null,
      position_ids = null,
      inputs_embeds = null,
      past_key_values = null,
      generation_config = null,
      logits_processor = null,
      ...kwargs
    }) {
      const modality_values = kwargs[modality_input_name];
      if (!inputs_embeds) {
        inputs_embeds = await self2.encode_text({ input_ids, ...kwargs });
        if (modality_values && input_ids.dims[1] !== 1) {
          const modality_features = await encode_function({
            [modality_input_name]: modality_values,
            ...kwargs
          });
          ({ inputs_embeds, attention_mask } = merge_function({
            [modality_output_name]: modality_features,
            inputs_embeds,
            input_ids,
            attention_mask
          }));
        } else if (past_key_values && modality_values && input_ids.dims[1] === 1) {
          const target_length = input_ids.dims[1];
          const past_length = Object.values(past_key_values)[0].dims.at(-2);
          attention_mask = (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.cat)([
            (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.ones)([input_ids.dims[0], past_length]),
            attention_mask.slice(null, [attention_mask.dims[1] - target_length, attention_mask.dims[1]])
          ], 1);
        }
      }
      if (!position_ids) {
        if (self2.config.model_type === "qwen2_vl") {
          const { image_grid_thw, video_grid_thw } = kwargs;
          [position_ids] = self2.get_rope_index(input_ids, image_grid_thw, video_grid_thw, attention_mask);
        }
      }
      const outputs = await decoderForward(self2, {
        inputs_embeds,
        past_key_values,
        attention_mask,
        position_ids,
        generation_config,
        logits_processor
      }, true);
      return outputs;
    }
    async function audioTextToTextForward(self2, params) {
      return await genericTextToTextForward(self2, {
        ...params,
        modality_input_name: "audio_values",
        modality_output_name: "audio_features",
        encode_function: self2.encode_audio.bind(self2),
        merge_function: self2._merge_input_ids_with_audio_features.bind(self2)
      });
    }
    async function imageTextToTextForward(self2, params) {
      return await genericTextToTextForward(self2, {
        ...params,
        modality_input_name: "pixel_values",
        modality_output_name: "image_features",
        encode_function: self2.encode_image.bind(self2),
        merge_function: self2._merge_input_ids_with_image_features.bind(self2)
      });
    }
    function cumsum_masked_fill(attention_mask, start_index = 0) {
      const [bz, seq_len] = attention_mask.dims;
      const attn_mask_data = attention_mask.data;
      const data = new BigInt64Array(attn_mask_data.length);
      for (let i = 0;i < bz; ++i) {
        const start = i * seq_len;
        let sum = BigInt(start_index);
        for (let j = 0;j < seq_len; ++j) {
          const index = start + j;
          if (attn_mask_data[index] === 0n) {
            data[index] = BigInt(1);
          } else {
            data[index] = sum;
            sum += attn_mask_data[index];
          }
        }
      }
      return { data, dims: attention_mask.dims };
    }
    function createPositionIds(model_inputs, past_key_values = null, start_index = 0) {
      const { input_ids, inputs_embeds, attention_mask } = model_inputs;
      const { data, dims } = cumsum_masked_fill(attention_mask, start_index);
      let position_ids = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.Tensor("int64", data, dims);
      if (past_key_values) {
        const offset = -(input_ids ?? inputs_embeds).dims.at(1);
        position_ids = position_ids.slice(null, [offset, null]);
      }
      return position_ids;
    }
    function decoder_prepare_inputs_for_generation(self2, input_ids, model_inputs, generation_config) {
      const past_length = model_inputs.past_key_values ? Object.values(model_inputs.past_key_values)[0].dims.at(-2) : 0;
      if (!model_inputs.attention_mask) {
        let dims;
        for (const key of ["input_ids", "inputs_embeds", "position_ids"]) {
          if (model_inputs[key]) {
            dims = model_inputs[key].dims;
            break;
          }
        }
        if (!dims) {
          throw new Error("attention_mask is not provided, and unable to infer its shape from model inputs.");
        }
        model_inputs.attention_mask = (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.ones)([dims[0], past_length + dims[1]]);
      }
      if (model_inputs.past_key_values) {
        const { input_ids: input_ids2, attention_mask } = model_inputs;
        if (attention_mask && attention_mask.dims[1] > input_ids2.dims[1]) {} else if (past_length < input_ids2.dims[1]) {
          model_inputs.input_ids = input_ids2.slice(null, [past_length, null]);
        } else {}
      }
      return model_inputs;
    }
    function encoder_decoder_prepare_inputs_for_generation(self2, input_ids, model_inputs, generation_config) {
      if (model_inputs.past_key_values) {
        input_ids = input_ids.map((x) => [x.at(-1)]);
      }
      return {
        ...model_inputs,
        decoder_input_ids: toI64Tensor(input_ids)
      };
    }
    function multimodal_text_to_text_prepare_inputs_for_generation(self2, ...args) {
      if (self2.config.is_encoder_decoder) {
        return encoder_decoder_prepare_inputs_for_generation(self2, ...args);
      } else {
        return decoder_prepare_inputs_for_generation(self2, ...args);
      }
    }
    function multimodality_prepare_inputs_for_generation(self2, input_ids, model_inputs, generation_config) {
      const has_past_key_values = !!model_inputs.past_key_values;
      if (generation_config.guidance_scale !== null && generation_config.guidance_scale > 1) {
        if (has_past_key_values) {
          model_inputs.input_ids = (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.cat)([
            model_inputs.input_ids,
            model_inputs.input_ids
          ], 0);
        } else {
          model_inputs.input_ids = (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.cat)([
            model_inputs.input_ids,
            (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.full_like)(model_inputs.input_ids, BigInt(generation_config.pad_token_id))
          ], 0);
          model_inputs.attention_mask = (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.cat)([
            model_inputs.attention_mask,
            (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.full_like)(model_inputs.attention_mask, 0n)
          ], 0);
        }
      }
      if (has_past_key_values || !model_inputs.pixel_values) {
        model_inputs.pixel_values = (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.full)([0, 0, 3, 384, 384], 1);
      }
      if (has_past_key_values) {
        const num_img_tokens = 0;
        const num_text_tokens = 1;
        const has_image = num_img_tokens > 0 ? 1 : 0;
        const batch_size = 1;
        model_inputs.images_seq_mask = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.Tensor("bool", new Array(num_img_tokens + num_text_tokens).fill(true).fill(false, 0, num_text_tokens), [batch_size, num_img_tokens + num_text_tokens]);
        model_inputs.images_emb_mask = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.Tensor("bool", new Array(num_img_tokens).fill(!!has_image), [batch_size, 1, num_img_tokens]);
      }
      return model_inputs;
    }

    class PreTrainedModel extends _utils_generic_js__WEBPACK_IMPORTED_MODULE_3__.Callable {
      main_input_name = "input_ids";
      forward_params = ["input_ids", "attention_mask"];
      constructor(config3, sessions, configs) {
        super();
        this.config = config3;
        this.sessions = sessions;
        this.configs = configs;
        const modelName = MODEL_CLASS_TO_NAME_MAPPING.get(this.constructor);
        const modelType = MODEL_TYPE_MAPPING.get(modelName);
        this.can_generate = false;
        this._forward = null;
        this._prepare_inputs_for_generation = null;
        switch (modelType) {
          case MODEL_TYPES.DecoderOnly:
            this.can_generate = true;
            this._forward = decoderForward;
            this._prepare_inputs_for_generation = decoder_prepare_inputs_for_generation;
            break;
          case MODEL_TYPES.Seq2Seq:
          case MODEL_TYPES.Vision2Seq:
          case MODEL_TYPES.Musicgen:
            this.can_generate = true;
            this._forward = seq2seqForward;
            this._prepare_inputs_for_generation = encoder_decoder_prepare_inputs_for_generation;
            break;
          case MODEL_TYPES.EncoderDecoder:
            this._forward = seq2seqForward;
            break;
          case MODEL_TYPES.ImageTextToText:
            this.can_generate = true;
            this._forward = imageTextToTextForward;
            this._prepare_inputs_for_generation = multimodal_text_to_text_prepare_inputs_for_generation;
            break;
          case MODEL_TYPES.AudioTextToText:
            this.can_generate = true;
            this._forward = audioTextToTextForward;
            this._prepare_inputs_for_generation = multimodal_text_to_text_prepare_inputs_for_generation;
            break;
          case MODEL_TYPES.Phi3V:
          case MODEL_TYPES.ImageAudioTextToText:
            this.can_generate = true;
            this._prepare_inputs_for_generation = multimodal_text_to_text_prepare_inputs_for_generation;
            break;
          case MODEL_TYPES.MultiModality:
            this.can_generate = true;
            this._prepare_inputs_for_generation = multimodality_prepare_inputs_for_generation;
            break;
          case MODEL_TYPES.AutoEncoder:
            this._forward = autoEncoderForward;
            break;
          default:
            this._forward = encoderForward;
            break;
        }
        if (this.can_generate) {
          this.forward_params.push("past_key_values");
        }
        this.custom_config = this.config["transformers.js_config"] ?? {};
      }
      async dispose() {
        const promises = [];
        for (const session of Object.values(this.sessions)) {
          if (session?.handler?.dispose) {
            promises.push(session.handler.dispose());
          }
        }
        return await Promise.all(promises);
      }
      static async from_pretrained(pretrained_model_name_or_path, {
        progress_callback = null,
        config: config3 = null,
        cache_dir = null,
        local_files_only = false,
        revision = "main",
        model_file_name = null,
        subfolder = "onnx",
        device = null,
        dtype = null,
        use_external_data_format = null,
        session_options = {}
      } = {}) {
        let options2 = {
          progress_callback,
          config: config3,
          cache_dir,
          local_files_only,
          revision,
          model_file_name,
          subfolder,
          device,
          dtype,
          use_external_data_format,
          session_options
        };
        const modelName = MODEL_CLASS_TO_NAME_MAPPING.get(this);
        const modelType = MODEL_TYPE_MAPPING.get(modelName);
        config3 = options2.config = await _configs_js__WEBPACK_IMPORTED_MODULE_0__.AutoConfig.from_pretrained(pretrained_model_name_or_path, options2);
        let info;
        if (modelType === MODEL_TYPES.DecoderOnly) {
          info = await Promise.all([
            constructSessions(pretrained_model_name_or_path, {
              model: options2.model_file_name ?? "model"
            }, options2),
            getOptionalConfigs(pretrained_model_name_or_path, {
              generation_config: "generation_config.json"
            }, options2)
          ]);
        } else if (modelType === MODEL_TYPES.Seq2Seq || modelType === MODEL_TYPES.Vision2Seq) {
          info = await Promise.all([
            constructSessions(pretrained_model_name_or_path, {
              model: "encoder_model",
              decoder_model_merged: "decoder_model_merged"
            }, options2),
            getOptionalConfigs(pretrained_model_name_or_path, {
              generation_config: "generation_config.json"
            }, options2)
          ]);
        } else if (modelType === MODEL_TYPES.MaskGeneration) {
          info = await Promise.all([
            constructSessions(pretrained_model_name_or_path, {
              model: "vision_encoder",
              prompt_encoder_mask_decoder: "prompt_encoder_mask_decoder"
            }, options2)
          ]);
        } else if (modelType === MODEL_TYPES.EncoderDecoder) {
          info = await Promise.all([
            constructSessions(pretrained_model_name_or_path, {
              model: "encoder_model",
              decoder_model_merged: "decoder_model_merged"
            }, options2)
          ]);
        } else if (modelType === MODEL_TYPES.ImageTextToText) {
          const sessions = {
            embed_tokens: "embed_tokens",
            vision_encoder: "vision_encoder",
            decoder_model_merged: "decoder_model_merged"
          };
          if (config3.is_encoder_decoder) {
            sessions["model"] = "encoder_model";
          }
          info = await Promise.all([
            constructSessions(pretrained_model_name_or_path, sessions, options2),
            getOptionalConfigs(pretrained_model_name_or_path, {
              generation_config: "generation_config.json"
            }, options2)
          ]);
        } else if (modelType === MODEL_TYPES.AudioTextToText) {
          const sessions = {
            embed_tokens: "embed_tokens",
            audio_encoder: "audio_encoder",
            decoder_model_merged: "decoder_model_merged"
          };
          info = await Promise.all([
            constructSessions(pretrained_model_name_or_path, sessions, options2),
            getOptionalConfigs(pretrained_model_name_or_path, {
              generation_config: "generation_config.json"
            }, options2)
          ]);
        } else if (modelType === MODEL_TYPES.ImageAudioTextToText) {
          const sessions = {
            embed_tokens: "embed_tokens",
            audio_encoder: "audio_encoder",
            vision_encoder: "vision_encoder",
            decoder_model_merged: "decoder_model_merged"
          };
          info = await Promise.all([
            constructSessions(pretrained_model_name_or_path, sessions, options2),
            getOptionalConfigs(pretrained_model_name_or_path, {
              generation_config: "generation_config.json"
            }, options2)
          ]);
        } else if (modelType === MODEL_TYPES.Musicgen) {
          info = await Promise.all([
            constructSessions(pretrained_model_name_or_path, {
              model: "text_encoder",
              decoder_model_merged: "decoder_model_merged",
              encodec_decode: "encodec_decode"
            }, options2),
            getOptionalConfigs(pretrained_model_name_or_path, {
              generation_config: "generation_config.json"
            }, options2)
          ]);
        } else if (modelType === MODEL_TYPES.MultiModality) {
          info = await Promise.all([
            constructSessions(pretrained_model_name_or_path, {
              prepare_inputs_embeds: "prepare_inputs_embeds",
              model: "language_model",
              lm_head: "lm_head",
              gen_head: "gen_head",
              gen_img_embeds: "gen_img_embeds",
              image_decode: "image_decode"
            }, options2),
            getOptionalConfigs(pretrained_model_name_or_path, {
              generation_config: "generation_config.json"
            }, options2)
          ]);
        } else if (modelType === MODEL_TYPES.Phi3V) {
          info = await Promise.all([
            constructSessions(pretrained_model_name_or_path, {
              prepare_inputs_embeds: "prepare_inputs_embeds",
              model: "model",
              vision_encoder: "vision_encoder"
            }, options2),
            getOptionalConfigs(pretrained_model_name_or_path, {
              generation_config: "generation_config.json"
            }, options2)
          ]);
        } else if (modelType === MODEL_TYPES.AutoEncoder) {
          info = await Promise.all([
            constructSessions(pretrained_model_name_or_path, {
              encoder_model: "encoder_model",
              decoder_model: "decoder_model"
            }, options2)
          ]);
        } else if (modelType === MODEL_TYPES.Supertonic) {
          info = await Promise.all([
            constructSessions(pretrained_model_name_or_path, {
              text_encoder: "text_encoder",
              latent_denoiser: "latent_denoiser",
              voice_decoder: "voice_decoder"
            }, options2)
          ]);
        } else {
          if (modelType !== MODEL_TYPES.EncoderOnly) {
            const type = modelName ?? config3?.model_type;
            if (type !== "custom") {
              console.warn(`Model type for '${type}' not found, assuming encoder-only architecture. Please report this at ${_utils_constants_js__WEBPACK_IMPORTED_MODULE_6__.GITHUB_ISSUE_URL}.`);
            }
          }
          info = await Promise.all([
            constructSessions(pretrained_model_name_or_path, {
              model: options2.model_file_name ?? "model"
            }, options2)
          ]);
        }
        return new this(config3, ...info);
      }
      async _call(model_inputs) {
        return await this.forward(model_inputs);
      }
      async forward(model_inputs) {
        return await this._forward(this, model_inputs);
      }
      get generation_config() {
        return this.configs?.generation_config ?? null;
      }
      _get_logits_processor(generation_config, input_ids_seq_length, logits_processor = null) {
        const processors = new _generation_logits_process_js__WEBPACK_IMPORTED_MODULE_7__.LogitsProcessorList;
        if (generation_config.repetition_penalty !== null && generation_config.repetition_penalty !== 1) {
          processors.push(new _generation_logits_process_js__WEBPACK_IMPORTED_MODULE_7__.RepetitionPenaltyLogitsProcessor(generation_config.repetition_penalty));
        }
        if (generation_config.no_repeat_ngram_size !== null && generation_config.no_repeat_ngram_size > 0) {
          processors.push(new _generation_logits_process_js__WEBPACK_IMPORTED_MODULE_7__.NoRepeatNGramLogitsProcessor(generation_config.no_repeat_ngram_size));
        }
        if (generation_config.bad_words_ids !== null) {
          processors.push(new _generation_logits_process_js__WEBPACK_IMPORTED_MODULE_7__.NoBadWordsLogitsProcessor(generation_config.bad_words_ids, generation_config.eos_token_id));
        }
        if (generation_config.min_length !== null && generation_config.eos_token_id !== null && generation_config.min_length > 0) {
          processors.push(new _generation_logits_process_js__WEBPACK_IMPORTED_MODULE_7__.MinLengthLogitsProcessor(generation_config.min_length, generation_config.eos_token_id));
        }
        if (generation_config.min_new_tokens !== null && generation_config.eos_token_id !== null && generation_config.min_new_tokens > 0) {
          processors.push(new _generation_logits_process_js__WEBPACK_IMPORTED_MODULE_7__.MinNewTokensLengthLogitsProcessor(input_ids_seq_length, generation_config.min_new_tokens, generation_config.eos_token_id));
        }
        if (generation_config.forced_bos_token_id !== null) {
          processors.push(new _generation_logits_process_js__WEBPACK_IMPORTED_MODULE_7__.ForcedBOSTokenLogitsProcessor(generation_config.forced_bos_token_id));
        }
        if (generation_config.forced_eos_token_id !== null) {
          processors.push(new _generation_logits_process_js__WEBPACK_IMPORTED_MODULE_7__.ForcedEOSTokenLogitsProcessor(generation_config.max_length, generation_config.forced_eos_token_id));
        }
        if (generation_config.begin_suppress_tokens !== null) {
          const begin_index = input_ids_seq_length > 1 || generation_config.forced_bos_token_id === null ? input_ids_seq_length : input_ids_seq_length + 1;
          processors.push(new _generation_logits_process_js__WEBPACK_IMPORTED_MODULE_7__.SuppressTokensAtBeginLogitsProcessor(generation_config.begin_suppress_tokens, begin_index));
        }
        if (generation_config.guidance_scale !== null && generation_config.guidance_scale > 1) {
          processors.push(new _generation_logits_process_js__WEBPACK_IMPORTED_MODULE_7__.ClassifierFreeGuidanceLogitsProcessor(generation_config.guidance_scale));
        }
        if (generation_config.temperature === 0 && generation_config.do_sample) {
          console.warn("`do_sample` changed to false because `temperature: 0` implies greedy sampling (always selecting the most likely token), which is incompatible with `do_sample: true`.");
          generation_config.do_sample = false;
        }
        if (generation_config.do_sample) {
          if (generation_config.temperature !== null && generation_config.temperature !== 1) {
            processors.push(new _generation_logits_process_js__WEBPACK_IMPORTED_MODULE_7__.TemperatureLogitsWarper(generation_config.temperature));
          }
        }
        if (logits_processor !== null) {
          processors.extend(logits_processor);
        }
        return processors;
      }
      _prepare_generation_config(generation_config, kwargs, cls = _generation_configuration_utils_js__WEBPACK_IMPORTED_MODULE_8__.GenerationConfig) {
        const config3 = { ...this.config };
        for (const key of ["decoder", "generator", "text_config"]) {
          if (key in config3) {
            Object.assign(config3, config3[key]);
          }
        }
        const gen_config = new cls(config3);
        Object.assign(gen_config, this.generation_config ?? {});
        if (generation_config) {
          Object.assign(gen_config, generation_config);
        }
        if (kwargs) {
          Object.assign(gen_config, (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_4__.pick)(kwargs, Object.getOwnPropertyNames(gen_config)));
        }
        return gen_config;
      }
      _get_stopping_criteria(generation_config, stopping_criteria = null) {
        const criteria = new _generation_stopping_criteria_js__WEBPACK_IMPORTED_MODULE_12__.StoppingCriteriaList;
        if (generation_config.max_length !== null) {
          criteria.push(new _generation_stopping_criteria_js__WEBPACK_IMPORTED_MODULE_12__.MaxLengthCriteria(generation_config.max_length, this.config.max_position_embeddings ?? null));
        }
        if (generation_config.eos_token_id !== null) {
          criteria.push(new _generation_stopping_criteria_js__WEBPACK_IMPORTED_MODULE_12__.EosTokenCriteria(generation_config.eos_token_id));
        }
        if (stopping_criteria) {
          criteria.extend(stopping_criteria);
        }
        return criteria;
      }
      _validate_model_class() {
        if (!this.can_generate) {
          const generate_compatible_mappings = [
            MODEL_FOR_CAUSAL_LM_MAPPING_NAMES,
            MODEL_FOR_VISION_2_SEQ_MAPPING_NAMES,
            MODEL_FOR_SEQ_TO_SEQ_CAUSAL_LM_MAPPING_NAMES,
            MODEL_FOR_SPEECH_SEQ_2_SEQ_MAPPING_NAMES
          ];
          const modelName = MODEL_CLASS_TO_NAME_MAPPING.get(this.constructor);
          const generate_compatible_classes = new Set;
          const modelType = this.config.model_type;
          for (const model_mapping of generate_compatible_mappings) {
            const supported_models = model_mapping.get(modelType);
            if (supported_models) {
              generate_compatible_classes.add(supported_models[0]);
            }
          }
          let errorMessage = `The current model class (${modelName}) is not compatible with \`.generate()\`, as it doesn't have a language model head.`;
          if (generate_compatible_classes.size > 0) {
            errorMessage += ` Please use the following class instead: ${[...generate_compatible_classes].join(", ")}`;
          }
          throw Error(errorMessage);
        }
      }
      prepare_inputs_for_generation(...args) {
        return this._prepare_inputs_for_generation(this, ...args);
      }
      _update_model_kwargs_for_generation({ generated_input_ids, outputs, model_inputs, is_encoder_decoder }) {
        model_inputs["past_key_values"] = this.getPastKeyValues(outputs, model_inputs.past_key_values);
        model_inputs["input_ids"] = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.Tensor("int64", generated_input_ids.flat(), [generated_input_ids.length, 1]);
        if (!is_encoder_decoder) {
          model_inputs.attention_mask = (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.cat)([
            model_inputs.attention_mask,
            (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.ones)([model_inputs.attention_mask.dims[0], 1])
          ], 1);
        } else if ("decoder_attention_mask" in model_inputs) {}
        model_inputs["position_ids"] = null;
        return model_inputs;
      }
      _prepare_model_inputs({ inputs, bos_token_id, model_kwargs }) {
        const model_inputs = (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_4__.pick)(model_kwargs, this.forward_params);
        const input_name = this.main_input_name;
        if (input_name in model_inputs) {
          if (inputs) {
            throw new Error("`inputs`: {inputs}` were passed alongside {input_name} which is not allowed. " + "Make sure to either pass {inputs} or {input_name}=...");
          }
        } else {
          model_inputs[input_name] = inputs;
        }
        const inputs_tensor = model_inputs[input_name];
        return { inputs_tensor, model_inputs, model_input_name: input_name };
      }
      async _prepare_encoder_decoder_kwargs_for_generation({ inputs_tensor, model_inputs, model_input_name, generation_config }) {
        if (this.sessions["model"].inputNames.includes("inputs_embeds") && !model_inputs.inputs_embeds && "_prepare_inputs_embeds" in this) {
          const { input_ids, pixel_values, attention_mask, ...kwargs } = model_inputs;
          const prepared_inputs = await this._prepare_inputs_embeds(model_inputs);
          model_inputs = {
            ...kwargs,
            ...(0, _utils_core_js__WEBPACK_IMPORTED_MODULE_4__.pick)(prepared_inputs, ["inputs_embeds", "attention_mask"])
          };
        }
        let { last_hidden_state } = await encoderForward(this, model_inputs);
        if (generation_config.guidance_scale !== null && generation_config.guidance_scale > 1) {
          last_hidden_state = (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.cat)([
            last_hidden_state,
            (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.full_like)(last_hidden_state, 0)
          ], 0);
          if ("attention_mask" in model_inputs) {
            model_inputs["attention_mask"] = (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.cat)([
              model_inputs["attention_mask"],
              (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.zeros_like)(model_inputs["attention_mask"])
            ], 0);
          }
        } else if (model_inputs.decoder_input_ids) {
          const decoder_input_ids_batch_size = toI64Tensor(model_inputs.decoder_input_ids).dims[0];
          if (decoder_input_ids_batch_size !== last_hidden_state.dims[0]) {
            if (last_hidden_state.dims[0] !== 1) {
              throw new Error(`The encoder outputs have a different batch size (${last_hidden_state.dims[0]}) than the decoder inputs (${decoder_input_ids_batch_size}).`);
            }
            last_hidden_state = (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.cat)(Array.from({ length: decoder_input_ids_batch_size }, () => last_hidden_state), 0);
          }
        }
        model_inputs["encoder_outputs"] = last_hidden_state;
        return model_inputs;
      }
      _prepare_decoder_input_ids_for_generation({ batch_size, model_input_name, model_kwargs, decoder_start_token_id, bos_token_id, generation_config }) {
        let { decoder_input_ids, ...model_inputs } = model_kwargs;
        if (!(decoder_input_ids instanceof _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.Tensor)) {
          if (!decoder_input_ids) {
            decoder_start_token_id ??= bos_token_id;
            if (this.config.model_type === "musicgen") {
              decoder_input_ids = Array.from({
                length: batch_size * this.config.decoder.num_codebooks
              }, () => [decoder_start_token_id]);
            } else if (Array.isArray(decoder_start_token_id)) {
              if (decoder_start_token_id.length !== batch_size) {
                throw new Error(`\`decoder_start_token_id\` expcted to have length ${batch_size} but got ${decoder_start_token_id.length}`);
              }
              decoder_input_ids = decoder_start_token_id;
            } else {
              decoder_input_ids = Array.from({
                length: batch_size
              }, () => [decoder_start_token_id]);
            }
          } else if (!Array.isArray(decoder_input_ids[0])) {
            decoder_input_ids = Array.from({
              length: batch_size
            }, () => decoder_input_ids);
          }
          decoder_input_ids = toI64Tensor(decoder_input_ids);
        }
        model_kwargs["decoder_attention_mask"] = (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.ones_like)(decoder_input_ids);
        return { input_ids: decoder_input_ids, model_inputs };
      }
      async generate({
        inputs = null,
        generation_config = null,
        logits_processor = null,
        stopping_criteria = null,
        streamer = null,
        ...kwargs
      }) {
        this._validate_model_class();
        generation_config = this._prepare_generation_config(generation_config, kwargs);
        let { inputs_tensor, model_inputs, model_input_name } = this._prepare_model_inputs({
          inputs,
          model_kwargs: kwargs
        });
        const is_encoder_decoder = this.config.is_encoder_decoder;
        if (!is_encoder_decoder) {} else if (!("encoder_outputs" in model_inputs)) {
          model_inputs = await this._prepare_encoder_decoder_kwargs_for_generation({ inputs_tensor, model_inputs, model_input_name, generation_config });
        }
        let input_ids;
        if (is_encoder_decoder) {
          ({ input_ids, model_inputs } = this._prepare_decoder_input_ids_for_generation({
            batch_size: model_inputs[model_input_name].dims.at(0),
            model_input_name,
            model_kwargs: model_inputs,
            decoder_start_token_id: generation_config.decoder_start_token_id,
            bos_token_id: generation_config.bos_token_id,
            generation_config
          }));
        } else {
          input_ids = model_inputs[model_input_name];
        }
        let input_ids_length = input_ids.dims.at(-1);
        if (generation_config.max_new_tokens !== null) {
          generation_config.max_length = input_ids_length + generation_config.max_new_tokens;
        }
        const prepared_logits_processor = this._get_logits_processor(generation_config, input_ids_length, logits_processor);
        const prepared_stopping_criteria = this._get_stopping_criteria(generation_config, stopping_criteria);
        const numInputs = model_inputs[model_input_name].dims.at(0);
        const sampler = _generation_logits_sampler_js__WEBPACK_IMPORTED_MODULE_13__.LogitsSampler.getSampler(generation_config);
        const scores = new Array(numInputs).fill(0);
        const all_input_ids = input_ids.tolist();
        if (streamer) {
          streamer.put(all_input_ids);
        }
        let outputs;
        let attentions = {};
        while (true) {
          model_inputs = this.prepare_inputs_for_generation(all_input_ids, model_inputs, generation_config);
          outputs = await this.forward(model_inputs);
          if (generation_config.output_attentions && generation_config.return_dict_in_generate) {
            const token_attentions = this.getAttentions(outputs);
            for (const key in token_attentions) {
              if (!(key in attentions)) {
                attentions[key] = [];
              }
              attentions[key].push(token_attentions[key]);
            }
          }
          const logits = outputs.logits.slice(null, -1, null);
          const next_tokens_scores = prepared_logits_processor(all_input_ids, logits);
          const generated_input_ids = [];
          for (let batch_idx = 0;batch_idx < next_tokens_scores.dims.at(0); ++batch_idx) {
            const logs = next_tokens_scores[batch_idx];
            const sampledTokens = await sampler(logs);
            for (const [newTokenId, logProb] of sampledTokens) {
              const bigint6 = BigInt(newTokenId);
              scores[batch_idx] += logProb;
              all_input_ids[batch_idx].push(bigint6);
              generated_input_ids.push([bigint6]);
              break;
            }
          }
          if (streamer) {
            streamer.put(generated_input_ids);
          }
          const stop = prepared_stopping_criteria(all_input_ids);
          if (stop.every((x) => x)) {
            break;
          }
          model_inputs = this._update_model_kwargs_for_generation({
            generated_input_ids,
            outputs,
            model_inputs,
            is_encoder_decoder
          });
        }
        if (streamer) {
          streamer.end();
        }
        const past_key_values = this.getPastKeyValues(outputs, model_inputs.past_key_values, true);
        const sequences = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.Tensor("int64", all_input_ids.flat(), [all_input_ids.length, all_input_ids[0].length]);
        if (generation_config.return_dict_in_generate) {
          return {
            sequences,
            past_key_values,
            ...attentions
          };
        } else {
          for (const tensor2 of Object.values(outputs)) {
            if (tensor2.location === "gpu-buffer") {
              tensor2.dispose();
            }
          }
          return sequences;
        }
      }
      getPastKeyValues(decoderResults, pastKeyValues, disposeEncoderPKVs = false) {
        const pkvs = Object.create(null);
        for (const name in decoderResults) {
          if (name.startsWith("present")) {
            const newName = name.replace("present_conv", "past_conv").replace("present", "past_key_values");
            const is_encoder_pkv = name.includes("encoder");
            if (is_encoder_pkv && pastKeyValues) {
              pkvs[newName] = pastKeyValues[newName];
            } else {
              pkvs[newName] = decoderResults[name];
            }
            if (pastKeyValues && (!is_encoder_pkv || disposeEncoderPKVs)) {
              const t = pastKeyValues[newName];
              if (t.location === "gpu-buffer") {
                t.dispose();
              }
            }
          }
        }
        return pkvs;
      }
      getAttentions(model_output) {
        const attentions = {};
        for (const attnName of ["cross_attentions", "encoder_attentions", "decoder_attentions"]) {
          for (const name in model_output) {
            if (name.startsWith(attnName)) {
              if (!(attnName in attentions)) {
                attentions[attnName] = [];
              }
              attentions[attnName].push(model_output[name]);
            }
          }
        }
        return attentions;
      }
      addPastKeyValues(decoderFeeds, pastKeyValues) {
        if (pastKeyValues) {
          Object.assign(decoderFeeds, pastKeyValues);
        } else {
          const session = this.sessions["decoder_model_merged"] ?? this.sessions["model"];
          const batch_size = (decoderFeeds[this.main_input_name] ?? decoderFeeds.attention_mask)?.dims?.[0] ?? 1;
          const dtype = session?.config?.kv_cache_dtype ?? "float32";
          const cls = dtype === "float16" ? _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.DataTypeMap.float16 : _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.DataTypeMap.float32;
          const shapes = (0, _configs_js__WEBPACK_IMPORTED_MODULE_0__.getCacheShapes)(this.config, { batch_size });
          for (const name in shapes) {
            const size = shapes[name].reduce((a, b) => a * b, 1);
            decoderFeeds[name] = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.Tensor(dtype, new cls(size), shapes[name]);
          }
        }
      }
      async encode_image({ pixel_values }) {
        return (await sessionRun(this.sessions["vision_encoder"], { pixel_values })).image_features;
      }
      async encode_text({ input_ids }) {
        return (await sessionRun(this.sessions["embed_tokens"], { input_ids })).inputs_embeds;
      }
      async encode_audio({ audio_values }) {
        return (await sessionRun(this.sessions["audio_encoder"], { audio_values })).audio_features;
      }
    }

    class ModelOutput {
    }

    class BaseModelOutput extends ModelOutput {
      constructor({ last_hidden_state, hidden_states = null, attentions = null }) {
        super();
        this.last_hidden_state = last_hidden_state;
        this.hidden_states = hidden_states;
        this.attentions = attentions;
      }
    }

    class BertPreTrainedModel extends PreTrainedModel {
    }

    class BertModel extends BertPreTrainedModel {
    }

    class BertForMaskedLM extends BertPreTrainedModel {
      async _call(model_inputs) {
        return new MaskedLMOutput(await super._call(model_inputs));
      }
    }

    class BertForSequenceClassification extends BertPreTrainedModel {
      async _call(model_inputs) {
        return new SequenceClassifierOutput(await super._call(model_inputs));
      }
    }

    class BertForTokenClassification extends BertPreTrainedModel {
      async _call(model_inputs) {
        return new TokenClassifierOutput(await super._call(model_inputs));
      }
    }

    class BertForQuestionAnswering extends BertPreTrainedModel {
      async _call(model_inputs) {
        return new QuestionAnsweringModelOutput(await super._call(model_inputs));
      }
    }

    class NeoBertPreTrainedModel extends PreTrainedModel {
    }

    class NeoBertModel extends NeoBertPreTrainedModel {
    }

    class NeoBertForMaskedLM extends NeoBertPreTrainedModel {
      async _call(model_inputs) {
        return new MaskedLMOutput(await super._call(model_inputs));
      }
    }

    class NeoBertForSequenceClassification extends NeoBertPreTrainedModel {
      async _call(model_inputs) {
        return new SequenceClassifierOutput(await super._call(model_inputs));
      }
    }

    class NeoBertForTokenClassification extends NeoBertPreTrainedModel {
      async _call(model_inputs) {
        return new TokenClassifierOutput(await super._call(model_inputs));
      }
    }

    class NeoBertForQuestionAnswering extends NeoBertPreTrainedModel {
      async _call(model_inputs) {
        return new QuestionAnsweringModelOutput(await super._call(model_inputs));
      }
    }

    class ModernBertPreTrainedModel extends PreTrainedModel {
    }

    class ModernBertModel extends ModernBertPreTrainedModel {
    }

    class ModernBertForMaskedLM extends ModernBertPreTrainedModel {
      async _call(model_inputs) {
        return new MaskedLMOutput(await super._call(model_inputs));
      }
    }

    class ModernBertForSequenceClassification extends ModernBertPreTrainedModel {
      async _call(model_inputs) {
        return new SequenceClassifierOutput(await super._call(model_inputs));
      }
    }

    class ModernBertForTokenClassification extends ModernBertPreTrainedModel {
      async _call(model_inputs) {
        return new TokenClassifierOutput(await super._call(model_inputs));
      }
    }

    class ModernBertDecoderPreTrainedModel extends PreTrainedModel {
    }

    class ModernBertDecoderModel extends ModernBertDecoderPreTrainedModel {
    }

    class ModernBertDecoderForCausalLM extends ModernBertDecoderPreTrainedModel {
    }

    class NomicBertPreTrainedModel extends PreTrainedModel {
    }

    class NomicBertModel extends NomicBertPreTrainedModel {
    }

    class RoFormerPreTrainedModel extends PreTrainedModel {
    }

    class RoFormerModel extends RoFormerPreTrainedModel {
    }

    class RoFormerForMaskedLM extends RoFormerPreTrainedModel {
      async _call(model_inputs) {
        return new MaskedLMOutput(await super._call(model_inputs));
      }
    }

    class RoFormerForSequenceClassification extends RoFormerPreTrainedModel {
      async _call(model_inputs) {
        return new SequenceClassifierOutput(await super._call(model_inputs));
      }
    }

    class RoFormerForTokenClassification extends RoFormerPreTrainedModel {
      async _call(model_inputs) {
        return new TokenClassifierOutput(await super._call(model_inputs));
      }
    }

    class RoFormerForQuestionAnswering extends RoFormerPreTrainedModel {
      async _call(model_inputs) {
        return new QuestionAnsweringModelOutput(await super._call(model_inputs));
      }
    }

    class ConvBertPreTrainedModel extends PreTrainedModel {
    }

    class ConvBertModel extends ConvBertPreTrainedModel {
    }

    class ConvBertForMaskedLM extends ConvBertPreTrainedModel {
      async _call(model_inputs) {
        return new MaskedLMOutput(await super._call(model_inputs));
      }
    }

    class ConvBertForSequenceClassification extends ConvBertPreTrainedModel {
      async _call(model_inputs) {
        return new SequenceClassifierOutput(await super._call(model_inputs));
      }
    }

    class ConvBertForTokenClassification extends ConvBertPreTrainedModel {
      async _call(model_inputs) {
        return new TokenClassifierOutput(await super._call(model_inputs));
      }
    }

    class ConvBertForQuestionAnswering extends ConvBertPreTrainedModel {
      async _call(model_inputs) {
        return new QuestionAnsweringModelOutput(await super._call(model_inputs));
      }
    }

    class ElectraPreTrainedModel extends PreTrainedModel {
    }

    class ElectraModel extends ElectraPreTrainedModel {
    }

    class ElectraForMaskedLM extends ElectraPreTrainedModel {
      async _call(model_inputs) {
        return new MaskedLMOutput(await super._call(model_inputs));
      }
    }

    class ElectraForSequenceClassification extends ElectraPreTrainedModel {
      async _call(model_inputs) {
        return new SequenceClassifierOutput(await super._call(model_inputs));
      }
    }

    class ElectraForTokenClassification extends ElectraPreTrainedModel {
      async _call(model_inputs) {
        return new TokenClassifierOutput(await super._call(model_inputs));
      }
    }

    class ElectraForQuestionAnswering extends ElectraPreTrainedModel {
      async _call(model_inputs) {
        return new QuestionAnsweringModelOutput(await super._call(model_inputs));
      }
    }

    class CamembertPreTrainedModel extends PreTrainedModel {
    }

    class CamembertModel extends CamembertPreTrainedModel {
    }

    class CamembertForMaskedLM extends CamembertPreTrainedModel {
      async _call(model_inputs) {
        return new MaskedLMOutput(await super._call(model_inputs));
      }
    }

    class CamembertForSequenceClassification extends CamembertPreTrainedModel {
      async _call(model_inputs) {
        return new SequenceClassifierOutput(await super._call(model_inputs));
      }
    }

    class CamembertForTokenClassification extends CamembertPreTrainedModel {
      async _call(model_inputs) {
        return new TokenClassifierOutput(await super._call(model_inputs));
      }
    }

    class CamembertForQuestionAnswering extends CamembertPreTrainedModel {
      async _call(model_inputs) {
        return new QuestionAnsweringModelOutput(await super._call(model_inputs));
      }
    }

    class DebertaPreTrainedModel extends PreTrainedModel {
    }

    class DebertaModel extends DebertaPreTrainedModel {
    }

    class DebertaForMaskedLM extends DebertaPreTrainedModel {
      async _call(model_inputs) {
        return new MaskedLMOutput(await super._call(model_inputs));
      }
    }

    class DebertaForSequenceClassification extends DebertaPreTrainedModel {
      async _call(model_inputs) {
        return new SequenceClassifierOutput(await super._call(model_inputs));
      }
    }

    class DebertaForTokenClassification extends DebertaPreTrainedModel {
      async _call(model_inputs) {
        return new TokenClassifierOutput(await super._call(model_inputs));
      }
    }

    class DebertaForQuestionAnswering extends DebertaPreTrainedModel {
      async _call(model_inputs) {
        return new QuestionAnsweringModelOutput(await super._call(model_inputs));
      }
    }

    class DebertaV2PreTrainedModel extends PreTrainedModel {
    }

    class DebertaV2Model extends DebertaV2PreTrainedModel {
    }

    class DebertaV2ForMaskedLM extends DebertaV2PreTrainedModel {
      async _call(model_inputs) {
        return new MaskedLMOutput(await super._call(model_inputs));
      }
    }

    class DebertaV2ForSequenceClassification extends DebertaV2PreTrainedModel {
      async _call(model_inputs) {
        return new SequenceClassifierOutput(await super._call(model_inputs));
      }
    }

    class DebertaV2ForTokenClassification extends DebertaV2PreTrainedModel {
      async _call(model_inputs) {
        return new TokenClassifierOutput(await super._call(model_inputs));
      }
    }

    class DebertaV2ForQuestionAnswering extends DebertaV2PreTrainedModel {
      async _call(model_inputs) {
        return new QuestionAnsweringModelOutput(await super._call(model_inputs));
      }
    }

    class DistilBertPreTrainedModel extends PreTrainedModel {
    }

    class DistilBertModel extends DistilBertPreTrainedModel {
    }

    class DistilBertForSequenceClassification extends DistilBertPreTrainedModel {
      async _call(model_inputs) {
        return new SequenceClassifierOutput(await super._call(model_inputs));
      }
    }

    class DistilBertForTokenClassification extends DistilBertPreTrainedModel {
      async _call(model_inputs) {
        return new TokenClassifierOutput(await super._call(model_inputs));
      }
    }

    class DistilBertForQuestionAnswering extends DistilBertPreTrainedModel {
      async _call(model_inputs) {
        return new QuestionAnsweringModelOutput(await super._call(model_inputs));
      }
    }

    class DistilBertForMaskedLM extends DistilBertPreTrainedModel {
      async _call(model_inputs) {
        return new MaskedLMOutput(await super._call(model_inputs));
      }
    }

    class EsmPreTrainedModel extends PreTrainedModel {
    }

    class EsmModel extends EsmPreTrainedModel {
    }

    class EsmForMaskedLM extends EsmPreTrainedModel {
      async _call(model_inputs) {
        return new MaskedLMOutput(await super._call(model_inputs));
      }
    }

    class EsmForSequenceClassification extends EsmPreTrainedModel {
      async _call(model_inputs) {
        return new SequenceClassifierOutput(await super._call(model_inputs));
      }
    }

    class EsmForTokenClassification extends EsmPreTrainedModel {
      async _call(model_inputs) {
        return new TokenClassifierOutput(await super._call(model_inputs));
      }
    }

    class MobileBertPreTrainedModel extends PreTrainedModel {
    }

    class MobileBertModel extends MobileBertPreTrainedModel {
    }

    class MobileBertForMaskedLM extends MobileBertPreTrainedModel {
      async _call(model_inputs) {
        return new MaskedLMOutput(await super._call(model_inputs));
      }
    }

    class MobileBertForSequenceClassification extends MobileBertPreTrainedModel {
      async _call(model_inputs) {
        return new SequenceClassifierOutput(await super._call(model_inputs));
      }
    }

    class MobileBertForQuestionAnswering extends MobileBertPreTrainedModel {
      async _call(model_inputs) {
        return new QuestionAnsweringModelOutput(await super._call(model_inputs));
      }
    }

    class MPNetPreTrainedModel extends PreTrainedModel {
    }

    class MPNetModel extends MPNetPreTrainedModel {
    }

    class MPNetForMaskedLM extends MPNetPreTrainedModel {
      async _call(model_inputs) {
        return new MaskedLMOutput(await super._call(model_inputs));
      }
    }

    class MPNetForSequenceClassification extends MPNetPreTrainedModel {
      async _call(model_inputs) {
        return new SequenceClassifierOutput(await super._call(model_inputs));
      }
    }

    class MPNetForTokenClassification extends MPNetPreTrainedModel {
      async _call(model_inputs) {
        return new TokenClassifierOutput(await super._call(model_inputs));
      }
    }

    class MPNetForQuestionAnswering extends MPNetPreTrainedModel {
      async _call(model_inputs) {
        return new QuestionAnsweringModelOutput(await super._call(model_inputs));
      }
    }

    class SqueezeBertPreTrainedModel extends PreTrainedModel {
    }

    class SqueezeBertModel extends SqueezeBertPreTrainedModel {
    }

    class SqueezeBertForMaskedLM extends SqueezeBertPreTrainedModel {
      async _call(model_inputs) {
        return new MaskedLMOutput(await super._call(model_inputs));
      }
    }

    class SqueezeBertForSequenceClassification extends SqueezeBertPreTrainedModel {
      async _call(model_inputs) {
        return new SequenceClassifierOutput(await super._call(model_inputs));
      }
    }

    class SqueezeBertForQuestionAnswering extends SqueezeBertPreTrainedModel {
      async _call(model_inputs) {
        return new QuestionAnsweringModelOutput(await super._call(model_inputs));
      }
    }

    class AlbertPreTrainedModel extends PreTrainedModel {
    }

    class AlbertModel extends AlbertPreTrainedModel {
    }

    class AlbertForSequenceClassification extends AlbertPreTrainedModel {
      async _call(model_inputs) {
        return new SequenceClassifierOutput(await super._call(model_inputs));
      }
    }

    class AlbertForQuestionAnswering extends AlbertPreTrainedModel {
      async _call(model_inputs) {
        return new QuestionAnsweringModelOutput(await super._call(model_inputs));
      }
    }

    class AlbertForMaskedLM extends AlbertPreTrainedModel {
      async _call(model_inputs) {
        return new MaskedLMOutput(await super._call(model_inputs));
      }
    }

    class T5PreTrainedModel extends PreTrainedModel {
      forward_params = [
        "input_ids",
        "attention_mask",
        "encoder_outputs",
        "decoder_input_ids",
        "decoder_attention_mask",
        "past_key_values"
      ];
    }

    class T5Model extends T5PreTrainedModel {
    }

    class T5ForConditionalGeneration extends T5PreTrainedModel {
    }

    class LongT5PreTrainedModel extends PreTrainedModel {
    }

    class LongT5Model extends LongT5PreTrainedModel {
    }

    class LongT5ForConditionalGeneration extends LongT5PreTrainedModel {
    }

    class MT5PreTrainedModel extends PreTrainedModel {
    }

    class MT5Model extends MT5PreTrainedModel {
    }

    class MT5ForConditionalGeneration extends MT5PreTrainedModel {
    }

    class BartPretrainedModel extends PreTrainedModel {
    }

    class BartModel extends BartPretrainedModel {
    }

    class BartForConditionalGeneration extends BartPretrainedModel {
    }

    class BartForSequenceClassification extends BartPretrainedModel {
      async _call(model_inputs) {
        return new SequenceClassifierOutput(await super._call(model_inputs));
      }
    }

    class MBartPreTrainedModel extends PreTrainedModel {
    }

    class MBartModel extends MBartPreTrainedModel {
    }

    class MBartForConditionalGeneration extends MBartPreTrainedModel {
    }

    class MBartForSequenceClassification extends MBartPreTrainedModel {
      async _call(model_inputs) {
        return new SequenceClassifierOutput(await super._call(model_inputs));
      }
    }

    class MBartForCausalLM extends MBartPreTrainedModel {
    }

    class BlenderbotPreTrainedModel extends PreTrainedModel {
    }

    class BlenderbotModel extends BlenderbotPreTrainedModel {
    }

    class BlenderbotForConditionalGeneration extends BlenderbotPreTrainedModel {
    }

    class BlenderbotSmallPreTrainedModel extends PreTrainedModel {
    }

    class BlenderbotSmallModel extends BlenderbotSmallPreTrainedModel {
    }

    class BlenderbotSmallForConditionalGeneration extends BlenderbotSmallPreTrainedModel {
    }

    class RobertaPreTrainedModel extends PreTrainedModel {
    }

    class RobertaModel extends RobertaPreTrainedModel {
    }

    class RobertaForMaskedLM extends RobertaPreTrainedModel {
      async _call(model_inputs) {
        return new MaskedLMOutput(await super._call(model_inputs));
      }
    }

    class RobertaForSequenceClassification extends RobertaPreTrainedModel {
      async _call(model_inputs) {
        return new SequenceClassifierOutput(await super._call(model_inputs));
      }
    }

    class RobertaForTokenClassification extends RobertaPreTrainedModel {
      async _call(model_inputs) {
        return new TokenClassifierOutput(await super._call(model_inputs));
      }
    }

    class RobertaForQuestionAnswering extends RobertaPreTrainedModel {
      async _call(model_inputs) {
        return new QuestionAnsweringModelOutput(await super._call(model_inputs));
      }
    }

    class XLMPreTrainedModel extends PreTrainedModel {
    }

    class XLMModel extends XLMPreTrainedModel {
    }

    class XLMWithLMHeadModel extends XLMPreTrainedModel {
      async _call(model_inputs) {
        return new MaskedLMOutput(await super._call(model_inputs));
      }
    }

    class XLMForSequenceClassification extends XLMPreTrainedModel {
      async _call(model_inputs) {
        return new SequenceClassifierOutput(await super._call(model_inputs));
      }
    }

    class XLMForTokenClassification extends XLMPreTrainedModel {
      async _call(model_inputs) {
        return new TokenClassifierOutput(await super._call(model_inputs));
      }
    }

    class XLMForQuestionAnswering extends XLMPreTrainedModel {
      async _call(model_inputs) {
        return new QuestionAnsweringModelOutput(await super._call(model_inputs));
      }
    }

    class XLMRobertaPreTrainedModel extends PreTrainedModel {
    }

    class XLMRobertaModel extends XLMRobertaPreTrainedModel {
    }

    class XLMRobertaForMaskedLM extends XLMRobertaPreTrainedModel {
      async _call(model_inputs) {
        return new MaskedLMOutput(await super._call(model_inputs));
      }
    }

    class XLMRobertaForSequenceClassification extends XLMRobertaPreTrainedModel {
      async _call(model_inputs) {
        return new SequenceClassifierOutput(await super._call(model_inputs));
      }
    }

    class XLMRobertaForTokenClassification extends XLMRobertaPreTrainedModel {
      async _call(model_inputs) {
        return new TokenClassifierOutput(await super._call(model_inputs));
      }
    }

    class XLMRobertaForQuestionAnswering extends XLMRobertaPreTrainedModel {
      async _call(model_inputs) {
        return new QuestionAnsweringModelOutput(await super._call(model_inputs));
      }
    }

    class ASTPreTrainedModel extends PreTrainedModel {
    }

    class ASTModel extends ASTPreTrainedModel {
    }

    class ASTForAudioClassification extends ASTPreTrainedModel {
    }

    class WhisperPreTrainedModel extends PreTrainedModel {
      requires_attention_mask = false;
      main_input_name = "input_features";
      forward_params = [
        "input_features",
        "attention_mask",
        "decoder_input_ids",
        "decoder_attention_mask",
        "past_key_values"
      ];
    }

    class WhisperModel extends WhisperPreTrainedModel {
    }

    class WhisperForConditionalGeneration extends WhisperPreTrainedModel {
      _prepare_generation_config(generation_config, kwargs) {
        return super._prepare_generation_config(generation_config, kwargs, _models_whisper_generation_whisper_js__WEBPACK_IMPORTED_MODULE_15__.WhisperGenerationConfig);
      }
      _retrieve_init_tokens(generation_config) {
        const init_tokens = [generation_config.decoder_start_token_id];
        let language = generation_config.language;
        const task = generation_config.task;
        if (generation_config.is_multilingual) {
          if (!language) {
            console.warn("No language specified - defaulting to English (en).");
            language = "en";
          }
          const language_code = (0, _models_whisper_common_whisper_js__WEBPACK_IMPORTED_MODULE_16__.whisper_language_to_code)(language);
          const language_token = `<|${language_code}|>`;
          init_tokens.push(generation_config.lang_to_id[language_token]);
          init_tokens.push(generation_config.task_to_id[task ?? "transcribe"]);
        } else if (language || task) {
          throw new Error("Cannot specify `task` or `language` for an English-only model. If the model is intended to be multilingual, pass `is_multilingual=true` to generate, or update the generation config.");
        }
        if (!generation_config.return_timestamps && generation_config.no_timestamps_token_id && init_tokens.at(-1) !== generation_config.no_timestamps_token_id) {
          init_tokens.push(generation_config.no_timestamps_token_id);
        } else if (generation_config.return_timestamps && init_tokens.at(-1) === generation_config.no_timestamps_token_id) {
          console.warn("<|notimestamps|> prompt token is removed from generation_config since `return_timestamps` is set to `true`.");
          init_tokens.pop();
        }
        return init_tokens.filter((token) => token != null);
      }
      async generate({
        inputs = null,
        generation_config = null,
        logits_processor = null,
        stopping_criteria = null,
        ...kwargs
      }) {
        generation_config = this._prepare_generation_config(generation_config, kwargs);
        const init_tokens = kwargs.decoder_input_ids ?? this._retrieve_init_tokens(generation_config);
        if (generation_config.return_timestamps) {
          logits_processor ??= new _generation_logits_process_js__WEBPACK_IMPORTED_MODULE_7__.LogitsProcessorList;
          logits_processor.push(new _generation_logits_process_js__WEBPACK_IMPORTED_MODULE_7__.WhisperTimeStampLogitsProcessor(generation_config, init_tokens));
        }
        if (generation_config.begin_suppress_tokens) {
          logits_processor ??= new _generation_logits_process_js__WEBPACK_IMPORTED_MODULE_7__.LogitsProcessorList;
          logits_processor.push(new _generation_logits_process_js__WEBPACK_IMPORTED_MODULE_7__.SuppressTokensAtBeginLogitsProcessor(generation_config.begin_suppress_tokens, init_tokens.length));
        }
        if (generation_config.return_token_timestamps) {
          if (!generation_config.alignment_heads) {
            throw new Error("Model generation config has no `alignment_heads`, token-level timestamps not available. " + "See https://gist.github.com/hollance/42e32852f24243b748ae6bc1f985b13a on how to add this property to the generation config.");
          }
          if (generation_config.task === "translate") {
            console.warn("Token-level timestamps may not be reliable for task 'translate'.");
          }
          generation_config.output_attentions = true;
          generation_config.return_dict_in_generate = true;
        }
        const outputs = await super.generate({
          inputs,
          generation_config,
          logits_processor,
          decoder_input_ids: init_tokens,
          ...kwargs
        });
        if (generation_config.return_token_timestamps) {
          outputs["token_timestamps"] = this._extract_token_timestamps(outputs, generation_config.alignment_heads, generation_config.num_frames);
        }
        return outputs;
      }
      _extract_token_timestamps(generate_outputs, alignment_heads, num_frames = null, time_precision = 0.02) {
        if (!generate_outputs.cross_attentions) {
          throw new Error("Model outputs must contain cross attentions to extract timestamps. " + "This is most likely because the model was not exported with `output_attentions=True`.");
        }
        if (num_frames == null) {
          console.warn("`num_frames` has not been set, meaning the entire audio will be analyzed. " + "This may lead to inaccurate token-level timestamps for short audios (< 30 seconds).");
        }
        let median_filter_width = this.config.median_filter_width;
        if (median_filter_width === undefined) {
          console.warn("Model config has no `median_filter_width`, using default value of 7.");
          median_filter_width = 7;
        }
        const batch = generate_outputs.cross_attentions;
        const cross_attentions = Array.from({ length: this.config.decoder_layers }, (_, i) => (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.cat)(batch.map((x) => x[i]), 2));
        const weights = (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.stack)(alignment_heads.map(([l, h]) => {
          if (l >= cross_attentions.length) {
            throw new Error(`Layer index ${l} is out of bounds for cross attentions (length ${cross_attentions.length}).`);
          }
          return num_frames ? cross_attentions[l].slice(null, h, null, [0, num_frames]) : cross_attentions[l].slice(null, h);
        })).transpose(1, 0, 2, 3);
        const [std, calculatedMean] = (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.std_mean)(weights, -2, 0, true);
        const smoothedWeights = weights.clone();
        for (let a = 0;a < smoothedWeights.dims[0]; ++a) {
          const aTensor = smoothedWeights[a];
          for (let b = 0;b < aTensor.dims[0]; ++b) {
            const bTensor = aTensor[b];
            const stdTensorData = std[a][b][0].data;
            const meanTensorData = calculatedMean[a][b][0].data;
            for (let c = 0;c < bTensor.dims[0]; ++c) {
              let cTensorData = bTensor[c].data;
              for (let d = 0;d < cTensorData.length; ++d) {
                cTensorData[d] = (cTensorData[d] - meanTensorData[d]) / stdTensorData[d];
              }
              cTensorData.set((0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_11__.medianFilter)(cTensorData, median_filter_width));
            }
          }
        }
        const batchedMatrices = [(0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.mean)(smoothedWeights, 1)];
        const timestampsShape = generate_outputs.sequences.dims;
        const timestamps = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.Tensor("float32", new Float32Array(timestampsShape[0] * timestampsShape[1]), timestampsShape);
        for (let batch_idx = 0;batch_idx < timestampsShape[0]; ++batch_idx) {
          const matrix = batchedMatrices[batch_idx].neg().squeeze_(0);
          const [text_indices, time_indices] = (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_11__.dynamic_time_warping)(matrix.tolist());
          const diffs = Array.from({ length: text_indices.length - 1 }, (v, i) => text_indices[i + 1] - text_indices[i]);
          const jumps = (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_4__.mergeArrays)([1], diffs).map((x) => !!x);
          const jump_times = [];
          for (let i = 0;i < jumps.length; ++i) {
            if (jumps[i]) {
              jump_times.push(time_indices[i] * time_precision);
            }
          }
          timestamps[batch_idx].data.set(jump_times, 1);
        }
        return timestamps;
      }
    }

    class LiteWhisperForConditionalGeneration extends WhisperForConditionalGeneration {
    }

    class MoonshinePreTrainedModel extends PreTrainedModel {
      requires_attention_mask = false;
      main_input_name = "input_values";
      forward_params = [
        "input_values",
        "decoder_input_ids",
        "past_key_values"
      ];
    }

    class MoonshineModel extends MoonshinePreTrainedModel {
    }

    class MoonshineForConditionalGeneration extends MoonshinePreTrainedModel {
    }

    class VisionEncoderDecoderModel extends PreTrainedModel {
      main_input_name = "pixel_values";
      forward_params = [
        "pixel_values",
        "decoder_input_ids",
        "encoder_hidden_states",
        "past_key_values"
      ];
    }

    class LlavaPreTrainedModel extends PreTrainedModel {
      forward_params = [
        "input_ids",
        "attention_mask",
        "pixel_values",
        "position_ids",
        "past_key_values"
      ];
    }

    class LlavaForConditionalGeneration extends LlavaPreTrainedModel {
      _merge_input_ids_with_image_features(kwargs) {
        const vision_hidden_size = kwargs.image_features.dims.at(-1);
        const reshaped_image_hidden_states = kwargs.image_features.view(-1, vision_hidden_size);
        return default_merge_input_ids_with_image_features({
          image_token_id: this.config.image_token_index,
          ...kwargs,
          image_features: reshaped_image_hidden_states
        });
      }
    }

    class LlavaOnevisionForConditionalGeneration extends LlavaForConditionalGeneration {
    }

    class Moondream1ForConditionalGeneration extends LlavaForConditionalGeneration {
    }

    class Florence2PreTrainedModel extends PreTrainedModel {
      forward_params = [
        "input_ids",
        "inputs_embeds",
        "attention_mask",
        "pixel_values",
        "encoder_outputs",
        "decoder_input_ids",
        "decoder_inputs_embeds",
        "decoder_attention_mask",
        "past_key_values"
      ];
      main_input_name = "inputs_embeds";
    }

    class Florence2ForConditionalGeneration extends Florence2PreTrainedModel {
      _merge_input_ids_with_image_features({
        inputs_embeds,
        image_features,
        input_ids,
        attention_mask
      }) {
        return {
          inputs_embeds: (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.cat)([
            image_features,
            inputs_embeds
          ], 1),
          attention_mask: (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.cat)([
            (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.ones)(image_features.dims.slice(0, 2)),
            attention_mask
          ], 1)
        };
      }
      async _prepare_inputs_embeds({ input_ids, pixel_values, inputs_embeds, attention_mask }) {
        if (!input_ids && !pixel_values) {
          throw new Error("Either `input_ids` or `pixel_values` should be provided.");
        }
        let text_features, image_features;
        if (input_ids) {
          text_features = await this.encode_text({ input_ids });
        }
        if (pixel_values) {
          image_features = await this.encode_image({ pixel_values });
        }
        if (text_features && image_features) {
          ({ inputs_embeds, attention_mask } = this._merge_input_ids_with_image_features({
            inputs_embeds: text_features,
            image_features,
            input_ids,
            attention_mask
          }));
        } else {
          inputs_embeds = text_features || image_features;
        }
        return { inputs_embeds, attention_mask };
      }
      async forward({
        input_ids,
        pixel_values,
        attention_mask,
        decoder_input_ids,
        decoder_attention_mask,
        encoder_outputs,
        past_key_values,
        inputs_embeds,
        decoder_inputs_embeds
      }) {
        if (!inputs_embeds) {
          ({ inputs_embeds, attention_mask } = await this._prepare_inputs_embeds({ input_ids, pixel_values, inputs_embeds, attention_mask }));
        }
        if (!encoder_outputs) {
          let { last_hidden_state } = await encoderForward(this, { inputs_embeds, attention_mask });
          encoder_outputs = last_hidden_state;
        }
        if (!decoder_inputs_embeds) {
          if (!decoder_input_ids) {
            throw new Error("Either `decoder_input_ids` or `decoder_inputs_embeds` should be provided.");
          }
          decoder_inputs_embeds = await this.encode_text({ input_ids: decoder_input_ids });
        }
        const decoderFeeds = {
          inputs_embeds: decoder_inputs_embeds,
          attention_mask: decoder_attention_mask,
          encoder_attention_mask: attention_mask,
          encoder_hidden_states: encoder_outputs,
          past_key_values
        };
        const decoder_outputs = await decoderForward(this, decoderFeeds, true);
        return decoder_outputs;
      }
    }

    class PaliGemmaPreTrainedModel extends PreTrainedModel {
      forward_params = [
        "input_ids",
        "attention_mask",
        "pixel_values",
        "position_ids",
        "past_key_values"
      ];
    }

    class PaliGemmaForConditionalGeneration extends PaliGemmaPreTrainedModel {
      _merge_input_ids_with_image_features(kwargs) {
        const vision_hidden_size = kwargs.image_features.dims.at(-1);
        const reshaped_image_hidden_states = kwargs.image_features.view(-1, vision_hidden_size);
        return default_merge_input_ids_with_image_features({
          image_token_id: this.config.image_token_index,
          ...kwargs,
          image_features: reshaped_image_hidden_states
        });
      }
    }

    class LlavaQwen2ForCausalLM extends LlavaPreTrainedModel {
      _merge_input_ids_with_image_features(kwargs) {
        const vision_hidden_size = kwargs.image_features.dims.at(-1);
        const reshaped_image_hidden_states = kwargs.image_features.view(-1, vision_hidden_size);
        return default_merge_input_ids_with_image_features({
          image_token_id: this.config.image_token_index,
          ...kwargs,
          image_features: reshaped_image_hidden_states
        });
      }
    }

    class Mistral3ForConditionalGeneration extends LlavaQwen2ForCausalLM {
    }

    class Gemma3nPreTrainedModel extends PreTrainedModel {
      forward_params = [
        "input_ids",
        "attention_mask",
        "inputs_embeds",
        "per_layer_inputs",
        "position_ids",
        "pixel_values",
        "input_features",
        "input_features_mask",
        "past_key_values"
      ];
    }

    class Gemma3nForConditionalGeneration extends Gemma3nPreTrainedModel {
      async forward({
        input_ids = null,
        attention_mask = null,
        pixel_values = null,
        input_features = null,
        input_features_mask = null,
        position_ids = null,
        inputs_embeds = null,
        per_layer_inputs = null,
        past_key_values = null,
        generation_config = null,
        logits_processor = null,
        ...kwargs
      }) {
        if (!inputs_embeds || !per_layer_inputs) {
          ({ inputs_embeds, per_layer_inputs } = await sessionRun(this.sessions["embed_tokens"], {
            input_ids
          }));
          if (input_ids.dims[1] !== 1) {
            if (pixel_values) {
              const { image_features } = await sessionRun(this.sessions["vision_encoder"], {
                pixel_values
              });
              ({ inputs_embeds, attention_mask } = this._merge_input_ids_with_image_features({
                image_features,
                inputs_embeds,
                input_ids,
                attention_mask
              }));
            }
            if (input_features) {
              const { audio_features } = await sessionRun(this.sessions["audio_encoder"], {
                input_features,
                input_features_mask
              });
              ({ inputs_embeds, attention_mask } = this._merge_input_ids_with_audio_features({
                audio_features,
                inputs_embeds,
                input_ids,
                attention_mask
              }));
            }
          }
        }
        const outputs = await decoderForward(this, {
          inputs_embeds,
          per_layer_inputs,
          past_key_values,
          attention_mask,
          position_ids,
          generation_config,
          logits_processor
        }, true);
        return outputs;
      }
      _merge_input_ids_with_image_features(kwargs) {
        const vision_hidden_size = kwargs.image_features.dims.at(-1);
        const reshaped_image_hidden_states = kwargs.image_features.view(-1, vision_hidden_size);
        return default_merge_input_ids_with_image_features({
          image_token_id: this.config.image_token_id,
          ...kwargs,
          image_features: reshaped_image_hidden_states
        });
      }
      _merge_input_ids_with_audio_features(kwargs) {
        const audio_hidden_size = kwargs.audio_features.dims.at(-1);
        const reshaped_audio_features = kwargs.audio_features.view(-1, audio_hidden_size);
        return default_merge_input_ids_with_audio_features({
          audio_token_id: this.config.audio_token_id,
          ...kwargs,
          audio_features: reshaped_audio_features
        });
      }
    }

    class Idefics3PreTrainedModel extends PreTrainedModel {
      forward_params = [
        "input_ids",
        "attention_mask",
        "pixel_values",
        "pixel_attention_mask",
        "position_ids",
        "past_key_values"
      ];
    }

    class Idefics3ForConditionalGeneration extends Idefics3PreTrainedModel {
      async encode_image({ pixel_values, pixel_attention_mask }) {
        const features = (await sessionRun(this.sessions["vision_encoder"], { pixel_values, pixel_attention_mask })).image_features;
        return features;
      }
      _merge_input_ids_with_image_features(kwargs) {
        const vision_hidden_size = kwargs.image_features.dims.at(-1);
        const reshaped_image_hidden_states = kwargs.image_features.view(-1, vision_hidden_size);
        return default_merge_input_ids_with_image_features({
          image_token_id: this.config.image_token_id,
          ...kwargs,
          image_features: reshaped_image_hidden_states
        });
      }
    }

    class SmolVLMForConditionalGeneration extends Idefics3ForConditionalGeneration {
    }

    class Phi3VPreTrainedModel extends PreTrainedModel {
      forward_params = [
        "input_ids",
        "inputs_embeds",
        "attention_mask",
        "position_ids",
        "pixel_values",
        "image_sizes",
        "past_key_values"
      ];
    }

    class Phi3VForCausalLM extends Phi3VPreTrainedModel {
      async forward({
        input_ids = null,
        attention_mask = null,
        pixel_values = null,
        image_sizes = null,
        position_ids = null,
        inputs_embeds = null,
        past_key_values = null,
        generation_config = null,
        logits_processor = null,
        ...kwargs
      }) {
        if (!inputs_embeds) {
          let image_features;
          if (pixel_values && input_ids.dims[1] !== 1) {
            if (!image_sizes) {
              throw new Error("`image_sizes` must be provided when `pixel_values` is provided.");
            }
            ({ image_features } = await sessionRun(this.sessions["vision_encoder"], {
              pixel_values,
              image_sizes
            }));
          } else {
            const hidden_size = this.config.normalized_config.hidden_size;
            image_features = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.Tensor("float32", [], [0, hidden_size]);
          }
          ({ inputs_embeds } = await sessionRun(this.sessions["prepare_inputs_embeds"], {
            input_ids,
            image_features
          }));
        }
        const outputs = await decoderForward(this, {
          inputs_embeds,
          past_key_values,
          attention_mask,
          position_ids,
          generation_config,
          logits_processor
        }, false);
        return outputs;
      }
    }

    class CLIPPreTrainedModel extends PreTrainedModel {
    }

    class CLIPModel extends CLIPPreTrainedModel {
    }

    class CLIPTextModel extends CLIPPreTrainedModel {
      static async from_pretrained(pretrained_model_name_or_path, options2 = {}) {
        return super.from_pretrained(pretrained_model_name_or_path, {
          ...options2,
          model_file_name: options2.model_file_name ?? "text_model"
        });
      }
    }

    class CLIPTextModelWithProjection extends CLIPPreTrainedModel {
      static async from_pretrained(pretrained_model_name_or_path, options2 = {}) {
        return super.from_pretrained(pretrained_model_name_or_path, {
          ...options2,
          model_file_name: options2.model_file_name ?? "text_model"
        });
      }
    }

    class CLIPVisionModel extends CLIPPreTrainedModel {
      static async from_pretrained(pretrained_model_name_or_path, options2 = {}) {
        return super.from_pretrained(pretrained_model_name_or_path, {
          ...options2,
          model_file_name: options2.model_file_name ?? "vision_model"
        });
      }
    }

    class CLIPVisionModelWithProjection extends CLIPPreTrainedModel {
      static async from_pretrained(pretrained_model_name_or_path, options2 = {}) {
        return super.from_pretrained(pretrained_model_name_or_path, {
          ...options2,
          model_file_name: options2.model_file_name ?? "vision_model"
        });
      }
    }

    class SiglipPreTrainedModel extends PreTrainedModel {
    }

    class SiglipModel extends SiglipPreTrainedModel {
    }

    class SiglipTextModel extends SiglipPreTrainedModel {
      static async from_pretrained(pretrained_model_name_or_path, options2 = {}) {
        return super.from_pretrained(pretrained_model_name_or_path, {
          ...options2,
          model_file_name: options2.model_file_name ?? "text_model"
        });
      }
    }

    class SiglipVisionModel extends CLIPPreTrainedModel {
      static async from_pretrained(pretrained_model_name_or_path, options2 = {}) {
        return super.from_pretrained(pretrained_model_name_or_path, {
          ...options2,
          model_file_name: options2.model_file_name ?? "vision_model"
        });
      }
    }

    class ChineseCLIPPreTrainedModel extends PreTrainedModel {
    }

    class ChineseCLIPModel extends ChineseCLIPPreTrainedModel {
    }

    class JinaCLIPPreTrainedModel extends PreTrainedModel {
    }

    class JinaCLIPModel extends JinaCLIPPreTrainedModel {
      async forward(model_inputs) {
        const missing_text_inputs = !model_inputs.input_ids;
        const missing_image_inputs = !model_inputs.pixel_values;
        if (missing_text_inputs && missing_image_inputs) {
          throw new Error("Either `input_ids` or `pixel_values` should be provided.");
        }
        if (missing_text_inputs) {
          model_inputs.input_ids = (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.ones)([model_inputs.pixel_values.dims[0], 1]);
        }
        if (missing_image_inputs) {
          const { image_size } = this.config.vision_config;
          model_inputs.pixel_values = (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.full)([0, 3, image_size, image_size], 0);
        }
        const { text_embeddings, image_embeddings, l2norm_text_embeddings, l2norm_image_embeddings } = await super.forward(model_inputs);
        const result = {};
        if (!missing_text_inputs) {
          result.text_embeddings = text_embeddings;
          result.l2norm_text_embeddings = l2norm_text_embeddings;
        }
        if (!missing_image_inputs) {
          result.image_embeddings = image_embeddings;
          result.l2norm_image_embeddings = l2norm_image_embeddings;
        }
        return result;
      }
    }

    class JinaCLIPTextModel extends JinaCLIPPreTrainedModel {
      static async from_pretrained(pretrained_model_name_or_path, options2 = {}) {
        return super.from_pretrained(pretrained_model_name_or_path, {
          ...options2,
          model_file_name: options2.model_file_name ?? "text_model"
        });
      }
    }

    class JinaCLIPVisionModel extends JinaCLIPPreTrainedModel {
      static async from_pretrained(pretrained_model_name_or_path, options2 = {}) {
        return super.from_pretrained(pretrained_model_name_or_path, {
          ...options2,
          model_file_name: options2.model_file_name ?? "vision_model"
        });
      }
    }

    class CLIPSegPreTrainedModel extends PreTrainedModel {
    }

    class CLIPSegModel extends CLIPSegPreTrainedModel {
    }

    class CLIPSegForImageSegmentation extends CLIPSegPreTrainedModel {
    }

    class GPT2PreTrainedModel extends PreTrainedModel {
    }

    class GPT2Model extends GPT2PreTrainedModel {
    }

    class GPT2LMHeadModel extends GPT2PreTrainedModel {
    }

    class JAISPreTrainedModel extends PreTrainedModel {
    }

    class JAISModel extends JAISPreTrainedModel {
    }

    class JAISLMHeadModel extends JAISPreTrainedModel {
    }

    class GPTNeoPreTrainedModel extends PreTrainedModel {
    }

    class GPTNeoModel extends GPTNeoPreTrainedModel {
    }

    class GPTNeoForCausalLM extends GPTNeoPreTrainedModel {
    }

    class GPTNeoXPreTrainedModel extends PreTrainedModel {
    }

    class GPTNeoXModel extends GPTNeoXPreTrainedModel {
    }

    class GPTNeoXForCausalLM extends GPTNeoXPreTrainedModel {
    }

    class GPTJPreTrainedModel extends PreTrainedModel {
    }

    class GPTJModel extends GPTJPreTrainedModel {
    }

    class GPTJForCausalLM extends GPTJPreTrainedModel {
    }

    class GPTBigCodePreTrainedModel extends PreTrainedModel {
    }

    class GPTBigCodeModel extends GPTBigCodePreTrainedModel {
    }

    class GPTBigCodeForCausalLM extends GPTBigCodePreTrainedModel {
    }

    class CodeGenPreTrainedModel extends PreTrainedModel {
    }

    class CodeGenModel extends CodeGenPreTrainedModel {
    }

    class CodeGenForCausalLM extends CodeGenPreTrainedModel {
    }

    class LlamaPreTrainedModel extends PreTrainedModel {
    }

    class LlamaModel extends LlamaPreTrainedModel {
    }

    class LlamaForCausalLM extends LlamaPreTrainedModel {
    }

    class Llama4PreTrainedModel extends PreTrainedModel {
    }

    class Llama4ForCausalLM extends Llama4PreTrainedModel {
    }

    class NanoChatPreTrainedModel extends PreTrainedModel {
    }

    class NanoChatModel extends NanoChatPreTrainedModel {
    }

    class NanoChatForCausalLM extends NanoChatPreTrainedModel {
    }

    class ArceePreTrainedModel extends PreTrainedModel {
    }

    class ArceeModel extends ArceePreTrainedModel {
    }

    class ArceeForCausalLM extends ArceePreTrainedModel {
    }

    class Lfm2PreTrainedModel extends PreTrainedModel {
    }

    class Lfm2Model extends Lfm2PreTrainedModel {
    }

    class Lfm2ForCausalLM extends Lfm2PreTrainedModel {
    }

    class SmolLM3PreTrainedModel extends PreTrainedModel {
    }

    class SmolLM3Model extends SmolLM3PreTrainedModel {
    }

    class SmolLM3ForCausalLM extends SmolLM3PreTrainedModel {
    }

    class HeliumPreTrainedModel extends PreTrainedModel {
    }

    class HeliumModel extends HeliumPreTrainedModel {
    }

    class HeliumForCausalLM extends HeliumPreTrainedModel {
    }

    class GlmPreTrainedModel extends PreTrainedModel {
    }

    class GlmModel extends GlmPreTrainedModel {
    }

    class GlmForCausalLM extends GlmPreTrainedModel {
    }

    class ExaonePreTrainedModel extends PreTrainedModel {
    }

    class ExaoneModel extends ExaonePreTrainedModel {
    }

    class ExaoneForCausalLM extends ExaonePreTrainedModel {
    }

    class MobileLLMPreTrainedModel extends PreTrainedModel {
    }

    class MobileLLMModel extends MobileLLMPreTrainedModel {
    }

    class MobileLLMForCausalLM extends MobileLLMPreTrainedModel {
    }

    class OlmoPreTrainedModel extends PreTrainedModel {
    }

    class OlmoModel extends OlmoPreTrainedModel {
    }

    class OlmoForCausalLM extends OlmoPreTrainedModel {
    }

    class Olmo2PreTrainedModel extends PreTrainedModel {
    }

    class Olmo2Model extends Olmo2PreTrainedModel {
    }

    class Olmo2ForCausalLM extends Olmo2PreTrainedModel {
    }

    class GranitePreTrainedModel extends PreTrainedModel {
    }

    class GraniteModel extends GranitePreTrainedModel {
    }

    class GraniteForCausalLM extends GranitePreTrainedModel {
    }

    class GraniteMoeHybridPreTrainedModel extends PreTrainedModel {
    }

    class GraniteMoeHybridModel extends GraniteMoeHybridPreTrainedModel {
    }

    class GraniteMoeHybridForCausalLM extends GraniteMoeHybridPreTrainedModel {
    }

    class CoherePreTrainedModel extends PreTrainedModel {
    }

    class CohereModel extends CoherePreTrainedModel {
    }

    class CohereForCausalLM extends CoherePreTrainedModel {
    }

    class GemmaPreTrainedModel extends PreTrainedModel {
    }

    class GemmaModel extends GemmaPreTrainedModel {
    }

    class GemmaForCausalLM extends GemmaPreTrainedModel {
    }

    class Gemma2PreTrainedModel extends PreTrainedModel {
    }

    class Gemma2Model extends Gemma2PreTrainedModel {
    }

    class Gemma2ForCausalLM extends Gemma2PreTrainedModel {
    }

    class VaultGemmaPreTrainedModel extends PreTrainedModel {
    }

    class VaultGemmaModel extends VaultGemmaPreTrainedModel {
    }

    class VaultGemmaForCausalLM extends VaultGemmaPreTrainedModel {
    }

    class Gemma3PreTrainedModel extends PreTrainedModel {
    }

    class Gemma3Model extends Gemma3PreTrainedModel {
    }

    class Gemma3ForCausalLM extends Gemma3PreTrainedModel {
    }

    class OpenELMPreTrainedModel extends PreTrainedModel {
    }

    class OpenELMModel extends OpenELMPreTrainedModel {
    }

    class OpenELMForCausalLM extends OpenELMPreTrainedModel {
    }

    class Qwen2PreTrainedModel extends PreTrainedModel {
    }

    class Qwen2Model extends Qwen2PreTrainedModel {
    }

    class Qwen2ForCausalLM extends Qwen2PreTrainedModel {
    }

    class Qwen3PreTrainedModel extends PreTrainedModel {
    }

    class Qwen3Model extends Qwen3PreTrainedModel {
    }

    class Qwen3ForCausalLM extends Qwen3PreTrainedModel {
    }

    class Qwen2VLPreTrainedModel extends PreTrainedModel {
      forward_params = [
        "input_ids",
        "attention_mask",
        "position_ids",
        "past_key_values",
        "pixel_values",
        "image_grid_thw"
      ];
    }

    class Qwen2VLForConditionalGeneration extends Qwen2VLPreTrainedModel {
      get_rope_index(input_ids, image_grid_thw, video_grid_thw, attention_mask) {
        const { vision_config, image_token_id, video_token_id, vision_start_token_id } = this.config;
        const spatial_merge_size = vision_config.spatial_merge_size ?? 2;
        const mrope_position_deltas = [];
        if (image_grid_thw || video_grid_thw) {
          let total_input_ids = input_ids.tolist();
          if (!attention_mask) {
            attention_mask = (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.ones_like)(input_ids);
          }
          const attention_mask_list = attention_mask.tolist();
          const position_ids_list = Array.from({ length: 3 }, (_) => Array.from({ length: input_ids.dims[0] }, (_2) => Array.from({ length: input_ids.dims[1] }, (_3) => 1)));
          const image_grid_thw_list = image_grid_thw ? image_grid_thw.tolist() : [];
          const video_grid_thw_list = video_grid_thw ? video_grid_thw.tolist() : [];
          let image_index = 0;
          let video_index = 0;
          for (let i = 0;i < total_input_ids.length; ++i) {
            const ids = total_input_ids[i].filter((_, j) => attention_mask_list[i][j] == 1);
            const vision_start_indices = ids.reduce((acc, x, idx) => {
              if (x == vision_start_token_id)
                acc.push(idx);
              return acc;
            }, []);
            const vision_tokens = vision_start_indices.map((x) => ids[x + 1]);
            const image_nums = vision_tokens.filter((x) => x == image_token_id).length;
            const video_nums = vision_tokens.filter((x) => x == video_token_id).length;
            let llm_pos_ids_list = [];
            let st = 0;
            let remain_images = image_nums;
            let remain_videos = video_nums;
            for (let j = 0;j < vision_tokens.length; ++j) {
              const next_image_token = ids.findIndex((x, i2) => i2 > st && x == image_token_id);
              const next_video_token = ids.findIndex((x, i2) => i2 > st && x == video_token_id);
              const ed_image = remain_images > 0 && next_image_token !== -1 ? next_image_token : ids.length + 1;
              const ed_video = remain_videos > 0 && next_video_token !== -1 ? next_video_token : ids.length + 1;
              let ed;
              let t, h, w;
              if (ed_image < ed_video) {
                [t, h, w] = image_grid_thw_list[image_index];
                ++image_index;
                --remain_images;
                ed = ed_image;
              } else {
                [t, h, w] = video_grid_thw_list[video_index];
                ++video_index;
                --remain_videos;
                ed = ed_video;
              }
              const [llm_grid_t, llm_grid_h, llm_grid_w] = [
                Number(t),
                Math.floor(Number(h) / spatial_merge_size),
                Math.floor(Number(w) / spatial_merge_size)
              ];
              const text_len = ed - st;
              const st_idx = llm_pos_ids_list.length > 0 ? (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_11__.max)(llm_pos_ids_list.at(-1))[0] + 1 : 0;
              llm_pos_ids_list.push(Array.from({ length: 3 * text_len }, (_, i2) => st_idx + i2 % text_len));
              const offset = text_len + st_idx;
              const grid_size = llm_grid_t * llm_grid_h * llm_grid_w;
              const t_index = Array.from({ length: grid_size }, (_, i2) => offset + Math.floor(i2 / (llm_grid_h * llm_grid_w)));
              const h_index = Array.from({ length: grid_size }, (_, i2) => offset + Math.floor(i2 / llm_grid_w) % llm_grid_h);
              const w_index = Array.from({ length: grid_size }, (_, i2) => offset + i2 % llm_grid_w);
              llm_pos_ids_list.push([t_index, h_index, w_index].flat());
              st = ed + grid_size;
            }
            if (st < ids.length) {
              const st_idx = llm_pos_ids_list.length > 0 ? (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_11__.max)(llm_pos_ids_list.at(-1))[0] + 1 : 0;
              const text_len = ids.length - st;
              llm_pos_ids_list.push(Array.from({ length: 3 * text_len }, (_, i2) => st_idx + i2 % text_len));
            }
            const num_items = llm_pos_ids_list.reduce((acc, x) => acc + x.length, 0);
            const llm_positions = new Array(num_items);
            let index = 0;
            for (let x = 0;x < 3; ++x) {
              for (let y = 0;y < llm_pos_ids_list.length; ++y) {
                const val = llm_pos_ids_list[y];
                const text_len = val.length / 3;
                for (let z2 = x * text_len;z2 < (x + 1) * text_len; ++z2) {
                  llm_positions[index++] = val[z2];
                }
              }
            }
            let count = 0;
            const attn_mask = attention_mask_list[i];
            for (let y = 0;y < attn_mask.length; ++y) {
              if (attn_mask[y] == 1) {
                for (let x = 0;x < 3; ++x) {
                  position_ids_list[x][i][y] = llm_positions[x * num_items / 3 + count];
                }
                ++count;
              }
            }
            const max_llm_positions = (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_11__.max)(llm_positions)[0];
            mrope_position_deltas.push(max_llm_positions + 1 - total_input_ids[i].length);
          }
          return [
            new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.Tensor("int64", position_ids_list.flat(Infinity), [3, input_ids.dims[0], input_ids.dims[1]]),
            new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.Tensor("int64", mrope_position_deltas, [mrope_position_deltas.length, 1])
          ];
        } else {
          if (attention_mask) {
            const { data, dims } = cumsum_masked_fill(attention_mask);
            const position_ids = BigInt64Array.from({ length: 3 * data.length }, (_, i) => data[i % data.length]);
            const mrope_position_deltas2 = Array.from({ length: dims[0] }, (_, i) => (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_11__.max)(data.subarray(dims[1] * i, dims[1] * (i + 1)))[0] + 1n + BigInt(dims[1]));
            return [
              new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.Tensor("int64", position_ids, [3, ...dims]),
              new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.Tensor("int64", mrope_position_deltas2, [mrope_position_deltas2.length, 1])
            ];
          } else {
            const [batch_size, seq_length] = input_ids.dims;
            const position_ids = BigInt64Array.from({ length: 3 * batch_size * seq_length }, (_, i) => BigInt(Math.floor(i % seq_length / batch_size)));
            return [
              new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.Tensor("int64", position_ids, [3, ...input_ids.dims]),
              (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.zeros)([batch_size, 1])
            ];
          }
        }
      }
      async encode_image({ pixel_values, image_grid_thw }) {
        const features = (await sessionRun(this.sessions["vision_encoder"], { pixel_values, grid_thw: image_grid_thw })).image_features;
        return features;
      }
      _merge_input_ids_with_image_features(kwargs) {
        return default_merge_input_ids_with_image_features({
          image_token_id: this.config.image_token_id,
          ...kwargs
        });
      }
      prepare_inputs_for_generation(input_ids, model_inputs, generation_config) {
        if (model_inputs.attention_mask && !model_inputs.position_ids) {
          if (!model_inputs.past_key_values) {
            [model_inputs.position_ids, model_inputs.rope_deltas] = this.get_rope_index(model_inputs.input_ids, model_inputs.image_grid_thw, model_inputs.video_grid_thw, model_inputs.attention_mask);
          } else {
            model_inputs.pixel_values = null;
            const delta = BigInt(Object.values(model_inputs.past_key_values)[0].dims.at(-2));
            const rope_deltas_list = model_inputs.rope_deltas.map((x) => delta + x);
            model_inputs.position_ids = (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.stack)([rope_deltas_list, rope_deltas_list, rope_deltas_list], 0);
          }
        }
        return model_inputs;
      }
    }

    class PhiPreTrainedModel extends PreTrainedModel {
    }

    class PhiModel extends PhiPreTrainedModel {
    }

    class PhiForCausalLM extends PhiPreTrainedModel {
    }

    class Phi3PreTrainedModel extends PreTrainedModel {
    }

    class Phi3Model extends Phi3PreTrainedModel {
    }

    class Phi3ForCausalLM extends Phi3PreTrainedModel {
    }

    class BloomPreTrainedModel extends PreTrainedModel {
    }

    class BloomModel extends BloomPreTrainedModel {
    }

    class BloomForCausalLM extends BloomPreTrainedModel {
    }

    class MptPreTrainedModel extends PreTrainedModel {
    }

    class MptModel extends MptPreTrainedModel {
    }

    class MptForCausalLM extends MptPreTrainedModel {
    }

    class OPTPreTrainedModel extends PreTrainedModel {
    }

    class OPTModel extends OPTPreTrainedModel {
    }

    class OPTForCausalLM extends OPTPreTrainedModel {
    }

    class ViTPreTrainedModel extends PreTrainedModel {
    }

    class ViTModel extends ViTPreTrainedModel {
    }

    class ViTForImageClassification extends ViTPreTrainedModel {
      async _call(model_inputs) {
        return new SequenceClassifierOutput(await super._call(model_inputs));
      }
    }

    class IJepaPreTrainedModel extends PreTrainedModel {
    }

    class IJepaModel extends IJepaPreTrainedModel {
    }

    class IJepaForImageClassification extends IJepaPreTrainedModel {
      async _call(model_inputs) {
        return new SequenceClassifierOutput(await super._call(model_inputs));
      }
    }

    class VitPosePreTrainedModel extends PreTrainedModel {
    }

    class VitPoseForPoseEstimation extends VitPosePreTrainedModel {
    }

    class PvtPreTrainedModel extends PreTrainedModel {
    }

    class PvtModel extends PvtPreTrainedModel {
    }

    class PvtForImageClassification extends PvtPreTrainedModel {
      async _call(model_inputs) {
        return new SequenceClassifierOutput(await super._call(model_inputs));
      }
    }

    class ViTMAEPreTrainedModel extends PreTrainedModel {
    }

    class ViTMAEModel extends ViTMAEPreTrainedModel {
    }

    class ViTMSNPreTrainedModel extends PreTrainedModel {
    }

    class ViTMSNModel extends ViTMSNPreTrainedModel {
    }

    class ViTMSNForImageClassification extends ViTMSNPreTrainedModel {
      async _call(model_inputs) {
        return new SequenceClassifierOutput(await super._call(model_inputs));
      }
    }

    class GroupViTPreTrainedModel extends PreTrainedModel {
    }

    class GroupViTModel extends GroupViTPreTrainedModel {
    }

    class FastViTPreTrainedModel extends PreTrainedModel {
    }

    class FastViTModel extends FastViTPreTrainedModel {
    }

    class FastViTForImageClassification extends FastViTPreTrainedModel {
      async _call(model_inputs) {
        return new SequenceClassifierOutput(await super._call(model_inputs));
      }
    }

    class VitMattePreTrainedModel extends PreTrainedModel {
    }

    class VitMatteForImageMatting extends VitMattePreTrainedModel {
      async _call(model_inputs) {
        return new ImageMattingOutput(await super._call(model_inputs));
      }
    }

    class MobileViTPreTrainedModel extends PreTrainedModel {
    }

    class MobileViTModel extends MobileViTPreTrainedModel {
    }

    class MobileViTForImageClassification extends MobileViTPreTrainedModel {
      async _call(model_inputs) {
        return new SequenceClassifierOutput(await super._call(model_inputs));
      }
    }

    class MobileViTV2PreTrainedModel extends PreTrainedModel {
    }

    class MobileViTV2Model extends MobileViTV2PreTrainedModel {
    }

    class MobileViTV2ForImageClassification extends MobileViTV2PreTrainedModel {
      async _call(model_inputs) {
        return new SequenceClassifierOutput(await super._call(model_inputs));
      }
    }

    class OwlViTPreTrainedModel extends PreTrainedModel {
    }

    class OwlViTModel extends OwlViTPreTrainedModel {
    }

    class OwlViTForObjectDetection extends OwlViTPreTrainedModel {
    }

    class Owlv2PreTrainedModel extends PreTrainedModel {
    }

    class Owlv2Model extends Owlv2PreTrainedModel {
    }

    class Owlv2ForObjectDetection extends Owlv2PreTrainedModel {
    }

    class BeitPreTrainedModel extends PreTrainedModel {
    }

    class BeitModel extends BeitPreTrainedModel {
    }

    class BeitForImageClassification extends BeitPreTrainedModel {
      async _call(model_inputs) {
        return new SequenceClassifierOutput(await super._call(model_inputs));
      }
    }

    class DetrPreTrainedModel extends PreTrainedModel {
    }

    class DetrModel extends DetrPreTrainedModel {
    }

    class DetrForObjectDetection extends DetrPreTrainedModel {
      async _call(model_inputs) {
        return new DetrObjectDetectionOutput(await super._call(model_inputs));
      }
    }

    class DetrForSegmentation extends DetrPreTrainedModel {
      async _call(model_inputs) {
        return new DetrSegmentationOutput(await super._call(model_inputs));
      }
    }

    class DetrObjectDetectionOutput extends ModelOutput {
      constructor({ logits, pred_boxes }) {
        super();
        this.logits = logits;
        this.pred_boxes = pred_boxes;
      }
    }

    class DetrSegmentationOutput extends ModelOutput {
      constructor({ logits, pred_boxes, pred_masks }) {
        super();
        this.logits = logits;
        this.pred_boxes = pred_boxes;
        this.pred_masks = pred_masks;
      }
    }

    class RTDetrPreTrainedModel extends PreTrainedModel {
    }

    class RTDetrModel extends RTDetrPreTrainedModel {
    }

    class RTDetrForObjectDetection extends RTDetrPreTrainedModel {
      async _call(model_inputs) {
        return new RTDetrObjectDetectionOutput(await super._call(model_inputs));
      }
    }

    class RTDetrObjectDetectionOutput extends ModelOutput {
      constructor({ logits, pred_boxes }) {
        super();
        this.logits = logits;
        this.pred_boxes = pred_boxes;
      }
    }

    class RTDetrV2PreTrainedModel extends PreTrainedModel {
    }

    class RTDetrV2Model extends RTDetrV2PreTrainedModel {
    }

    class RTDetrV2ForObjectDetection extends RTDetrV2PreTrainedModel {
      async _call(model_inputs) {
        return new RTDetrV2ObjectDetectionOutput(await super._call(model_inputs));
      }
    }

    class RTDetrV2ObjectDetectionOutput extends RTDetrObjectDetectionOutput {
    }

    class RFDetrPreTrainedModel extends PreTrainedModel {
    }

    class RFDetrModel extends RFDetrPreTrainedModel {
    }

    class RFDetrForObjectDetection extends RFDetrPreTrainedModel {
      async _call(model_inputs) {
        return new RFDetrObjectDetectionOutput(await super._call(model_inputs));
      }
    }

    class RFDetrObjectDetectionOutput extends RTDetrObjectDetectionOutput {
    }

    class DFinePreTrainedModel extends PreTrainedModel {
    }

    class DFineModel extends DFinePreTrainedModel {
    }

    class DFineForObjectDetection extends DFinePreTrainedModel {
      async _call(model_inputs) {
        return new RTDetrObjectDetectionOutput(await super._call(model_inputs));
      }
    }

    class TableTransformerPreTrainedModel extends PreTrainedModel {
    }

    class TableTransformerModel extends TableTransformerPreTrainedModel {
    }

    class TableTransformerForObjectDetection extends TableTransformerPreTrainedModel {
      async _call(model_inputs) {
        return new TableTransformerObjectDetectionOutput(await super._call(model_inputs));
      }
    }

    class TableTransformerObjectDetectionOutput extends DetrObjectDetectionOutput {
    }

    class DeiTPreTrainedModel extends PreTrainedModel {
    }

    class DeiTModel extends DeiTPreTrainedModel {
    }

    class DeiTForImageClassification extends DeiTPreTrainedModel {
      async _call(model_inputs) {
        return new SequenceClassifierOutput(await super._call(model_inputs));
      }
    }

    class HieraPreTrainedModel extends PreTrainedModel {
    }

    class HieraModel extends HieraPreTrainedModel {
    }

    class HieraForImageClassification extends HieraPreTrainedModel {
      async _call(model_inputs) {
        return new SequenceClassifierOutput(await super._call(model_inputs));
      }
    }

    class ResNetPreTrainedModel extends PreTrainedModel {
    }

    class ResNetModel extends ResNetPreTrainedModel {
    }

    class ResNetForImageClassification extends ResNetPreTrainedModel {
      async _call(model_inputs) {
        return new SequenceClassifierOutput(await super._call(model_inputs));
      }
    }

    class SwinPreTrainedModel extends PreTrainedModel {
    }

    class SwinModel extends SwinPreTrainedModel {
    }

    class SwinForImageClassification extends SwinPreTrainedModel {
      async _call(model_inputs) {
        return new SequenceClassifierOutput(await super._call(model_inputs));
      }
    }

    class SwinForSemanticSegmentation extends SwinPreTrainedModel {
    }

    class Swin2SRPreTrainedModel extends PreTrainedModel {
    }

    class Swin2SRModel extends Swin2SRPreTrainedModel {
    }

    class Swin2SRForImageSuperResolution extends Swin2SRPreTrainedModel {
    }

    class DPTPreTrainedModel extends PreTrainedModel {
    }

    class DPTModel extends DPTPreTrainedModel {
    }

    class DPTForDepthEstimation extends DPTPreTrainedModel {
    }

    class DepthAnythingPreTrainedModel extends PreTrainedModel {
    }

    class DepthAnythingForDepthEstimation extends DepthAnythingPreTrainedModel {
    }

    class SapiensPreTrainedModel extends PreTrainedModel {
    }

    class SapiensForSemanticSegmentation extends SapiensPreTrainedModel {
    }

    class SapiensForDepthEstimation extends SapiensPreTrainedModel {
    }

    class SapiensForNormalEstimation extends SapiensPreTrainedModel {
    }

    class DepthProPreTrainedModel extends PreTrainedModel {
    }

    class DepthProForDepthEstimation extends DepthProPreTrainedModel {
    }

    class Metric3DPreTrainedModel extends PreTrainedModel {
    }

    class Metric3DForDepthEstimation extends Metric3DPreTrainedModel {
    }

    class Metric3Dv2PreTrainedModel extends PreTrainedModel {
    }

    class Metric3Dv2ForDepthEstimation extends Metric3Dv2PreTrainedModel {
    }

    class MaskFormerPreTrainedModel extends PreTrainedModel {
    }

    class MaskFormerModel extends MaskFormerPreTrainedModel {
    }

    class MaskFormerForInstanceSegmentation extends MaskFormerPreTrainedModel {
    }

    class GLPNPreTrainedModel extends PreTrainedModel {
    }

    class GLPNModel extends GLPNPreTrainedModel {
    }

    class GLPNForDepthEstimation extends GLPNPreTrainedModel {
    }

    class DonutSwinPreTrainedModel extends PreTrainedModel {
    }

    class DonutSwinModel extends DonutSwinPreTrainedModel {
    }

    class ConvNextPreTrainedModel extends PreTrainedModel {
    }

    class ConvNextModel extends ConvNextPreTrainedModel {
    }

    class ConvNextForImageClassification extends ConvNextPreTrainedModel {
      async _call(model_inputs) {
        return new SequenceClassifierOutput(await super._call(model_inputs));
      }
    }

    class ConvNextV2PreTrainedModel extends PreTrainedModel {
    }

    class ConvNextV2Model extends ConvNextV2PreTrainedModel {
    }

    class ConvNextV2ForImageClassification extends ConvNextV2PreTrainedModel {
      async _call(model_inputs) {
        return new SequenceClassifierOutput(await super._call(model_inputs));
      }
    }

    class Dinov2PreTrainedModel extends PreTrainedModel {
    }

    class Dinov2Model extends Dinov2PreTrainedModel {
    }

    class Dinov2ForImageClassification extends Dinov2PreTrainedModel {
      async _call(model_inputs) {
        return new SequenceClassifierOutput(await super._call(model_inputs));
      }
    }

    class Dinov2WithRegistersPreTrainedModel extends PreTrainedModel {
    }

    class Dinov2WithRegistersModel extends Dinov2WithRegistersPreTrainedModel {
    }

    class Dinov2WithRegistersForImageClassification extends Dinov2WithRegistersPreTrainedModel {
      async _call(model_inputs) {
        return new SequenceClassifierOutput(await super._call(model_inputs));
      }
    }

    class DINOv3ViTPreTrainedModel extends PreTrainedModel {
    }

    class DINOv3ViTModel extends DINOv3ViTPreTrainedModel {
    }

    class DINOv3ConvNextPreTrainedModel extends PreTrainedModel {
    }

    class DINOv3ConvNextModel extends DINOv3ConvNextPreTrainedModel {
    }

    class GroundingDinoPreTrainedModel extends PreTrainedModel {
    }

    class GroundingDinoForObjectDetection extends GroundingDinoPreTrainedModel {
    }

    class YolosPreTrainedModel extends PreTrainedModel {
    }

    class YolosModel extends YolosPreTrainedModel {
    }

    class YolosForObjectDetection extends YolosPreTrainedModel {
      async _call(model_inputs) {
        return new YolosObjectDetectionOutput(await super._call(model_inputs));
      }
    }

    class YolosObjectDetectionOutput extends ModelOutput {
      constructor({ logits, pred_boxes }) {
        super();
        this.logits = logits;
        this.pred_boxes = pred_boxes;
      }
    }

    class SamPreTrainedModel extends PreTrainedModel {
    }

    class SamModel extends SamPreTrainedModel {
      async get_image_embeddings({ pixel_values }) {
        return await encoderForward(this, { pixel_values });
      }
      async forward(model_inputs) {
        if (!model_inputs.image_embeddings || !model_inputs.image_positional_embeddings) {
          model_inputs = {
            ...model_inputs,
            ...await this.get_image_embeddings(model_inputs)
          };
        } else {
          model_inputs = { ...model_inputs };
        }
        model_inputs.input_labels ??= (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.ones)(model_inputs.input_points.dims.slice(0, -1));
        const decoder_inputs = {
          image_embeddings: model_inputs.image_embeddings,
          image_positional_embeddings: model_inputs.image_positional_embeddings
        };
        if (model_inputs.input_points) {
          decoder_inputs.input_points = model_inputs.input_points;
        }
        if (model_inputs.input_labels) {
          decoder_inputs.input_labels = model_inputs.input_labels;
        }
        if (model_inputs.input_boxes) {
          decoder_inputs.input_boxes = model_inputs.input_boxes;
        }
        return await sessionRun(this.sessions["prompt_encoder_mask_decoder"], decoder_inputs);
      }
      async _call(model_inputs) {
        return new SamImageSegmentationOutput(await super._call(model_inputs));
      }
    }

    class SamImageSegmentationOutput extends ModelOutput {
      constructor({ iou_scores, pred_masks }) {
        super();
        this.iou_scores = iou_scores;
        this.pred_masks = pred_masks;
      }
    }

    class Sam2ImageSegmentationOutput extends ModelOutput {
      constructor({ iou_scores, pred_masks, object_score_logits }) {
        super();
        this.iou_scores = iou_scores;
        this.pred_masks = pred_masks;
        this.object_score_logits = object_score_logits;
      }
    }

    class Sam2PreTrainedModel extends PreTrainedModel {
    }

    class Sam2Model extends Sam2PreTrainedModel {
      async get_image_embeddings({ pixel_values }) {
        return await encoderForward(this, { pixel_values });
      }
      async forward(model_inputs) {
        const { num_feature_levels } = this.config.vision_config;
        const image_embeddings_name = Array.from({ length: num_feature_levels }, (_, i) => `image_embeddings.${i}`);
        if (image_embeddings_name.some((name) => !model_inputs[name])) {
          model_inputs = {
            ...model_inputs,
            ...await this.get_image_embeddings(model_inputs)
          };
        } else {
          model_inputs = { ...model_inputs };
        }
        if (model_inputs.input_points) {
          if (model_inputs.input_boxes && model_inputs.input_boxes.dims[1] !== 1) {
            throw new Error("When both `input_points` and `input_boxes` are provided, the number of boxes per image must be 1.");
          }
          const shape = model_inputs.input_points.dims;
          model_inputs.input_labels ??= (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.ones)(shape.slice(0, -1));
          model_inputs.input_boxes ??= (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.full)([shape[0], 0, 4], 0);
        } else if (model_inputs.input_boxes) {
          const shape = model_inputs.input_boxes.dims;
          model_inputs.input_labels = (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.full)([shape[0], shape[1], 0], -1n);
          model_inputs.input_points = (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.full)([shape[0], 1, 0, 2], 0);
        } else {
          throw new Error("At least one of `input_points` or `input_boxes` must be provided.");
        }
        const prompt_encoder_mask_decoder_session = this.sessions["prompt_encoder_mask_decoder"];
        const decoder_inputs = (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_4__.pick)(model_inputs, prompt_encoder_mask_decoder_session.inputNames);
        return await sessionRun(prompt_encoder_mask_decoder_session, decoder_inputs);
      }
      async _call(model_inputs) {
        return new Sam2ImageSegmentationOutput(await super._call(model_inputs));
      }
    }

    class EdgeTamModel extends Sam2Model {
    }

    class Sam3TrackerModel extends Sam2Model {
    }

    class MarianPreTrainedModel extends PreTrainedModel {
    }

    class MarianModel extends MarianPreTrainedModel {
    }

    class MarianMTModel extends MarianPreTrainedModel {
    }

    class M2M100PreTrainedModel extends PreTrainedModel {
    }

    class M2M100Model extends M2M100PreTrainedModel {
    }

    class M2M100ForConditionalGeneration extends M2M100PreTrainedModel {
    }

    class Wav2Vec2PreTrainedModel extends PreTrainedModel {
    }

    class Wav2Vec2Model extends Wav2Vec2PreTrainedModel {
    }

    class Wav2Vec2ForCTC extends Wav2Vec2PreTrainedModel {
      async _call(model_inputs) {
        return new CausalLMOutput(await super._call(model_inputs));
      }
    }

    class Wav2Vec2ForSequenceClassification extends Wav2Vec2PreTrainedModel {
      async _call(model_inputs) {
        return new SequenceClassifierOutput(await super._call(model_inputs));
      }
    }

    class Wav2Vec2ForAudioFrameClassification extends Wav2Vec2PreTrainedModel {
      async _call(model_inputs) {
        return new TokenClassifierOutput(await super._call(model_inputs));
      }
    }

    class ParakeetPreTrainedModel extends PreTrainedModel {
    }

    class ParakeetForCTC extends ParakeetPreTrainedModel {
      async _call(model_inputs) {
        return new CausalLMOutput(await super._call(model_inputs));
      }
    }

    class PyAnnotePreTrainedModel extends PreTrainedModel {
    }

    class PyAnnoteModel extends PyAnnotePreTrainedModel {
    }

    class PyAnnoteForAudioFrameClassification extends PyAnnotePreTrainedModel {
      async _call(model_inputs) {
        return new TokenClassifierOutput(await super._call(model_inputs));
      }
    }

    class WeSpeakerResNetPreTrainedModel extends PreTrainedModel {
    }

    class WeSpeakerResNetModel extends WeSpeakerResNetPreTrainedModel {
    }

    class UniSpeechPreTrainedModel extends PreTrainedModel {
    }

    class UniSpeechModel extends UniSpeechPreTrainedModel {
    }

    class UniSpeechForCTC extends UniSpeechPreTrainedModel {
      async _call(model_inputs) {
        return new CausalLMOutput(await super._call(model_inputs));
      }
    }

    class UniSpeechForSequenceClassification extends UniSpeechPreTrainedModel {
      async _call(model_inputs) {
        return new SequenceClassifierOutput(await super._call(model_inputs));
      }
    }

    class UniSpeechSatPreTrainedModel extends PreTrainedModel {
    }

    class UniSpeechSatModel extends UniSpeechSatPreTrainedModel {
    }

    class UniSpeechSatForCTC extends UniSpeechSatPreTrainedModel {
      async _call(model_inputs) {
        return new CausalLMOutput(await super._call(model_inputs));
      }
    }

    class UniSpeechSatForSequenceClassification extends UniSpeechSatPreTrainedModel {
      async _call(model_inputs) {
        return new SequenceClassifierOutput(await super._call(model_inputs));
      }
    }

    class UniSpeechSatForAudioFrameClassification extends UniSpeechSatPreTrainedModel {
      async _call(model_inputs) {
        return new TokenClassifierOutput(await super._call(model_inputs));
      }
    }

    class Wav2Vec2BertPreTrainedModel extends PreTrainedModel {
    }

    class Wav2Vec2BertModel extends Wav2Vec2BertPreTrainedModel {
    }

    class Wav2Vec2BertForCTC extends Wav2Vec2BertPreTrainedModel {
      async _call(model_inputs) {
        return new CausalLMOutput(await super._call(model_inputs));
      }
    }

    class Wav2Vec2BertForSequenceClassification extends Wav2Vec2BertPreTrainedModel {
      async _call(model_inputs) {
        return new SequenceClassifierOutput(await super._call(model_inputs));
      }
    }

    class HubertPreTrainedModel extends PreTrainedModel {
    }

    class HubertModel extends Wav2Vec2PreTrainedModel {
    }

    class HubertForCTC extends Wav2Vec2PreTrainedModel {
      async _call(model_inputs) {
        return new CausalLMOutput(await super._call(model_inputs));
      }
    }

    class HubertForSequenceClassification extends Wav2Vec2PreTrainedModel {
      async _call(model_inputs) {
        return new SequenceClassifierOutput(await super._call(model_inputs));
      }
    }

    class WavLMPreTrainedModel extends PreTrainedModel {
    }

    class WavLMModel extends WavLMPreTrainedModel {
    }

    class WavLMForCTC extends WavLMPreTrainedModel {
      async _call(model_inputs) {
        return new CausalLMOutput(await super._call(model_inputs));
      }
    }

    class WavLMForSequenceClassification extends WavLMPreTrainedModel {
      async _call(model_inputs) {
        return new SequenceClassifierOutput(await super._call(model_inputs));
      }
    }

    class WavLMForXVector extends WavLMPreTrainedModel {
      async _call(model_inputs) {
        return new XVectorOutput(await super._call(model_inputs));
      }
    }

    class WavLMForAudioFrameClassification extends WavLMPreTrainedModel {
      async _call(model_inputs) {
        return new TokenClassifierOutput(await super._call(model_inputs));
      }
    }

    class StyleTextToSpeech2PreTrainedModel extends PreTrainedModel {
    }

    class StyleTextToSpeech2Model extends StyleTextToSpeech2PreTrainedModel {
    }

    class SpeechT5PreTrainedModel extends PreTrainedModel {
    }

    class SpeechT5Model extends SpeechT5PreTrainedModel {
    }

    class SpeechT5ForSpeechToText extends SpeechT5PreTrainedModel {
    }

    class SpeechT5ForTextToSpeech extends SpeechT5PreTrainedModel {
      async generate_speech(input_values, speaker_embeddings, {
        threshold = 0.5,
        minlenratio = 0,
        maxlenratio = 20,
        vocoder = null
      } = {}) {
        const model_inputs = {
          input_ids: input_values
        };
        const { encoder_outputs, encoder_attention_mask } = await encoderForward(this, model_inputs);
        const r = encoder_outputs.dims[1] / this.config.reduction_factor;
        const maxlen = Math.floor(r * maxlenratio);
        const minlen = Math.floor(r * minlenratio);
        const num_mel_bins = this.config.num_mel_bins;
        let spectrogramParts = [];
        let past_key_values = null;
        let decoder_outputs = null;
        let idx = 0;
        while (true) {
          ++idx;
          const use_cache_branch = boolTensor(!!decoder_outputs);
          let output_sequence;
          if (decoder_outputs) {
            output_sequence = decoder_outputs.output_sequence_out;
          } else {
            output_sequence = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.Tensor("float32", new Float32Array(num_mel_bins), [1, 1, num_mel_bins]);
          }
          let decoderFeeds = {
            use_cache_branch,
            output_sequence,
            encoder_attention_mask,
            speaker_embeddings,
            encoder_hidden_states: encoder_outputs
          };
          this.addPastKeyValues(decoderFeeds, past_key_values);
          decoder_outputs = await sessionRun(this.sessions["decoder_model_merged"], decoderFeeds);
          past_key_values = this.getPastKeyValues(decoder_outputs, past_key_values);
          const { prob, spectrum } = decoder_outputs;
          spectrogramParts.push(spectrum);
          if (idx >= minlen && (Array.from(prob.data).filter((p) => p >= threshold).length > 0 || idx >= maxlen)) {
            break;
          }
        }
        const spectrogram = (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.cat)(spectrogramParts);
        const { waveform } = await sessionRun(vocoder.sessions["model"], { spectrogram });
        return {
          spectrogram,
          waveform
        };
      }
    }

    class SpeechT5HifiGan extends PreTrainedModel {
      main_input_name = "spectrogram";
    }

    class SupertonicPreTrainedModel extends PreTrainedModel {
    }

    class SupertonicForConditionalGeneration extends SupertonicPreTrainedModel {
      async generate_speech({
        input_ids,
        attention_mask,
        style,
        num_inference_steps = 5,
        speed = 1.05
      }) {
        const { sampling_rate, chunk_compress_factor, base_chunk_size, latent_dim } = this.config;
        const { last_hidden_state, durations } = await sessionRun(this.sessions["text_encoder"], {
          input_ids,
          attention_mask,
          style
        });
        durations.div_(speed);
        const wav_len_max = durations.max().item() * sampling_rate;
        const chunk_size = base_chunk_size * chunk_compress_factor;
        const latent_len = Math.floor((wav_len_max + chunk_size - 1) / chunk_size);
        const batch_size = input_ids.dims[0];
        const latent_mask = (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.ones)([batch_size, latent_len]);
        const num_steps = (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.full)([batch_size], num_inference_steps);
        let noisy_latents = (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.randn)([batch_size, latent_dim * chunk_compress_factor, latent_len]);
        for (let step = 0;step < num_inference_steps; ++step) {
          const timestep = (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.full)([batch_size], step);
          ({ denoised_latents: noisy_latents } = await sessionRun(this.sessions["latent_denoiser"], {
            style,
            noisy_latents,
            latent_mask,
            encoder_outputs: last_hidden_state,
            attention_mask,
            timestep,
            num_inference_steps: num_steps
          }));
        }
        const { waveform } = await sessionRun(this.sessions["voice_decoder"], {
          latents: noisy_latents
        });
        return {
          waveform,
          durations
        };
      }
    }

    class TrOCRPreTrainedModel extends PreTrainedModel {
    }

    class TrOCRForCausalLM extends TrOCRPreTrainedModel {
    }

    class MistralPreTrainedModel extends PreTrainedModel {
    }

    class MistralModel extends MistralPreTrainedModel {
    }

    class MistralForCausalLM extends MistralPreTrainedModel {
    }

    class MinistralPreTrainedModel extends PreTrainedModel {
    }

    class MinistralModel extends MinistralPreTrainedModel {
    }

    class MinistralForCausalLM extends MinistralPreTrainedModel {
    }

    class Ministral3PreTrainedModel extends PreTrainedModel {
    }

    class Ministral3Model extends Ministral3PreTrainedModel {
    }

    class Ministral3ForCausalLM extends Ministral3PreTrainedModel {
    }

    class Ernie4_5PreTrainedModel extends PreTrainedModel {
    }

    class Ernie4_5Model extends Ernie4_5PreTrainedModel {
    }

    class Ernie4_5ForCausalLM extends Ernie4_5PreTrainedModel {
    }

    class Starcoder2PreTrainedModel extends PreTrainedModel {
    }

    class Starcoder2Model extends Starcoder2PreTrainedModel {
    }

    class Starcoder2ForCausalLM extends Starcoder2PreTrainedModel {
    }

    class FalconPreTrainedModel extends PreTrainedModel {
    }

    class FalconModel extends FalconPreTrainedModel {
    }

    class FalconForCausalLM extends FalconPreTrainedModel {
    }

    class ClapPreTrainedModel extends PreTrainedModel {
    }

    class ClapModel extends ClapPreTrainedModel {
    }

    class ClapTextModelWithProjection extends ClapPreTrainedModel {
      static async from_pretrained(pretrained_model_name_or_path, options2 = {}) {
        return super.from_pretrained(pretrained_model_name_or_path, {
          ...options2,
          model_file_name: options2.model_file_name ?? "text_model"
        });
      }
    }

    class ClapAudioModelWithProjection extends ClapPreTrainedModel {
      static async from_pretrained(pretrained_model_name_or_path, options2 = {}) {
        return super.from_pretrained(pretrained_model_name_or_path, {
          ...options2,
          model_file_name: options2.model_file_name ?? "audio_model"
        });
      }
    }

    class VitsPreTrainedModel extends PreTrainedModel {
    }

    class VitsModel extends VitsPreTrainedModel {
      async _call(model_inputs) {
        return new VitsModelOutput(await super._call(model_inputs));
      }
    }

    class SegformerPreTrainedModel extends PreTrainedModel {
    }

    class SegformerModel extends SegformerPreTrainedModel {
    }

    class SegformerForImageClassification extends SegformerPreTrainedModel {
    }

    class SegformerForSemanticSegmentation extends SegformerPreTrainedModel {
    }

    class StableLmPreTrainedModel extends PreTrainedModel {
    }

    class StableLmModel extends StableLmPreTrainedModel {
    }

    class StableLmForCausalLM extends StableLmPreTrainedModel {
    }

    class EfficientNetPreTrainedModel extends PreTrainedModel {
    }

    class EfficientNetModel extends EfficientNetPreTrainedModel {
    }

    class EfficientNetForImageClassification extends EfficientNetPreTrainedModel {
      async _call(model_inputs) {
        return new SequenceClassifierOutput(await super._call(model_inputs));
      }
    }

    class MusicgenPreTrainedModel extends PreTrainedModel {
    }

    class MusicgenModel extends MusicgenPreTrainedModel {
    }

    class MusicgenForCausalLM extends MusicgenPreTrainedModel {
    }

    class MusicgenForConditionalGeneration extends PreTrainedModel {
      forward_params = [
        "input_ids",
        "attention_mask",
        "encoder_outputs",
        "decoder_input_ids",
        "decoder_attention_mask",
        "past_key_values"
      ];
      _apply_and_filter_by_delay_pattern_mask(outputs) {
        const [bs_x_codebooks, seqLength] = outputs.dims;
        const num_codebooks = this.config.decoder.num_codebooks;
        const upperBound = seqLength - num_codebooks;
        let newDataSize = 0;
        for (let i = 0;i < outputs.size; ++i) {
          if (outputs.data[i] === this.config.decoder.pad_token_id) {
            continue;
          }
          const row = i % seqLength;
          const col = Math.floor(i / seqLength) % num_codebooks;
          const diff = row - col;
          if (diff > 0 && diff <= upperBound) {
            outputs.data[newDataSize++] = outputs.data[i];
          }
        }
        const batch_size = Math.floor(bs_x_codebooks / num_codebooks);
        const inferred = newDataSize / (batch_size * num_codebooks);
        return new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_9__.Tensor(outputs.type, outputs.data.slice(0, newDataSize), [batch_size, num_codebooks, inferred]);
      }
      prepare_inputs_for_generation(input_ids, model_inputs, generation_config) {
        let clonedInputIds = structuredClone(input_ids);
        for (let i = 0;i < clonedInputIds.length; ++i) {
          for (let j = 0;j < clonedInputIds[i].length; ++j) {
            if (i % this.config.decoder.num_codebooks >= j) {
              clonedInputIds[i][j] = BigInt(this.config.decoder.pad_token_id);
            }
          }
        }
        if (generation_config.guidance_scale !== null && generation_config.guidance_scale > 1) {
          clonedInputIds = clonedInputIds.concat(clonedInputIds);
        }
        const prepped = super.prepare_inputs_for_generation(clonedInputIds, model_inputs, generation_config);
        return prepped;
      }
      async generate(options2) {
        const output_ids = await super.generate(options2);
        const audio_codes = this._apply_and_filter_by_delay_pattern_mask(output_ids).unsqueeze_(0);
        const { audio_values } = await sessionRun(this.sessions["encodec_decode"], { audio_codes });
        return audio_values;
      }
    }

    class MobileNetV1PreTrainedModel extends PreTrainedModel {
    }

    class MobileNetV1Model extends MobileNetV1PreTrainedModel {
    }

    class MobileNetV1ForImageClassification extends MobileNetV1PreTrainedModel {
      async _call(model_inputs) {
        return new SequenceClassifierOutput(await super._call(model_inputs));
      }
    }

    class MobileNetV1ForSemanticSegmentation extends MobileNetV1PreTrainedModel {
    }

    class MobileNetV2PreTrainedModel extends PreTrainedModel {
    }

    class MobileNetV2Model extends MobileNetV2PreTrainedModel {
    }

    class MobileNetV2ForImageClassification extends MobileNetV2PreTrainedModel {
      async _call(model_inputs) {
        return new SequenceClassifierOutput(await super._call(model_inputs));
      }
    }

    class MobileNetV2ForSemanticSegmentation extends MobileNetV2PreTrainedModel {
    }

    class MobileNetV3PreTrainedModel extends PreTrainedModel {
    }

    class MobileNetV3Model extends MobileNetV3PreTrainedModel {
    }

    class MobileNetV3ForImageClassification extends MobileNetV3PreTrainedModel {
      async _call(model_inputs) {
        return new SequenceClassifierOutput(await super._call(model_inputs));
      }
    }

    class MobileNetV3ForSemanticSegmentation extends MobileNetV3PreTrainedModel {
    }

    class MobileNetV4PreTrainedModel extends PreTrainedModel {
    }

    class MobileNetV4Model extends MobileNetV4PreTrainedModel {
    }

    class MobileNetV4ForImageClassification extends MobileNetV4PreTrainedModel {
      async _call(model_inputs) {
        return new SequenceClassifierOutput(await super._call(model_inputs));
      }
    }

    class MobileNetV4ForSemanticSegmentation extends MobileNetV4PreTrainedModel {
    }

    class DecisionTransformerPreTrainedModel extends PreTrainedModel {
    }

    class DecisionTransformerModel extends DecisionTransformerPreTrainedModel {
    }

    class MultiModalityPreTrainedModel extends PreTrainedModel {
    }

    class MultiModalityCausalLM extends MultiModalityPreTrainedModel {
      forward_params = [
        "input_ids",
        "pixel_values",
        "images_seq_mask",
        "images_emb_mask",
        "attention_mask",
        "position_ids",
        "past_key_values"
      ];
      constructor(...args) {
        super(...args);
        this._generation_mode = "text";
      }
      async forward(model_inputs) {
        const mode = this._generation_mode ?? "text";
        let output_1;
        if (mode === "text" || !model_inputs.past_key_values) {
          const session = this.sessions["prepare_inputs_embeds"];
          const prep_inputs = (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_4__.pick)(model_inputs, session.inputNames);
          output_1 = await sessionRun(session, prep_inputs);
        } else {
          const session = this.sessions["gen_img_embeds"];
          const prep_inputs = (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_4__.pick)({
            image_ids: model_inputs.input_ids
          }, session.inputNames);
          output_1 = await sessionRun(session, prep_inputs);
        }
        const input_2 = { ...model_inputs, ...output_1 };
        const output_2 = await decoderForward(this, input_2);
        const head = this.sessions[mode === "text" ? "lm_head" : "gen_head"];
        if (!head) {
          throw new Error(`Unable to find "${head}" generation head`);
        }
        const output_3 = await sessionRun(head, (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_4__.pick)(output_2, head.inputNames));
        return {
          ...output_1,
          ...output_2,
          ...output_3
        };
      }
      async generate(options2) {
        this._generation_mode = "text";
        return super.generate(options2);
      }
      async generate_images(options2) {
        this._generation_mode = "image";
        const start_num_tokens = (options2.inputs ?? options2[this.main_input_name]).dims[1];
        const all_tokens = await super.generate(options2);
        const generated_tokens = all_tokens.slice(null, [start_num_tokens, null]);
        const image_decode = this.sessions["image_decode"];
        const { decoded_image } = await sessionRun(image_decode, {
          generated_tokens
        });
        const clamped = decoded_image.add_(1).mul_(255 / 2).clamp_(0, 255).to("uint8");
        const images = [];
        for (const tensor2 of clamped) {
          const img = _utils_image_js__WEBPACK_IMPORTED_MODULE_10__.RawImage.fromTensor(tensor2);
          images.push(img);
        }
        return images;
      }
    }

    class MgpstrModelOutput extends ModelOutput {
      constructor({ char_logits, bpe_logits, wp_logits }) {
        super();
        this.char_logits = char_logits;
        this.bpe_logits = bpe_logits;
        this.wp_logits = wp_logits;
      }
      get logits() {
        return [this.char_logits, this.bpe_logits, this.wp_logits];
      }
    }

    class MgpstrPreTrainedModel extends PreTrainedModel {
    }

    class MgpstrForSceneTextRecognition extends MgpstrPreTrainedModel {
      async _call(model_inputs) {
        return new MgpstrModelOutput(await super._call(model_inputs));
      }
    }

    class PatchTSTPreTrainedModel extends PreTrainedModel {
    }

    class PatchTSTModel extends PatchTSTPreTrainedModel {
    }

    class PatchTSTForPrediction extends PatchTSTPreTrainedModel {
    }

    class PatchTSMixerPreTrainedModel extends PreTrainedModel {
    }

    class PatchTSMixerModel extends PatchTSMixerPreTrainedModel {
    }

    class PatchTSMixerForPrediction extends PatchTSMixerPreTrainedModel {
    }

    class UltravoxPreTrainedModel extends PreTrainedModel {
      forward_params = [
        "input_ids",
        "attention_mask",
        "position_ids",
        "audio_values",
        "past_key_values"
      ];
    }

    class UltravoxModel extends UltravoxPreTrainedModel {
      _merge_input_ids_with_audio_features(kwargs) {
        const audio_hidden_size = kwargs.audio_features.dims.at(-1);
        const reshaped_audio_features = kwargs.audio_features.view(-1, audio_hidden_size);
        return default_merge_input_ids_with_audio_features({
          audio_token_id: this.config.ignore_index ?? this.config.audio_token_id,
          ...kwargs,
          audio_features: reshaped_audio_features
        });
      }
    }

    class VoxtralForConditionalGeneration extends UltravoxModel {
    }

    class MimiPreTrainedModel extends PreTrainedModel {
      main_input_name = "input_values";
      forward_params = ["input_values"];
    }

    class MimiEncoderOutput extends ModelOutput {
      constructor({ audio_codes }) {
        super();
        this.audio_codes = audio_codes;
      }
    }

    class MimiDecoderOutput extends ModelOutput {
      constructor({ audio_values }) {
        super();
        this.audio_values = audio_values;
      }
    }

    class MimiModel extends MimiPreTrainedModel {
      async encode(inputs) {
        return new MimiEncoderOutput(await sessionRun(this.sessions["encoder_model"], inputs));
      }
      async decode(inputs) {
        return new MimiDecoderOutput(await sessionRun(this.sessions["decoder_model"], inputs));
      }
    }

    class MimiEncoderModel extends MimiPreTrainedModel {
      static async from_pretrained(pretrained_model_name_or_path, options2 = {}) {
        return super.from_pretrained(pretrained_model_name_or_path, {
          ...options2,
          model_file_name: options2.model_file_name ?? "encoder_model"
        });
      }
    }

    class MimiDecoderModel extends MimiPreTrainedModel {
      static async from_pretrained(pretrained_model_name_or_path, options2 = {}) {
        return super.from_pretrained(pretrained_model_name_or_path, {
          ...options2,
          model_file_name: options2.model_file_name ?? "decoder_model"
        });
      }
    }

    class DacPreTrainedModel extends PreTrainedModel {
      main_input_name = "input_values";
      forward_params = ["input_values"];
    }

    class DacEncoderOutput extends ModelOutput {
      constructor({ audio_codes }) {
        super();
        this.audio_codes = audio_codes;
      }
    }

    class DacDecoderOutput extends ModelOutput {
      constructor({ audio_values }) {
        super();
        this.audio_values = audio_values;
      }
    }

    class DacModel extends DacPreTrainedModel {
      async encode(inputs) {
        return new DacEncoderOutput(await sessionRun(this.sessions["encoder_model"], inputs));
      }
      async decode(inputs) {
        return new DacDecoderOutput(await sessionRun(this.sessions["decoder_model"], inputs));
      }
    }

    class DacEncoderModel extends DacPreTrainedModel {
      static async from_pretrained(pretrained_model_name_or_path, options2 = {}) {
        return super.from_pretrained(pretrained_model_name_or_path, {
          ...options2,
          model_file_name: options2.model_file_name ?? "encoder_model"
        });
      }
    }

    class DacDecoderModel extends DacPreTrainedModel {
      static async from_pretrained(pretrained_model_name_or_path, options2 = {}) {
        return super.from_pretrained(pretrained_model_name_or_path, {
          ...options2,
          model_file_name: options2.model_file_name ?? "decoder_model"
        });
      }
    }

    class SnacPreTrainedModel extends PreTrainedModel {
      main_input_name = "input_values";
      forward_params = ["input_values"];
    }

    class SnacModel extends SnacPreTrainedModel {
      async encode(inputs) {
        return await sessionRun(this.sessions["encoder_model"], inputs);
      }
      async decode(inputs) {
        return await sessionRun(this.sessions["decoder_model"], inputs);
      }
    }

    class SnacEncoderModel extends SnacPreTrainedModel {
      static async from_pretrained(pretrained_model_name_or_path, options2 = {}) {
        return super.from_pretrained(pretrained_model_name_or_path, {
          ...options2,
          model_file_name: options2.model_file_name ?? "encoder_model"
        });
      }
    }

    class SnacDecoderModel extends SnacPreTrainedModel {
      static async from_pretrained(pretrained_model_name_or_path, options2 = {}) {
        return super.from_pretrained(pretrained_model_name_or_path, {
          ...options2,
          model_file_name: options2.model_file_name ?? "decoder_model"
        });
      }
    }

    class PretrainedMixin {
      static MODEL_CLASS_MAPPINGS = null;
      static BASE_IF_FAIL = false;
      static async from_pretrained(pretrained_model_name_or_path, {
        progress_callback = null,
        config: config3 = null,
        cache_dir = null,
        local_files_only = false,
        revision = "main",
        model_file_name = null,
        subfolder = "onnx",
        device = null,
        dtype = null,
        use_external_data_format = null,
        session_options = {}
      } = {}) {
        const options2 = {
          progress_callback,
          config: config3,
          cache_dir,
          local_files_only,
          revision,
          model_file_name,
          subfolder,
          device,
          dtype,
          use_external_data_format,
          session_options
        };
        options2.config = await _configs_js__WEBPACK_IMPORTED_MODULE_0__.AutoConfig.from_pretrained(pretrained_model_name_or_path, options2);
        if (!this.MODEL_CLASS_MAPPINGS) {
          throw new Error("`MODEL_CLASS_MAPPINGS` not implemented for this type of `AutoClass`: " + this.name);
        }
        const model_type = options2.config.model_type;
        for (const MODEL_CLASS_MAPPING of this.MODEL_CLASS_MAPPINGS) {
          let modelInfo = MODEL_CLASS_MAPPING.get(model_type);
          if (!modelInfo) {
            for (const cls of MODEL_CLASS_MAPPING.values()) {
              if (cls[0] === model_type) {
                modelInfo = cls;
                break;
              }
            }
            if (!modelInfo)
              continue;
          }
          return await modelInfo[1].from_pretrained(pretrained_model_name_or_path, options2);
        }
        if (this.BASE_IF_FAIL) {
          if (!CUSTOM_ARCHITECTURES.has(model_type)) {
            console.warn(`Unknown model class "${model_type}", attempting to construct from base class.`);
          }
          return await PreTrainedModel.from_pretrained(pretrained_model_name_or_path, options2);
        } else {
          throw Error(`Unsupported model type: ${model_type}`);
        }
      }
    }
    const MODEL_MAPPING_NAMES_ENCODER_ONLY = new Map([
      ["bert", ["BertModel", BertModel]],
      ["neobert", ["NeoBertModel", NeoBertModel]],
      ["modernbert", ["ModernBertModel", ModernBertModel]],
      ["nomic_bert", ["NomicBertModel", NomicBertModel]],
      ["roformer", ["RoFormerModel", RoFormerModel]],
      ["electra", ["ElectraModel", ElectraModel]],
      ["esm", ["EsmModel", EsmModel]],
      ["convbert", ["ConvBertModel", ConvBertModel]],
      ["camembert", ["CamembertModel", CamembertModel]],
      ["deberta", ["DebertaModel", DebertaModel]],
      ["deberta-v2", ["DebertaV2Model", DebertaV2Model]],
      ["mpnet", ["MPNetModel", MPNetModel]],
      ["albert", ["AlbertModel", AlbertModel]],
      ["distilbert", ["DistilBertModel", DistilBertModel]],
      ["roberta", ["RobertaModel", RobertaModel]],
      ["xlm", ["XLMModel", XLMModel]],
      ["xlm-roberta", ["XLMRobertaModel", XLMRobertaModel]],
      ["clap", ["ClapModel", ClapModel]],
      ["clip", ["CLIPModel", CLIPModel]],
      ["clipseg", ["CLIPSegModel", CLIPSegModel]],
      ["chinese_clip", ["ChineseCLIPModel", ChineseCLIPModel]],
      ["siglip", ["SiglipModel", SiglipModel]],
      ["jina_clip", ["JinaCLIPModel", JinaCLIPModel]],
      ["mobilebert", ["MobileBertModel", MobileBertModel]],
      ["squeezebert", ["SqueezeBertModel", SqueezeBertModel]],
      ["wav2vec2", ["Wav2Vec2Model", Wav2Vec2Model]],
      ["wav2vec2-bert", ["Wav2Vec2BertModel", Wav2Vec2BertModel]],
      ["unispeech", ["UniSpeechModel", UniSpeechModel]],
      ["unispeech-sat", ["UniSpeechSatModel", UniSpeechSatModel]],
      ["hubert", ["HubertModel", HubertModel]],
      ["wavlm", ["WavLMModel", WavLMModel]],
      ["audio-spectrogram-transformer", ["ASTModel", ASTModel]],
      ["vits", ["VitsModel", VitsModel]],
      ["pyannote", ["PyAnnoteModel", PyAnnoteModel]],
      ["wespeaker-resnet", ["WeSpeakerResNetModel", WeSpeakerResNetModel]],
      ["detr", ["DetrModel", DetrModel]],
      ["rt_detr", ["RTDetrModel", RTDetrModel]],
      ["rt_detr_v2", ["RTDetrV2Model", RTDetrV2Model]],
      ["rf_detr", ["RFDetrModel", RFDetrModel]],
      ["d_fine", ["DFineModel", DFineModel]],
      ["table-transformer", ["TableTransformerModel", TableTransformerModel]],
      ["vit", ["ViTModel", ViTModel]],
      ["ijepa", ["IJepaModel", IJepaModel]],
      ["pvt", ["PvtModel", PvtModel]],
      ["vit_msn", ["ViTMSNModel", ViTMSNModel]],
      ["vit_mae", ["ViTMAEModel", ViTMAEModel]],
      ["groupvit", ["GroupViTModel", GroupViTModel]],
      ["fastvit", ["FastViTModel", FastViTModel]],
      ["mobilevit", ["MobileViTModel", MobileViTModel]],
      ["mobilevitv2", ["MobileViTV2Model", MobileViTV2Model]],
      ["owlvit", ["OwlViTModel", OwlViTModel]],
      ["owlv2", ["Owlv2Model", Owlv2Model]],
      ["beit", ["BeitModel", BeitModel]],
      ["deit", ["DeiTModel", DeiTModel]],
      ["hiera", ["HieraModel", HieraModel]],
      ["convnext", ["ConvNextModel", ConvNextModel]],
      ["convnextv2", ["ConvNextV2Model", ConvNextV2Model]],
      ["dinov2", ["Dinov2Model", Dinov2Model]],
      ["dinov2_with_registers", ["Dinov2WithRegistersModel", Dinov2WithRegistersModel]],
      ["dinov3_vit", ["DINOv3ViTModel", DINOv3ViTModel]],
      ["dinov3_convnext", ["DINOv3ConvNextModel", DINOv3ConvNextModel]],
      ["resnet", ["ResNetModel", ResNetModel]],
      ["swin", ["SwinModel", SwinModel]],
      ["swin2sr", ["Swin2SRModel", Swin2SRModel]],
      ["donut-swin", ["DonutSwinModel", DonutSwinModel]],
      ["yolos", ["YolosModel", YolosModel]],
      ["dpt", ["DPTModel", DPTModel]],
      ["glpn", ["GLPNModel", GLPNModel]],
      ["hifigan", ["SpeechT5HifiGan", SpeechT5HifiGan]],
      ["efficientnet", ["EfficientNetModel", EfficientNetModel]],
      ["decision_transformer", ["DecisionTransformerModel", DecisionTransformerModel]],
      ["patchtst", ["PatchTSTForPrediction", PatchTSTModel]],
      ["patchtsmixer", ["PatchTSMixerForPrediction", PatchTSMixerModel]],
      ["mobilenet_v1", ["MobileNetV1Model", MobileNetV1Model]],
      ["mobilenet_v2", ["MobileNetV2Model", MobileNetV2Model]],
      ["mobilenet_v3", ["MobileNetV3Model", MobileNetV3Model]],
      ["mobilenet_v4", ["MobileNetV4Model", MobileNetV4Model]],
      ["maskformer", ["MaskFormerModel", MaskFormerModel]],
      ["mgp-str", ["MgpstrForSceneTextRecognition", MgpstrForSceneTextRecognition]],
      ["style_text_to_speech_2", ["StyleTextToSpeech2Model", StyleTextToSpeech2Model]]
    ]);
    const MODEL_MAPPING_NAMES_ENCODER_DECODER = new Map([
      ["t5", ["T5Model", T5Model]],
      ["longt5", ["LongT5Model", LongT5Model]],
      ["mt5", ["MT5Model", MT5Model]],
      ["bart", ["BartModel", BartModel]],
      ["mbart", ["MBartModel", MBartModel]],
      ["marian", ["MarianModel", MarianModel]],
      ["whisper", ["WhisperModel", WhisperModel]],
      ["m2m_100", ["M2M100Model", M2M100Model]],
      ["blenderbot", ["BlenderbotModel", BlenderbotModel]],
      ["blenderbot-small", ["BlenderbotSmallModel", BlenderbotSmallModel]]
    ]);
    const MODEL_MAPPING_NAMES_AUTO_ENCODER = new Map([
      ["mimi", ["MimiModel", MimiModel]],
      ["dac", ["DacModel", DacModel]],
      ["snac", ["SnacModel", SnacModel]]
    ]);
    const MODEL_MAPPING_NAMES_DECODER_ONLY = new Map([
      ["bloom", ["BloomModel", BloomModel]],
      ["jais", ["JAISModel", JAISModel]],
      ["gpt2", ["GPT2Model", GPT2Model]],
      ["gptj", ["GPTJModel", GPTJModel]],
      ["gpt_bigcode", ["GPTBigCodeModel", GPTBigCodeModel]],
      ["gpt_neo", ["GPTNeoModel", GPTNeoModel]],
      ["gpt_neox", ["GPTNeoXModel", GPTNeoXModel]],
      ["codegen", ["CodeGenModel", CodeGenModel]],
      ["llama", ["LlamaModel", LlamaModel]],
      ["nanochat", ["NanoChatModel", NanoChatModel]],
      ["arcee", ["ArceeModel", ArceeModel]],
      ["lfm2", ["Lfm2Model", Lfm2Model]],
      ["smollm3", ["SmolLM3Model", SmolLM3Model]],
      ["exaone", ["ExaoneModel", ExaoneModel]],
      ["olmo", ["OlmoModel", OlmoModel]],
      ["olmo2", ["Olmo2Model", Olmo2Model]],
      ["mobilellm", ["MobileLLMModel", MobileLLMModel]],
      ["granite", ["GraniteModel", GraniteModel]],
      ["granitemoehybrid", ["GraniteMoeHybridModel", GraniteMoeHybridModel]],
      ["cohere", ["CohereModel", CohereModel]],
      ["gemma", ["GemmaModel", GemmaModel]],
      ["gemma2", ["Gemma2Model", Gemma2Model]],
      ["vaultgemma", ["VaultGemmaModel", VaultGemmaModel]],
      ["gemma3_text", ["Gemma3Model", Gemma3Model]],
      ["helium", ["HeliumModel", HeliumModel]],
      ["glm", ["GlmModel", GlmModel]],
      ["openelm", ["OpenELMModel", OpenELMModel]],
      ["qwen2", ["Qwen2Model", Qwen2Model]],
      ["qwen3", ["Qwen3Model", Qwen3Model]],
      ["phi", ["PhiModel", PhiModel]],
      ["phi3", ["Phi3Model", Phi3Model]],
      ["mpt", ["MptModel", MptModel]],
      ["opt", ["OPTModel", OPTModel]],
      ["mistral", ["MistralModel", MistralModel]],
      ["ministral", ["MinistralModel", MinistralModel]],
      ["ministral3", ["Ministral3Model", Ministral3Model]],
      ["ernie4_5", ["Ernie4_5Model", Ernie4_5Model]],
      ["starcoder2", ["Starcoder2Model", Starcoder2Model]],
      ["falcon", ["FalconModel", FalconModel]],
      ["stablelm", ["StableLmModel", StableLmModel]],
      ["modernbert-decoder", ["ModernBertDecoderModel", ModernBertDecoderModel]]
    ]);
    const MODEL_FOR_SPEECH_SEQ_2_SEQ_MAPPING_NAMES = new Map([
      ["speecht5", ["SpeechT5ForSpeechToText", SpeechT5ForSpeechToText]],
      ["whisper", ["WhisperForConditionalGeneration", WhisperForConditionalGeneration]],
      ["lite-whisper", ["LiteWhisperForConditionalGeneration", LiteWhisperForConditionalGeneration]],
      ["moonshine", ["MoonshineForConditionalGeneration", MoonshineForConditionalGeneration]]
    ]);
    const MODEL_FOR_TEXT_TO_SPECTROGRAM_MAPPING_NAMES = new Map([
      ["speecht5", ["SpeechT5ForTextToSpeech", SpeechT5ForTextToSpeech]]
    ]);
    const MODEL_FOR_TEXT_TO_WAVEFORM_MAPPING_NAMES = new Map([
      ["vits", ["VitsModel", VitsModel]],
      ["musicgen", ["MusicgenForConditionalGeneration", MusicgenForConditionalGeneration]],
      ["supertonic", ["SupertonicForConditionalGeneration", SupertonicForConditionalGeneration]]
    ]);
    const MODEL_FOR_SEQUENCE_CLASSIFICATION_MAPPING_NAMES = new Map([
      ["bert", ["BertForSequenceClassification", BertForSequenceClassification]],
      ["neobert", ["NeoBertForSequenceClassification", NeoBertForSequenceClassification]],
      ["modernbert", ["ModernBertForSequenceClassification", ModernBertForSequenceClassification]],
      ["roformer", ["RoFormerForSequenceClassification", RoFormerForSequenceClassification]],
      ["electra", ["ElectraForSequenceClassification", ElectraForSequenceClassification]],
      ["esm", ["EsmForSequenceClassification", EsmForSequenceClassification]],
      ["convbert", ["ConvBertForSequenceClassification", ConvBertForSequenceClassification]],
      ["camembert", ["CamembertForSequenceClassification", CamembertForSequenceClassification]],
      ["deberta", ["DebertaForSequenceClassification", DebertaForSequenceClassification]],
      ["deberta-v2", ["DebertaV2ForSequenceClassification", DebertaV2ForSequenceClassification]],
      ["mpnet", ["MPNetForSequenceClassification", MPNetForSequenceClassification]],
      ["albert", ["AlbertForSequenceClassification", AlbertForSequenceClassification]],
      ["distilbert", ["DistilBertForSequenceClassification", DistilBertForSequenceClassification]],
      ["roberta", ["RobertaForSequenceClassification", RobertaForSequenceClassification]],
      ["xlm", ["XLMForSequenceClassification", XLMForSequenceClassification]],
      ["xlm-roberta", ["XLMRobertaForSequenceClassification", XLMRobertaForSequenceClassification]],
      ["bart", ["BartForSequenceClassification", BartForSequenceClassification]],
      ["mbart", ["MBartForSequenceClassification", MBartForSequenceClassification]],
      ["mobilebert", ["MobileBertForSequenceClassification", MobileBertForSequenceClassification]],
      ["squeezebert", ["SqueezeBertForSequenceClassification", SqueezeBertForSequenceClassification]]
    ]);
    const MODEL_FOR_TOKEN_CLASSIFICATION_MAPPING_NAMES = new Map([
      ["bert", ["BertForTokenClassification", BertForTokenClassification]],
      ["neobert", ["NeoBertForTokenClassification", NeoBertForTokenClassification]],
      ["modernbert", ["ModernBertForTokenClassification", ModernBertForTokenClassification]],
      ["roformer", ["RoFormerForTokenClassification", RoFormerForTokenClassification]],
      ["electra", ["ElectraForTokenClassification", ElectraForTokenClassification]],
      ["esm", ["EsmForTokenClassification", EsmForTokenClassification]],
      ["convbert", ["ConvBertForTokenClassification", ConvBertForTokenClassification]],
      ["camembert", ["CamembertForTokenClassification", CamembertForTokenClassification]],
      ["deberta", ["DebertaForTokenClassification", DebertaForTokenClassification]],
      ["deberta-v2", ["DebertaV2ForTokenClassification", DebertaV2ForTokenClassification]],
      ["mpnet", ["MPNetForTokenClassification", MPNetForTokenClassification]],
      ["distilbert", ["DistilBertForTokenClassification", DistilBertForTokenClassification]],
      ["roberta", ["RobertaForTokenClassification", RobertaForTokenClassification]],
      ["xlm", ["XLMForTokenClassification", XLMForTokenClassification]],
      ["xlm-roberta", ["XLMRobertaForTokenClassification", XLMRobertaForTokenClassification]]
    ]);
    const MODEL_FOR_SEQ_TO_SEQ_CAUSAL_LM_MAPPING_NAMES = new Map([
      ["t5", ["T5ForConditionalGeneration", T5ForConditionalGeneration]],
      ["longt5", ["LongT5ForConditionalGeneration", LongT5ForConditionalGeneration]],
      ["mt5", ["MT5ForConditionalGeneration", MT5ForConditionalGeneration]],
      ["bart", ["BartForConditionalGeneration", BartForConditionalGeneration]],
      ["mbart", ["MBartForConditionalGeneration", MBartForConditionalGeneration]],
      ["marian", ["MarianMTModel", MarianMTModel]],
      ["m2m_100", ["M2M100ForConditionalGeneration", M2M100ForConditionalGeneration]],
      ["blenderbot", ["BlenderbotForConditionalGeneration", BlenderbotForConditionalGeneration]],
      ["blenderbot-small", ["BlenderbotSmallForConditionalGeneration", BlenderbotSmallForConditionalGeneration]]
    ]);
    const MODEL_FOR_CAUSAL_LM_MAPPING_NAMES = new Map([
      ["bloom", ["BloomForCausalLM", BloomForCausalLM]],
      ["gpt2", ["GPT2LMHeadModel", GPT2LMHeadModel]],
      ["jais", ["JAISLMHeadModel", JAISLMHeadModel]],
      ["gptj", ["GPTJForCausalLM", GPTJForCausalLM]],
      ["gpt_bigcode", ["GPTBigCodeForCausalLM", GPTBigCodeForCausalLM]],
      ["gpt_neo", ["GPTNeoForCausalLM", GPTNeoForCausalLM]],
      ["gpt_neox", ["GPTNeoXForCausalLM", GPTNeoXForCausalLM]],
      ["codegen", ["CodeGenForCausalLM", CodeGenForCausalLM]],
      ["llama", ["LlamaForCausalLM", LlamaForCausalLM]],
      ["nanochat", ["NanoChatForCausalLM", NanoChatForCausalLM]],
      ["llama4_text", ["Llama4ForCausalLM", Llama4ForCausalLM]],
      ["arcee", ["ArceeForCausalLM", ArceeForCausalLM]],
      ["lfm2", ["Lfm2ForCausalLM", Lfm2ForCausalLM]],
      ["smollm3", ["SmolLM3ForCausalLM", SmolLM3ForCausalLM]],
      ["exaone", ["ExaoneForCausalLM", ExaoneForCausalLM]],
      ["olmo", ["OlmoForCausalLM", OlmoForCausalLM]],
      ["olmo2", ["Olmo2ForCausalLM", Olmo2ForCausalLM]],
      ["mobilellm", ["MobileLLMForCausalLM", MobileLLMForCausalLM]],
      ["granite", ["GraniteForCausalLM", GraniteForCausalLM]],
      ["granitemoehybrid", ["GraniteMoeHybridForCausalLM", GraniteMoeHybridForCausalLM]],
      ["cohere", ["CohereForCausalLM", CohereForCausalLM]],
      ["gemma", ["GemmaForCausalLM", GemmaForCausalLM]],
      ["gemma2", ["Gemma2ForCausalLM", Gemma2ForCausalLM]],
      ["vaultgemma", ["VaultGemmaForCausalLM", VaultGemmaForCausalLM]],
      ["gemma3_text", ["Gemma3ForCausalLM", Gemma3ForCausalLM]],
      ["helium", ["HeliumForCausalLM", HeliumForCausalLM]],
      ["glm", ["GlmForCausalLM", GlmForCausalLM]],
      ["openelm", ["OpenELMForCausalLM", OpenELMForCausalLM]],
      ["qwen2", ["Qwen2ForCausalLM", Qwen2ForCausalLM]],
      ["qwen3", ["Qwen3ForCausalLM", Qwen3ForCausalLM]],
      ["phi", ["PhiForCausalLM", PhiForCausalLM]],
      ["phi3", ["Phi3ForCausalLM", Phi3ForCausalLM]],
      ["mpt", ["MptForCausalLM", MptForCausalLM]],
      ["opt", ["OPTForCausalLM", OPTForCausalLM]],
      ["mbart", ["MBartForCausalLM", MBartForCausalLM]],
      ["mistral", ["MistralForCausalLM", MistralForCausalLM]],
      ["ministral", ["MinistralForCausalLM", MinistralForCausalLM]],
      ["ministral3", ["Ministral3ForCausalLM", Ministral3ForCausalLM]],
      ["ernie4_5", ["Ernie4_5ForCausalLM", Ernie4_5ForCausalLM]],
      ["starcoder2", ["Starcoder2ForCausalLM", Starcoder2ForCausalLM]],
      ["falcon", ["FalconForCausalLM", FalconForCausalLM]],
      ["trocr", ["TrOCRForCausalLM", TrOCRForCausalLM]],
      ["stablelm", ["StableLmForCausalLM", StableLmForCausalLM]],
      ["modernbert-decoder", ["ModernBertDecoderForCausalLM", ModernBertDecoderForCausalLM]],
      ["phi3_v", ["Phi3VForCausalLM", Phi3VForCausalLM]]
    ]);
    const MODEL_FOR_MULTIMODALITY_MAPPING_NAMES = new Map([
      ["multi_modality", ["MultiModalityCausalLM", MultiModalityCausalLM]]
    ]);
    const MODEL_FOR_MASKED_LM_MAPPING_NAMES = new Map([
      ["bert", ["BertForMaskedLM", BertForMaskedLM]],
      ["neobert", ["NeoBertForMaskedLM", NeoBertForMaskedLM]],
      ["modernbert", ["ModernBertForMaskedLM", ModernBertForMaskedLM]],
      ["roformer", ["RoFormerForMaskedLM", RoFormerForMaskedLM]],
      ["electra", ["ElectraForMaskedLM", ElectraForMaskedLM]],
      ["esm", ["EsmForMaskedLM", EsmForMaskedLM]],
      ["convbert", ["ConvBertForMaskedLM", ConvBertForMaskedLM]],
      ["camembert", ["CamembertForMaskedLM", CamembertForMaskedLM]],
      ["deberta", ["DebertaForMaskedLM", DebertaForMaskedLM]],
      ["deberta-v2", ["DebertaV2ForMaskedLM", DebertaV2ForMaskedLM]],
      ["mpnet", ["MPNetForMaskedLM", MPNetForMaskedLM]],
      ["albert", ["AlbertForMaskedLM", AlbertForMaskedLM]],
      ["distilbert", ["DistilBertForMaskedLM", DistilBertForMaskedLM]],
      ["roberta", ["RobertaForMaskedLM", RobertaForMaskedLM]],
      ["xlm", ["XLMWithLMHeadModel", XLMWithLMHeadModel]],
      ["xlm-roberta", ["XLMRobertaForMaskedLM", XLMRobertaForMaskedLM]],
      ["mobilebert", ["MobileBertForMaskedLM", MobileBertForMaskedLM]],
      ["squeezebert", ["SqueezeBertForMaskedLM", SqueezeBertForMaskedLM]]
    ]);
    const MODEL_FOR_QUESTION_ANSWERING_MAPPING_NAMES = new Map([
      ["bert", ["BertForQuestionAnswering", BertForQuestionAnswering]],
      ["neobert", ["NeoBertForQuestionAnswering", NeoBertForQuestionAnswering]],
      ["roformer", ["RoFormerForQuestionAnswering", RoFormerForQuestionAnswering]],
      ["electra", ["ElectraForQuestionAnswering", ElectraForQuestionAnswering]],
      ["convbert", ["ConvBertForQuestionAnswering", ConvBertForQuestionAnswering]],
      ["camembert", ["CamembertForQuestionAnswering", CamembertForQuestionAnswering]],
      ["deberta", ["DebertaForQuestionAnswering", DebertaForQuestionAnswering]],
      ["deberta-v2", ["DebertaV2ForQuestionAnswering", DebertaV2ForQuestionAnswering]],
      ["mpnet", ["MPNetForQuestionAnswering", MPNetForQuestionAnswering]],
      ["albert", ["AlbertForQuestionAnswering", AlbertForQuestionAnswering]],
      ["distilbert", ["DistilBertForQuestionAnswering", DistilBertForQuestionAnswering]],
      ["roberta", ["RobertaForQuestionAnswering", RobertaForQuestionAnswering]],
      ["xlm", ["XLMForQuestionAnswering", XLMForQuestionAnswering]],
      ["xlm-roberta", ["XLMRobertaForQuestionAnswering", XLMRobertaForQuestionAnswering]],
      ["mobilebert", ["MobileBertForQuestionAnswering", MobileBertForQuestionAnswering]],
      ["squeezebert", ["SqueezeBertForQuestionAnswering", SqueezeBertForQuestionAnswering]]
    ]);
    const MODEL_FOR_VISION_2_SEQ_MAPPING_NAMES = new Map([
      ["vision-encoder-decoder", ["VisionEncoderDecoderModel", VisionEncoderDecoderModel]],
      ["idefics3", ["Idefics3ForConditionalGeneration", Idefics3ForConditionalGeneration]],
      ["smolvlm", ["SmolVLMForConditionalGeneration", SmolVLMForConditionalGeneration]]
    ]);
    const MODEL_FOR_IMAGE_TEXT_TO_TEXT_MAPPING_NAMES = new Map([
      ["llava", ["LlavaForConditionalGeneration", LlavaForConditionalGeneration]],
      ["llava_onevision", ["LlavaOnevisionForConditionalGeneration", LlavaOnevisionForConditionalGeneration]],
      ["moondream1", ["Moondream1ForConditionalGeneration", Moondream1ForConditionalGeneration]],
      ["florence2", ["Florence2ForConditionalGeneration", Florence2ForConditionalGeneration]],
      ["qwen2-vl", ["Qwen2VLForConditionalGeneration", Qwen2VLForConditionalGeneration]],
      ["idefics3", ["Idefics3ForConditionalGeneration", Idefics3ForConditionalGeneration]],
      ["smolvlm", ["SmolVLMForConditionalGeneration", SmolVLMForConditionalGeneration]],
      ["paligemma", ["PaliGemmaForConditionalGeneration", PaliGemmaForConditionalGeneration]],
      ["llava_qwen2", ["LlavaQwen2ForCausalLM", LlavaQwen2ForCausalLM]],
      ["gemma3n", ["Gemma3nForConditionalGeneration", Gemma3nForConditionalGeneration]],
      ["mistral3", ["Mistral3ForConditionalGeneration", Mistral3ForConditionalGeneration]]
    ]);
    const MODEL_FOR_AUDIO_TEXT_TO_TEXT_MAPPING_NAMES = new Map([
      ["ultravox", ["UltravoxModel", UltravoxModel]],
      ["voxtral", ["VoxtralForConditionalGeneration", VoxtralForConditionalGeneration]]
    ]);
    const MODEL_FOR_DOCUMENT_QUESTION_ANSWERING_MAPPING_NAMES = new Map([
      ["vision-encoder-decoder", ["VisionEncoderDecoderModel", VisionEncoderDecoderModel]]
    ]);
    const MODEL_FOR_IMAGE_CLASSIFICATION_MAPPING_NAMES = new Map([
      ["vit", ["ViTForImageClassification", ViTForImageClassification]],
      ["ijepa", ["IJepaForImageClassification", IJepaForImageClassification]],
      ["pvt", ["PvtForImageClassification", PvtForImageClassification]],
      ["vit_msn", ["ViTMSNForImageClassification", ViTMSNForImageClassification]],
      ["fastvit", ["FastViTForImageClassification", FastViTForImageClassification]],
      ["mobilevit", ["MobileViTForImageClassification", MobileViTForImageClassification]],
      ["mobilevitv2", ["MobileViTV2ForImageClassification", MobileViTV2ForImageClassification]],
      ["beit", ["BeitForImageClassification", BeitForImageClassification]],
      ["deit", ["DeiTForImageClassification", DeiTForImageClassification]],
      ["hiera", ["HieraForImageClassification", HieraForImageClassification]],
      ["convnext", ["ConvNextForImageClassification", ConvNextForImageClassification]],
      ["convnextv2", ["ConvNextV2ForImageClassification", ConvNextV2ForImageClassification]],
      ["dinov2", ["Dinov2ForImageClassification", Dinov2ForImageClassification]],
      ["dinov2_with_registers", ["Dinov2WithRegistersForImageClassification", Dinov2WithRegistersForImageClassification]],
      ["resnet", ["ResNetForImageClassification", ResNetForImageClassification]],
      ["swin", ["SwinForImageClassification", SwinForImageClassification]],
      ["segformer", ["SegformerForImageClassification", SegformerForImageClassification]],
      ["efficientnet", ["EfficientNetForImageClassification", EfficientNetForImageClassification]],
      ["mobilenet_v1", ["MobileNetV1ForImageClassification", MobileNetV1ForImageClassification]],
      ["mobilenet_v2", ["MobileNetV2ForImageClassification", MobileNetV2ForImageClassification]],
      ["mobilenet_v3", ["MobileNetV3ForImageClassification", MobileNetV3ForImageClassification]],
      ["mobilenet_v4", ["MobileNetV4ForImageClassification", MobileNetV4ForImageClassification]]
    ]);
    const MODEL_FOR_OBJECT_DETECTION_MAPPING_NAMES = new Map([
      ["detr", ["DetrForObjectDetection", DetrForObjectDetection]],
      ["rt_detr", ["RTDetrForObjectDetection", RTDetrForObjectDetection]],
      ["rt_detr_v2", ["RTDetrV2ForObjectDetection", RTDetrV2ForObjectDetection]],
      ["rf_detr", ["RFDetrForObjectDetection", RFDetrForObjectDetection]],
      ["d_fine", ["DFineForObjectDetection", DFineForObjectDetection]],
      ["table-transformer", ["TableTransformerForObjectDetection", TableTransformerForObjectDetection]],
      ["yolos", ["YolosForObjectDetection", YolosForObjectDetection]]
    ]);
    const MODEL_FOR_ZERO_SHOT_OBJECT_DETECTION_MAPPING_NAMES = new Map([
      ["owlvit", ["OwlViTForObjectDetection", OwlViTForObjectDetection]],
      ["owlv2", ["Owlv2ForObjectDetection", Owlv2ForObjectDetection]],
      ["grounding-dino", ["GroundingDinoForObjectDetection", GroundingDinoForObjectDetection]]
    ]);
    const MODEL_FOR_IMAGE_SEGMENTATION_MAPPING_NAMES = new Map([
      ["detr", ["DetrForSegmentation", DetrForSegmentation]],
      ["clipseg", ["CLIPSegForImageSegmentation", CLIPSegForImageSegmentation]]
    ]);
    const MODEL_FOR_SEMANTIC_SEGMENTATION_MAPPING_NAMES = new Map([
      ["segformer", ["SegformerForSemanticSegmentation", SegformerForSemanticSegmentation]],
      ["sapiens", ["SapiensForSemanticSegmentation", SapiensForSemanticSegmentation]],
      ["swin", ["SwinForSemanticSegmentation", SwinForSemanticSegmentation]],
      ["mobilenet_v1", ["MobileNetV1ForSemanticSegmentation", MobileNetV1ForSemanticSegmentation]],
      ["mobilenet_v2", ["MobileNetV2ForSemanticSegmentation", MobileNetV2ForSemanticSegmentation]],
      ["mobilenet_v3", ["MobileNetV3ForSemanticSegmentation", MobileNetV3ForSemanticSegmentation]],
      ["mobilenet_v4", ["MobileNetV4ForSemanticSegmentation", MobileNetV4ForSemanticSegmentation]]
    ]);
    const MODEL_FOR_UNIVERSAL_SEGMENTATION_MAPPING_NAMES = new Map([
      ["detr", ["DetrForSegmentation", DetrForSegmentation]],
      ["maskformer", ["MaskFormerForInstanceSegmentation", MaskFormerForInstanceSegmentation]]
    ]);
    const MODEL_FOR_MASK_GENERATION_MAPPING_NAMES = new Map([
      ["sam", ["SamModel", SamModel]],
      ["sam2", ["Sam2Model", Sam2Model]],
      ["edgetam", ["EdgeTamModel", EdgeTamModel]],
      ["sam3_tracker", ["Sam3TrackerModel", Sam3TrackerModel]]
    ]);
    const MODEL_FOR_CTC_MAPPING_NAMES = new Map([
      ["wav2vec2", ["Wav2Vec2ForCTC", Wav2Vec2ForCTC]],
      ["wav2vec2-bert", ["Wav2Vec2BertForCTC", Wav2Vec2BertForCTC]],
      ["unispeech", ["UniSpeechForCTC", UniSpeechForCTC]],
      ["unispeech-sat", ["UniSpeechSatForCTC", UniSpeechSatForCTC]],
      ["wavlm", ["WavLMForCTC", WavLMForCTC]],
      ["hubert", ["HubertForCTC", HubertForCTC]],
      ["parakeet_ctc", ["ParakeetForCTC", ParakeetForCTC]]
    ]);
    const MODEL_FOR_AUDIO_CLASSIFICATION_MAPPING_NAMES = new Map([
      ["wav2vec2", ["Wav2Vec2ForSequenceClassification", Wav2Vec2ForSequenceClassification]],
      ["wav2vec2-bert", ["Wav2Vec2BertForSequenceClassification", Wav2Vec2BertForSequenceClassification]],
      ["unispeech", ["UniSpeechForSequenceClassification", UniSpeechForSequenceClassification]],
      ["unispeech-sat", ["UniSpeechSatForSequenceClassification", UniSpeechSatForSequenceClassification]],
      ["wavlm", ["WavLMForSequenceClassification", WavLMForSequenceClassification]],
      ["hubert", ["HubertForSequenceClassification", HubertForSequenceClassification]],
      ["audio-spectrogram-transformer", ["ASTForAudioClassification", ASTForAudioClassification]]
    ]);
    const MODEL_FOR_AUDIO_XVECTOR_MAPPING_NAMES = new Map([
      ["wavlm", ["WavLMForXVector", WavLMForXVector]]
    ]);
    const MODEL_FOR_AUDIO_FRAME_CLASSIFICATION_MAPPING_NAMES = new Map([
      ["unispeech-sat", ["UniSpeechSatForAudioFrameClassification", UniSpeechSatForAudioFrameClassification]],
      ["wavlm", ["WavLMForAudioFrameClassification", WavLMForAudioFrameClassification]],
      ["wav2vec2", ["Wav2Vec2ForAudioFrameClassification", Wav2Vec2ForAudioFrameClassification]],
      ["pyannote", ["PyAnnoteForAudioFrameClassification", PyAnnoteForAudioFrameClassification]]
    ]);
    const MODEL_FOR_IMAGE_MATTING_MAPPING_NAMES = new Map([
      ["vitmatte", ["VitMatteForImageMatting", VitMatteForImageMatting]]
    ]);
    const MODEL_FOR_TIME_SERIES_PREDICTION_MAPPING_NAMES = new Map([
      ["patchtst", ["PatchTSTForPrediction", PatchTSTForPrediction]],
      ["patchtsmixer", ["PatchTSMixerForPrediction", PatchTSMixerForPrediction]]
    ]);
    const MODEL_FOR_IMAGE_TO_IMAGE_MAPPING_NAMES = new Map([
      ["swin2sr", ["Swin2SRForImageSuperResolution", Swin2SRForImageSuperResolution]]
    ]);
    const MODEL_FOR_DEPTH_ESTIMATION_MAPPING_NAMES = new Map([
      ["dpt", ["DPTForDepthEstimation", DPTForDepthEstimation]],
      ["depth_anything", ["DepthAnythingForDepthEstimation", DepthAnythingForDepthEstimation]],
      ["glpn", ["GLPNForDepthEstimation", GLPNForDepthEstimation]],
      ["sapiens", ["SapiensForDepthEstimation", SapiensForDepthEstimation]],
      ["depth_pro", ["DepthProForDepthEstimation", DepthProForDepthEstimation]],
      ["metric3d", ["Metric3DForDepthEstimation", Metric3DForDepthEstimation]],
      ["metric3dv2", ["Metric3Dv2ForDepthEstimation", Metric3Dv2ForDepthEstimation]]
    ]);
    const MODEL_FOR_NORMAL_ESTIMATION_MAPPING_NAMES = new Map([
      ["sapiens", ["SapiensForNormalEstimation", SapiensForNormalEstimation]]
    ]);
    const MODEL_FOR_POSE_ESTIMATION_MAPPING_NAMES = new Map([
      ["vitpose", ["VitPoseForPoseEstimation", VitPoseForPoseEstimation]]
    ]);
    const MODEL_FOR_IMAGE_FEATURE_EXTRACTION_MAPPING_NAMES = new Map([
      ["clip", ["CLIPVisionModelWithProjection", CLIPVisionModelWithProjection]],
      ["siglip", ["SiglipVisionModel", SiglipVisionModel]],
      ["jina_clip", ["JinaCLIPVisionModel", JinaCLIPVisionModel]]
    ]);
    const MODEL_CLASS_TYPE_MAPPING = [
      [MODEL_MAPPING_NAMES_ENCODER_ONLY, MODEL_TYPES.EncoderOnly],
      [MODEL_MAPPING_NAMES_ENCODER_DECODER, MODEL_TYPES.EncoderDecoder],
      [MODEL_MAPPING_NAMES_DECODER_ONLY, MODEL_TYPES.DecoderOnly],
      [MODEL_MAPPING_NAMES_AUTO_ENCODER, MODEL_TYPES.AutoEncoder],
      [MODEL_FOR_SEQUENCE_CLASSIFICATION_MAPPING_NAMES, MODEL_TYPES.EncoderOnly],
      [MODEL_FOR_TOKEN_CLASSIFICATION_MAPPING_NAMES, MODEL_TYPES.EncoderOnly],
      [MODEL_FOR_SEQ_TO_SEQ_CAUSAL_LM_MAPPING_NAMES, MODEL_TYPES.Seq2Seq],
      [MODEL_FOR_SPEECH_SEQ_2_SEQ_MAPPING_NAMES, MODEL_TYPES.Seq2Seq],
      [MODEL_FOR_CAUSAL_LM_MAPPING_NAMES, MODEL_TYPES.DecoderOnly],
      [MODEL_FOR_MULTIMODALITY_MAPPING_NAMES, MODEL_TYPES.MultiModality],
      [MODEL_FOR_MASKED_LM_MAPPING_NAMES, MODEL_TYPES.EncoderOnly],
      [MODEL_FOR_QUESTION_ANSWERING_MAPPING_NAMES, MODEL_TYPES.EncoderOnly],
      [MODEL_FOR_VISION_2_SEQ_MAPPING_NAMES, MODEL_TYPES.Vision2Seq],
      [MODEL_FOR_IMAGE_TEXT_TO_TEXT_MAPPING_NAMES, MODEL_TYPES.ImageTextToText],
      [MODEL_FOR_AUDIO_TEXT_TO_TEXT_MAPPING_NAMES, MODEL_TYPES.AudioTextToText],
      [MODEL_FOR_IMAGE_CLASSIFICATION_MAPPING_NAMES, MODEL_TYPES.EncoderOnly],
      [MODEL_FOR_IMAGE_SEGMENTATION_MAPPING_NAMES, MODEL_TYPES.EncoderOnly],
      [MODEL_FOR_UNIVERSAL_SEGMENTATION_MAPPING_NAMES, MODEL_TYPES.EncoderOnly],
      [MODEL_FOR_SEMANTIC_SEGMENTATION_MAPPING_NAMES, MODEL_TYPES.EncoderOnly],
      [MODEL_FOR_IMAGE_MATTING_MAPPING_NAMES, MODEL_TYPES.EncoderOnly],
      [MODEL_FOR_TIME_SERIES_PREDICTION_MAPPING_NAMES, MODEL_TYPES.EncoderOnly],
      [MODEL_FOR_IMAGE_TO_IMAGE_MAPPING_NAMES, MODEL_TYPES.EncoderOnly],
      [MODEL_FOR_DEPTH_ESTIMATION_MAPPING_NAMES, MODEL_TYPES.EncoderOnly],
      [MODEL_FOR_NORMAL_ESTIMATION_MAPPING_NAMES, MODEL_TYPES.EncoderOnly],
      [MODEL_FOR_POSE_ESTIMATION_MAPPING_NAMES, MODEL_TYPES.EncoderOnly],
      [MODEL_FOR_OBJECT_DETECTION_MAPPING_NAMES, MODEL_TYPES.EncoderOnly],
      [MODEL_FOR_ZERO_SHOT_OBJECT_DETECTION_MAPPING_NAMES, MODEL_TYPES.EncoderOnly],
      [MODEL_FOR_MASK_GENERATION_MAPPING_NAMES, MODEL_TYPES.MaskGeneration],
      [MODEL_FOR_CTC_MAPPING_NAMES, MODEL_TYPES.EncoderOnly],
      [MODEL_FOR_AUDIO_CLASSIFICATION_MAPPING_NAMES, MODEL_TYPES.EncoderOnly],
      [MODEL_FOR_TEXT_TO_SPECTROGRAM_MAPPING_NAMES, MODEL_TYPES.Seq2Seq],
      [MODEL_FOR_TEXT_TO_WAVEFORM_MAPPING_NAMES, MODEL_TYPES.EncoderOnly],
      [MODEL_FOR_AUDIO_XVECTOR_MAPPING_NAMES, MODEL_TYPES.EncoderOnly],
      [MODEL_FOR_AUDIO_FRAME_CLASSIFICATION_MAPPING_NAMES, MODEL_TYPES.EncoderOnly],
      [MODEL_FOR_IMAGE_FEATURE_EXTRACTION_MAPPING_NAMES, MODEL_TYPES.EncoderOnly]
    ];
    for (const [mappings, type] of MODEL_CLASS_TYPE_MAPPING) {
      for (const [name, model] of mappings.values()) {
        MODEL_TYPE_MAPPING.set(name, type);
        MODEL_CLASS_TO_NAME_MAPPING.set(model, name);
        MODEL_NAME_TO_CLASS_MAPPING.set(name, model);
      }
    }
    const CUSTOM_MAPPING = [
      ["MusicgenForConditionalGeneration", MusicgenForConditionalGeneration, MODEL_TYPES.Musicgen],
      ["Phi3VForCausalLM", Phi3VForCausalLM, MODEL_TYPES.Phi3V],
      ["CLIPTextModelWithProjection", CLIPTextModelWithProjection, MODEL_TYPES.EncoderOnly],
      ["SiglipTextModel", SiglipTextModel, MODEL_TYPES.EncoderOnly],
      ["JinaCLIPTextModel", JinaCLIPTextModel, MODEL_TYPES.EncoderOnly],
      ["ClapTextModelWithProjection", ClapTextModelWithProjection, MODEL_TYPES.EncoderOnly],
      ["ClapAudioModelWithProjection", ClapAudioModelWithProjection, MODEL_TYPES.EncoderOnly],
      ["DacEncoderModel", DacEncoderModel, MODEL_TYPES.EncoderOnly],
      ["DacDecoderModel", DacDecoderModel, MODEL_TYPES.EncoderOnly],
      ["MimiEncoderModel", MimiEncoderModel, MODEL_TYPES.EncoderOnly],
      ["MimiDecoderModel", MimiDecoderModel, MODEL_TYPES.EncoderOnly],
      ["SnacEncoderModel", SnacEncoderModel, MODEL_TYPES.EncoderOnly],
      ["SnacDecoderModel", SnacDecoderModel, MODEL_TYPES.EncoderOnly],
      ["Gemma3nForConditionalGeneration", Gemma3nForConditionalGeneration, MODEL_TYPES.ImageAudioTextToText],
      ["SupertonicForConditionalGeneration", SupertonicForConditionalGeneration, MODEL_TYPES.Supertonic]
    ];
    for (const [name, model, type] of CUSTOM_MAPPING) {
      MODEL_TYPE_MAPPING.set(name, type);
      MODEL_CLASS_TO_NAME_MAPPING.set(model, name);
      MODEL_NAME_TO_CLASS_MAPPING.set(name, model);
    }
    const CUSTOM_ARCHITECTURES = new Map([
      ["modnet", MODEL_FOR_IMAGE_SEGMENTATION_MAPPING_NAMES],
      ["birefnet", MODEL_FOR_IMAGE_SEGMENTATION_MAPPING_NAMES],
      ["isnet", MODEL_FOR_IMAGE_SEGMENTATION_MAPPING_NAMES],
      ["ben", MODEL_FOR_IMAGE_SEGMENTATION_MAPPING_NAMES]
    ]);
    for (const [name, mapping] of CUSTOM_ARCHITECTURES.entries()) {
      mapping.set(name, ["PreTrainedModel", PreTrainedModel]);
      MODEL_TYPE_MAPPING.set(name, MODEL_TYPES.EncoderOnly);
      MODEL_CLASS_TO_NAME_MAPPING.set(PreTrainedModel, name);
      MODEL_NAME_TO_CLASS_MAPPING.set(name, PreTrainedModel);
    }

    class AutoModel extends PretrainedMixin {
      static MODEL_CLASS_MAPPINGS = MODEL_CLASS_TYPE_MAPPING.map((x) => x[0]);
      static BASE_IF_FAIL = true;
    }

    class AutoModelForSequenceClassification extends PretrainedMixin {
      static MODEL_CLASS_MAPPINGS = [MODEL_FOR_SEQUENCE_CLASSIFICATION_MAPPING_NAMES];
    }

    class AutoModelForTokenClassification extends PretrainedMixin {
      static MODEL_CLASS_MAPPINGS = [MODEL_FOR_TOKEN_CLASSIFICATION_MAPPING_NAMES];
    }

    class AutoModelForSeq2SeqLM extends PretrainedMixin {
      static MODEL_CLASS_MAPPINGS = [MODEL_FOR_SEQ_TO_SEQ_CAUSAL_LM_MAPPING_NAMES];
    }

    class AutoModelForSpeechSeq2Seq extends PretrainedMixin {
      static MODEL_CLASS_MAPPINGS = [MODEL_FOR_SPEECH_SEQ_2_SEQ_MAPPING_NAMES];
    }

    class AutoModelForTextToSpectrogram extends PretrainedMixin {
      static MODEL_CLASS_MAPPINGS = [MODEL_FOR_TEXT_TO_SPECTROGRAM_MAPPING_NAMES];
    }

    class AutoModelForTextToWaveform extends PretrainedMixin {
      static MODEL_CLASS_MAPPINGS = [MODEL_FOR_TEXT_TO_WAVEFORM_MAPPING_NAMES];
    }

    class AutoModelForCausalLM extends PretrainedMixin {
      static MODEL_CLASS_MAPPINGS = [MODEL_FOR_CAUSAL_LM_MAPPING_NAMES];
    }

    class AutoModelForMaskedLM extends PretrainedMixin {
      static MODEL_CLASS_MAPPINGS = [MODEL_FOR_MASKED_LM_MAPPING_NAMES];
    }

    class AutoModelForQuestionAnswering extends PretrainedMixin {
      static MODEL_CLASS_MAPPINGS = [MODEL_FOR_QUESTION_ANSWERING_MAPPING_NAMES];
    }

    class AutoModelForVision2Seq extends PretrainedMixin {
      static MODEL_CLASS_MAPPINGS = [MODEL_FOR_VISION_2_SEQ_MAPPING_NAMES];
    }

    class AutoModelForImageClassification extends PretrainedMixin {
      static MODEL_CLASS_MAPPINGS = [MODEL_FOR_IMAGE_CLASSIFICATION_MAPPING_NAMES];
    }

    class AutoModelForImageSegmentation extends PretrainedMixin {
      static MODEL_CLASS_MAPPINGS = [MODEL_FOR_IMAGE_SEGMENTATION_MAPPING_NAMES];
    }

    class AutoModelForSemanticSegmentation extends PretrainedMixin {
      static MODEL_CLASS_MAPPINGS = [MODEL_FOR_SEMANTIC_SEGMENTATION_MAPPING_NAMES];
    }

    class AutoModelForUniversalSegmentation extends PretrainedMixin {
      static MODEL_CLASS_MAPPINGS = [MODEL_FOR_UNIVERSAL_SEGMENTATION_MAPPING_NAMES];
    }

    class AutoModelForObjectDetection extends PretrainedMixin {
      static MODEL_CLASS_MAPPINGS = [MODEL_FOR_OBJECT_DETECTION_MAPPING_NAMES];
    }

    class AutoModelForZeroShotObjectDetection extends PretrainedMixin {
      static MODEL_CLASS_MAPPINGS = [MODEL_FOR_ZERO_SHOT_OBJECT_DETECTION_MAPPING_NAMES];
    }

    class AutoModelForMaskGeneration extends PretrainedMixin {
      static MODEL_CLASS_MAPPINGS = [MODEL_FOR_MASK_GENERATION_MAPPING_NAMES];
    }

    class AutoModelForCTC extends PretrainedMixin {
      static MODEL_CLASS_MAPPINGS = [MODEL_FOR_CTC_MAPPING_NAMES];
    }

    class AutoModelForAudioClassification extends PretrainedMixin {
      static MODEL_CLASS_MAPPINGS = [MODEL_FOR_AUDIO_CLASSIFICATION_MAPPING_NAMES];
    }

    class AutoModelForXVector extends PretrainedMixin {
      static MODEL_CLASS_MAPPINGS = [MODEL_FOR_AUDIO_XVECTOR_MAPPING_NAMES];
    }

    class AutoModelForAudioFrameClassification extends PretrainedMixin {
      static MODEL_CLASS_MAPPINGS = [MODEL_FOR_AUDIO_FRAME_CLASSIFICATION_MAPPING_NAMES];
    }

    class AutoModelForDocumentQuestionAnswering extends PretrainedMixin {
      static MODEL_CLASS_MAPPINGS = [MODEL_FOR_DOCUMENT_QUESTION_ANSWERING_MAPPING_NAMES];
    }

    class AutoModelForImageMatting extends PretrainedMixin {
      static MODEL_CLASS_MAPPINGS = [MODEL_FOR_IMAGE_MATTING_MAPPING_NAMES];
    }

    class AutoModelForImageToImage extends PretrainedMixin {
      static MODEL_CLASS_MAPPINGS = [MODEL_FOR_IMAGE_TO_IMAGE_MAPPING_NAMES];
    }

    class AutoModelForDepthEstimation extends PretrainedMixin {
      static MODEL_CLASS_MAPPINGS = [MODEL_FOR_DEPTH_ESTIMATION_MAPPING_NAMES];
    }

    class AutoModelForNormalEstimation extends PretrainedMixin {
      static MODEL_CLASS_MAPPINGS = [MODEL_FOR_NORMAL_ESTIMATION_MAPPING_NAMES];
    }

    class AutoModelForPoseEstimation extends PretrainedMixin {
      static MODEL_CLASS_MAPPINGS = [MODEL_FOR_POSE_ESTIMATION_MAPPING_NAMES];
    }

    class AutoModelForImageFeatureExtraction extends PretrainedMixin {
      static MODEL_CLASS_MAPPINGS = [MODEL_FOR_IMAGE_FEATURE_EXTRACTION_MAPPING_NAMES];
    }

    class AutoModelForImageTextToText extends PretrainedMixin {
      static MODEL_CLASS_MAPPINGS = [MODEL_FOR_IMAGE_TEXT_TO_TEXT_MAPPING_NAMES];
    }

    class AutoModelForAudioTextToText extends PretrainedMixin {
      static MODEL_CLASS_MAPPINGS = [MODEL_FOR_AUDIO_TEXT_TO_TEXT_MAPPING_NAMES];
    }

    class Seq2SeqLMOutput extends ModelOutput {
      constructor({ logits, past_key_values, encoder_outputs, decoder_attentions = null, cross_attentions = null }) {
        super();
        this.logits = logits;
        this.past_key_values = past_key_values;
        this.encoder_outputs = encoder_outputs;
        this.decoder_attentions = decoder_attentions;
        this.cross_attentions = cross_attentions;
      }
    }

    class SequenceClassifierOutput extends ModelOutput {
      constructor({ logits, ...attentions }) {
        super();
        this.logits = logits;
        const attentions_list = Object.values(attentions);
        if (attentions_list.length > 0) {
          this.attentions = attentions_list;
        }
      }
    }

    class XVectorOutput extends ModelOutput {
      constructor({ logits, embeddings }) {
        super();
        this.logits = logits;
        this.embeddings = embeddings;
      }
    }

    class TokenClassifierOutput extends ModelOutput {
      constructor({ logits }) {
        super();
        this.logits = logits;
      }
    }

    class MaskedLMOutput extends ModelOutput {
      constructor({ logits }) {
        super();
        this.logits = logits;
      }
    }

    class QuestionAnsweringModelOutput extends ModelOutput {
      constructor({ start_logits, end_logits }) {
        super();
        this.start_logits = start_logits;
        this.end_logits = end_logits;
      }
    }

    class CausalLMOutput extends ModelOutput {
      constructor({ logits }) {
        super();
        this.logits = logits;
      }
    }

    class CausalLMOutputWithPast extends ModelOutput {
      constructor({ logits, past_key_values }) {
        super();
        this.logits = logits;
        this.past_key_values = past_key_values;
      }
    }

    class ImageMattingOutput extends ModelOutput {
      constructor({ alphas }) {
        super();
        this.alphas = alphas;
      }
    }

    class VitsModelOutput extends ModelOutput {
      constructor({ waveform, spectrogram }) {
        super();
        this.waveform = waveform;
        this.spectrogram = spectrogram;
      }
    }
  },
  "./src/models/audio_spectrogram_transformer/feature_extraction_audio_spectrogram_transformer.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!******************************************************************************************************!*\
      !*** ./src/models/audio_spectrogram_transformer/feature_extraction_audio_spectrogram_transformer.js ***!
      \******************************************************************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      ASTFeatureExtractor: () => ASTFeatureExtractor
    });
    var _base_feature_extraction_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/feature_extraction_utils.js");
    /*! ../../base/feature_extraction_utils.js */
    var _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/utils/tensor.js");
    /*! ../../utils/tensor.js */
    var _utils_audio_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/utils/audio.js");
    /*! ../../utils/audio.js */

    class ASTFeatureExtractor extends _base_feature_extraction_utils_js__WEBPACK_IMPORTED_MODULE_0__.FeatureExtractor {
      constructor(config3) {
        super(config3);
        const sampling_rate = this.config.sampling_rate;
        const mel_filters = (0, _utils_audio_js__WEBPACK_IMPORTED_MODULE_2__.mel_filter_bank)(257, this.config.num_mel_bins, 20, Math.floor(sampling_rate / 2), sampling_rate, null, "kaldi", true);
        this.mel_filters = mel_filters;
        this.window = (0, _utils_audio_js__WEBPACK_IMPORTED_MODULE_2__.window_function)(400, "hann", {
          periodic: false
        });
        this.mean = this.config.mean;
        this.std = this.config.std;
      }
      async _extract_fbank_features(waveform, max_length) {
        return (0, _utils_audio_js__WEBPACK_IMPORTED_MODULE_2__.spectrogram)(waveform, this.window, 400, 160, {
          fft_length: 512,
          power: 2,
          center: false,
          preemphasis: 0.97,
          mel_filters: this.mel_filters,
          log_mel: "log",
          mel_floor: 0.0000001192092955078125,
          remove_dc_offset: true,
          max_num_frames: max_length,
          transpose: true
        });
      }
      async _call(audio) {
        (0, _base_feature_extraction_utils_js__WEBPACK_IMPORTED_MODULE_0__.validate_audio_inputs)(audio, "ASTFeatureExtractor");
        const features = await this._extract_fbank_features(audio, this.config.max_length);
        if (this.config.do_normalize) {
          const denom = this.std * 2;
          const features_data = features.data;
          for (let i = 0;i < features_data.length; ++i) {
            features_data[i] = (features_data[i] - this.mean) / denom;
          }
        }
        return {
          input_values: features.unsqueeze_(0)
        };
      }
    }
  },
  "./src/models/auto/feature_extraction_auto.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!****************************************************!*\
      !*** ./src/models/auto/feature_extraction_auto.js ***!
      \****************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      AutoFeatureExtractor: () => AutoFeatureExtractor
    });
    var _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/utils/constants.js");
    /*! ../../utils/constants.js */
    var _utils_hub_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/utils/hub.js");
    /*! ../../utils/hub.js */
    var _base_feature_extraction_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/base/feature_extraction_utils.js");
    /*! ../../base/feature_extraction_utils.js */
    var _feature_extractors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/models/feature_extractors.js");
    /*! ../feature_extractors.js */

    class AutoFeatureExtractor {
      static async from_pretrained(pretrained_model_name_or_path, options2 = {}) {
        const preprocessorConfig = await (0, _utils_hub_js__WEBPACK_IMPORTED_MODULE_1__.getModelJSON)(pretrained_model_name_or_path, _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.FEATURE_EXTRACTOR_NAME, true, options2);
        const key = preprocessorConfig.feature_extractor_type;
        const feature_extractor_class = _feature_extractors_js__WEBPACK_IMPORTED_MODULE_3__[key];
        if (!feature_extractor_class) {
          throw new Error(`Unknown feature_extractor_type: '${key}'. Please report this at ${_utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.GITHUB_ISSUE_URL}.`);
        }
        return new feature_extractor_class(preprocessorConfig);
      }
    }
  },
  "./src/models/auto/image_processing_auto.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!**************************************************!*\
      !*** ./src/models/auto/image_processing_auto.js ***!
      \**************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      AutoImageProcessor: () => AutoImageProcessor
    });
    var _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/utils/constants.js");
    /*! ../../utils/constants.js */
    var _utils_hub_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/utils/hub.js");
    /*! ../../utils/hub.js */
    var _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/base/image_processors_utils.js");
    /*! ../../base/image_processors_utils.js */
    var _image_processors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/models/image_processors.js");
    /*! ../image_processors.js */

    class AutoImageProcessor {
      static async from_pretrained(pretrained_model_name_or_path, options2 = {}) {
        const preprocessorConfig = await (0, _utils_hub_js__WEBPACK_IMPORTED_MODULE_1__.getModelJSON)(pretrained_model_name_or_path, _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.IMAGE_PROCESSOR_NAME, true, options2);
        const key = preprocessorConfig.image_processor_type ?? preprocessorConfig.feature_extractor_type;
        let image_processor_class = _image_processors_js__WEBPACK_IMPORTED_MODULE_3__[key?.replace(/Fast$/, "")];
        if (!image_processor_class) {
          if (key !== undefined) {
            console.warn(`Image processor type '${key}' not found, assuming base ImageProcessor. Please report this at ${_utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.GITHUB_ISSUE_URL}.`);
          }
          image_processor_class = _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_2__.ImageProcessor;
        }
        return new image_processor_class(preprocessorConfig);
      }
    }
  },
  "./src/models/auto/processing_auto.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!********************************************!*\
      !*** ./src/models/auto/processing_auto.js ***!
      \********************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      AutoProcessor: () => AutoProcessor
    });
    var _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/utils/constants.js");
    /*! ../../utils/constants.js */
    var _utils_hub_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/utils/hub.js");
    /*! ../../utils/hub.js */
    var _base_processing_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/base/processing_utils.js");
    /*! ../../base/processing_utils.js */
    var _processors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/models/processors.js");
    /*! ../processors.js */
    var _image_processors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./src/models/image_processors.js");
    /*! ../image_processors.js */
    var _feature_extractors_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./src/models/feature_extractors.js");
    /*! ../feature_extractors.js */

    class AutoProcessor {
      static async from_pretrained(pretrained_model_name_or_path, options2 = {}) {
        const preprocessorConfig = await (0, _utils_hub_js__WEBPACK_IMPORTED_MODULE_1__.getModelJSON)(pretrained_model_name_or_path, _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__.IMAGE_PROCESSOR_NAME, true, options2);
        const { image_processor_type, feature_extractor_type, processor_class } = preprocessorConfig;
        if (processor_class && _processors_js__WEBPACK_IMPORTED_MODULE_3__[processor_class]) {
          return _processors_js__WEBPACK_IMPORTED_MODULE_3__[processor_class].from_pretrained(pretrained_model_name_or_path, options2);
        }
        if (!image_processor_type && !feature_extractor_type) {
          throw new Error("No `image_processor_type` or `feature_extractor_type` found in the config.");
        }
        const components = {};
        if (image_processor_type) {
          const image_processor_class = _image_processors_js__WEBPACK_IMPORTED_MODULE_4__[image_processor_type.replace(/Fast$/, "")];
          if (!image_processor_class) {
            throw new Error(`Unknown image_processor_type: '${image_processor_type}'.`);
          }
          components.image_processor = new image_processor_class(preprocessorConfig);
        }
        if (feature_extractor_type) {
          const image_processor_class = _image_processors_js__WEBPACK_IMPORTED_MODULE_4__[feature_extractor_type];
          if (image_processor_class) {
            components.image_processor = new image_processor_class(preprocessorConfig);
          } else {
            const feature_extractor_class = _feature_extractors_js__WEBPACK_IMPORTED_MODULE_5__[feature_extractor_type];
            if (!feature_extractor_class) {
              throw new Error(`Unknown feature_extractor_type: '${feature_extractor_type}'.`);
            }
            components.feature_extractor = new feature_extractor_class(preprocessorConfig);
          }
        }
        const config3 = {};
        return new _base_processing_utils_js__WEBPACK_IMPORTED_MODULE_2__.Processor(config3, components, null);
      }
    }
  },
  "./src/models/beit/image_processing_beit.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!**************************************************!*\
      !*** ./src/models/beit/image_processing_beit.js ***!
      \**************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      BeitFeatureExtractor: () => BeitFeatureExtractor
    });
    var _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/image_processors_utils.js");
    /*! ../../base/image_processors_utils.js */

    class BeitFeatureExtractor extends _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__.ImageProcessor {
    }
  },
  "./src/models/bit/image_processing_bit.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!************************************************!*\
      !*** ./src/models/bit/image_processing_bit.js ***!
      \************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      BitImageProcessor: () => BitImageProcessor
    });
    var _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/image_processors_utils.js");
    /*! ../../base/image_processors_utils.js */

    class BitImageProcessor extends _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__.ImageProcessor {
    }
  },
  "./src/models/chinese_clip/image_processing_chinese_clip.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!******************************************************************!*\
      !*** ./src/models/chinese_clip/image_processing_chinese_clip.js ***!
      \******************************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      ChineseCLIPFeatureExtractor: () => ChineseCLIPFeatureExtractor
    });
    var _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/image_processors_utils.js");
    /*! ../../base/image_processors_utils.js */

    class ChineseCLIPFeatureExtractor extends _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__.ImageProcessor {
    }
  },
  "./src/models/clap/feature_extraction_clap.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!****************************************************!*\
      !*** ./src/models/clap/feature_extraction_clap.js ***!
      \****************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      ClapFeatureExtractor: () => ClapFeatureExtractor
    });
    var _base_feature_extraction_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/feature_extraction_utils.js");
    /*! ../../base/feature_extraction_utils.js */
    var _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/utils/tensor.js");
    /*! ../../utils/tensor.js */
    var _utils_audio_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/utils/audio.js");
    /*! ../../utils/audio.js */

    class ClapFeatureExtractor extends _base_feature_extraction_utils_js__WEBPACK_IMPORTED_MODULE_0__.FeatureExtractor {
      constructor(config3) {
        super(config3);
        this.mel_filters = (0, _utils_audio_js__WEBPACK_IMPORTED_MODULE_2__.mel_filter_bank)(this.config.nb_frequency_bins, this.config.feature_size, this.config.frequency_min, this.config.frequency_max, this.config.sampling_rate, null, "htk");
        this.mel_filters_slaney = (0, _utils_audio_js__WEBPACK_IMPORTED_MODULE_2__.mel_filter_bank)(this.config.nb_frequency_bins, this.config.feature_size, this.config.frequency_min, this.config.frequency_max, this.config.sampling_rate, "slaney", "slaney");
        this.window = (0, _utils_audio_js__WEBPACK_IMPORTED_MODULE_2__.window_function)(this.config.fft_window_size, "hann");
      }
      async _get_input_mel(waveform, max_length, truncation, padding) {
        let input_mel;
        let longer = false;
        const diff = waveform.length - max_length;
        if (diff > 0) {
          if (truncation === "rand_trunc") {
            longer = true;
            const idx = Math.floor(Math.random() * (diff + 1));
            waveform = waveform.subarray(idx, idx + max_length);
            input_mel = await this._extract_fbank_features(waveform, this.mel_filters_slaney, this.config.nb_max_samples);
          } else {
            throw new Error(`Truncation strategy "${truncation}" not implemented`);
          }
        } else {
          if (diff < 0) {
            let padded = new Float64Array(max_length);
            padded.set(waveform);
            if (padding === "repeat") {
              for (let i = waveform.length;i < max_length; i += waveform.length) {
                padded.set(waveform.subarray(0, Math.min(waveform.length, max_length - i)), i);
              }
            } else if (padding === "repeatpad") {
              for (let i = waveform.length;i < -diff; i += waveform.length) {
                padded.set(waveform, i);
              }
            }
            waveform = padded;
          }
          if (truncation === "fusion") {
            throw new Error(`Truncation strategy "${truncation}" not implemented`);
          }
          input_mel = await this._extract_fbank_features(waveform, this.mel_filters_slaney, this.config.nb_max_samples);
        }
        return input_mel.unsqueeze_(0);
      }
      async _extract_fbank_features(waveform, mel_filters, max_length = null) {
        return (0, _utils_audio_js__WEBPACK_IMPORTED_MODULE_2__.spectrogram)(waveform, this.window, this.config.fft_window_size, this.config.hop_length, {
          power: 2,
          mel_filters,
          log_mel: "dB",
          max_num_frames: max_length,
          do_pad: false,
          transpose: true
        });
      }
      async _call(audio, {
        max_length = null
      } = {}) {
        (0, _base_feature_extraction_utils_js__WEBPACK_IMPORTED_MODULE_0__.validate_audio_inputs)(audio, "ClapFeatureExtractor");
        const padded_inputs = await this._get_input_mel(audio, max_length ?? this.config.nb_max_samples, this.config.truncation, this.config.padding);
        return {
          input_features: padded_inputs.unsqueeze_(0)
        };
      }
    }
  },
  "./src/models/clip/image_processing_clip.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!**************************************************!*\
      !*** ./src/models/clip/image_processing_clip.js ***!
      \**************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      CLIPFeatureExtractor: () => CLIPFeatureExtractor,
      CLIPImageProcessor: () => CLIPImageProcessor
    });
    var _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/image_processors_utils.js");
    /*! ../../base/image_processors_utils.js */

    class CLIPImageProcessor extends _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__.ImageProcessor {
    }

    class CLIPFeatureExtractor extends CLIPImageProcessor {
    }
  },
  "./src/models/convnext/image_processing_convnext.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!**********************************************************!*\
      !*** ./src/models/convnext/image_processing_convnext.js ***!
      \**********************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      ConvNextFeatureExtractor: () => ConvNextFeatureExtractor,
      ConvNextImageProcessor: () => ConvNextImageProcessor
    });
    var _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/image_processors_utils.js");
    /*! ../../base/image_processors_utils.js */

    class ConvNextImageProcessor extends _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__.ImageProcessor {
      constructor(config3) {
        super(config3);
        this.crop_pct = this.config.crop_pct ?? 224 / 256;
      }
      async resize(image) {
        const shortest_edge = this.size?.shortest_edge;
        if (shortest_edge === undefined) {
          throw new Error(`Size dictionary must contain 'shortest_edge' key.`);
        }
        if (shortest_edge < 384) {
          const resize_shortest_edge = Math.floor(shortest_edge / this.crop_pct);
          const [newWidth, newHeight] = this.get_resize_output_image_size(image, {
            shortest_edge: resize_shortest_edge
          });
          image = await image.resize(newWidth, newHeight, {
            resample: this.resample
          });
          image = await image.center_crop(shortest_edge, shortest_edge);
        } else {
          image = await image.resize(shortest_edge, shortest_edge, {
            resample: this.resample
          });
        }
        return image;
      }
    }

    class ConvNextFeatureExtractor extends ConvNextImageProcessor {
    }
  },
  "./src/models/dac/feature_extraction_dac.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!**************************************************!*\
      !*** ./src/models/dac/feature_extraction_dac.js ***!
      \**************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      DacFeatureExtractor: () => DacFeatureExtractor
    });
    var _encodec_feature_extraction_encodec_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/models/encodec/feature_extraction_encodec.js");
    /*! ../encodec/feature_extraction_encodec.js */

    class DacFeatureExtractor extends _encodec_feature_extraction_encodec_js__WEBPACK_IMPORTED_MODULE_0__.EncodecFeatureExtractor {
    }
  },
  "./src/models/deit/image_processing_deit.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!**************************************************!*\
      !*** ./src/models/deit/image_processing_deit.js ***!
      \**************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      DeiTFeatureExtractor: () => DeiTFeatureExtractor,
      DeiTImageProcessor: () => DeiTImageProcessor
    });
    var _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/image_processors_utils.js");
    /*! ../../base/image_processors_utils.js */

    class DeiTImageProcessor extends _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__.ImageProcessor {
    }

    class DeiTFeatureExtractor extends DeiTImageProcessor {
    }
  },
  "./src/models/detr/image_processing_detr.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!**************************************************!*\
      !*** ./src/models/detr/image_processing_detr.js ***!
      \**************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      DetrFeatureExtractor: () => DetrFeatureExtractor,
      DetrImageProcessor: () => DetrImageProcessor
    });
    var _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/image_processors_utils.js");
    /*! ../../base/image_processors_utils.js */
    var _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/utils/tensor.js");
    /*! ../../utils/tensor.js */

    class DetrImageProcessor extends _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__.ImageProcessor {
      async _call(images) {
        const result = await super._call(images);
        const maskSize = [result.pixel_values.dims[0], 64, 64];
        const pixel_mask = (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__.full)(maskSize, 1n);
        return { ...result, pixel_mask };
      }
      post_process_object_detection(...args) {
        return (0, _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__.post_process_object_detection)(...args);
      }
      post_process_panoptic_segmentation(...args) {
        return (0, _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__.post_process_panoptic_segmentation)(...args);
      }
      post_process_instance_segmentation(...args) {
        return (0, _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__.post_process_instance_segmentation)(...args);
      }
    }

    class DetrFeatureExtractor extends DetrImageProcessor {
    }
  },
  "./src/models/dinov3_vit/image_processing_dinov3_vit.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!**************************************************************!*\
      !*** ./src/models/dinov3_vit/image_processing_dinov3_vit.js ***!
      \**************************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      DINOv3ViTImageProcessor: () => DINOv3ViTImageProcessor
    });
    var _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/image_processors_utils.js");
    /*! ../../base/image_processors_utils.js */

    class DINOv3ViTImageProcessor extends _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__.ImageProcessor {
    }
  },
  "./src/models/donut/image_processing_donut.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!****************************************************!*\
      !*** ./src/models/donut/image_processing_donut.js ***!
      \****************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      DonutFeatureExtractor: () => DonutFeatureExtractor,
      DonutImageProcessor: () => DonutImageProcessor
    });
    var _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/image_processors_utils.js");
    /*! ../../base/image_processors_utils.js */

    class DonutImageProcessor extends _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__.ImageProcessor {
      pad_image(pixelData, imgDims, padSize, options2 = {}) {
        const [imageHeight, imageWidth, imageChannels] = imgDims;
        let image_mean = this.image_mean;
        if (!Array.isArray(this.image_mean)) {
          image_mean = new Array(imageChannels).fill(image_mean);
        }
        let image_std = this.image_std;
        if (!Array.isArray(image_std)) {
          image_std = new Array(imageChannels).fill(image_mean);
        }
        const constant_values = image_mean.map((x, i) => -x / image_std[i]);
        return super.pad_image(pixelData, imgDims, padSize, {
          center: true,
          constant_values,
          ...options2
        });
      }
    }

    class DonutFeatureExtractor extends DonutImageProcessor {
    }
  },
  "./src/models/dpt/image_processing_dpt.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!************************************************!*\
      !*** ./src/models/dpt/image_processing_dpt.js ***!
      \************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      DPTFeatureExtractor: () => DPTFeatureExtractor,
      DPTImageProcessor: () => DPTImageProcessor
    });
    var _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/image_processors_utils.js");
    /*! ../../base/image_processors_utils.js */

    class DPTImageProcessor extends _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__.ImageProcessor {
    }

    class DPTFeatureExtractor extends DPTImageProcessor {
    }
  },
  "./src/models/efficientnet/image_processing_efficientnet.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!******************************************************************!*\
      !*** ./src/models/efficientnet/image_processing_efficientnet.js ***!
      \******************************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      EfficientNetImageProcessor: () => EfficientNetImageProcessor
    });
    var _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/image_processors_utils.js");
    /*! ../../base/image_processors_utils.js */

    class EfficientNetImageProcessor extends _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__.ImageProcessor {
      constructor(config3) {
        super(config3);
        this.include_top = this.config.include_top ?? true;
        if (this.include_top) {
          this.image_std = this.image_std.map((x) => x * x);
        }
      }
    }
  },
  "./src/models/encodec/feature_extraction_encodec.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!**********************************************************!*\
      !*** ./src/models/encodec/feature_extraction_encodec.js ***!
      \**********************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      EncodecFeatureExtractor: () => EncodecFeatureExtractor
    });
    var _base_feature_extraction_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/feature_extraction_utils.js");
    /*! ../../base/feature_extraction_utils.js */
    var _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/utils/tensor.js");
    /*! ../../utils/tensor.js */

    class EncodecFeatureExtractor extends _base_feature_extraction_utils_js__WEBPACK_IMPORTED_MODULE_0__.FeatureExtractor {
      async _call(audio) {
        (0, _base_feature_extraction_utils_js__WEBPACK_IMPORTED_MODULE_0__.validate_audio_inputs)(audio, "EncodecFeatureExtractor");
        if (audio instanceof Float64Array) {
          audio = new Float32Array(audio);
        }
        const num_channels = this.config.feature_size;
        if (audio.length % num_channels !== 0) {
          throw new Error(`The length of the audio data must be a multiple of the number of channels (${num_channels}).`);
        }
        const shape = [
          1,
          num_channels,
          audio.length / num_channels
        ];
        return {
          input_values: new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__.Tensor("float32", audio, shape)
        };
      }
    }
  },
  "./src/models/feature_extractors.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!******************************************!*\
      !*** ./src/models/feature_extractors.js ***!
      \******************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      ASTFeatureExtractor: () => _audio_spectrogram_transformer_feature_extraction_audio_spectrogram_transformer_js__WEBPACK_IMPORTED_MODULE_0__.ASTFeatureExtractor,
      ClapFeatureExtractor: () => _clap_feature_extraction_clap_js__WEBPACK_IMPORTED_MODULE_2__.ClapFeatureExtractor,
      DacFeatureExtractor: () => _dac_feature_extraction_dac_js__WEBPACK_IMPORTED_MODULE_3__.DacFeatureExtractor,
      EncodecFeatureExtractor: () => _encodec_feature_extraction_encodec_js__WEBPACK_IMPORTED_MODULE_1__.EncodecFeatureExtractor,
      Gemma3nAudioFeatureExtractor: () => _gemma3n_feature_extraction_gemma3n_js__WEBPACK_IMPORTED_MODULE_4__.Gemma3nAudioFeatureExtractor,
      ImageFeatureExtractor: () => _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_14__.ImageProcessor,
      MoonshineFeatureExtractor: () => _moonshine_feature_extraction_moonshine_js__WEBPACK_IMPORTED_MODULE_5__.MoonshineFeatureExtractor,
      ParakeetFeatureExtractor: () => _parakeet_feature_extraction_parakeet_js__WEBPACK_IMPORTED_MODULE_6__.ParakeetFeatureExtractor,
      PyAnnoteFeatureExtractor: () => _pyannote_feature_extraction_pyannote_js__WEBPACK_IMPORTED_MODULE_7__.PyAnnoteFeatureExtractor,
      SeamlessM4TFeatureExtractor: () => _seamless_m4t_feature_extraction_seamless_m4t_js__WEBPACK_IMPORTED_MODULE_8__.SeamlessM4TFeatureExtractor,
      SnacFeatureExtractor: () => _snac_feature_extraction_snac_js__WEBPACK_IMPORTED_MODULE_9__.SnacFeatureExtractor,
      SpeechT5FeatureExtractor: () => _speecht5_feature_extraction_speecht5_js__WEBPACK_IMPORTED_MODULE_10__.SpeechT5FeatureExtractor,
      Wav2Vec2FeatureExtractor: () => _wav2vec2_feature_extraction_wav2vec2_js__WEBPACK_IMPORTED_MODULE_11__.Wav2Vec2FeatureExtractor,
      WeSpeakerFeatureExtractor: () => _wespeaker_feature_extraction_wespeaker_js__WEBPACK_IMPORTED_MODULE_12__.WeSpeakerFeatureExtractor,
      WhisperFeatureExtractor: () => _whisper_feature_extraction_whisper_js__WEBPACK_IMPORTED_MODULE_13__.WhisperFeatureExtractor
    });
    var _audio_spectrogram_transformer_feature_extraction_audio_spectrogram_transformer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/models/audio_spectrogram_transformer/feature_extraction_audio_spectrogram_transformer.js");
    /*! ./audio_spectrogram_transformer/feature_extraction_audio_spectrogram_transformer.js */
    var _encodec_feature_extraction_encodec_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/models/encodec/feature_extraction_encodec.js");
    /*! ./encodec/feature_extraction_encodec.js */
    var _clap_feature_extraction_clap_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/models/clap/feature_extraction_clap.js");
    /*! ./clap/feature_extraction_clap.js */
    var _dac_feature_extraction_dac_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/models/dac/feature_extraction_dac.js");
    /*! ./dac/feature_extraction_dac.js */
    var _gemma3n_feature_extraction_gemma3n_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./src/models/gemma3n/feature_extraction_gemma3n.js");
    /*! ./gemma3n/feature_extraction_gemma3n.js */
    var _moonshine_feature_extraction_moonshine_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./src/models/moonshine/feature_extraction_moonshine.js");
    /*! ./moonshine/feature_extraction_moonshine.js */
    var _parakeet_feature_extraction_parakeet_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./src/models/parakeet/feature_extraction_parakeet.js");
    /*! ./parakeet/feature_extraction_parakeet.js */
    var _pyannote_feature_extraction_pyannote_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./src/models/pyannote/feature_extraction_pyannote.js");
    /*! ./pyannote/feature_extraction_pyannote.js */
    var _seamless_m4t_feature_extraction_seamless_m4t_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./src/models/seamless_m4t/feature_extraction_seamless_m4t.js");
    /*! ./seamless_m4t/feature_extraction_seamless_m4t.js */
    var _snac_feature_extraction_snac_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./src/models/snac/feature_extraction_snac.js");
    /*! ./snac/feature_extraction_snac.js */
    var _speecht5_feature_extraction_speecht5_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./src/models/speecht5/feature_extraction_speecht5.js");
    /*! ./speecht5/feature_extraction_speecht5.js */
    var _wav2vec2_feature_extraction_wav2vec2_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./src/models/wav2vec2/feature_extraction_wav2vec2.js");
    /*! ./wav2vec2/feature_extraction_wav2vec2.js */
    var _wespeaker_feature_extraction_wespeaker_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./src/models/wespeaker/feature_extraction_wespeaker.js");
    /*! ./wespeaker/feature_extraction_wespeaker.js */
    var _whisper_feature_extraction_whisper_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./src/models/whisper/feature_extraction_whisper.js");
    /*! ./whisper/feature_extraction_whisper.js */
    var _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("./src/base/image_processors_utils.js");
    /*! ../base/image_processors_utils.js */
  },
  "./src/models/florence2/processing_florence2.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!******************************************************!*\
      !*** ./src/models/florence2/processing_florence2.js ***!
      \******************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      Florence2Processor: () => Florence2Processor
    });
    var _base_processing_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/processing_utils.js");
    /*! ../../base/processing_utils.js */
    var _auto_image_processing_auto_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/models/auto/image_processing_auto.js");
    /*! ../auto/image_processing_auto.js */
    var _tokenizers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/tokenizers.js");
    /*! ../../tokenizers.js */

    class Florence2Processor extends _base_processing_utils_js__WEBPACK_IMPORTED_MODULE_0__.Processor {
      static tokenizer_class = _tokenizers_js__WEBPACK_IMPORTED_MODULE_2__.AutoTokenizer;
      static image_processor_class = _auto_image_processing_auto_js__WEBPACK_IMPORTED_MODULE_1__.AutoImageProcessor;
      constructor(config3, components, chat_template) {
        super(config3, components, chat_template);
        const {
          tasks_answer_post_processing_type,
          task_prompts_without_inputs,
          task_prompts_with_input
        } = this.image_processor.config;
        this.tasks_answer_post_processing_type = new Map(Object.entries(tasks_answer_post_processing_type ?? {}));
        this.task_prompts_without_inputs = new Map(Object.entries(task_prompts_without_inputs ?? {}));
        this.task_prompts_with_input = new Map(Object.entries(task_prompts_with_input ?? {}));
        this.regexes = {
          quad_boxes: /(.+?)<loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)>/gm,
          bboxes: /([^<]+)?<loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)>/gm
        };
        this.size_per_bin = 1000;
      }
      construct_prompts(text) {
        if (typeof text === "string") {
          text = [text];
        }
        const prompts = [];
        for (const t of text) {
          if (this.task_prompts_without_inputs.has(t)) {
            prompts.push(this.task_prompts_without_inputs.get(t));
          } else {
            for (const [task, prompt] of this.task_prompts_with_input) {
              if (t.includes(task)) {
                prompts.push(prompt.replaceAll("{input}", t).replaceAll(task, ""));
                break;
              }
            }
            if (prompts.length !== text.length) {
              prompts.push(t);
            }
          }
        }
        return prompts;
      }
      post_process_generation(text, task, image_size) {
        const task_answer_post_processing_type = this.tasks_answer_post_processing_type.get(task) ?? "pure_text";
        text = text.replaceAll("<s>", "").replaceAll("</s>", "");
        let final_answer;
        switch (task_answer_post_processing_type) {
          case "pure_text":
            final_answer = text;
            break;
          case "description_with_bboxes":
          case "bboxes":
          case "phrase_grounding":
          case "ocr":
            const key = task_answer_post_processing_type === "ocr" ? "quad_boxes" : "bboxes";
            const matches = text.matchAll(this.regexes[key]);
            const labels = [];
            const items = [];
            for (const [_, label, ...locations] of matches) {
              labels.push(label ? label.trim() : labels.at(-1) ?? "");
              items.push(locations.map((x, i) => (Number(x) + 0.5) / this.size_per_bin * image_size[i % 2]));
            }
            final_answer = { labels, [key]: items };
            break;
          default:
            throw new Error(`Task "${task}" (of type "${task_answer_post_processing_type}") not yet implemented.`);
        }
        return { [task]: final_answer };
      }
      async _call(images, text = null, kwargs = {}) {
        if (!images && !text) {
          throw new Error("Either text or images must be provided");
        }
        const image_inputs = await this.image_processor(images, kwargs);
        const text_inputs = text ? this.tokenizer(this.construct_prompts(text), kwargs) : {};
        return {
          ...image_inputs,
          ...text_inputs
        };
      }
    }
  },
  "./src/models/gemma3n/feature_extraction_gemma3n.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!**********************************************************!*\
      !*** ./src/models/gemma3n/feature_extraction_gemma3n.js ***!
      \**********************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      Gemma3nAudioFeatureExtractor: () => Gemma3nAudioFeatureExtractor
    });
    var _base_feature_extraction_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/feature_extraction_utils.js");
    /*! ../../base/feature_extraction_utils.js */
    var _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/utils/tensor.js");
    /*! ../../utils/tensor.js */
    var _utils_audio_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/utils/audio.js");
    /*! ../../utils/audio.js */

    class Gemma3nAudioFeatureExtractor extends _base_feature_extraction_utils_js__WEBPACK_IMPORTED_MODULE_0__.FeatureExtractor {
      constructor(config3) {
        super(config3);
        const {
          fft_length,
          feature_size,
          min_frequency,
          max_frequency,
          sampling_rate,
          frame_length
        } = this.config;
        const mel_filters = (0, _utils_audio_js__WEBPACK_IMPORTED_MODULE_2__.mel_filter_bank)(Math.floor(1 + fft_length / 2), feature_size, min_frequency, max_frequency, sampling_rate, null, "htk", false);
        this.mel_filters = mel_filters;
        this.window = (0, _utils_audio_js__WEBPACK_IMPORTED_MODULE_2__.window_function)(frame_length, "hann");
      }
      async _extract_fbank_features(waveform, max_length) {
        return (0, _utils_audio_js__WEBPACK_IMPORTED_MODULE_2__.spectrogram)(waveform, this.window, this.config.frame_length, this.config.hop_length, {
          fft_length: this.config.fft_length,
          center: false,
          onesided: true,
          preemphasis: this.config.preemphasis,
          preemphasis_htk_flavor: this.config.preemphasis_htk_flavor,
          mel_filters: this.mel_filters,
          log_mel: "log",
          mel_floor: this.config.mel_floor,
          remove_dc_offset: false,
          transpose: true
        });
      }
      async _call(audio, {
        max_length = 480000,
        truncation = true,
        padding = true,
        pad_to_multiple_of = 128
      } = {}) {
        (0, _base_feature_extraction_utils_js__WEBPACK_IMPORTED_MODULE_0__.validate_audio_inputs)(audio, "Gemma3nAudioFeatureExtractor");
        if (truncation && audio.length > max_length) {
          audio = audio.slice(0, max_length);
        }
        if (padding && audio.length % pad_to_multiple_of !== 0) {
          const padding_length = pad_to_multiple_of - audio.length % pad_to_multiple_of;
          const padded_audio = new Float64Array(audio.length + padding_length);
          padded_audio.set(audio);
          if (this.config.padding_value !== 0) {
            padded_audio.fill(this.config.padding_value, audio.length);
          }
          audio = padded_audio;
        }
        const features = await this._extract_fbank_features(audio, this.config.max_length);
        const padded_attention_mask = (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__.full)([1, features.dims[0]], true);
        return {
          input_features: features.unsqueeze_(0),
          input_features_mask: padded_attention_mask
        };
      }
    }
  },
  "./src/models/gemma3n/processing_gemma3n.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!**************************************************!*\
      !*** ./src/models/gemma3n/processing_gemma3n.js ***!
      \**************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      Gemma3nProcessor: () => Gemma3nProcessor
    });
    var _base_processing_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/processing_utils.js");
    /*! ../../base/processing_utils.js */
    var _auto_image_processing_auto_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/models/auto/image_processing_auto.js");
    /*! ../auto/image_processing_auto.js */
    var _auto_feature_extraction_auto_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/models/auto/feature_extraction_auto.js");
    /*! ../auto/feature_extraction_auto.js */
    var _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/tokenizers.js");
    /*! ../../tokenizers.js */
    var _utils_image_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./src/utils/image.js");
    /*! ../../utils/image.js */
    var _utils_audio_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./src/utils/audio.js");
    /*! ../../utils/audio.js */

    class Gemma3nProcessor extends _base_processing_utils_js__WEBPACK_IMPORTED_MODULE_0__.Processor {
      static image_processor_class = _auto_image_processing_auto_js__WEBPACK_IMPORTED_MODULE_1__.AutoImageProcessor;
      static feature_extractor_class = _auto_feature_extraction_auto_js__WEBPACK_IMPORTED_MODULE_2__.AutoFeatureExtractor;
      static tokenizer_class = _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.AutoTokenizer;
      static uses_processor_config = true;
      static uses_chat_template_file = true;
      constructor(config3, components, chat_template) {
        super(config3, components, chat_template);
        this.audio_seq_length = this.config.audio_seq_length;
        this.image_seq_length = this.config.image_seq_length;
        const {
          audio_token_id,
          boa_token,
          audio_token,
          eoa_token,
          image_token_id,
          boi_token,
          image_token,
          eoi_token
        } = this.tokenizer.config;
        this.audio_token_id = audio_token_id;
        this.boa_token = boa_token;
        this.audio_token = audio_token;
        const audio_tokens_expanded = audio_token.repeat(this.audio_seq_length);
        this.full_audio_sequence = `

${boa_token}${audio_tokens_expanded}${eoa_token}

`;
        this.image_token_id = image_token_id;
        this.boi_token = boi_token;
        this.image_token = image_token;
        const image_tokens_expanded = image_token.repeat(this.image_seq_length);
        this.full_image_sequence = `

${boi_token}${image_tokens_expanded}${eoi_token}

`;
      }
      async _call(text, images = null, audio = null, options2 = {}) {
        if (typeof text === "string") {
          text = [text];
        }
        let audio_inputs;
        if (audio) {
          audio_inputs = await this.feature_extractor(audio, options2);
          text = text.map((prompt) => prompt.replaceAll(this.audio_token, this.full_audio_sequence));
        }
        let image_inputs;
        if (images) {
          image_inputs = await this.image_processor(images, options2);
          text = text.map((prompt) => prompt.replaceAll(this.image_token, this.full_image_sequence));
        }
        let text_inputs = this.tokenizer(text, options2);
        return {
          ...text_inputs,
          ...image_inputs,
          ...audio_inputs
        };
      }
    }
  },
  "./src/models/glpn/image_processing_glpn.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!**************************************************!*\
      !*** ./src/models/glpn/image_processing_glpn.js ***!
      \**************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      GLPNFeatureExtractor: () => GLPNFeatureExtractor
    });
    var _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/image_processors_utils.js");
    /*! ../../base/image_processors_utils.js */

    class GLPNFeatureExtractor extends _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__.ImageProcessor {
    }
  },
  "./src/models/grounding_dino/image_processing_grounding_dino.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!**********************************************************************!*\
      !*** ./src/models/grounding_dino/image_processing_grounding_dino.js ***!
      \**********************************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      GroundingDinoImageProcessor: () => GroundingDinoImageProcessor
    });
    var _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/image_processors_utils.js");
    /*! ../../base/image_processors_utils.js */
    var _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/utils/tensor.js");
    /*! ../../utils/tensor.js */

    class GroundingDinoImageProcessor extends _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__.ImageProcessor {
      async _call(images) {
        const result = await super._call(images);
        const dims = result.pixel_values.dims;
        const pixel_mask = (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__.ones)([dims[0], dims[2], dims[3]]);
        return { ...result, pixel_mask };
      }
    }
  },
  "./src/models/grounding_dino/processing_grounding_dino.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!****************************************************************!*\
      !*** ./src/models/grounding_dino/processing_grounding_dino.js ***!
      \****************************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      GroundingDinoProcessor: () => GroundingDinoProcessor
    });
    var _base_processing_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/processing_utils.js");
    /*! ../../base/processing_utils.js */
    var _auto_image_processing_auto_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/models/auto/image_processing_auto.js");
    /*! ../auto/image_processing_auto.js */
    var _tokenizers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/tokenizers.js");
    /*! ../../tokenizers.js */
    var _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/base/image_processors_utils.js");
    /*! ../../base/image_processors_utils.js */
    function get_phrases_from_posmap(posmaps, input_ids) {
      const left_idx = 0;
      const right_idx = posmaps.dims.at(-1) - 1;
      const posmaps_list = posmaps.tolist();
      posmaps_list.fill(false, 0, left_idx + 1);
      posmaps_list.fill(false, right_idx);
      const input_ids_list = input_ids.tolist();
      return posmaps_list.map((val, idx) => val ? idx : null).filter((idx) => idx !== null).map((i) => input_ids_list[i]);
    }

    class GroundingDinoProcessor extends _base_processing_utils_js__WEBPACK_IMPORTED_MODULE_0__.Processor {
      static tokenizer_class = _tokenizers_js__WEBPACK_IMPORTED_MODULE_2__.AutoTokenizer;
      static image_processor_class = _auto_image_processing_auto_js__WEBPACK_IMPORTED_MODULE_1__.AutoImageProcessor;
      async _call(images, text, options2 = {}) {
        const image_inputs = images ? await this.image_processor(images, options2) : {};
        const text_inputs = text ? this.tokenizer(text, options2) : {};
        return {
          ...text_inputs,
          ...image_inputs
        };
      }
      post_process_grounded_object_detection(outputs, input_ids, {
        box_threshold = 0.25,
        text_threshold = 0.25,
        target_sizes = null
      } = {}) {
        const { logits, pred_boxes } = outputs;
        const batch_size = logits.dims[0];
        if (target_sizes !== null && target_sizes.length !== batch_size) {
          throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");
        }
        const num_queries = logits.dims.at(1);
        const probs = logits.sigmoid();
        const scores = probs.max(-1).tolist();
        const boxes = pred_boxes.tolist().map((batch) => batch.map((box) => (0, _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_3__.center_to_corners_format)(box)));
        const results = [];
        for (let i = 0;i < batch_size; ++i) {
          const target_size = target_sizes !== null ? target_sizes[i] : null;
          if (target_size !== null) {
            boxes[i] = boxes[i].map((box) => box.map((x, j) => x * target_size[(j + 1) % 2]));
          }
          const batch_scores = scores[i];
          const final_scores = [];
          const final_phrases = [];
          const final_boxes = [];
          for (let j = 0;j < num_queries; ++j) {
            const score = batch_scores[j];
            if (score <= box_threshold) {
              continue;
            }
            const box = boxes[i][j];
            const prob = probs[i][j];
            final_scores.push(score);
            final_boxes.push(box);
            const phrases = get_phrases_from_posmap(prob.gt(text_threshold), input_ids[i]);
            final_phrases.push(phrases);
          }
          results.push({ scores: final_scores, boxes: final_boxes, labels: this.batch_decode(final_phrases) });
        }
        return results;
      }
    }
  },
  "./src/models/idefics3/image_processing_idefics3.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!**********************************************************!*\
      !*** ./src/models/idefics3/image_processing_idefics3.js ***!
      \**********************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      Idefics3ImageProcessor: () => Idefics3ImageProcessor
    });
    var _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/image_processors_utils.js");
    /*! ../../base/image_processors_utils.js */
    var _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/utils/tensor.js");
    /*! ../../utils/tensor.js */

    class Idefics3ImageProcessor extends _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__.ImageProcessor {
      constructor(config3) {
        super(config3);
        this.do_image_splitting = config3.do_image_splitting ?? true;
        this.max_image_size = config3.max_image_size;
      }
      get_resize_for_vision_encoder(pixel_values, vision_encoder_max_size) {
        let [height, width] = pixel_values.dims.slice(-2);
        const aspect_ratio = width / height;
        if (width >= height) {
          width = Math.ceil(width / vision_encoder_max_size) * vision_encoder_max_size;
          height = Math.floor(width / aspect_ratio);
          height = Math.ceil(height / vision_encoder_max_size) * vision_encoder_max_size;
        } else {
          height = Math.ceil(height / vision_encoder_max_size) * vision_encoder_max_size;
          width = Math.floor(height * aspect_ratio);
          width = Math.ceil(width / vision_encoder_max_size) * vision_encoder_max_size;
        }
        return { height, width };
      }
      async _call(images, {
        do_image_splitting = null,
        return_row_col_info = false
      } = {}) {
        let batched_2d_images;
        if (!Array.isArray(images)) {
          batched_2d_images = [[images]];
        } else {
          if (images.length === 0 || !images[0]) {
            throw new Error("No images provided.");
          }
          if (!Array.isArray(images[0])) {
            batched_2d_images = [images];
          } else {
            batched_2d_images = images;
          }
        }
        let all_pixel_values = [];
        let images_list_rows = [];
        let images_list_cols = [];
        const original_sizes = [];
        const reshaped_input_sizes = [];
        for (const image_batch of batched_2d_images) {
          let images_list = await Promise.all(image_batch.map((x) => this.preprocess(x)));
          original_sizes.push(...images_list.map((x) => x.original_size));
          reshaped_input_sizes.push(...images_list.map((x) => x.reshaped_input_size));
          images_list.forEach((x) => x.pixel_values.unsqueeze_(0));
          const { longest_edge } = this.max_image_size;
          let images_tensor;
          if (do_image_splitting ?? this.do_image_splitting) {
            let image_rows = new Array(images_list.length);
            let image_cols = new Array(images_list.length);
            images_tensor = await Promise.all(images_list.map(async (x, i) => {
              const new_size = this.get_resize_for_vision_encoder(x.pixel_values, longest_edge);
              const resized = await (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__.interpolate_4d)(x.pixel_values, {
                size: [new_size.height, new_size.width]
              });
              const { frames, num_splits_h, num_splits_w } = await this.split_image(resized, this.max_image_size);
              image_rows[i] = num_splits_h;
              image_cols[i] = num_splits_w;
              return (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__.cat)(frames, 0);
            }));
            images_list_rows.push(image_rows);
            images_list_cols.push(image_cols);
          } else {
            const size = [longest_edge, longest_edge];
            images_tensor = await Promise.all(images_list.map((x) => (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__.interpolate_4d)(x.pixel_values, { size })));
            images_list_rows.push(new Array(images_list.length).fill(0));
            images_list_cols.push(new Array(images_list.length).fill(0));
          }
          all_pixel_values.push((0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__.cat)(images_tensor, 0));
        }
        const batch_size = all_pixel_values.length;
        const [n, c, h, w] = all_pixel_values[0].dims;
        let pixel_values;
        let pixel_attention_mask;
        if (batch_size === 1) {
          pixel_values = all_pixel_values[0].unsqueeze_(0);
          pixel_attention_mask = (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__.full)([batch_size, n, h, w], true);
        } else {
          const max_num_patches = Math.max(...all_pixel_values.map((x) => x.dims.at(0)));
          pixel_attention_mask = (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__.full)([batch_size, max_num_patches, h, w], true);
          const pixel_attention_mask_data = pixel_attention_mask.data;
          const pixel_attention_mask_stride = max_num_patches * h * w;
          for (let i = 0;i < batch_size; ++i) {
            const num_patches = all_pixel_values[i].dims[0];
            if (num_patches < max_num_patches) {
              all_pixel_values[i] = (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__.cat)([
                all_pixel_values[i],
                (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__.full)([max_num_patches - num_patches, c, h, w], 0)
              ], 0);
              const start_offset = i * pixel_attention_mask_stride + num_patches * h * w;
              const end_offset = (i + 1) * pixel_attention_mask_stride;
              pixel_attention_mask_data.fill(false, start_offset, end_offset);
            }
          }
          pixel_values = (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__.stack)(all_pixel_values, 0);
        }
        return {
          pixel_values,
          pixel_attention_mask,
          original_sizes,
          reshaped_input_sizes,
          ...return_row_col_info ? { rows: images_list_rows, cols: images_list_cols } : {}
        };
      }
      async split_image(pixel_values, { longest_edge }) {
        const max_height = longest_edge;
        const max_width = longest_edge;
        const frames = [];
        const [height, width] = pixel_values.dims.slice(-2);
        let num_splits_h = 0, num_splits_w = 0;
        if (height > max_height || width > max_width) {
          num_splits_h = Math.ceil(height / max_height);
          num_splits_w = Math.ceil(width / max_width);
          const optimal_height = Math.ceil(height / num_splits_h);
          const optimal_width = Math.ceil(width / num_splits_w);
          for (let r = 0;r < num_splits_h; ++r) {
            for (let c = 0;c < num_splits_w; ++c) {
              let start_x, start_y, end_x, end_y;
              if (r === num_splits_h - 1) {
                start_y = height - optimal_height;
                end_y = height;
              } else {
                start_y = r * optimal_height;
                end_y = (r + 1) * optimal_height;
              }
              if (c === num_splits_w - 1) {
                start_x = width - optimal_width;
                end_x = width;
              } else {
                start_x = c * optimal_width;
                end_x = (c + 1) * optimal_width;
              }
              const starts = [start_y, start_x];
              const ends = [end_y, end_x];
              const patch = await (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__.slice)(pixel_values, starts, ends, [2, 3]);
              frames.push(patch);
            }
          }
          const global_image_height = max_height;
          const global_image_width = max_width;
          if (height !== global_image_height || width !== global_image_width) {
            pixel_values = await (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__.interpolate_4d)(pixel_values, {
              size: [global_image_height, global_image_width]
            });
          }
        }
        frames.push(pixel_values);
        return { frames, num_splits_h, num_splits_w };
      }
    }
  },
  "./src/models/idefics3/processing_idefics3.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!****************************************************!*\
      !*** ./src/models/idefics3/processing_idefics3.js ***!
      \****************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      Idefics3Processor: () => Idefics3Processor
    });
    var _base_processing_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/processing_utils.js");
    /*! ../../base/processing_utils.js */
    var _auto_image_processing_auto_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/models/auto/image_processing_auto.js");
    /*! ../auto/image_processing_auto.js */
    var _tokenizers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/tokenizers.js");
    /*! ../../tokenizers.js */
    var _utils_image_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/utils/image.js");
    /*! ../../utils/image.js */
    var _utils_core_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./src/utils/core.js");
    /*! ../../utils/core.js */
    function _prompt_split_image(image_seq_len, image_rows, image_cols, fake_token_around_image, image_token, global_img_token) {
      let text_split_images = "";
      for (let n_h = 0;n_h < image_rows; ++n_h) {
        for (let n_w = 0;n_w < image_cols; ++n_w) {
          text_split_images += fake_token_around_image + `<row_${n_h + 1}_col_${n_w + 1}>` + image_token.repeat(image_seq_len);
        }
        text_split_images += `
`;
      }
      text_split_images += `
${fake_token_around_image}` + `${global_img_token}` + image_token.repeat(image_seq_len) + `${fake_token_around_image}`;
      return text_split_images;
    }
    function _prompt_single_image(image_seq_len, fake_token_around_image, image_token, global_img_token) {
      return `${fake_token_around_image}` + `${global_img_token}` + image_token.repeat(image_seq_len) + `${fake_token_around_image}`;
    }
    function get_image_prompt_string(image_rows, image_cols, image_seq_len, fake_token_around_image, image_token, global_img_token) {
      if (image_rows === 0 && image_cols === 0) {
        return _prompt_single_image(image_seq_len, fake_token_around_image, image_token, global_img_token);
      }
      return _prompt_split_image(image_seq_len, image_rows, image_cols, fake_token_around_image, image_token, global_img_token);
    }

    class Idefics3Processor extends _base_processing_utils_js__WEBPACK_IMPORTED_MODULE_0__.Processor {
      static image_processor_class = _auto_image_processing_auto_js__WEBPACK_IMPORTED_MODULE_1__.AutoImageProcessor;
      static tokenizer_class = _tokenizers_js__WEBPACK_IMPORTED_MODULE_2__.AutoTokenizer;
      static uses_processor_config = true;
      fake_image_token = "<fake_token_around_image>";
      image_token = "<image>";
      global_img_token = "<global-img>";
      async _call(text, images = null, options2 = {}) {
        options2.return_row_col_info ??= true;
        let image_inputs;
        if (images) {
          image_inputs = await this.image_processor(images, options2);
        }
        if (!Array.isArray(text)) {
          text = [text];
        }
        const image_rows = image_inputs.rows ?? [new Array(text.length).fill(0)];
        const image_cols = image_inputs.cols ?? [new Array(text.length).fill(0)];
        const image_seq_len = this.config.image_seq_len;
        const n_images_in_text = [];
        const prompt_strings = [];
        for (let i = 0;i < text.length; ++i) {
          const sample = text[i];
          const sample_rows = image_rows[i];
          const sample_cols = image_cols[i];
          n_images_in_text.push((0, _utils_core_js__WEBPACK_IMPORTED_MODULE_4__.count)(sample, this.image_token));
          const image_prompt_strings = sample_rows.map((n_rows, j) => get_image_prompt_string(n_rows, sample_cols[j], image_seq_len, this.fake_image_token, this.image_token, this.global_img_token));
          const split_sample = sample.split(this.image_token);
          if (split_sample.length === 0) {
            throw new Error("The image token should be present in the text.");
          }
          let new_sample = split_sample[0];
          for (let j = 0;j < image_prompt_strings.length; ++j) {
            new_sample += image_prompt_strings[j] + split_sample[j + 1];
          }
          prompt_strings.push(new_sample);
        }
        const text_inputs = this.tokenizer(prompt_strings);
        return {
          ...text_inputs,
          ...image_inputs
        };
      }
    }
  },
  "./src/models/image_processors.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!****************************************!*\
      !*** ./src/models/image_processors.js ***!
      \****************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      BeitFeatureExtractor: () => _beit_image_processing_beit_js__WEBPACK_IMPORTED_MODULE_0__.BeitFeatureExtractor,
      BitImageProcessor: () => _bit_image_processing_bit_js__WEBPACK_IMPORTED_MODULE_1__.BitImageProcessor,
      CLIPFeatureExtractor: () => _clip_image_processing_clip_js__WEBPACK_IMPORTED_MODULE_3__.CLIPFeatureExtractor,
      CLIPImageProcessor: () => _clip_image_processing_clip_js__WEBPACK_IMPORTED_MODULE_3__.CLIPImageProcessor,
      ChineseCLIPFeatureExtractor: () => _chinese_clip_image_processing_chinese_clip_js__WEBPACK_IMPORTED_MODULE_2__.ChineseCLIPFeatureExtractor,
      ConvNextFeatureExtractor: () => _convnext_image_processing_convnext_js__WEBPACK_IMPORTED_MODULE_4__.ConvNextFeatureExtractor,
      ConvNextImageProcessor: () => _convnext_image_processing_convnext_js__WEBPACK_IMPORTED_MODULE_4__.ConvNextImageProcessor,
      DINOv3ViTImageProcessor: () => _dinov3_vit_image_processing_dinov3_vit_js__WEBPACK_IMPORTED_MODULE_7__.DINOv3ViTImageProcessor,
      DPTFeatureExtractor: () => _dpt_image_processing_dpt_js__WEBPACK_IMPORTED_MODULE_9__.DPTFeatureExtractor,
      DPTImageProcessor: () => _dpt_image_processing_dpt_js__WEBPACK_IMPORTED_MODULE_9__.DPTImageProcessor,
      DeiTFeatureExtractor: () => _deit_image_processing_deit_js__WEBPACK_IMPORTED_MODULE_5__.DeiTFeatureExtractor,
      DeiTImageProcessor: () => _deit_image_processing_deit_js__WEBPACK_IMPORTED_MODULE_5__.DeiTImageProcessor,
      DetrFeatureExtractor: () => _detr_image_processing_detr_js__WEBPACK_IMPORTED_MODULE_6__.DetrFeatureExtractor,
      DetrImageProcessor: () => _detr_image_processing_detr_js__WEBPACK_IMPORTED_MODULE_6__.DetrImageProcessor,
      DonutFeatureExtractor: () => _donut_image_processing_donut_js__WEBPACK_IMPORTED_MODULE_8__.DonutFeatureExtractor,
      DonutImageProcessor: () => _donut_image_processing_donut_js__WEBPACK_IMPORTED_MODULE_8__.DonutImageProcessor,
      EfficientNetImageProcessor: () => _efficientnet_image_processing_efficientnet_js__WEBPACK_IMPORTED_MODULE_10__.EfficientNetImageProcessor,
      GLPNFeatureExtractor: () => _glpn_image_processing_glpn_js__WEBPACK_IMPORTED_MODULE_11__.GLPNFeatureExtractor,
      GroundingDinoImageProcessor: () => _grounding_dino_image_processing_grounding_dino_js__WEBPACK_IMPORTED_MODULE_12__.GroundingDinoImageProcessor,
      Idefics3ImageProcessor: () => _idefics3_image_processing_idefics3_js__WEBPACK_IMPORTED_MODULE_13__.Idefics3ImageProcessor,
      JinaCLIPImageProcessor: () => _jina_clip_image_processing_jina_clip_js__WEBPACK_IMPORTED_MODULE_15__.JinaCLIPImageProcessor,
      LlavaOnevisionImageProcessor: () => _llava_onevision_image_processing_llava_onevision_js__WEBPACK_IMPORTED_MODULE_16__.LlavaOnevisionImageProcessor,
      Mask2FormerImageProcessor: () => _mask2former_image_processing_mask2former_js__WEBPACK_IMPORTED_MODULE_17__.Mask2FormerImageProcessor,
      MaskFormerFeatureExtractor: () => _maskformer_image_processing_maskformer_js__WEBPACK_IMPORTED_MODULE_18__.MaskFormerFeatureExtractor,
      MaskFormerImageProcessor: () => _maskformer_image_processing_maskformer_js__WEBPACK_IMPORTED_MODULE_18__.MaskFormerImageProcessor,
      MobileNetV1FeatureExtractor: () => _mobilenet_v1_image_processing_mobilenet_v1_js__WEBPACK_IMPORTED_MODULE_19__.MobileNetV1FeatureExtractor,
      MobileNetV1ImageProcessor: () => _mobilenet_v1_image_processing_mobilenet_v1_js__WEBPACK_IMPORTED_MODULE_19__.MobileNetV1ImageProcessor,
      MobileNetV2FeatureExtractor: () => _mobilenet_v2_image_processing_mobilenet_v2_js__WEBPACK_IMPORTED_MODULE_20__.MobileNetV2FeatureExtractor,
      MobileNetV2ImageProcessor: () => _mobilenet_v2_image_processing_mobilenet_v2_js__WEBPACK_IMPORTED_MODULE_20__.MobileNetV2ImageProcessor,
      MobileNetV3FeatureExtractor: () => _mobilenet_v3_image_processing_mobilenet_v3_js__WEBPACK_IMPORTED_MODULE_21__.MobileNetV3FeatureExtractor,
      MobileNetV3ImageProcessor: () => _mobilenet_v3_image_processing_mobilenet_v3_js__WEBPACK_IMPORTED_MODULE_21__.MobileNetV3ImageProcessor,
      MobileNetV4FeatureExtractor: () => _mobilenet_v4_image_processing_mobilenet_v4_js__WEBPACK_IMPORTED_MODULE_22__.MobileNetV4FeatureExtractor,
      MobileNetV4ImageProcessor: () => _mobilenet_v4_image_processing_mobilenet_v4_js__WEBPACK_IMPORTED_MODULE_22__.MobileNetV4ImageProcessor,
      MobileViTFeatureExtractor: () => _mobilevit_image_processing_mobilevit_js__WEBPACK_IMPORTED_MODULE_23__.MobileViTFeatureExtractor,
      MobileViTImageProcessor: () => _mobilevit_image_processing_mobilevit_js__WEBPACK_IMPORTED_MODULE_23__.MobileViTImageProcessor,
      NougatImageProcessor: () => _nougat_image_processing_nougat_js__WEBPACK_IMPORTED_MODULE_24__.NougatImageProcessor,
      OwlViTFeatureExtractor: () => _owlvit_image_processing_owlvit_js__WEBPACK_IMPORTED_MODULE_26__.OwlViTFeatureExtractor,
      OwlViTImageProcessor: () => _owlvit_image_processing_owlvit_js__WEBPACK_IMPORTED_MODULE_26__.OwlViTImageProcessor,
      Owlv2ImageProcessor: () => _owlv2_image_processing_owlv2_js__WEBPACK_IMPORTED_MODULE_25__.Owlv2ImageProcessor,
      Phi3VImageProcessor: () => _phi3_v_image_processing_phi3_v_js__WEBPACK_IMPORTED_MODULE_27__.Phi3VImageProcessor,
      PixtralImageProcessor: () => _pixtral_image_processing_pixtral_js__WEBPACK_IMPORTED_MODULE_28__.PixtralImageProcessor,
      PvtImageProcessor: () => _pvt_image_processing_pvt_js__WEBPACK_IMPORTED_MODULE_29__.PvtImageProcessor,
      Qwen2VLImageProcessor: () => _qwen2_vl_image_processing_qwen2_vl_js__WEBPACK_IMPORTED_MODULE_30__.Qwen2VLImageProcessor,
      RTDetrImageProcessor: () => _rt_detr_image_processing_rt_detr_js__WEBPACK_IMPORTED_MODULE_31__.RTDetrImageProcessor,
      Sam2ImageProcessor: () => _sam2_image_processing_sam2_js__WEBPACK_IMPORTED_MODULE_33__.Sam2ImageProcessor,
      Sam3ImageProcessor: () => _sam3_image_processing_sam3_js__WEBPACK_IMPORTED_MODULE_34__.Sam3ImageProcessor,
      SamImageProcessor: () => _sam_image_processing_sam_js__WEBPACK_IMPORTED_MODULE_32__.SamImageProcessor,
      SegformerFeatureExtractor: () => _segformer_image_processing_segformer_js__WEBPACK_IMPORTED_MODULE_35__.SegformerFeatureExtractor,
      SegformerImageProcessor: () => _segformer_image_processing_segformer_js__WEBPACK_IMPORTED_MODULE_35__.SegformerImageProcessor,
      SiglipImageProcessor: () => _siglip_image_processing_siglip_js__WEBPACK_IMPORTED_MODULE_36__.SiglipImageProcessor,
      SmolVLMImageProcessor: () => _smolvlm_image_processing_smolvlm_js__WEBPACK_IMPORTED_MODULE_37__.SmolVLMImageProcessor,
      Swin2SRImageProcessor: () => _swin2sr_image_processing_swin2sr_js__WEBPACK_IMPORTED_MODULE_38__.Swin2SRImageProcessor,
      VLMImageProcessor: () => _janus_image_processing_janus_js__WEBPACK_IMPORTED_MODULE_14__.VLMImageProcessor,
      ViTFeatureExtractor: () => _vit_image_processing_vit_js__WEBPACK_IMPORTED_MODULE_39__.ViTFeatureExtractor,
      ViTImageProcessor: () => _vit_image_processing_vit_js__WEBPACK_IMPORTED_MODULE_39__.ViTImageProcessor,
      VitMatteImageProcessor: () => _vitmatte_image_processing_vitmatte_js__WEBPACK_IMPORTED_MODULE_40__.VitMatteImageProcessor,
      VitPoseImageProcessor: () => _vitpose_image_processing_vitpose_js__WEBPACK_IMPORTED_MODULE_41__.VitPoseImageProcessor,
      YolosFeatureExtractor: () => _yolos_image_processing_yolos_js__WEBPACK_IMPORTED_MODULE_42__.YolosFeatureExtractor,
      YolosImageProcessor: () => _yolos_image_processing_yolos_js__WEBPACK_IMPORTED_MODULE_42__.YolosImageProcessor
    });
    var _beit_image_processing_beit_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/models/beit/image_processing_beit.js");
    /*! ./beit/image_processing_beit.js */
    var _bit_image_processing_bit_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/models/bit/image_processing_bit.js");
    /*! ./bit/image_processing_bit.js */
    var _chinese_clip_image_processing_chinese_clip_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/models/chinese_clip/image_processing_chinese_clip.js");
    /*! ./chinese_clip/image_processing_chinese_clip.js */
    var _clip_image_processing_clip_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/models/clip/image_processing_clip.js");
    /*! ./clip/image_processing_clip.js */
    var _convnext_image_processing_convnext_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./src/models/convnext/image_processing_convnext.js");
    /*! ./convnext/image_processing_convnext.js */
    var _deit_image_processing_deit_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./src/models/deit/image_processing_deit.js");
    /*! ./deit/image_processing_deit.js */
    var _detr_image_processing_detr_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./src/models/detr/image_processing_detr.js");
    /*! ./detr/image_processing_detr.js */
    var _dinov3_vit_image_processing_dinov3_vit_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./src/models/dinov3_vit/image_processing_dinov3_vit.js");
    /*! ./dinov3_vit/image_processing_dinov3_vit.js */
    var _donut_image_processing_donut_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./src/models/donut/image_processing_donut.js");
    /*! ./donut/image_processing_donut.js */
    var _dpt_image_processing_dpt_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./src/models/dpt/image_processing_dpt.js");
    /*! ./dpt/image_processing_dpt.js */
    var _efficientnet_image_processing_efficientnet_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./src/models/efficientnet/image_processing_efficientnet.js");
    /*! ./efficientnet/image_processing_efficientnet.js */
    var _glpn_image_processing_glpn_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./src/models/glpn/image_processing_glpn.js");
    /*! ./glpn/image_processing_glpn.js */
    var _grounding_dino_image_processing_grounding_dino_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./src/models/grounding_dino/image_processing_grounding_dino.js");
    /*! ./grounding_dino/image_processing_grounding_dino.js */
    var _idefics3_image_processing_idefics3_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./src/models/idefics3/image_processing_idefics3.js");
    /*! ./idefics3/image_processing_idefics3.js */
    var _janus_image_processing_janus_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("./src/models/janus/image_processing_janus.js");
    /*! ./janus/image_processing_janus.js */
    var _jina_clip_image_processing_jina_clip_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__("./src/models/jina_clip/image_processing_jina_clip.js");
    /*! ./jina_clip/image_processing_jina_clip.js */
    var _llava_onevision_image_processing_llava_onevision_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__("./src/models/llava_onevision/image_processing_llava_onevision.js");
    /*! ./llava_onevision/image_processing_llava_onevision.js */
    var _mask2former_image_processing_mask2former_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__("./src/models/mask2former/image_processing_mask2former.js");
    /*! ./mask2former/image_processing_mask2former.js */
    var _maskformer_image_processing_maskformer_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__("./src/models/maskformer/image_processing_maskformer.js");
    /*! ./maskformer/image_processing_maskformer.js */
    var _mobilenet_v1_image_processing_mobilenet_v1_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__("./src/models/mobilenet_v1/image_processing_mobilenet_v1.js");
    /*! ./mobilenet_v1/image_processing_mobilenet_v1.js */
    var _mobilenet_v2_image_processing_mobilenet_v2_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__("./src/models/mobilenet_v2/image_processing_mobilenet_v2.js");
    /*! ./mobilenet_v2/image_processing_mobilenet_v2.js */
    var _mobilenet_v3_image_processing_mobilenet_v3_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__("./src/models/mobilenet_v3/image_processing_mobilenet_v3.js");
    /*! ./mobilenet_v3/image_processing_mobilenet_v3.js */
    var _mobilenet_v4_image_processing_mobilenet_v4_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__("./src/models/mobilenet_v4/image_processing_mobilenet_v4.js");
    /*! ./mobilenet_v4/image_processing_mobilenet_v4.js */
    var _mobilevit_image_processing_mobilevit_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__("./src/models/mobilevit/image_processing_mobilevit.js");
    /*! ./mobilevit/image_processing_mobilevit.js */
    var _nougat_image_processing_nougat_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__("./src/models/nougat/image_processing_nougat.js");
    /*! ./nougat/image_processing_nougat.js */
    var _owlv2_image_processing_owlv2_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__("./src/models/owlv2/image_processing_owlv2.js");
    /*! ./owlv2/image_processing_owlv2.js */
    var _owlvit_image_processing_owlvit_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__("./src/models/owlvit/image_processing_owlvit.js");
    /*! ./owlvit/image_processing_owlvit.js */
    var _phi3_v_image_processing_phi3_v_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__("./src/models/phi3_v/image_processing_phi3_v.js");
    /*! ./phi3_v/image_processing_phi3_v.js */
    var _pixtral_image_processing_pixtral_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__("./src/models/pixtral/image_processing_pixtral.js");
    /*! ./pixtral/image_processing_pixtral.js */
    var _pvt_image_processing_pvt_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__("./src/models/pvt/image_processing_pvt.js");
    /*! ./pvt/image_processing_pvt.js */
    var _qwen2_vl_image_processing_qwen2_vl_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__("./src/models/qwen2_vl/image_processing_qwen2_vl.js");
    /*! ./qwen2_vl/image_processing_qwen2_vl.js */
    var _rt_detr_image_processing_rt_detr_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__("./src/models/rt_detr/image_processing_rt_detr.js");
    /*! ./rt_detr/image_processing_rt_detr.js */
    var _sam_image_processing_sam_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__("./src/models/sam/image_processing_sam.js");
    /*! ./sam/image_processing_sam.js */
    var _sam2_image_processing_sam2_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__("./src/models/sam2/image_processing_sam2.js");
    /*! ./sam2/image_processing_sam2.js */
    var _sam3_image_processing_sam3_js__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__("./src/models/sam3/image_processing_sam3.js");
    /*! ./sam3/image_processing_sam3.js */
    var _segformer_image_processing_segformer_js__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__("./src/models/segformer/image_processing_segformer.js");
    /*! ./segformer/image_processing_segformer.js */
    var _siglip_image_processing_siglip_js__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__("./src/models/siglip/image_processing_siglip.js");
    /*! ./siglip/image_processing_siglip.js */
    var _smolvlm_image_processing_smolvlm_js__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__("./src/models/smolvlm/image_processing_smolvlm.js");
    /*! ./smolvlm/image_processing_smolvlm.js */
    var _swin2sr_image_processing_swin2sr_js__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__("./src/models/swin2sr/image_processing_swin2sr.js");
    /*! ./swin2sr/image_processing_swin2sr.js */
    var _vit_image_processing_vit_js__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__("./src/models/vit/image_processing_vit.js");
    /*! ./vit/image_processing_vit.js */
    var _vitmatte_image_processing_vitmatte_js__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__("./src/models/vitmatte/image_processing_vitmatte.js");
    /*! ./vitmatte/image_processing_vitmatte.js */
    var _vitpose_image_processing_vitpose_js__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__("./src/models/vitpose/image_processing_vitpose.js");
    /*! ./vitpose/image_processing_vitpose.js */
    var _yolos_image_processing_yolos_js__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__("./src/models/yolos/image_processing_yolos.js");
    /*! ./yolos/image_processing_yolos.js */
  },
  "./src/models/janus/image_processing_janus.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!****************************************************!*\
      !*** ./src/models/janus/image_processing_janus.js ***!
      \****************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      VLMImageProcessor: () => VLMImageProcessor
    });
    var _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/image_processors_utils.js");
    /*! ../../base/image_processors_utils.js */

    class VLMImageProcessor extends _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__.ImageProcessor {
      constructor(config3) {
        super({
          do_pad: true,
          pad_size: {
            width: config3.image_size,
            height: config3.image_size
          },
          ...config3
        });
        this.constant_values = this.config.background_color.map((x) => x * this.rescale_factor);
      }
      pad_image(pixelData, imgDims, padSize, options2) {
        return super.pad_image(pixelData, imgDims, padSize, {
          constant_values: this.constant_values,
          center: true,
          ...options2
        });
      }
    }
  },
  "./src/models/janus/processing_janus.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!**********************************************!*\
      !*** ./src/models/janus/processing_janus.js ***!
      \**********************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      VLChatProcessor: () => VLChatProcessor
    });
    var _base_processing_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/processing_utils.js");
    /*! ../../base/processing_utils.js */
    var _auto_image_processing_auto_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/models/auto/image_processing_auto.js");
    /*! ../auto/image_processing_auto.js */
    var _tokenizers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/tokenizers.js");
    /*! ../../tokenizers.js */
    var _utils_core_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/utils/core.js");
    /*! ../../utils/core.js */
    var _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./src/utils/tensor.js");
    /*! ../../utils/tensor.js */
    var _utils_image_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./src/utils/image.js");
    /*! ../../utils/image.js */

    class VLChatProcessor extends _base_processing_utils_js__WEBPACK_IMPORTED_MODULE_0__.Processor {
      static image_processor_class = _auto_image_processing_auto_js__WEBPACK_IMPORTED_MODULE_1__.AutoImageProcessor;
      static tokenizer_class = _tokenizers_js__WEBPACK_IMPORTED_MODULE_2__.AutoTokenizer;
      static uses_processor_config = true;
      constructor(config3, components, chat_template) {
        super(config3, components, chat_template);
        this.image_tag = this.config.image_tag;
        this.image_start_tag = this.config.image_start_tag;
        this.image_end_tag = this.config.image_end_tag;
        this.num_image_tokens = this.config.num_image_tokens;
      }
      async _call(conversation, {
        images = null,
        chat_template = "default"
      } = {}) {
        if (!images) {
          images = await Promise.all(conversation.filter((msg) => msg.images).flatMap((msg) => msg.images).map((img) => _utils_image_js__WEBPACK_IMPORTED_MODULE_5__.RawImage.read(img)));
        } else if (!Array.isArray(images)) {
          images = [images];
        }
        const tokenizer = this.tokenizer;
        const result = tokenizer.apply_chat_template(conversation, {
          tokenize: false,
          add_generation_prompt: true,
          chat_template
        });
        const encode3 = (text) => tokenizer.encode(text, { add_special_tokens: false });
        const parts = result.split(this.image_tag);
        const num_images = parts.length - 1;
        if (images.length !== num_images) {
          throw new Error(`Number of images provided (${images.length}) does not match number of "${this.image_tag}" image tags (${num_images})`);
        }
        const [
          image_placeholder_tag_id,
          image_start_tag_id,
          image_end_tag_id
        ] = tokenizer.model.convert_tokens_to_ids([
          this.image_tag,
          this.image_start_tag,
          this.image_end_tag
        ]);
        let input_ids = encode3(parts[0]);
        let images_seq_mask = new Array(input_ids.length).fill(false);
        for (let i = 1;i < parts.length; ++i) {
          const placeholder_image_tokens = new Array(this.num_image_tokens).fill(image_placeholder_tag_id);
          const tokens = encode3(parts[i]);
          input_ids = (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_3__.mergeArrays)(input_ids, [image_start_tag_id], placeholder_image_tokens, [image_end_tag_id], tokens);
          const image_mask = new Array(this.num_image_tokens).fill(true);
          images_seq_mask = (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_3__.mergeArrays)(images_seq_mask, [false], image_mask, [false], new Array(tokens.length).fill(false));
        }
        const dims = [1, input_ids.length];
        const final = {
          input_ids: new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor("int64", input_ids, dims),
          attention_mask: new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor("int64", new Array(input_ids.length).fill(1), dims),
          images_seq_mask: new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor("bool", images_seq_mask, dims),
          images_emb_mask: new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor("bool", new Array(num_images * this.num_image_tokens).fill(true), [1, num_images, this.num_image_tokens])
        };
        if (images && images.length > 0) {
          const image_inputs = await this.image_processor(images);
          image_inputs.pixel_values.unsqueeze_(0);
          return { ...final, ...image_inputs };
        }
        return final;
      }
    }
  },
  "./src/models/jina_clip/image_processing_jina_clip.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!************************************************************!*\
      !*** ./src/models/jina_clip/image_processing_jina_clip.js ***!
      \************************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      JinaCLIPImageProcessor: () => JinaCLIPImageProcessor
    });
    var _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/image_processors_utils.js");
    /*! ../../base/image_processors_utils.js */

    class JinaCLIPImageProcessor extends _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__.ImageProcessor {
      constructor(config3) {
        const { resize_mode, fill_color, interpolation, size, ...other } = config3;
        const new_size = resize_mode === "squash" ? { width: size, height: size } : resize_mode === "shortest" ? { shortest_edge: size } : { longest_edge: size };
        const resample = interpolation === "bicubic" ? 3 : 2;
        super({
          ...other,
          size: new_size,
          resample,
          do_center_crop: true,
          crop_size: size,
          do_normalize: true
        });
      }
    }
  },
  "./src/models/jina_clip/processing_jina_clip.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!******************************************************!*\
      !*** ./src/models/jina_clip/processing_jina_clip.js ***!
      \******************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      JinaCLIPProcessor: () => JinaCLIPProcessor
    });
    var _base_processing_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/processing_utils.js");
    /*! ../../base/processing_utils.js */
    var _auto_image_processing_auto_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/models/auto/image_processing_auto.js");
    /*! ../auto/image_processing_auto.js */
    var _tokenizers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/tokenizers.js");
    /*! ../../tokenizers.js */

    class JinaCLIPProcessor extends _base_processing_utils_js__WEBPACK_IMPORTED_MODULE_0__.Processor {
      static tokenizer_class = _tokenizers_js__WEBPACK_IMPORTED_MODULE_2__.AutoTokenizer;
      static image_processor_class = _auto_image_processing_auto_js__WEBPACK_IMPORTED_MODULE_1__.AutoImageProcessor;
      async _call(text = null, images = null, kwargs = {}) {
        if (!text && !images) {
          throw new Error("Either text or images must be provided");
        }
        const text_inputs = text ? this.tokenizer(text, kwargs) : {};
        const image_inputs = images ? await this.image_processor(images, kwargs) : {};
        return {
          ...text_inputs,
          ...image_inputs
        };
      }
    }
  },
  "./src/models/llava/processing_llava.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!**********************************************!*\
      !*** ./src/models/llava/processing_llava.js ***!
      \**********************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      LlavaProcessor: () => LlavaProcessor
    });
    var _base_processing_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/processing_utils.js");
    /*! ../../base/processing_utils.js */
    var _auto_image_processing_auto_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/models/auto/image_processing_auto.js");
    /*! ../auto/image_processing_auto.js */
    var _tokenizers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/tokenizers.js");
    /*! ../../tokenizers.js */

    class LlavaProcessor extends _base_processing_utils_js__WEBPACK_IMPORTED_MODULE_0__.Processor {
      static tokenizer_class = _tokenizers_js__WEBPACK_IMPORTED_MODULE_2__.AutoTokenizer;
      static image_processor_class = _auto_image_processing_auto_js__WEBPACK_IMPORTED_MODULE_1__.AutoImageProcessor;
      static uses_processor_config = true;
      async _call(images, text = null, kwargs = {}) {
        const image_inputs = await this.image_processor(images, kwargs);
        if (text) {
          const [height, width] = image_inputs.pixel_values.dims.slice(-2);
          const { image_token, patch_size, num_additional_image_tokens } = this.config;
          const num_image_tokens = Math.floor(height / patch_size) * Math.floor(width / patch_size) + num_additional_image_tokens;
          text = structuredClone(text);
          if (!Array.isArray(text)) {
            text = [text];
          }
          for (let i = 0;i < text.length; ++i) {
            text[i] = text[i].replace(image_token, image_token.repeat(num_image_tokens));
          }
        }
        const text_inputs = text ? this.tokenizer(text, kwargs) : {};
        return {
          ...image_inputs,
          ...text_inputs
        };
      }
    }
  },
  "./src/models/llava_onevision/image_processing_llava_onevision.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!************************************************************************!*\
      !*** ./src/models/llava_onevision/image_processing_llava_onevision.js ***!
      \************************************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      LlavaOnevisionImageProcessor: () => LlavaOnevisionImageProcessor
    });
    var _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/image_processors_utils.js");
    /*! ../../base/image_processors_utils.js */

    class LlavaOnevisionImageProcessor extends _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__.ImageProcessor {
    }
  },
  "./src/models/mask2former/image_processing_mask2former.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!****************************************************************!*\
      !*** ./src/models/mask2former/image_processing_mask2former.js ***!
      \****************************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      Mask2FormerImageProcessor: () => Mask2FormerImageProcessor
    });
    var _maskformer_image_processing_maskformer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/models/maskformer/image_processing_maskformer.js");
    /*! ../maskformer/image_processing_maskformer.js */

    class Mask2FormerImageProcessor extends _maskformer_image_processing_maskformer_js__WEBPACK_IMPORTED_MODULE_0__.MaskFormerImageProcessor {
    }
  },
  "./src/models/maskformer/image_processing_maskformer.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!**************************************************************!*\
      !*** ./src/models/maskformer/image_processing_maskformer.js ***!
      \**************************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      MaskFormerFeatureExtractor: () => MaskFormerFeatureExtractor,
      MaskFormerImageProcessor: () => MaskFormerImageProcessor
    });
    var _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/image_processors_utils.js");
    /*! ../../base/image_processors_utils.js */

    class MaskFormerImageProcessor extends _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__.ImageProcessor {
      post_process_panoptic_segmentation(...args) {
        return (0, _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__.post_process_panoptic_segmentation)(...args);
      }
      post_process_instance_segmentation(...args) {
        return (0, _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__.post_process_instance_segmentation)(...args);
      }
    }

    class MaskFormerFeatureExtractor extends MaskFormerImageProcessor {
    }
  },
  "./src/models/mgp_str/processing_mgp_str.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!**************************************************!*\
      !*** ./src/models/mgp_str/processing_mgp_str.js ***!
      \**************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      MgpstrProcessor: () => MgpstrProcessor
    });
    var _base_processing_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/processing_utils.js");
    /*! ../../base/processing_utils.js */
    var _auto_image_processing_auto_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/models/auto/image_processing_auto.js");
    /*! ../auto/image_processing_auto.js */
    var _tokenizers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/tokenizers.js");
    /*! ../../tokenizers.js */
    var _utils_maths_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/utils/maths.js");
    /*! ../../utils/maths.js */
    const DECODE_TYPE_MAPPING = {
      char: ["char_decode", 1],
      bpe: ["bpe_decode", 2],
      wp: ["wp_decode", 102]
    };

    class MgpstrProcessor extends _base_processing_utils_js__WEBPACK_IMPORTED_MODULE_0__.Processor {
      static tokenizer_class = _tokenizers_js__WEBPACK_IMPORTED_MODULE_2__.AutoTokenizer;
      static image_processor_class = _auto_image_processing_auto_js__WEBPACK_IMPORTED_MODULE_1__.AutoImageProcessor;
      get char_tokenizer() {
        return this.components.char_tokenizer;
      }
      get bpe_tokenizer() {
        return this.components.bpe_tokenizer;
      }
      get wp_tokenizer() {
        return this.components.wp_tokenizer;
      }
      _decode_helper(pred_logits, format) {
        if (!DECODE_TYPE_MAPPING.hasOwnProperty(format)) {
          throw new Error(`Format ${format} is not supported.`);
        }
        const [decoder_name, eos_token] = DECODE_TYPE_MAPPING[format];
        const decoder = this[decoder_name].bind(this);
        const [batch_size, batch_max_length] = pred_logits.dims;
        const conf_scores = [];
        const all_ids = [];
        const pred_logits_list = pred_logits.tolist();
        for (let i = 0;i < batch_size; ++i) {
          const logits = pred_logits_list[i];
          const ids = [];
          const scores = [];
          for (let j = 1;j < batch_max_length; ++j) {
            const [max_prob, max_prob_index] = (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_3__.max)((0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_3__.softmax)(logits[j]));
            scores.push(max_prob);
            if (max_prob_index == eos_token) {
              break;
            }
            ids.push(max_prob_index);
          }
          const confidence_score = scores.length > 0 ? scores.reduce((a, b) => a * b, 1) : 0;
          all_ids.push(ids);
          conf_scores.push(confidence_score);
        }
        const decoded = decoder(all_ids);
        return [decoded, conf_scores];
      }
      char_decode(sequences) {
        return this.char_tokenizer.batch_decode(sequences).map((str2) => str2.replaceAll(" ", ""));
      }
      bpe_decode(sequences) {
        return this.bpe_tokenizer.batch_decode(sequences);
      }
      wp_decode(sequences) {
        return this.wp_tokenizer.batch_decode(sequences).map((str2) => str2.replaceAll(" ", ""));
      }
      batch_decode([char_logits, bpe_logits, wp_logits]) {
        const [char_preds, char_scores] = this._decode_helper(char_logits, "char");
        const [bpe_preds, bpe_scores] = this._decode_helper(bpe_logits, "bpe");
        const [wp_preds, wp_scores] = this._decode_helper(wp_logits, "wp");
        const generated_text = [];
        const scores = [];
        for (let i = 0;i < char_preds.length; ++i) {
          const [max_score, max_score_index] = (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_3__.max)([char_scores[i], bpe_scores[i], wp_scores[i]]);
          generated_text.push([char_preds[i], bpe_preds[i], wp_preds[i]][max_score_index]);
          scores.push(max_score);
        }
        return {
          generated_text,
          scores,
          char_preds,
          bpe_preds,
          wp_preds
        };
      }
      static async from_pretrained(...args) {
        const base = await super.from_pretrained(...args);
        const bpe_tokenizer = await _tokenizers_js__WEBPACK_IMPORTED_MODULE_2__.AutoTokenizer.from_pretrained("Xenova/gpt2");
        const wp_tokenizer = await _tokenizers_js__WEBPACK_IMPORTED_MODULE_2__.AutoTokenizer.from_pretrained("Xenova/bert-base-uncased");
        base.components = {
          image_processor: base.image_processor,
          char_tokenizer: base.tokenizer,
          bpe_tokenizer,
          wp_tokenizer
        };
        return base;
      }
      async _call(images, text = null) {
        const result = await this.image_processor(images);
        if (text) {
          result.labels = this.tokenizer(text).input_ids;
        }
        return result;
      }
    }
  },
  "./src/models/mobilenet_v1/image_processing_mobilenet_v1.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!******************************************************************!*\
      !*** ./src/models/mobilenet_v1/image_processing_mobilenet_v1.js ***!
      \******************************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      MobileNetV1FeatureExtractor: () => MobileNetV1FeatureExtractor,
      MobileNetV1ImageProcessor: () => MobileNetV1ImageProcessor
    });
    var _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/image_processors_utils.js");
    /*! ../../base/image_processors_utils.js */

    class MobileNetV1ImageProcessor extends _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__.ImageProcessor {
    }

    class MobileNetV1FeatureExtractor extends MobileNetV1ImageProcessor {
    }
  },
  "./src/models/mobilenet_v2/image_processing_mobilenet_v2.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!******************************************************************!*\
      !*** ./src/models/mobilenet_v2/image_processing_mobilenet_v2.js ***!
      \******************************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      MobileNetV2FeatureExtractor: () => MobileNetV2FeatureExtractor,
      MobileNetV2ImageProcessor: () => MobileNetV2ImageProcessor
    });
    var _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/image_processors_utils.js");
    /*! ../../base/image_processors_utils.js */

    class MobileNetV2ImageProcessor extends _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__.ImageProcessor {
    }

    class MobileNetV2FeatureExtractor extends MobileNetV2ImageProcessor {
    }
  },
  "./src/models/mobilenet_v3/image_processing_mobilenet_v3.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!******************************************************************!*\
      !*** ./src/models/mobilenet_v3/image_processing_mobilenet_v3.js ***!
      \******************************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      MobileNetV3FeatureExtractor: () => MobileNetV3FeatureExtractor,
      MobileNetV3ImageProcessor: () => MobileNetV3ImageProcessor
    });
    var _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/image_processors_utils.js");
    /*! ../../base/image_processors_utils.js */

    class MobileNetV3ImageProcessor extends _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__.ImageProcessor {
    }

    class MobileNetV3FeatureExtractor extends MobileNetV3ImageProcessor {
    }
  },
  "./src/models/mobilenet_v4/image_processing_mobilenet_v4.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!******************************************************************!*\
      !*** ./src/models/mobilenet_v4/image_processing_mobilenet_v4.js ***!
      \******************************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      MobileNetV4FeatureExtractor: () => MobileNetV4FeatureExtractor,
      MobileNetV4ImageProcessor: () => MobileNetV4ImageProcessor
    });
    var _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/image_processors_utils.js");
    /*! ../../base/image_processors_utils.js */

    class MobileNetV4ImageProcessor extends _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__.ImageProcessor {
    }

    class MobileNetV4FeatureExtractor extends MobileNetV4ImageProcessor {
    }
  },
  "./src/models/mobilevit/image_processing_mobilevit.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!************************************************************!*\
      !*** ./src/models/mobilevit/image_processing_mobilevit.js ***!
      \************************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      MobileViTFeatureExtractor: () => MobileViTFeatureExtractor,
      MobileViTImageProcessor: () => MobileViTImageProcessor
    });
    var _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/image_processors_utils.js");
    /*! ../../base/image_processors_utils.js */

    class MobileViTImageProcessor extends _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__.ImageProcessor {
    }

    class MobileViTFeatureExtractor extends MobileViTImageProcessor {
    }
  },
  "./src/models/moonshine/feature_extraction_moonshine.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!**************************************************************!*\
      !*** ./src/models/moonshine/feature_extraction_moonshine.js ***!
      \**************************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      MoonshineFeatureExtractor: () => MoonshineFeatureExtractor
    });
    var _base_feature_extraction_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/feature_extraction_utils.js");
    /*! ../../base/feature_extraction_utils.js */
    var _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/utils/tensor.js");
    /*! ../../utils/tensor.js */

    class MoonshineFeatureExtractor extends _base_feature_extraction_utils_js__WEBPACK_IMPORTED_MODULE_0__.FeatureExtractor {
      async _call(audio) {
        (0, _base_feature_extraction_utils_js__WEBPACK_IMPORTED_MODULE_0__.validate_audio_inputs)(audio, "MoonshineFeatureExtractor");
        if (audio instanceof Float64Array) {
          audio = new Float32Array(audio);
        }
        const shape = [
          1,
          audio.length
        ];
        return {
          input_values: new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__.Tensor("float32", audio, shape)
        };
      }
    }
  },
  "./src/models/moonshine/processing_moonshine.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!******************************************************!*\
      !*** ./src/models/moonshine/processing_moonshine.js ***!
      \******************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      MoonshineProcessor: () => MoonshineProcessor
    });
    var _auto_feature_extraction_auto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/models/auto/feature_extraction_auto.js");
    /*! ../auto/feature_extraction_auto.js */
    var _tokenizers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/tokenizers.js");
    /*! ../../tokenizers.js */
    var _base_processing_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/base/processing_utils.js");
    /*! ../../base/processing_utils.js */

    class MoonshineProcessor extends _base_processing_utils_js__WEBPACK_IMPORTED_MODULE_2__.Processor {
      static tokenizer_class = _tokenizers_js__WEBPACK_IMPORTED_MODULE_1__.AutoTokenizer;
      static feature_extractor_class = _auto_feature_extraction_auto_js__WEBPACK_IMPORTED_MODULE_0__.AutoFeatureExtractor;
      async _call(audio) {
        return await this.feature_extractor(audio);
      }
    }
  },
  "./src/models/nougat/image_processing_nougat.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!******************************************************!*\
      !*** ./src/models/nougat/image_processing_nougat.js ***!
      \******************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      NougatImageProcessor: () => NougatImageProcessor
    });
    var _donut_image_processing_donut_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/models/donut/image_processing_donut.js");
    /*! ../donut/image_processing_donut.js */

    class NougatImageProcessor extends _donut_image_processing_donut_js__WEBPACK_IMPORTED_MODULE_0__.DonutImageProcessor {
    }
  },
  "./src/models/owlv2/image_processing_owlv2.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!****************************************************!*\
      !*** ./src/models/owlv2/image_processing_owlv2.js ***!
      \****************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      Owlv2ImageProcessor: () => Owlv2ImageProcessor
    });
    var _owlvit_image_processing_owlvit_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/models/owlvit/image_processing_owlvit.js");
    /*! ../owlvit/image_processing_owlvit.js */

    class Owlv2ImageProcessor extends _owlvit_image_processing_owlvit_js__WEBPACK_IMPORTED_MODULE_0__.OwlViTImageProcessor {
    }
  },
  "./src/models/owlvit/image_processing_owlvit.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!******************************************************!*\
      !*** ./src/models/owlvit/image_processing_owlvit.js ***!
      \******************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      OwlViTFeatureExtractor: () => OwlViTFeatureExtractor,
      OwlViTImageProcessor: () => OwlViTImageProcessor
    });
    var _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/image_processors_utils.js");
    /*! ../../base/image_processors_utils.js */

    class OwlViTImageProcessor extends _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__.ImageProcessor {
      post_process_object_detection(...args) {
        return (0, _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__.post_process_object_detection)(...args);
      }
    }

    class OwlViTFeatureExtractor extends OwlViTImageProcessor {
    }
  },
  "./src/models/owlvit/processing_owlvit.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!************************************************!*\
      !*** ./src/models/owlvit/processing_owlvit.js ***!
      \************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      OwlViTProcessor: () => OwlViTProcessor
    });
    var _base_processing_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/processing_utils.js");
    /*! ../../base/processing_utils.js */
    var _auto_image_processing_auto_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/models/auto/image_processing_auto.js");
    /*! ../auto/image_processing_auto.js */
    var _tokenizers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/tokenizers.js");
    /*! ../../tokenizers.js */

    class OwlViTProcessor extends _base_processing_utils_js__WEBPACK_IMPORTED_MODULE_0__.Processor {
      static tokenizer_class = _tokenizers_js__WEBPACK_IMPORTED_MODULE_2__.AutoTokenizer;
      static image_processor_class = _auto_image_processing_auto_js__WEBPACK_IMPORTED_MODULE_1__.AutoImageProcessor;
    }
  },
  "./src/models/paligemma/processing_paligemma.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!******************************************************!*\
      !*** ./src/models/paligemma/processing_paligemma.js ***!
      \******************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      PaliGemmaProcessor: () => PaliGemmaProcessor
    });
    var _base_processing_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/processing_utils.js");
    /*! ../../base/processing_utils.js */
    var _auto_image_processing_auto_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/models/auto/image_processing_auto.js");
    /*! ../auto/image_processing_auto.js */
    var _tokenizers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/tokenizers.js");
    /*! ../../tokenizers.js */
    const IMAGE_TOKEN = "<image>";
    function build_string_from_input(prompt, bos_token, image_seq_len, image_token, num_images) {
      return `${image_token.repeat(image_seq_len * num_images)}${bos_token}${prompt}
`;
    }

    class PaliGemmaProcessor extends _base_processing_utils_js__WEBPACK_IMPORTED_MODULE_0__.Processor {
      static tokenizer_class = _tokenizers_js__WEBPACK_IMPORTED_MODULE_2__.AutoTokenizer;
      static image_processor_class = _auto_image_processing_auto_js__WEBPACK_IMPORTED_MODULE_1__.AutoImageProcessor;
      static uses_processor_config = false;
      async _call(images, text = null, kwargs = {}) {
        if (!text) {
          console.warn("You are using PaliGemma without a text prefix. It will perform as a picture-captioning model.");
          text = "";
        }
        if (!Array.isArray(images)) {
          images = [images];
        }
        if (!Array.isArray(text)) {
          text = [text];
        }
        const bos_token = this.tokenizer.bos_token;
        const image_seq_length = this.image_processor.config.image_seq_length;
        let input_strings;
        if (text.some((t) => t.includes(IMAGE_TOKEN))) {
          input_strings = text.map((sample) => {
            const expanded_sample = sample.replaceAll(IMAGE_TOKEN, IMAGE_TOKEN.repeat(image_seq_length));
            const bos_rfind_index = expanded_sample.lastIndexOf(IMAGE_TOKEN);
            const bos_index = bos_rfind_index === -1 ? 0 : bos_rfind_index + IMAGE_TOKEN.length;
            return expanded_sample.slice(0, bos_index) + bos_token + expanded_sample.slice(bos_index) + `
`;
          });
        } else {
          console.warn("You are passing both `text` and `images` to `PaliGemmaProcessor`. The processor expects special " + "image tokens in the text, as many tokens as there are images per each text. It is recommended to " + "add `<image>` tokens in the very beginning of your text. For this call, we will infer how many images " + "each text has and add special tokens.");
          input_strings = text.map((sample) => build_string_from_input(sample, bos_token, image_seq_length, IMAGE_TOKEN, images.length));
        }
        const text_inputs = this.tokenizer(input_strings, kwargs);
        const image_inputs = await this.image_processor(images, kwargs);
        return {
          ...image_inputs,
          ...text_inputs
        };
      }
    }
  },
  "./src/models/parakeet/feature_extraction_parakeet.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!************************************************************!*\
      !*** ./src/models/parakeet/feature_extraction_parakeet.js ***!
      \************************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      ParakeetFeatureExtractor: () => ParakeetFeatureExtractor
    });
    var _base_feature_extraction_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/feature_extraction_utils.js");
    /*! ../../base/feature_extraction_utils.js */
    var _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/utils/tensor.js");
    /*! ../../utils/tensor.js */
    var _utils_audio_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/utils/audio.js");
    /*! ../../utils/audio.js */
    const EPSILON = 0.00001;

    class ParakeetFeatureExtractor extends _base_feature_extraction_utils_js__WEBPACK_IMPORTED_MODULE_0__.FeatureExtractor {
      constructor(config3) {
        super(config3);
        this.config.mel_filters ??= (0, _utils_audio_js__WEBPACK_IMPORTED_MODULE_2__.mel_filter_bank)(Math.floor(1 + this.config.n_fft / 2), this.config.feature_size, 0, this.config.sampling_rate / 2, this.config.sampling_rate, "slaney", "slaney");
        const window2 = (0, _utils_audio_js__WEBPACK_IMPORTED_MODULE_2__.window_function)(this.config.win_length, "hann", {
          periodic: false
        });
        this.window = new Float64Array(this.config.n_fft);
        const offset = Math.floor((this.config.n_fft - this.config.win_length) / 2);
        this.window.set(window2, offset);
      }
      async _extract_fbank_features(waveform) {
        const preemphasis = this.config.preemphasis;
        waveform = new Float64Array(waveform);
        for (let j = waveform.length - 1;j >= 1; --j) {
          waveform[j] -= preemphasis * waveform[j - 1];
        }
        const features = await (0, _utils_audio_js__WEBPACK_IMPORTED_MODULE_2__.spectrogram)(waveform, this.window, this.window.length, this.config.hop_length, {
          fft_length: this.config.n_fft,
          power: 2,
          mel_filters: this.config.mel_filters,
          log_mel: "log",
          mel_floor: -Infinity,
          pad_mode: "constant",
          center: true,
          transpose: true,
          mel_offset: 2 ** -24
        });
        return features;
      }
      async _call(audio) {
        (0, _base_feature_extraction_utils_js__WEBPACK_IMPORTED_MODULE_0__.validate_audio_inputs)(audio, "ParakeetFeatureExtractor");
        const features = await this._extract_fbank_features(audio);
        const features_length = Math.floor((audio.length + Math.floor(this.config.n_fft / 2) * 2 - this.config.n_fft) / this.config.hop_length);
        const features_data = features.data;
        features_data.fill(0, features_length * features.dims[1]);
        const [num_frames, num_features] = features.dims;
        const sum = new Float64Array(num_features);
        const sum_sq = new Float64Array(num_features);
        for (let i = 0;i < features_length; ++i) {
          const offset = i * num_features;
          for (let j = 0;j < num_features; ++j) {
            const val = features_data[offset + j];
            sum[j] += val;
            sum_sq[j] += val * val;
          }
        }
        const divisor = features_length > 1 ? features_length - 1 : 1;
        for (let j = 0;j < num_features; ++j) {
          const mean = sum[j] / features_length;
          const variance = (sum_sq[j] - features_length * mean * mean) / divisor;
          const std = Math.sqrt(variance) + EPSILON;
          const inv_std = 1 / std;
          for (let i = 0;i < features_length; ++i) {
            const index = i * num_features + j;
            features_data[index] = (features_data[index] - mean) * inv_std;
          }
        }
        const mask_data = new BigInt64Array(num_frames);
        mask_data.fill(1n, 0, features_length);
        return {
          input_features: features.unsqueeze_(0),
          attention_mask: new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__.Tensor("int64", mask_data, [1, num_frames])
        };
      }
    }
  },
  "./src/models/phi3_v/image_processing_phi3_v.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!******************************************************!*\
      !*** ./src/models/phi3_v/image_processing_phi3_v.js ***!
      \******************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      Phi3VImageProcessor: () => Phi3VImageProcessor
    });
    var _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/image_processors_utils.js");
    /*! ../../base/image_processors_utils.js */
    var _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/utils/tensor.js");
    /*! ../../utils/tensor.js */
    const IMAGE_SIZE = 336;
    const SLICE_AXES = [2, 3];
    const { ceil, floor, sqrt } = Math;

    class Phi3VImageProcessor extends _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__.ImageProcessor {
      constructor(config3) {
        super({
          ...config3,
          do_normalize: true,
          do_pad: true,
          pad_size: "custom",
          do_convert_rgb: true,
          do_resize: true
        });
        this._num_crops = config3.num_crops;
      }
      calc_num_image_tokens_from_image_size(width, height) {
        const { num_img_tokens } = this.config;
        return floor((floor(height / IMAGE_SIZE) * floor(width / IMAGE_SIZE) + 1) * num_img_tokens + 1 + (floor(height / IMAGE_SIZE) + 1) * sqrt(num_img_tokens));
      }
      get_resize_output_image_size(image, size) {
        const hd_num = this._num_crops;
        const [width, height] = image.size;
        let ratio = width / height;
        let scale = 1;
        while (scale * Math.ceil(scale / ratio) <= hd_num) {
          scale += 1;
        }
        scale -= 1;
        const new_w = Math.floor(scale * 336);
        const new_h = Math.floor(new_w / ratio);
        return [new_w, new_h];
      }
      pad_image(pixelData, imgDims, padSize, options2 = {}) {
        const [imageHeight, imageWidth] = imgDims;
        const height = IMAGE_SIZE * ceil(imageHeight / IMAGE_SIZE);
        const width = IMAGE_SIZE * ceil(imageWidth / IMAGE_SIZE);
        const constant_values = [1, 1, 1].map((x, i) => (x - this.image_mean[i]) / this.image_std[i]);
        return super.pad_image(pixelData, imgDims, { width, height }, {
          center: true,
          constant_values,
          ...options2
        });
      }
      async _call(images, {
        num_crops = null
      } = {}) {
        this._num_crops = num_crops ??= this.config.num_crops;
        if (num_crops < 4 || sqrt(num_crops) % 1 !== 0) {
          throw new Error("num_crops must be a square number >= 4");
        }
        if (!Array.isArray(images)) {
          images = [images];
        }
        const num_images = images.length;
        const imageData = await Promise.all(images.map((x) => this.preprocess(x)));
        const original_sizes = imageData.map((x) => x.original_size);
        const reshaped_input_sizes = imageData.map((x) => x.reshaped_input_size);
        const all_pixel_values = [];
        for (const { pixel_values: pixel_values2 } of imageData) {
          pixel_values2.unsqueeze_(0);
          const [height, width] = pixel_values2.dims.slice(-2);
          const batch_pixel_values = await (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__.interpolate_4d)(pixel_values2, {
            size: [IMAGE_SIZE, IMAGE_SIZE],
            mode: "bicubic"
          });
          if (num_crops > 0) {
            const patches = [];
            const sqrt_patches = sqrt(num_crops);
            const patch_width = floor(width / sqrt_patches);
            const patch_height = floor(height / sqrt_patches);
            for (let y = 0;y < sqrt_patches; ++y) {
              for (let x = 0;x < sqrt_patches; ++x) {
                let start_x, start_y, end_x, end_y;
                if (y === sqrt_patches - 1) {
                  start_y = height - patch_height;
                  end_y = height;
                } else {
                  start_y = y * patch_height;
                  end_y = (y + 1) * patch_height;
                }
                if (x === sqrt_patches - 1) {
                  start_x = width - patch_width;
                  end_x = width;
                } else {
                  start_x = x * patch_width;
                  end_x = (x + 1) * patch_width;
                }
                const starts = [start_y, start_x];
                const ends = [end_y, end_x];
                const patch = await (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__.slice)(pixel_values2, starts, ends, SLICE_AXES);
                patches.push(patch);
              }
            }
            const resized_tensors = await (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__.interpolate_4d)((0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__.cat)(patches, 0), {
              size: [IMAGE_SIZE, IMAGE_SIZE],
              mode: "bicubic"
            });
            all_pixel_values.push((0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__.cat)([batch_pixel_values, resized_tensors], 0));
          } else {
            all_pixel_values.push(batch_pixel_values);
          }
        }
        const pixel_values = (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__.stack)(all_pixel_values, 0);
        const sizes = reshaped_input_sizes.map((x) => x.map((y) => IMAGE_SIZE * ceil(y / IMAGE_SIZE)));
        const image_sizes = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__.Tensor("int64", sizes.flat(), [num_images, 2]);
        const num_img_tokens = sizes.map(([height, width]) => this.calc_num_image_tokens_from_image_size(width, height));
        return { pixel_values, original_sizes, reshaped_input_sizes, image_sizes, num_img_tokens };
      }
    }
  },
  "./src/models/phi3_v/processing_phi3_v.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!************************************************!*\
      !*** ./src/models/phi3_v/processing_phi3_v.js ***!
      \************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      Phi3VProcessor: () => Phi3VProcessor
    });
    var _base_processing_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/processing_utils.js");
    /*! ../../base/processing_utils.js */
    var _auto_image_processing_auto_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/models/auto/image_processing_auto.js");
    /*! ../auto/image_processing_auto.js */
    var _tokenizers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/tokenizers.js");
    /*! ../../tokenizers.js */
    var _utils_image_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/utils/image.js");
    /*! ../../utils/image.js */
    const IMAGE_TOKEN = "<|image|>";
    const IMAGE_TOKEN_PATTERN = /<\|image_\d+\|>/g;

    class Phi3VProcessor extends _base_processing_utils_js__WEBPACK_IMPORTED_MODULE_0__.Processor {
      static image_processor_class = _auto_image_processing_auto_js__WEBPACK_IMPORTED_MODULE_1__.AutoImageProcessor;
      static tokenizer_class = _tokenizers_js__WEBPACK_IMPORTED_MODULE_2__.AutoTokenizer;
      async _call(text, images = null, {
        padding = true,
        truncation = true,
        num_crops = null
      } = {}) {
        if (!Array.isArray(text)) {
          text = [text];
        }
        let text_inputs, image_inputs;
        if (images) {
          image_inputs = await this.image_processor(images, { num_crops });
          const { num_img_tokens } = image_inputs;
          const prompt_chunks = text.map((t, i) => t.split(IMAGE_TOKEN_PATTERN).join(IMAGE_TOKEN.repeat(num_img_tokens[i])));
          text_inputs = this.tokenizer(prompt_chunks, { padding, truncation });
          const image_token_id = this.tokenizer.model.convert_tokens_to_ids([IMAGE_TOKEN])[0];
          text_inputs.input_ids.map_((id) => id == image_token_id ? -id : id);
        } else {
          text_inputs = this.tokenizer(text);
        }
        return {
          ...text_inputs,
          ...image_inputs
        };
      }
    }
  },
  "./src/models/pixtral/image_processing_pixtral.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!********************************************************!*\
      !*** ./src/models/pixtral/image_processing_pixtral.js ***!
      \********************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      PixtralImageProcessor: () => PixtralImageProcessor
    });
    var _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/image_processors_utils.js");
    /*! ../../base/image_processors_utils.js */

    class PixtralImageProcessor extends _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__.ImageProcessor {
      get_resize_output_image_size(image, size) {
        const { longest_edge } = size;
        if (longest_edge === undefined) {
          throw new Error("size must contain 'longest_edge'");
        }
        const [srcWidth, srcHeight] = image.size;
        const ratio = Math.max(srcWidth, srcHeight) / longest_edge;
        let newWidth = srcWidth;
        let newHeight = srcHeight;
        if (ratio > 1) {
          newWidth = Math.floor(srcWidth / ratio);
          newHeight = Math.floor(srcHeight / ratio);
        }
        const { patch_size, spatial_merge_size } = this.config;
        if (!spatial_merge_size) {
          throw new Error("config must contain 'spatial_merge_size'");
        }
        const real_patch_size = patch_size * spatial_merge_size;
        const num_width_tokens = Math.floor((newWidth - 1) / real_patch_size) + 1;
        const num_height_tokens = Math.floor((newHeight - 1) / real_patch_size) + 1;
        return [num_width_tokens * real_patch_size, num_height_tokens * real_patch_size];
      }
    }
  },
  "./src/models/pixtral/processing_pixtral.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!**************************************************!*\
      !*** ./src/models/pixtral/processing_pixtral.js ***!
      \**************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      PixtralProcessor: () => PixtralProcessor
    });
    var _base_processing_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/processing_utils.js");
    /*! ../../base/processing_utils.js */
    var _auto_image_processing_auto_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/models/auto/image_processing_auto.js");
    /*! ../auto/image_processing_auto.js */
    var _tokenizers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/tokenizers.js");
    /*! ../../tokenizers.js */

    class PixtralProcessor extends _base_processing_utils_js__WEBPACK_IMPORTED_MODULE_0__.Processor {
      static tokenizer_class = _tokenizers_js__WEBPACK_IMPORTED_MODULE_2__.AutoTokenizer;
      static image_processor_class = _auto_image_processing_auto_js__WEBPACK_IMPORTED_MODULE_1__.AutoImageProcessor;
      static uses_processor_config = true;
      async _call(images, text = null, kwargs = {}) {
        const image_inputs = await this.image_processor(images, kwargs);
        if (text) {
          const [height, width] = image_inputs.pixel_values.dims.slice(-2);
          const { image_token, image_break_token, image_end_token, patch_size, spatial_merge_size } = this.config;
          const real_patch_size = patch_size * spatial_merge_size;
          const num_height_tokens = Math.floor(height / real_patch_size);
          const num_width_tokens = Math.floor(width / real_patch_size);
          text = structuredClone(text);
          if (!Array.isArray(text)) {
            text = [text];
          }
          for (let i = 0;i < text.length; ++i) {
            const width_tokens = image_token.repeat(num_width_tokens);
            const row = width_tokens + image_break_token;
            const finalRow = width_tokens + image_end_token;
            const full = row.repeat(num_height_tokens - 1) + finalRow;
            text[i] = text[i].replace(image_token, full);
          }
        }
        const text_inputs = text ? this.tokenizer(text, kwargs) : {};
        return {
          ...image_inputs,
          ...text_inputs
        };
      }
    }
  },
  "./src/models/processors.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!**********************************!*\
      !*** ./src/models/processors.js ***!
      \**********************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      Florence2Processor: () => _florence2_processing_florence2_js__WEBPACK_IMPORTED_MODULE_0__.Florence2Processor,
      Gemma3nProcessor: () => _gemma3n_processing_gemma3n_js__WEBPACK_IMPORTED_MODULE_1__.Gemma3nProcessor,
      GroundingDinoProcessor: () => _grounding_dino_processing_grounding_dino_js__WEBPACK_IMPORTED_MODULE_2__.GroundingDinoProcessor,
      Idefics3Processor: () => _idefics3_processing_idefics3_js__WEBPACK_IMPORTED_MODULE_3__.Idefics3Processor,
      JinaCLIPProcessor: () => _jina_clip_processing_jina_clip_js__WEBPACK_IMPORTED_MODULE_5__.JinaCLIPProcessor,
      LlavaProcessor: () => _llava_processing_llava_js__WEBPACK_IMPORTED_MODULE_6__.LlavaProcessor,
      MgpstrProcessor: () => _mgp_str_processing_mgp_str_js__WEBPACK_IMPORTED_MODULE_7__.MgpstrProcessor,
      MoonshineProcessor: () => _moonshine_processing_moonshine_js__WEBPACK_IMPORTED_MODULE_8__.MoonshineProcessor,
      OwlViTProcessor: () => _owlvit_processing_owlvit_js__WEBPACK_IMPORTED_MODULE_9__.OwlViTProcessor,
      PaliGemmaProcessor: () => _paligemma_processing_paligemma_js__WEBPACK_IMPORTED_MODULE_10__.PaliGemmaProcessor,
      Phi3VProcessor: () => _phi3_v_processing_phi3_v_js__WEBPACK_IMPORTED_MODULE_11__.Phi3VProcessor,
      PixtralProcessor: () => _pixtral_processing_pixtral_js__WEBPACK_IMPORTED_MODULE_12__.PixtralProcessor,
      PyAnnoteProcessor: () => _pyannote_processing_pyannote_js__WEBPACK_IMPORTED_MODULE_13__.PyAnnoteProcessor,
      Qwen2VLProcessor: () => _qwen2_vl_processing_qwen2_vl_js__WEBPACK_IMPORTED_MODULE_14__.Qwen2VLProcessor,
      Sam2Processor: () => _sam2_processing_sam2_js__WEBPACK_IMPORTED_MODULE_16__.Sam2Processor,
      Sam2VideoProcessor: () => _sam2_processing_sam2_js__WEBPACK_IMPORTED_MODULE_16__.Sam2VideoProcessor,
      SamProcessor: () => _sam_processing_sam_js__WEBPACK_IMPORTED_MODULE_15__.SamProcessor,
      SmolVLMProcessor: () => _smolvlm_processing_smolvlm_js__WEBPACK_IMPORTED_MODULE_17__.SmolVLMProcessor,
      SpeechT5Processor: () => _speecht5_processing_speecht5_js__WEBPACK_IMPORTED_MODULE_18__.SpeechT5Processor,
      UltravoxProcessor: () => _ultravox_processing_ultravox_js__WEBPACK_IMPORTED_MODULE_19__.UltravoxProcessor,
      VLChatProcessor: () => _janus_processing_janus_js__WEBPACK_IMPORTED_MODULE_4__.VLChatProcessor,
      VoxtralProcessor: () => _voxtral_processing_voxtral_js__WEBPACK_IMPORTED_MODULE_20__.VoxtralProcessor,
      Wav2Vec2Processor: () => _wav2vec2_processing_wav2vec2_js__WEBPACK_IMPORTED_MODULE_21__.Wav2Vec2Processor,
      Wav2Vec2ProcessorWithLM: () => _wav2vec2_with_lm_processing_wav2vec2_with_lm_js__WEBPACK_IMPORTED_MODULE_22__.Wav2Vec2ProcessorWithLM,
      WhisperProcessor: () => _whisper_processing_whisper_js__WEBPACK_IMPORTED_MODULE_23__.WhisperProcessor
    });
    var _florence2_processing_florence2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/models/florence2/processing_florence2.js");
    /*! ./florence2/processing_florence2.js */
    var _gemma3n_processing_gemma3n_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/models/gemma3n/processing_gemma3n.js");
    /*! ./gemma3n/processing_gemma3n.js */
    var _grounding_dino_processing_grounding_dino_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/models/grounding_dino/processing_grounding_dino.js");
    /*! ./grounding_dino/processing_grounding_dino.js */
    var _idefics3_processing_idefics3_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/models/idefics3/processing_idefics3.js");
    /*! ./idefics3/processing_idefics3.js */
    var _janus_processing_janus_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./src/models/janus/processing_janus.js");
    /*! ./janus/processing_janus.js */
    var _jina_clip_processing_jina_clip_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./src/models/jina_clip/processing_jina_clip.js");
    /*! ./jina_clip/processing_jina_clip.js */
    var _llava_processing_llava_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./src/models/llava/processing_llava.js");
    /*! ./llava/processing_llava.js */
    var _mgp_str_processing_mgp_str_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./src/models/mgp_str/processing_mgp_str.js");
    /*! ./mgp_str/processing_mgp_str.js */
    var _moonshine_processing_moonshine_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./src/models/moonshine/processing_moonshine.js");
    /*! ./moonshine/processing_moonshine.js */
    var _owlvit_processing_owlvit_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./src/models/owlvit/processing_owlvit.js");
    /*! ./owlvit/processing_owlvit.js */
    var _paligemma_processing_paligemma_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./src/models/paligemma/processing_paligemma.js");
    /*! ./paligemma/processing_paligemma.js */
    var _phi3_v_processing_phi3_v_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./src/models/phi3_v/processing_phi3_v.js");
    /*! ./phi3_v/processing_phi3_v.js */
    var _pixtral_processing_pixtral_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./src/models/pixtral/processing_pixtral.js");
    /*! ./pixtral/processing_pixtral.js */
    var _pyannote_processing_pyannote_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./src/models/pyannote/processing_pyannote.js");
    /*! ./pyannote/processing_pyannote.js */
    var _qwen2_vl_processing_qwen2_vl_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("./src/models/qwen2_vl/processing_qwen2_vl.js");
    /*! ./qwen2_vl/processing_qwen2_vl.js */
    var _sam_processing_sam_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__("./src/models/sam/processing_sam.js");
    /*! ./sam/processing_sam.js */
    var _sam2_processing_sam2_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__("./src/models/sam2/processing_sam2.js");
    /*! ./sam2/processing_sam2.js */
    var _smolvlm_processing_smolvlm_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__("./src/models/smolvlm/processing_smolvlm.js");
    /*! ./smolvlm/processing_smolvlm.js */
    var _speecht5_processing_speecht5_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__("./src/models/speecht5/processing_speecht5.js");
    /*! ./speecht5/processing_speecht5.js */
    var _ultravox_processing_ultravox_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__("./src/models/ultravox/processing_ultravox.js");
    /*! ./ultravox/processing_ultravox.js */
    var _voxtral_processing_voxtral_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__("./src/models/voxtral/processing_voxtral.js");
    /*! ./voxtral/processing_voxtral.js */
    var _wav2vec2_processing_wav2vec2_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__("./src/models/wav2vec2/processing_wav2vec2.js");
    /*! ./wav2vec2/processing_wav2vec2.js */
    var _wav2vec2_with_lm_processing_wav2vec2_with_lm_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__("./src/models/wav2vec2_with_lm/processing_wav2vec2_with_lm.js");
    /*! ./wav2vec2_with_lm/processing_wav2vec2_with_lm.js */
    var _whisper_processing_whisper_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__("./src/models/whisper/processing_whisper.js");
    /*! ./whisper/processing_whisper.js */
  },
  "./src/models/pvt/image_processing_pvt.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!************************************************!*\
      !*** ./src/models/pvt/image_processing_pvt.js ***!
      \************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      PvtImageProcessor: () => PvtImageProcessor
    });
    var _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/image_processors_utils.js");
    /*! ../../base/image_processors_utils.js */

    class PvtImageProcessor extends _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__.ImageProcessor {
    }
  },
  "./src/models/pyannote/feature_extraction_pyannote.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!************************************************************!*\
      !*** ./src/models/pyannote/feature_extraction_pyannote.js ***!
      \************************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      PyAnnoteFeatureExtractor: () => PyAnnoteFeatureExtractor
    });
    var _base_feature_extraction_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/feature_extraction_utils.js");
    /*! ../../base/feature_extraction_utils.js */
    var _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/utils/tensor.js");
    /*! ../../utils/tensor.js */
    var _utils_maths_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/utils/maths.js");
    /*! ../../utils/maths.js */

    class PyAnnoteFeatureExtractor extends _base_feature_extraction_utils_js__WEBPACK_IMPORTED_MODULE_0__.FeatureExtractor {
      async _call(audio) {
        (0, _base_feature_extraction_utils_js__WEBPACK_IMPORTED_MODULE_0__.validate_audio_inputs)(audio, "PyAnnoteFeatureExtractor");
        if (audio instanceof Float64Array) {
          audio = new Float32Array(audio);
        }
        const shape = [
          1,
          1,
          audio.length
        ];
        return {
          input_values: new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__.Tensor("float32", audio, shape)
        };
      }
      samples_to_frames(samples) {
        return (samples - this.config.offset) / this.config.step;
      }
      post_process_speaker_diarization(logits, num_samples) {
        const ratio = num_samples / this.samples_to_frames(num_samples) / this.config.sampling_rate;
        const results = [];
        for (const scores of logits.tolist()) {
          const accumulated_segments = [];
          let current_speaker = -1;
          for (let i = 0;i < scores.length; ++i) {
            const probabilities = (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.softmax)(scores[i]);
            const [score, id] = (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.max)(probabilities);
            const [start, end] = [i, i + 1];
            if (id !== current_speaker) {
              current_speaker = id;
              accumulated_segments.push({ id, start, end, score });
            } else {
              accumulated_segments.at(-1).end = end;
              accumulated_segments.at(-1).score += score;
            }
          }
          results.push(accumulated_segments.map(({ id, start, end, score }) => ({
            id,
            start: start * ratio,
            end: end * ratio,
            confidence: score / (end - start)
          })));
        }
        return results;
      }
    }
  },
  "./src/models/pyannote/processing_pyannote.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!****************************************************!*\
      !*** ./src/models/pyannote/processing_pyannote.js ***!
      \****************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      PyAnnoteProcessor: () => PyAnnoteProcessor
    });
    var _base_processing_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/processing_utils.js");
    /*! ../../base/processing_utils.js */
    var _feature_extraction_pyannote_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/models/pyannote/feature_extraction_pyannote.js");
    /*! ./feature_extraction_pyannote.js */

    class PyAnnoteProcessor extends _base_processing_utils_js__WEBPACK_IMPORTED_MODULE_0__.Processor {
      static feature_extractor_class = _feature_extraction_pyannote_js__WEBPACK_IMPORTED_MODULE_1__.PyAnnoteFeatureExtractor;
      async _call(audio) {
        return await this.feature_extractor(audio);
      }
      post_process_speaker_diarization(...args) {
        return this.feature_extractor.post_process_speaker_diarization(...args);
      }
      get sampling_rate() {
        return this.feature_extractor.config.sampling_rate;
      }
    }
  },
  "./src/models/qwen2_vl/image_processing_qwen2_vl.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!**********************************************************!*\
      !*** ./src/models/qwen2_vl/image_processing_qwen2_vl.js ***!
      \**********************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      Qwen2VLImageProcessor: () => Qwen2VLImageProcessor
    });
    var _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/image_processors_utils.js");
    /*! ../../base/image_processors_utils.js */
    var _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/utils/tensor.js");
    /*! ../../utils/tensor.js */

    class Qwen2VLImageProcessor extends _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__.ImageProcessor {
      async _call(images, ...args) {
        const { pixel_values, original_sizes, reshaped_input_sizes } = await super._call(images, ...args);
        let patches = pixel_values;
        const { temporal_patch_size, merge_size, patch_size } = this.config;
        if (patches.dims[0] === 1) {
          patches = (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__.cat)(Array.from({ length: temporal_patch_size }, () => patches), 0);
        }
        const grid_t = patches.dims[0] / temporal_patch_size;
        const channel = patches.dims[1];
        const grid_h = Math.floor(patches.dims[2] / patch_size);
        const grid_w = Math.floor(patches.dims[3] / patch_size);
        const flatten_patches = patches.view(grid_t, temporal_patch_size, channel, Math.floor(grid_h / merge_size), merge_size, patch_size, Math.floor(grid_w / merge_size), merge_size, patch_size).permute(0, 3, 6, 4, 7, 2, 1, 5, 8).view(grid_t * grid_h * grid_w, channel * temporal_patch_size * patch_size * patch_size);
        const image_grid_thw = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__.Tensor("int64", [grid_t, grid_h, grid_w], [1, 3]);
        return {
          pixel_values: flatten_patches,
          image_grid_thw,
          original_sizes,
          reshaped_input_sizes
        };
      }
    }
  },
  "./src/models/qwen2_vl/processing_qwen2_vl.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!****************************************************!*\
      !*** ./src/models/qwen2_vl/processing_qwen2_vl.js ***!
      \****************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      Qwen2VLProcessor: () => Qwen2VLProcessor
    });
    var _base_processing_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/processing_utils.js");
    /*! ../../base/processing_utils.js */
    var _auto_image_processing_auto_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/models/auto/image_processing_auto.js");
    /*! ../auto/image_processing_auto.js */
    var _tokenizers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/tokenizers.js");
    /*! ../../tokenizers.js */
    var _utils_image_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/utils/image.js");
    /*! ../../utils/image.js */

    class Qwen2VLProcessor extends _base_processing_utils_js__WEBPACK_IMPORTED_MODULE_0__.Processor {
      static image_processor_class = _auto_image_processing_auto_js__WEBPACK_IMPORTED_MODULE_1__.AutoImageProcessor;
      static tokenizer_class = _tokenizers_js__WEBPACK_IMPORTED_MODULE_2__.AutoTokenizer;
      async _call(text, images = null, ...args) {
        if (!Array.isArray(text)) {
          text = [text];
        }
        let image_inputs, image_grid_thw;
        if (images) {
          image_inputs = await this.image_processor(images);
          image_grid_thw = image_inputs.image_grid_thw;
        }
        if (image_grid_thw) {
          let merge_length = this.image_processor.config.merge_size ** 2;
          let index = 0;
          const image_grid_thw_list = image_grid_thw.tolist();
          text = text.map((t) => {
            while (t.includes("<|image_pad|>")) {
              const prod = Number(image_grid_thw_list[index++].reduce((a, b) => a * b, 1n));
              t = t.replace("<|image_pad|>", "<|placeholder|>".repeat(Math.floor(prod / merge_length)));
            }
            return t.replaceAll("<|placeholder|>", "<|image_pad|>");
          });
        }
        const text_inputs = this.tokenizer(text);
        return {
          ...text_inputs,
          ...image_inputs
        };
      }
    }
  },
  "./src/models/rt_detr/image_processing_rt_detr.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!********************************************************!*\
      !*** ./src/models/rt_detr/image_processing_rt_detr.js ***!
      \********************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      RTDetrImageProcessor: () => RTDetrImageProcessor
    });
    var _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/image_processors_utils.js");
    /*! ../../base/image_processors_utils.js */

    class RTDetrImageProcessor extends _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__.ImageProcessor {
      post_process_object_detection(...args) {
        return (0, _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__.post_process_object_detection)(...args);
      }
    }
  },
  "./src/models/sam/image_processing_sam.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!************************************************!*\
      !*** ./src/models/sam/image_processing_sam.js ***!
      \************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      SamImageProcessor: () => SamImageProcessor
    });
    var _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/image_processors_utils.js");
    /*! ../../base/image_processors_utils.js */
    var _utils_core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/utils/core.js");
    /*! ../../utils/core.js */
    var _utils_tensor_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/utils/tensor.js");
    /*! ../../utils/tensor.js */

    class SamImageProcessor extends _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__.ImageProcessor {
      reshape_input_points(input_points, original_sizes, reshaped_input_sizes, is_bounding_box = false) {
        input_points = structuredClone(input_points);
        let shape = (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_1__.calculateDimensions)(input_points);
        if (shape.length === 3) {
          if (!is_bounding_box) {
            shape = [1, ...shape];
          }
          input_points = [input_points];
        } else if (shape.length !== 4) {
          throw Error("The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.");
        }
        for (let i = 0;i < input_points.length; ++i) {
          const [originalHeight, originalWidth] = original_sizes[i];
          const [reshapedHeight, reshapedWidth] = reshaped_input_sizes[i];
          const resizeFactors = [
            reshapedWidth / originalWidth,
            reshapedHeight / originalHeight
          ];
          for (let j = 0;j < input_points[i].length; ++j) {
            for (let k = 0;k < input_points[i][j].length; ++k) {
              for (let w = 0;w < input_points[i][j][k].length; ++w) {
                input_points[i][j][k][w] *= resizeFactors[w % 2];
              }
            }
          }
        }
        return new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_2__.Tensor("float32", Float32Array.from(input_points.flat(Infinity)), shape);
      }
      add_input_labels(input_labels, input_points) {
        let shape = (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_1__.calculateDimensions)(input_labels);
        if (shape.length === 2) {
          shape = [1, ...shape];
          input_labels = [input_labels];
        } else if (shape.length !== 3) {
          throw Error("The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.");
        }
        if (shape.some((x, i) => x !== input_points.dims[i])) {
          throw Error(`The first ${shape.length} dimensions of 'input_points' and 'input_labels' must be the same.`);
        }
        return new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_2__.Tensor("int64", input_labels.flat(Infinity).map(BigInt), shape);
      }
      async _call(images, {
        input_points = null,
        input_labels = null,
        input_boxes = null
      } = {}) {
        const processed = await super._call(images);
        if (input_points) {
          processed.input_points = this.reshape_input_points(input_points, processed.original_sizes, processed.reshaped_input_sizes);
        }
        if (input_labels) {
          if (!processed.input_points) {
            throw Error("`input_points` must be provided if `input_labels` are provided.");
          }
          processed.input_labels = this.add_input_labels(input_labels, processed.input_points);
        }
        if (input_boxes) {
          processed.input_boxes = this.reshape_input_points(input_boxes, processed.original_sizes, processed.reshaped_input_sizes, true);
        }
        return processed;
      }
      async post_process_masks(masks, original_sizes, reshaped_input_sizes, {
        mask_threshold = 0,
        binarize = true,
        pad_size = null
      } = {}) {
        const output_masks = [];
        pad_size = pad_size ?? this.pad_size ?? this.size;
        const target_image_size = [pad_size.height, pad_size.width];
        for (let i = 0;i < original_sizes.length; ++i) {
          const original_size = original_sizes[i];
          const reshaped_input_size = reshaped_input_sizes[i];
          let interpolated_mask = await (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_2__.interpolate_4d)(masks[i], { mode: "bilinear", size: target_image_size });
          interpolated_mask = interpolated_mask.slice(null, null, [0, reshaped_input_size[0]], [0, reshaped_input_size[1]]);
          interpolated_mask = await (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_2__.interpolate_4d)(interpolated_mask, { mode: "bilinear", size: original_size });
          if (binarize) {
            const data = interpolated_mask.data;
            const binarizedMaskData = new Uint8Array(data.length);
            for (let i2 = 0;i2 < data.length; ++i2) {
              if (data[i2] > mask_threshold) {
                binarizedMaskData[i2] = 1;
              }
            }
            interpolated_mask = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_2__.Tensor("bool", binarizedMaskData, interpolated_mask.dims);
          }
          output_masks.push(interpolated_mask);
        }
        return output_masks;
      }
      generate_crop_boxes(image, target_size, {
        crop_n_layers = 0,
        overlap_ratio = 512 / 1500,
        points_per_crop = 32,
        crop_n_points_downscale_factor = 1
      } = {}) {}
    }
  },
  "./src/models/sam/processing_sam.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!******************************************!*\
      !*** ./src/models/sam/processing_sam.js ***!
      \******************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      SamProcessor: () => SamProcessor
    });
    var _base_processing_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/processing_utils.js");
    /*! ../../base/processing_utils.js */
    var _auto_image_processing_auto_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/models/auto/image_processing_auto.js");
    /*! ../auto/image_processing_auto.js */

    class SamProcessor extends _base_processing_utils_js__WEBPACK_IMPORTED_MODULE_0__.Processor {
      static image_processor_class = _auto_image_processing_auto_js__WEBPACK_IMPORTED_MODULE_1__.AutoImageProcessor;
      async _call(...args) {
        return await this.image_processor(...args);
      }
      post_process_masks(...args) {
        return this.image_processor.post_process_masks(...args);
      }
      reshape_input_points(...args) {
        return this.image_processor.reshape_input_points(...args);
      }
    }
  },
  "./src/models/sam2/image_processing_sam2.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!**************************************************!*\
      !*** ./src/models/sam2/image_processing_sam2.js ***!
      \**************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      Sam2ImageProcessor: () => _sam_image_processing_sam_js__WEBPACK_IMPORTED_MODULE_0__.SamImageProcessor
    });
    var _sam_image_processing_sam_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/models/sam/image_processing_sam.js");
    /*! ../sam/image_processing_sam.js */
  },
  "./src/models/sam2/processing_sam2.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!********************************************!*\
      !*** ./src/models/sam2/processing_sam2.js ***!
      \********************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      Sam2Processor: () => Sam2Processor,
      Sam2VideoProcessor: () => Sam2VideoProcessor
    });
    var _sam_processing_sam_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/models/sam/processing_sam.js");
    /*! ../sam/processing_sam.js */

    class Sam2Processor extends _sam_processing_sam_js__WEBPACK_IMPORTED_MODULE_0__.SamProcessor {
    }

    class Sam2VideoProcessor extends Sam2Processor {
    }
  },
  "./src/models/sam3/image_processing_sam3.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!**************************************************!*\
      !*** ./src/models/sam3/image_processing_sam3.js ***!
      \**************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      Sam3ImageProcessor: () => _sam2_image_processing_sam2_js__WEBPACK_IMPORTED_MODULE_0__.Sam2ImageProcessor
    });
    var _sam2_image_processing_sam2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/models/sam2/image_processing_sam2.js");
    /*! ../sam2/image_processing_sam2.js */
  },
  "./src/models/seamless_m4t/feature_extraction_seamless_m4t.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!********************************************************************!*\
      !*** ./src/models/seamless_m4t/feature_extraction_seamless_m4t.js ***!
      \********************************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      SeamlessM4TFeatureExtractor: () => SeamlessM4TFeatureExtractor
    });
    var _base_feature_extraction_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/feature_extraction_utils.js");
    /*! ../../base/feature_extraction_utils.js */
    var _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/utils/tensor.js");
    /*! ../../utils/tensor.js */
    var _utils_audio_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/utils/audio.js");
    /*! ../../utils/audio.js */

    class SeamlessM4TFeatureExtractor extends _base_feature_extraction_utils_js__WEBPACK_IMPORTED_MODULE_0__.FeatureExtractor {
      constructor(config3) {
        super(config3);
        const sampling_rate = this.config.sampling_rate;
        const mel_filters = (0, _utils_audio_js__WEBPACK_IMPORTED_MODULE_2__.mel_filter_bank)(257, this.config.num_mel_bins, 20, Math.floor(sampling_rate / 2), sampling_rate, null, "kaldi", true);
        this.mel_filters = mel_filters;
        this.window = (0, _utils_audio_js__WEBPACK_IMPORTED_MODULE_2__.window_function)(400, "povey", {
          periodic: false
        });
      }
      async _extract_fbank_features(waveform, max_length) {
        waveform = waveform.map((x) => x * 32768);
        return (0, _utils_audio_js__WEBPACK_IMPORTED_MODULE_2__.spectrogram)(waveform, this.window, 400, 160, {
          fft_length: 512,
          power: 2,
          center: false,
          preemphasis: 0.97,
          mel_filters: this.mel_filters,
          log_mel: "log",
          mel_floor: 0.0000001192092955078125,
          remove_dc_offset: true,
          max_num_frames: max_length,
          transpose: true
        });
      }
      async _call(audio, {
        padding = true,
        pad_to_multiple_of = 2,
        do_normalize_per_mel_bins = true,
        return_attention_mask = true
      } = {}) {
        (0, _base_feature_extraction_utils_js__WEBPACK_IMPORTED_MODULE_0__.validate_audio_inputs)(audio, "SeamlessM4TFeatureExtractor");
        let features = await this._extract_fbank_features(audio, this.config.max_length);
        if (do_normalize_per_mel_bins) {
          const [num_features, feature_size] = features.dims;
          const data = features.data;
          for (let i = 0;i < feature_size; ++i) {
            let sum = 0;
            for (let j = 0;j < num_features; ++j) {
              sum += data[j * feature_size + i];
            }
            const mean = sum / num_features;
            let variance = 0;
            for (let j = 0;j < num_features; ++j) {
              variance += (data[j * feature_size + i] - mean) ** 2;
            }
            variance /= num_features - 1;
            const std = Math.sqrt(variance + 0.0000001);
            for (let j = 0;j < num_features; ++j) {
              const index = j * feature_size + i;
              data[index] = (data[index] - mean) / std;
            }
          }
        }
        let padded_attention_mask;
        if (padding) {
          const [num_frames2, num_channels2] = features.dims;
          const data = features.data;
          const pad_size = num_frames2 % pad_to_multiple_of;
          if (pad_size > 0) {
            const padded_data = new Float32Array(num_channels2 * (num_frames2 + pad_size));
            padded_data.set(data);
            padded_data.fill(this.config.padding_value, data.length);
            const numPaddedFrames = num_frames2 + pad_size;
            features = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__.Tensor(features.type, padded_data, [numPaddedFrames, num_channels2]);
            if (return_attention_mask) {
              padded_attention_mask = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__.Tensor("int64", new BigInt64Array(numPaddedFrames), [1, numPaddedFrames]);
              padded_attention_mask.data.fill(1n, 0, num_frames2);
            }
          }
        }
        const [num_frames, num_channels] = features.dims;
        const stride = this.config.stride;
        const remainder = num_frames % stride;
        if (remainder !== 0) {
          throw new Error(`The number of frames (${num_frames}) must be a multiple of the stride (${stride}).`);
        }
        const input_features = features.view(1, Math.floor(num_frames / stride), num_channels * stride);
        const result = { input_features };
        if (return_attention_mask) {
          const reshapedNumFrames = input_features.dims[1];
          const attention_mask_data = new BigInt64Array(reshapedNumFrames);
          if (padded_attention_mask) {
            const padded_attention_mask_data = padded_attention_mask.data;
            for (let i = 1, j = 0;i < num_frames; i += stride, ++j) {
              attention_mask_data[j] = padded_attention_mask_data[i];
            }
          } else {
            attention_mask_data.fill(1n);
          }
          result.attention_mask = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__.Tensor("int64", attention_mask_data, [1, reshapedNumFrames]);
        }
        return result;
      }
    }
  },
  "./src/models/segformer/image_processing_segformer.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!************************************************************!*\
      !*** ./src/models/segformer/image_processing_segformer.js ***!
      \************************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      SegformerFeatureExtractor: () => SegformerFeatureExtractor,
      SegformerImageProcessor: () => SegformerImageProcessor
    });
    var _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/image_processors_utils.js");
    /*! ../../base/image_processors_utils.js */

    class SegformerImageProcessor extends _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__.ImageProcessor {
      post_process_semantic_segmentation(...args) {
        return (0, _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__.post_process_semantic_segmentation)(...args);
      }
    }

    class SegformerFeatureExtractor extends SegformerImageProcessor {
    }
  },
  "./src/models/siglip/image_processing_siglip.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!******************************************************!*\
      !*** ./src/models/siglip/image_processing_siglip.js ***!
      \******************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      SiglipImageProcessor: () => SiglipImageProcessor
    });
    var _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/image_processors_utils.js");
    /*! ../../base/image_processors_utils.js */

    class SiglipImageProcessor extends _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__.ImageProcessor {
    }
  },
  "./src/models/smolvlm/image_processing_smolvlm.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!********************************************************!*\
      !*** ./src/models/smolvlm/image_processing_smolvlm.js ***!
      \********************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      SmolVLMImageProcessor: () => _idefics3_image_processing_idefics3_js__WEBPACK_IMPORTED_MODULE_0__.Idefics3ImageProcessor
    });
    var _idefics3_image_processing_idefics3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/models/idefics3/image_processing_idefics3.js");
    /*! ../idefics3/image_processing_idefics3.js */
  },
  "./src/models/smolvlm/processing_smolvlm.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!**************************************************!*\
      !*** ./src/models/smolvlm/processing_smolvlm.js ***!
      \**************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      SmolVLMProcessor: () => _idefics3_processing_idefics3_js__WEBPACK_IMPORTED_MODULE_0__.Idefics3Processor
    });
    var _idefics3_processing_idefics3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/models/idefics3/processing_idefics3.js");
    /*! ../idefics3/processing_idefics3.js */
  },
  "./src/models/snac/feature_extraction_snac.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!****************************************************!*\
      !*** ./src/models/snac/feature_extraction_snac.js ***!
      \****************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      SnacFeatureExtractor: () => SnacFeatureExtractor
    });
    var _dac_feature_extraction_dac_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/models/dac/feature_extraction_dac.js");
    /*! ../dac/feature_extraction_dac.js */

    class SnacFeatureExtractor extends _dac_feature_extraction_dac_js__WEBPACK_IMPORTED_MODULE_0__.DacFeatureExtractor {
    }
  },
  "./src/models/speecht5/feature_extraction_speecht5.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!************************************************************!*\
      !*** ./src/models/speecht5/feature_extraction_speecht5.js ***!
      \************************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      SpeechT5FeatureExtractor: () => SpeechT5FeatureExtractor
    });
    var _base_feature_extraction_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/feature_extraction_utils.js");
    /*! ../../base/feature_extraction_utils.js */

    class SpeechT5FeatureExtractor extends _base_feature_extraction_utils_js__WEBPACK_IMPORTED_MODULE_0__.FeatureExtractor {
    }
  },
  "./src/models/speecht5/processing_speecht5.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!****************************************************!*\
      !*** ./src/models/speecht5/processing_speecht5.js ***!
      \****************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      SpeechT5Processor: () => SpeechT5Processor
    });
    var _base_processing_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/processing_utils.js");
    /*! ../../base/processing_utils.js */
    var _tokenizers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/tokenizers.js");
    /*! ../../tokenizers.js */
    var _auto_feature_extraction_auto_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/models/auto/feature_extraction_auto.js");
    /*! ../auto/feature_extraction_auto.js */

    class SpeechT5Processor extends _base_processing_utils_js__WEBPACK_IMPORTED_MODULE_0__.Processor {
      static tokenizer_class = _tokenizers_js__WEBPACK_IMPORTED_MODULE_1__.AutoTokenizer;
      static feature_extractor_class = _auto_feature_extraction_auto_js__WEBPACK_IMPORTED_MODULE_2__.AutoFeatureExtractor;
      async _call(input) {
        return await this.feature_extractor(input);
      }
    }
  },
  "./src/models/swin2sr/image_processing_swin2sr.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!********************************************************!*\
      !*** ./src/models/swin2sr/image_processing_swin2sr.js ***!
      \********************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      Swin2SRImageProcessor: () => Swin2SRImageProcessor
    });
    var _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/image_processors_utils.js");
    /*! ../../base/image_processors_utils.js */

    class Swin2SRImageProcessor extends _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__.ImageProcessor {
      pad_image(pixelData, imgDims, padSize, options2 = {}) {
        const [imageHeight, imageWidth, imageChannels] = imgDims;
        return super.pad_image(pixelData, imgDims, {
          width: imageWidth + (padSize - imageWidth % padSize) % padSize,
          height: imageHeight + (padSize - imageHeight % padSize) % padSize
        }, {
          mode: "symmetric",
          center: false,
          constant_values: -1,
          ...options2
        });
      }
    }
  },
  "./src/models/ultravox/processing_ultravox.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!****************************************************!*\
      !*** ./src/models/ultravox/processing_ultravox.js ***!
      \****************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      UltravoxProcessor: () => UltravoxProcessor
    });
    var _auto_feature_extraction_auto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/models/auto/feature_extraction_auto.js");
    /*! ../auto/feature_extraction_auto.js */
    var _tokenizers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/tokenizers.js");
    /*! ../../tokenizers.js */
    var _base_processing_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/base/processing_utils.js");
    /*! ../../base/processing_utils.js */

    class UltravoxProcessor extends _base_processing_utils_js__WEBPACK_IMPORTED_MODULE_2__.Processor {
      static tokenizer_class = _tokenizers_js__WEBPACK_IMPORTED_MODULE_1__.AutoTokenizer;
      static feature_extractor_class = _auto_feature_extraction_auto_js__WEBPACK_IMPORTED_MODULE_0__.AutoFeatureExtractor;
      static uses_processor_config = true;
      async _call(text, audio = null, kwargs = {}) {
        if (Array.isArray(text)) {
          throw new Error("Batched inputs are not supported yet.");
        }
        let audio_inputs = {};
        if (audio) {
          const audio_len = audio.length;
          const { input_features } = await this.feature_extractor(audio, {
            ...kwargs,
            max_length: audio_len
          });
          const nb_encoder_frames = Math.round(audio_len / this.config.encoder_ds_factor + 0.0001);
          const audio_embed_frames = 1 + Math.ceil(nb_encoder_frames / this.config.stack_factor);
          audio_inputs["audio_token_len"] = [audio_embed_frames];
          audio_inputs["audio_values"] = input_features;
          const image_token = this.config.audio_placeholder;
          if (!text.includes(image_token)) {
            throw new Error(`The input text does not contain the image token ${image_token}.`);
          }
          text = text.replaceAll(image_token, image_token.repeat(audio_embed_frames));
        }
        const text_inputs = this.tokenizer(text, {
          add_special_tokens: false,
          ...kwargs
        });
        return {
          ...text_inputs,
          ...audio_inputs
        };
      }
    }
  },
  "./src/models/vit/image_processing_vit.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!************************************************!*\
      !*** ./src/models/vit/image_processing_vit.js ***!
      \************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      ViTFeatureExtractor: () => ViTFeatureExtractor,
      ViTImageProcessor: () => ViTImageProcessor
    });
    var _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/image_processors_utils.js");
    /*! ../../base/image_processors_utils.js */

    class ViTImageProcessor extends _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__.ImageProcessor {
    }

    class ViTFeatureExtractor extends ViTImageProcessor {
    }
  },
  "./src/models/vitmatte/image_processing_vitmatte.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!**********************************************************!*\
      !*** ./src/models/vitmatte/image_processing_vitmatte.js ***!
      \**********************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      VitMatteImageProcessor: () => VitMatteImageProcessor
    });
    var _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/image_processors_utils.js");
    /*! ../../base/image_processors_utils.js */
    var _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/utils/tensor.js");
    /*! ../../utils/tensor.js */

    class VitMatteImageProcessor extends _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__.ImageProcessor {
      async _call(images, trimaps) {
        if (!Array.isArray(images)) {
          images = [images];
        }
        if (!Array.isArray(trimaps)) {
          trimaps = [trimaps];
        }
        const imageData = await Promise.all(images.map((x) => this.preprocess(x)));
        const trimapData = await Promise.all(trimaps.map((x) => this.preprocess(x, {
          do_normalize: false,
          do_convert_rgb: false,
          do_convert_grayscale: true
        })));
        const pixel_values = (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__.stack)(imageData.map((x, i) => (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__.cat)([x.pixel_values, trimapData[i].pixel_values], 0)), 0);
        return {
          pixel_values,
          original_sizes: imageData.map((x) => x.original_size),
          reshaped_input_sizes: imageData.map((x) => x.reshaped_input_size)
        };
      }
    }
  },
  "./src/models/vitpose/image_processing_vitpose.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!********************************************************!*\
      !*** ./src/models/vitpose/image_processing_vitpose.js ***!
      \********************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      VitPoseImageProcessor: () => VitPoseImageProcessor
    });
    var _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/image_processors_utils.js");
    /*! ../../base/image_processors_utils.js */

    class VitPoseImageProcessor extends _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__.ImageProcessor {
      post_process_pose_estimation(outputs, boxes, {
        threshold = null
      } = {}) {
        const heatmaps = outputs.tolist();
        const [batch_size, num_classes, height, width] = outputs.dims;
        const results = [];
        for (let b = 0;b < batch_size; ++b) {
          const heatmap = heatmaps[b];
          const bboxes = boxes[b];
          const batch_results = [];
          for (let n = 0;n < bboxes.length; ++n) {
            const bbox = bboxes[n];
            const keypoints = [];
            const scores = [];
            const labels = [];
            const xScale = bbox.at(-2) / width;
            const yScale = bbox.at(-1) / height;
            for (let c = 0;c < heatmap.length; ++c) {
              let [xWeightedSum, yWeightedSum] = [0, 0];
              let sum = 0;
              let score = -Infinity;
              const row = heatmap[c];
              for (let y = 0;y < row.length; ++y) {
                const col = row[y];
                for (let x = 0;x < col.length; ++x) {
                  const value = col[x];
                  sum += value;
                  score = Math.max(score, value);
                  xWeightedSum += (x + 0.5) * value;
                  yWeightedSum += y * value;
                }
              }
              if (threshold != null && score < threshold)
                continue;
              const keypoint = [
                xScale * xWeightedSum / sum,
                yScale * yWeightedSum / sum
              ];
              keypoints.push(keypoint);
              labels.push(c);
              scores.push(score);
            }
            batch_results.push({
              bbox,
              scores,
              labels,
              keypoints
            });
          }
          results.push(batch_results);
        }
        return results;
      }
    }
  },
  "./src/models/voxtral/processing_voxtral.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!**************************************************!*\
      !*** ./src/models/voxtral/processing_voxtral.js ***!
      \**************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      VoxtralProcessor: () => VoxtralProcessor
    });
    var _auto_feature_extraction_auto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/models/auto/feature_extraction_auto.js");
    /*! ../auto/feature_extraction_auto.js */
    var _tokenizers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/tokenizers.js");
    /*! ../../tokenizers.js */
    var _base_processing_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/base/processing_utils.js");
    /*! ../../base/processing_utils.js */
    var _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/utils/tensor.js");
    /*! ../../utils/tensor.js */
    const AUDIO_TOKEN = "[AUDIO]";
    const BEGIN_AUDIO_TOKEN = "[BEGIN_AUDIO]";
    const NUM_AUDIO_TOKENS = 375;
    function chunk(audio, n_samples) {
      const chunks = [];
      for (let i = 0;i < audio.length; i += n_samples) {
        chunks.push(audio.subarray(i, Math.min(i + n_samples, audio.length)));
      }
      return chunks;
    }

    class VoxtralProcessor extends _base_processing_utils_js__WEBPACK_IMPORTED_MODULE_2__.Processor {
      static tokenizer_class = _tokenizers_js__WEBPACK_IMPORTED_MODULE_1__.AutoTokenizer;
      static feature_extractor_class = _auto_feature_extraction_auto_js__WEBPACK_IMPORTED_MODULE_0__.AutoFeatureExtractor;
      static uses_processor_config = false;
      async _call(text, audio = null, kwargs = {}) {
        if (Array.isArray(text)) {
          throw new Error("Batched inputs are not supported yet.");
        }
        const audio_inputs = {};
        if (audio) {
          if (!text.includes(AUDIO_TOKEN)) {
            throw new Error(`The input text does not contain the audio token ${AUDIO_TOKEN}.`);
          }
          if (!Array.isArray(audio)) {
            audio = [audio];
          }
          const text_parts = text.split(AUDIO_TOKEN);
          const num_audio_tokens = text_parts.length - 1;
          if (num_audio_tokens !== audio.length) {
            throw new Error(`The number of audio inputs (${audio.length}) does not match the number of audio tokens in the text (${num_audio_tokens}).`);
          }
          const n_samples = this.feature_extractor.config.n_samples;
          const audio_chunks = audio.map((a) => chunk(a, n_samples));
          const chunk_counts = audio_chunks.map((chunks) => chunks.length);
          const all_chunks = audio_chunks.flat();
          const features = (await Promise.all(all_chunks.map((audio_input) => this.feature_extractor(audio_input, kwargs)))).map((x) => x.input_features);
          audio_inputs["audio_values"] = features.length > 1 ? (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.cat)(features, 0) : features[0];
          let new_text = text_parts[0];
          for (let i = 0;i < chunk_counts.length; ++i) {
            new_text += BEGIN_AUDIO_TOKEN;
            for (let j = 0;j < chunk_counts[i]; ++j) {
              new_text += AUDIO_TOKEN.repeat(NUM_AUDIO_TOKENS);
            }
            new_text += text_parts[i + 1];
          }
          text = new_text;
        }
        const text_inputs = this.tokenizer(text, {
          add_special_tokens: false,
          ...kwargs
        });
        return {
          ...text_inputs,
          ...audio_inputs
        };
      }
    }
  },
  "./src/models/wav2vec2/feature_extraction_wav2vec2.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!************************************************************!*\
      !*** ./src/models/wav2vec2/feature_extraction_wav2vec2.js ***!
      \************************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      Wav2Vec2FeatureExtractor: () => Wav2Vec2FeatureExtractor
    });
    var _base_feature_extraction_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/feature_extraction_utils.js");
    /*! ../../base/feature_extraction_utils.js */
    var _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/utils/tensor.js");
    /*! ../../utils/tensor.js */

    class Wav2Vec2FeatureExtractor extends _base_feature_extraction_utils_js__WEBPACK_IMPORTED_MODULE_0__.FeatureExtractor {
      _zero_mean_unit_var_norm(input_values) {
        const sum = input_values.reduce((a, b) => a + b, 0);
        const mean = sum / input_values.length;
        const variance = input_values.reduce((a, b) => a + (b - mean) ** 2, 0) / input_values.length;
        return input_values.map((x) => (x - mean) / Math.sqrt(variance + 0.0000001));
      }
      async _call(audio) {
        (0, _base_feature_extraction_utils_js__WEBPACK_IMPORTED_MODULE_0__.validate_audio_inputs)(audio, "Wav2Vec2FeatureExtractor");
        if (audio instanceof Float64Array) {
          audio = new Float32Array(audio);
        }
        let input_values = audio;
        if (this.config.do_normalize) {
          input_values = this._zero_mean_unit_var_norm(input_values);
        }
        const shape = [1, input_values.length];
        return {
          input_values: new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__.Tensor("float32", input_values, shape),
          attention_mask: new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__.Tensor("int64", new BigInt64Array(input_values.length).fill(1n), shape)
        };
      }
    }
  },
  "./src/models/wav2vec2/processing_wav2vec2.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!****************************************************!*\
      !*** ./src/models/wav2vec2/processing_wav2vec2.js ***!
      \****************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      Wav2Vec2Processor: () => Wav2Vec2Processor
    });
    var _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/tokenizers.js");
    /*! ../../tokenizers.js */
    var _auto_feature_extraction_auto_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/models/auto/feature_extraction_auto.js");
    /*! ../auto/feature_extraction_auto.js */
    var _base_processing_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/base/processing_utils.js");
    /*! ../../base/processing_utils.js */

    class Wav2Vec2Processor extends _base_processing_utils_js__WEBPACK_IMPORTED_MODULE_2__.Processor {
      static tokenizer_class = _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer;
      static feature_extractor_class = _auto_feature_extraction_auto_js__WEBPACK_IMPORTED_MODULE_1__.AutoFeatureExtractor;
      async _call(audio) {
        return await this.feature_extractor(audio);
      }
    }
  },
  "./src/models/wav2vec2_with_lm/processing_wav2vec2_with_lm.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!********************************************************************!*\
      !*** ./src/models/wav2vec2_with_lm/processing_wav2vec2_with_lm.js ***!
      \********************************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      Wav2Vec2ProcessorWithLM: () => Wav2Vec2ProcessorWithLM
    });
    var _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/tokenizers.js");
    /*! ../../tokenizers.js */
    var _auto_feature_extraction_auto_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/models/auto/feature_extraction_auto.js");
    /*! ../auto/feature_extraction_auto.js */
    var _base_processing_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/base/processing_utils.js");
    /*! ../../base/processing_utils.js */

    class Wav2Vec2ProcessorWithLM extends _base_processing_utils_js__WEBPACK_IMPORTED_MODULE_2__.Processor {
      static tokenizer_class = _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer;
      static feature_extractor_class = _auto_feature_extraction_auto_js__WEBPACK_IMPORTED_MODULE_1__.AutoFeatureExtractor;
      async _call(audio) {
        return await this.feature_extractor(audio);
      }
    }
  },
  "./src/models/wespeaker/feature_extraction_wespeaker.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!**************************************************************!*\
      !*** ./src/models/wespeaker/feature_extraction_wespeaker.js ***!
      \**************************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      WeSpeakerFeatureExtractor: () => WeSpeakerFeatureExtractor
    });
    var _base_feature_extraction_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/feature_extraction_utils.js");
    /*! ../../base/feature_extraction_utils.js */
    var _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/utils/tensor.js");
    /*! ../../utils/tensor.js */
    var _utils_audio_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/utils/audio.js");
    /*! ../../utils/audio.js */

    class WeSpeakerFeatureExtractor extends _base_feature_extraction_utils_js__WEBPACK_IMPORTED_MODULE_0__.FeatureExtractor {
      constructor(config3) {
        super(config3);
        const sampling_rate = this.config.sampling_rate;
        const mel_filters = (0, _utils_audio_js__WEBPACK_IMPORTED_MODULE_2__.mel_filter_bank)(257, this.config.num_mel_bins, 20, Math.floor(sampling_rate / 2), sampling_rate, null, "kaldi", true);
        this.mel_filters = mel_filters;
        this.window = (0, _utils_audio_js__WEBPACK_IMPORTED_MODULE_2__.window_function)(400, "hamming", {
          periodic: false
        });
        this.min_num_frames = this.config.min_num_frames;
      }
      async _extract_fbank_features(waveform) {
        waveform = waveform.map((x) => x * 32768);
        return (0, _utils_audio_js__WEBPACK_IMPORTED_MODULE_2__.spectrogram)(waveform, this.window, 400, 160, {
          fft_length: 512,
          power: 2,
          center: false,
          preemphasis: 0.97,
          mel_filters: this.mel_filters,
          log_mel: "log",
          mel_floor: 0.0000001192092955078125,
          remove_dc_offset: true,
          transpose: true,
          min_num_frames: this.min_num_frames
        });
      }
      async _call(audio) {
        (0, _base_feature_extraction_utils_js__WEBPACK_IMPORTED_MODULE_0__.validate_audio_inputs)(audio, "WeSpeakerFeatureExtractor");
        const features = (await this._extract_fbank_features(audio)).unsqueeze_(0);
        if (this.config.fbank_centering_span === null) {
          const meanData = features.mean(1).data;
          const featuresData = features.data;
          const [batch_size, num_frames, feature_size] = features.dims;
          for (let i = 0;i < batch_size; ++i) {
            const offset1 = i * num_frames * feature_size;
            const offset2 = i * feature_size;
            for (let j = 0;j < num_frames; ++j) {
              const offset3 = offset1 + j * feature_size;
              for (let k = 0;k < feature_size; ++k) {
                featuresData[offset3 + k] -= meanData[offset2 + k];
              }
            }
          }
        }
        return {
          input_features: features
        };
      }
    }
  },
  "./src/models/whisper/common_whisper.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!**********************************************!*\
      !*** ./src/models/whisper/common_whisper.js ***!
      \**********************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      WHISPER_LANGUAGE_MAPPING: () => WHISPER_LANGUAGE_MAPPING,
      WHISPER_TO_LANGUAGE_CODE_MAPPING: () => WHISPER_TO_LANGUAGE_CODE_MAPPING,
      whisper_language_to_code: () => whisper_language_to_code
    });
    const WHISPER_LANGUAGES = [
      ["en", "english"],
      ["zh", "chinese"],
      ["de", "german"],
      ["es", "spanish"],
      ["ru", "russian"],
      ["ko", "korean"],
      ["fr", "french"],
      ["ja", "japanese"],
      ["pt", "portuguese"],
      ["tr", "turkish"],
      ["pl", "polish"],
      ["ca", "catalan"],
      ["nl", "dutch"],
      ["ar", "arabic"],
      ["sv", "swedish"],
      ["it", "italian"],
      ["id", "indonesian"],
      ["hi", "hindi"],
      ["fi", "finnish"],
      ["vi", "vietnamese"],
      ["he", "hebrew"],
      ["uk", "ukrainian"],
      ["el", "greek"],
      ["ms", "malay"],
      ["cs", "czech"],
      ["ro", "romanian"],
      ["da", "danish"],
      ["hu", "hungarian"],
      ["ta", "tamil"],
      ["no", "norwegian"],
      ["th", "thai"],
      ["ur", "urdu"],
      ["hr", "croatian"],
      ["bg", "bulgarian"],
      ["lt", "lithuanian"],
      ["la", "latin"],
      ["mi", "maori"],
      ["ml", "malayalam"],
      ["cy", "welsh"],
      ["sk", "slovak"],
      ["te", "telugu"],
      ["fa", "persian"],
      ["lv", "latvian"],
      ["bn", "bengali"],
      ["sr", "serbian"],
      ["az", "azerbaijani"],
      ["sl", "slovenian"],
      ["kn", "kannada"],
      ["et", "estonian"],
      ["mk", "macedonian"],
      ["br", "breton"],
      ["eu", "basque"],
      ["is", "icelandic"],
      ["hy", "armenian"],
      ["ne", "nepali"],
      ["mn", "mongolian"],
      ["bs", "bosnian"],
      ["kk", "kazakh"],
      ["sq", "albanian"],
      ["sw", "swahili"],
      ["gl", "galician"],
      ["mr", "marathi"],
      ["pa", "punjabi"],
      ["si", "sinhala"],
      ["km", "khmer"],
      ["sn", "shona"],
      ["yo", "yoruba"],
      ["so", "somali"],
      ["af", "afrikaans"],
      ["oc", "occitan"],
      ["ka", "georgian"],
      ["be", "belarusian"],
      ["tg", "tajik"],
      ["sd", "sindhi"],
      ["gu", "gujarati"],
      ["am", "amharic"],
      ["yi", "yiddish"],
      ["lo", "lao"],
      ["uz", "uzbek"],
      ["fo", "faroese"],
      ["ht", "haitian creole"],
      ["ps", "pashto"],
      ["tk", "turkmen"],
      ["nn", "nynorsk"],
      ["mt", "maltese"],
      ["sa", "sanskrit"],
      ["lb", "luxembourgish"],
      ["my", "myanmar"],
      ["bo", "tibetan"],
      ["tl", "tagalog"],
      ["mg", "malagasy"],
      ["as", "assamese"],
      ["tt", "tatar"],
      ["haw", "hawaiian"],
      ["ln", "lingala"],
      ["ha", "hausa"],
      ["ba", "bashkir"],
      ["jw", "javanese"],
      ["su", "sundanese"]
    ];
    const WHISPER_LANGUAGE_MAPPING = new Map(WHISPER_LANGUAGES);
    const WHISPER_TO_LANGUAGE_CODE_MAPPING = new Map([
      ...WHISPER_LANGUAGES.map(([k, v]) => [v, k]),
      ...[
        ["burmese", "my"],
        ["valencian", "ca"],
        ["flemish", "nl"],
        ["haitian", "ht"],
        ["letzeburgesch", "lb"],
        ["pushto", "ps"],
        ["panjabi", "pa"],
        ["moldavian", "ro"],
        ["moldovan", "ro"],
        ["sinhalese", "si"],
        ["castilian", "es"]
      ]
    ]);
    function whisper_language_to_code(language) {
      language = language.toLowerCase();
      let language_code = WHISPER_TO_LANGUAGE_CODE_MAPPING.get(language);
      if (language_code === undefined) {
        const language_special_token = language.match(/^<\|([a-z]{2})\|>$/);
        if (language_special_token) {
          language = language_special_token[1];
        }
        if (WHISPER_LANGUAGE_MAPPING.has(language)) {
          language_code = language;
        } else {
          const is_language_code = language.length === 2;
          const langs = is_language_code ? WHISPER_LANGUAGE_MAPPING.keys() : WHISPER_LANGUAGE_MAPPING.values();
          throw new Error(`Language "${language}" is not supported. Must be one of: ${JSON.stringify(Array.from(langs))}`);
        }
      }
      return language_code;
    }
  },
  "./src/models/whisper/feature_extraction_whisper.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!**********************************************************!*\
      !*** ./src/models/whisper/feature_extraction_whisper.js ***!
      \**********************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      WhisperFeatureExtractor: () => WhisperFeatureExtractor
    });
    var _base_feature_extraction_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/feature_extraction_utils.js");
    /*! ../../base/feature_extraction_utils.js */
    var _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/utils/tensor.js");
    /*! ../../utils/tensor.js */
    var _utils_audio_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/utils/audio.js");
    /*! ../../utils/audio.js */
    var _utils_maths_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/utils/maths.js");
    /*! ../../utils/maths.js */

    class WhisperFeatureExtractor extends _base_feature_extraction_utils_js__WEBPACK_IMPORTED_MODULE_0__.FeatureExtractor {
      constructor(config3) {
        super(config3);
        this.config.mel_filters ??= (0, _utils_audio_js__WEBPACK_IMPORTED_MODULE_2__.mel_filter_bank)(Math.floor(1 + this.config.n_fft / 2), this.config.feature_size, 0, 8000, this.config.sampling_rate, "slaney", "slaney");
        this.window = (0, _utils_audio_js__WEBPACK_IMPORTED_MODULE_2__.window_function)(this.config.n_fft, "hann");
      }
      async _extract_fbank_features(waveform) {
        const features = await (0, _utils_audio_js__WEBPACK_IMPORTED_MODULE_2__.spectrogram)(waveform, this.window, this.config.n_fft, this.config.hop_length, {
          power: 2,
          mel_filters: this.config.mel_filters,
          log_mel: "log10",
          max_num_frames: Math.min(Math.floor(waveform.length / this.config.hop_length), this.config.nb_max_frames)
        });
        const data = features.data;
        const maxValue = (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_3__.max)(data)[0];
        for (let i = 0;i < data.length; ++i) {
          data[i] = (Math.max(data[i], maxValue - 8) + 4) / 4;
        }
        return features;
      }
      async _call(audio, {
        max_length = null
      } = {}) {
        (0, _base_feature_extraction_utils_js__WEBPACK_IMPORTED_MODULE_0__.validate_audio_inputs)(audio, "WhisperFeatureExtractor");
        let waveform;
        const length = max_length ?? this.config.n_samples;
        if (audio.length > length) {
          if (audio.length > this.config.n_samples) {
            console.warn("Attempting to extract features for audio longer than 30 seconds. " + "If using a pipeline to extract transcript from a long audio clip, " + "remember to specify `chunk_length_s` and/or `stride_length_s`.");
          }
          waveform = audio.slice(0, length);
        } else {
          waveform = new Float32Array(length);
          waveform.set(audio);
        }
        const features = await this._extract_fbank_features(waveform);
        return {
          input_features: features.unsqueeze_(0)
        };
      }
    }
  },
  "./src/models/whisper/generation_whisper.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!**************************************************!*\
      !*** ./src/models/whisper/generation_whisper.js ***!
      \**************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      WhisperGenerationConfig: () => WhisperGenerationConfig
    });
    var _generation_configuration_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/generation/configuration_utils.js");
    /*! ../../generation/configuration_utils.js */

    class WhisperGenerationConfig extends _generation_configuration_utils_js__WEBPACK_IMPORTED_MODULE_0__.GenerationConfig {
      return_timestamps = null;
      return_token_timestamps = null;
      num_frames = null;
      alignment_heads = null;
      task = null;
      language = null;
      no_timestamps_token_id = null;
      prompt_ids = null;
      is_multilingual = null;
      lang_to_id = null;
      task_to_id = null;
      max_initial_timestamp_index = 1;
    }
  },
  "./src/models/whisper/processing_whisper.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!**************************************************!*\
      !*** ./src/models/whisper/processing_whisper.js ***!
      \**************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      WhisperProcessor: () => WhisperProcessor
    });
    var _auto_feature_extraction_auto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/models/auto/feature_extraction_auto.js");
    /*! ../auto/feature_extraction_auto.js */
    var _tokenizers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/tokenizers.js");
    /*! ../../tokenizers.js */
    var _base_processing_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/base/processing_utils.js");
    /*! ../../base/processing_utils.js */

    class WhisperProcessor extends _base_processing_utils_js__WEBPACK_IMPORTED_MODULE_2__.Processor {
      static tokenizer_class = _tokenizers_js__WEBPACK_IMPORTED_MODULE_1__.AutoTokenizer;
      static feature_extractor_class = _auto_feature_extraction_auto_js__WEBPACK_IMPORTED_MODULE_0__.AutoFeatureExtractor;
      async _call(audio) {
        return await this.feature_extractor(audio);
      }
    }
  },
  "./src/models/yolos/image_processing_yolos.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!****************************************************!*\
      !*** ./src/models/yolos/image_processing_yolos.js ***!
      \****************************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      YolosFeatureExtractor: () => YolosFeatureExtractor,
      YolosImageProcessor: () => YolosImageProcessor
    });
    var _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/base/image_processors_utils.js");
    /*! ../../base/image_processors_utils.js */

    class YolosImageProcessor extends _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__.ImageProcessor {
      post_process_object_detection(...args) {
        return (0, _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_0__.post_process_object_detection)(...args);
      }
    }

    class YolosFeatureExtractor extends YolosImageProcessor {
    }
  },
  "./src/ops/registry.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!*****************************!*\
      !*** ./src/ops/registry.js ***!
      \*****************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      TensorOpRegistry: () => TensorOpRegistry
    });
    var _backends_onnx_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/backends/onnx.js");
    /*! ../backends/onnx.js */
    var _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/utils/tensor.js");
    /*! ../utils/tensor.js */
    const wrap2 = async (session_bytes, session_options, names) => {
      const session = await (0, _backends_onnx_js__WEBPACK_IMPORTED_MODULE_0__.createInferenceSession)(new Uint8Array(session_bytes), session_options);
      return async (inputs) => {
        const proxied = (0, _backends_onnx_js__WEBPACK_IMPORTED_MODULE_0__.isONNXProxy)();
        const ortFeed = Object.fromEntries(Object.entries(inputs).map(([k, v]) => [k, (proxied ? v.clone() : v).ort_tensor]));
        const outputs = await (0, _backends_onnx_js__WEBPACK_IMPORTED_MODULE_0__.runInferenceSession)(session, ortFeed);
        if (Array.isArray(names)) {
          return names.map((n) => new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__.Tensor(outputs[n]));
        } else {
          return new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_1__.Tensor(outputs[names]);
        }
      };
    };

    class TensorOpRegistry {
      static session_options = {};
      static get nearest_interpolate_4d() {
        if (!this._nearest_interpolate_4d) {
          this._nearest_interpolate_4d = wrap2([8, 10, 18, 0, 58, 129, 1, 10, 41, 10, 1, 120, 10, 0, 10, 0, 10, 1, 115, 18, 1, 121, 34, 6, 82, 101, 115, 105, 122, 101, 42, 18, 10, 4, 109, 111, 100, 101, 34, 7, 110, 101, 97, 114, 101, 115, 116, 160, 1, 3, 18, 1, 114, 90, 31, 10, 1, 120, 18, 26, 10, 24, 8, 1, 18, 20, 10, 3, 18, 1, 98, 10, 3, 18, 1, 99, 10, 3, 18, 1, 104, 10, 3, 18, 1, 119, 90, 15, 10, 1, 115, 18, 10, 10, 8, 8, 7, 18, 4, 10, 2, 8, 4, 98, 31, 10, 1, 121, 18, 26, 10, 24, 8, 1, 18, 20, 10, 3, 18, 1, 98, 10, 3, 18, 1, 99, 10, 3, 18, 1, 104, 10, 3, 18, 1, 119, 66, 2, 16, 21], this.session_options, "y");
        }
        return this._nearest_interpolate_4d;
      }
      static get bilinear_interpolate_4d() {
        if (!this._bilinear_interpolate_4d) {
          this._bilinear_interpolate_4d = wrap2([8, 9, 18, 0, 58, 128, 1, 10, 40, 10, 1, 120, 10, 0, 10, 0, 10, 1, 115, 18, 1, 121, 34, 6, 82, 101, 115, 105, 122, 101, 42, 17, 10, 4, 109, 111, 100, 101, 34, 6, 108, 105, 110, 101, 97, 114, 160, 1, 3, 18, 1, 114, 90, 31, 10, 1, 120, 18, 26, 10, 24, 8, 1, 18, 20, 10, 3, 18, 1, 98, 10, 3, 18, 1, 99, 10, 3, 18, 1, 104, 10, 3, 18, 1, 119, 90, 15, 10, 1, 115, 18, 10, 10, 8, 8, 7, 18, 4, 10, 2, 8, 4, 98, 31, 10, 1, 121, 18, 26, 10, 24, 8, 1, 18, 20, 10, 3, 18, 1, 98, 10, 3, 18, 1, 99, 10, 3, 18, 1, 104, 10, 3, 18, 1, 119, 66, 2, 16, 20], this.session_options, "y");
        }
        return this._bilinear_interpolate_4d;
      }
      static get bicubic_interpolate_4d() {
        if (!this._bicubic_interpolate_4d) {
          this._bicubic_interpolate_4d = wrap2([8, 9, 18, 0, 58, 127, 10, 39, 10, 1, 120, 10, 0, 10, 0, 10, 1, 115, 18, 1, 121, 34, 6, 82, 101, 115, 105, 122, 101, 42, 16, 10, 4, 109, 111, 100, 101, 34, 5, 99, 117, 98, 105, 99, 160, 1, 3, 18, 1, 114, 90, 31, 10, 1, 120, 18, 26, 10, 24, 8, 1, 18, 20, 10, 3, 18, 1, 98, 10, 3, 18, 1, 99, 10, 3, 18, 1, 104, 10, 3, 18, 1, 119, 90, 15, 10, 1, 115, 18, 10, 10, 8, 8, 7, 18, 4, 10, 2, 8, 4, 98, 31, 10, 1, 121, 18, 26, 10, 24, 8, 1, 18, 20, 10, 3, 18, 1, 98, 10, 3, 18, 1, 99, 10, 3, 18, 1, 104, 10, 3, 18, 1, 119, 66, 2, 16, 20], this.session_options, "y");
        }
        return this._bicubic_interpolate_4d;
      }
      static get matmul() {
        if (!this._matmul) {
          this._matmul = wrap2([8, 9, 18, 0, 58, 55, 10, 17, 10, 1, 97, 10, 1, 98, 18, 1, 99, 34, 6, 77, 97, 116, 77, 117, 108, 18, 1, 114, 90, 9, 10, 1, 97, 18, 4, 10, 2, 8, 1, 90, 9, 10, 1, 98, 18, 4, 10, 2, 8, 1, 98, 9, 10, 1, 99, 18, 4, 10, 2, 8, 1, 66, 2, 16, 20], this.session_options, "c");
        }
        return this._matmul;
      }
      static get stft() {
        if (!this._stft) {
          this._stft = wrap2([8, 7, 18, 0, 58, 148, 1, 10, 38, 10, 1, 115, 10, 1, 106, 10, 1, 119, 10, 1, 108, 18, 1, 111, 34, 4, 83, 84, 70, 84, 42, 15, 10, 8, 111, 110, 101, 115, 105, 100, 101, 100, 24, 1, 160, 1, 2, 18, 1, 115, 90, 26, 10, 1, 115, 18, 21, 10, 19, 8, 1, 18, 15, 10, 3, 18, 1, 98, 10, 3, 18, 1, 115, 10, 3, 18, 1, 99, 90, 11, 10, 1, 106, 18, 6, 10, 4, 8, 7, 18, 0, 90, 16, 10, 1, 119, 18, 11, 10, 9, 8, 1, 18, 5, 10, 3, 18, 1, 119, 90, 11, 10, 1, 108, 18, 6, 10, 4, 8, 7, 18, 0, 98, 31, 10, 1, 111, 18, 26, 10, 24, 8, 1, 18, 20, 10, 3, 18, 1, 98, 10, 3, 18, 1, 102, 10, 3, 18, 1, 100, 10, 3, 18, 1, 99, 66, 2, 16, 17], this.session_options, "o");
        }
        return this._stft;
      }
      static get rfft() {
        if (!this._rfft) {
          this._rfft = wrap2([8, 9, 18, 0, 58, 97, 10, 33, 10, 1, 120, 10, 0, 10, 1, 97, 18, 1, 121, 34, 3, 68, 70, 84, 42, 15, 10, 8, 111, 110, 101, 115, 105, 100, 101, 100, 24, 1, 160, 1, 2, 18, 1, 100, 90, 21, 10, 1, 120, 18, 16, 10, 14, 8, 1, 18, 10, 10, 3, 18, 1, 115, 10, 3, 18, 1, 99, 90, 11, 10, 1, 97, 18, 6, 10, 4, 8, 7, 18, 0, 98, 21, 10, 1, 121, 18, 16, 10, 14, 8, 1, 18, 10, 10, 3, 18, 1, 115, 10, 3, 18, 1, 99, 66, 2, 16, 20], this.session_options, "y");
        }
        return this._rfft;
      }
      static get top_k() {
        if (!this._top_k) {
          this._top_k = wrap2([8, 10, 18, 0, 58, 73, 10, 18, 10, 1, 120, 10, 1, 107, 18, 1, 118, 18, 1, 105, 34, 4, 84, 111, 112, 75, 18, 1, 116, 90, 9, 10, 1, 120, 18, 4, 10, 2, 8, 1, 90, 15, 10, 1, 107, 18, 10, 10, 8, 8, 7, 18, 4, 10, 2, 8, 1, 98, 9, 10, 1, 118, 18, 4, 10, 2, 8, 1, 98, 9, 10, 1, 105, 18, 4, 10, 2, 8, 7, 66, 2, 16, 21], this.session_options, ["v", "i"]);
        }
        return this._top_k;
      }
      static get slice() {
        if (!this._slice) {
          this._slice = wrap2([8, 7, 18, 0, 58, 96, 10, 25, 10, 1, 120, 10, 1, 115, 10, 1, 101, 10, 1, 97, 10, 1, 116, 18, 1, 121, 34, 5, 83, 108, 105, 99, 101, 18, 1, 114, 90, 9, 10, 1, 120, 18, 4, 10, 2, 8, 1, 90, 9, 10, 1, 115, 18, 4, 10, 2, 8, 7, 90, 9, 10, 1, 101, 18, 4, 10, 2, 8, 7, 90, 9, 10, 1, 97, 18, 4, 10, 2, 8, 7, 90, 9, 10, 1, 116, 18, 4, 10, 2, 8, 7, 98, 9, 10, 1, 121, 18, 4, 10, 2, 8, 1, 66, 2, 16, 13], this.session_options, "y");
        }
        return this._slice;
      }
    }
  },
  "./src/pipelines.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!**************************!*\
      !*** ./src/pipelines.js ***!
      \**************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      AudioClassificationPipeline: () => AudioClassificationPipeline,
      AutomaticSpeechRecognitionPipeline: () => AutomaticSpeechRecognitionPipeline,
      BackgroundRemovalPipeline: () => BackgroundRemovalPipeline,
      DepthEstimationPipeline: () => DepthEstimationPipeline,
      DocumentQuestionAnsweringPipeline: () => DocumentQuestionAnsweringPipeline,
      FeatureExtractionPipeline: () => FeatureExtractionPipeline,
      FillMaskPipeline: () => FillMaskPipeline,
      ImageClassificationPipeline: () => ImageClassificationPipeline,
      ImageFeatureExtractionPipeline: () => ImageFeatureExtractionPipeline,
      ImageSegmentationPipeline: () => ImageSegmentationPipeline,
      ImageToImagePipeline: () => ImageToImagePipeline,
      ImageToTextPipeline: () => ImageToTextPipeline,
      ObjectDetectionPipeline: () => ObjectDetectionPipeline,
      Pipeline: () => Pipeline,
      QuestionAnsweringPipeline: () => QuestionAnsweringPipeline,
      SummarizationPipeline: () => SummarizationPipeline,
      Text2TextGenerationPipeline: () => Text2TextGenerationPipeline,
      TextClassificationPipeline: () => TextClassificationPipeline,
      TextGenerationPipeline: () => TextGenerationPipeline,
      TextToAudioPipeline: () => TextToAudioPipeline,
      TokenClassificationPipeline: () => TokenClassificationPipeline,
      TranslationPipeline: () => TranslationPipeline,
      ZeroShotAudioClassificationPipeline: () => ZeroShotAudioClassificationPipeline,
      ZeroShotClassificationPipeline: () => ZeroShotClassificationPipeline,
      ZeroShotImageClassificationPipeline: () => ZeroShotImageClassificationPipeline,
      ZeroShotObjectDetectionPipeline: () => ZeroShotObjectDetectionPipeline,
      pipeline: () => pipeline2
    });
    var _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/tokenizers.js");
    /*! ./tokenizers.js */
    var _models_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/models.js");
    /*! ./models.js */
    var _models_auto_processing_auto_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/models/auto/processing_auto.js");
    /*! ./models/auto/processing_auto.js */
    var _base_processing_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/base/processing_utils.js");
    /*! ./base/processing_utils.js */
    var _utils_generic_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./src/utils/generic.js");
    /*! ./utils/generic.js */
    var _utils_core_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./src/utils/core.js");
    /*! ./utils/core.js */
    var _utils_maths_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./src/utils/maths.js");
    /*! ./utils/maths.js */
    var _utils_audio_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./src/utils/audio.js");
    /*! ./utils/audio.js */
    var _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./src/utils/tensor.js");
    /*! ./utils/tensor.js */
    var _utils_image_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./src/utils/image.js");
    /*! ./utils/image.js */
    async function prepareImages(images) {
      if (!Array.isArray(images)) {
        images = [images];
      }
      return await Promise.all(images.map((x) => _utils_image_js__WEBPACK_IMPORTED_MODULE_9__.RawImage.read(x)));
    }
    async function prepareAudios(audios, sampling_rate) {
      if (!Array.isArray(audios)) {
        audios = [audios];
      }
      return await Promise.all(audios.map((x) => {
        if (typeof x === "string" || x instanceof URL) {
          return (0, _utils_audio_js__WEBPACK_IMPORTED_MODULE_7__.read_audio)(x, sampling_rate);
        } else if (x instanceof Float64Array) {
          return new Float32Array(x);
        }
        return x;
      }));
    }
    function get_bounding_box(box, asInteger) {
      if (asInteger) {
        box = box.map((x) => x | 0);
      }
      const [xmin, ymin, xmax, ymax] = box;
      return { xmin, ymin, xmax, ymax };
    }

    class Pipeline extends _utils_generic_js__WEBPACK_IMPORTED_MODULE_4__.Callable {
      constructor({ task, model, tokenizer = null, processor = null }) {
        super();
        this.task = task;
        this.model = model;
        this.tokenizer = tokenizer;
        this.processor = processor;
      }
      async dispose() {
        await this.model.dispose();
      }
    }

    class TextClassificationPipeline extends Pipeline {
      constructor(options2) {
        super(options2);
      }
      async _call(texts, {
        top_k = 1
      } = {}) {
        const model_inputs = this.tokenizer(texts, {
          padding: true,
          truncation: true
        });
        const outputs = await this.model(model_inputs);
        const function_to_apply = this.model.config.problem_type === "multi_label_classification" ? (batch) => batch.sigmoid() : (batch) => new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.Tensor("float32", (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_6__.softmax)(batch.data), batch.dims);
        const id2label = this.model.config.id2label;
        const toReturn = [];
        for (const batch of outputs.logits) {
          const output = function_to_apply(batch);
          const scores = await (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.topk)(output, top_k);
          const values = scores[0].tolist();
          const indices = scores[1].tolist();
          const vals = indices.map((x, i) => ({
            label: id2label ? id2label[x] : `LABEL_${x}`,
            score: values[i]
          }));
          if (top_k === 1) {
            toReturn.push(...vals);
          } else {
            toReturn.push(vals);
          }
        }
        return Array.isArray(texts) || top_k === 1 ? toReturn : toReturn[0];
      }
    }

    class TokenClassificationPipeline extends Pipeline {
      constructor(options2) {
        super(options2);
      }
      async _call(texts, {
        ignore_labels = ["O"]
      } = {}) {
        const isBatched = Array.isArray(texts);
        const model_inputs = this.tokenizer(isBatched ? texts : [texts], {
          padding: true,
          truncation: true
        });
        const outputs = await this.model(model_inputs);
        const logits = outputs.logits;
        const id2label = this.model.config.id2label;
        const toReturn = [];
        for (let i = 0;i < logits.dims[0]; ++i) {
          const ids = model_inputs.input_ids[i];
          const batch = logits[i];
          const tokens = [];
          for (let j = 0;j < batch.dims[0]; ++j) {
            const tokenData = batch[j];
            const topScoreIndex = (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_6__.max)(tokenData.data)[1];
            const entity = id2label ? id2label[topScoreIndex] : `LABEL_${topScoreIndex}`;
            if (ignore_labels.includes(entity)) {
              continue;
            }
            const word = this.tokenizer.decode([ids[j].item()], { skip_special_tokens: true });
            if (word === "") {
              continue;
            }
            const scores = (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_6__.softmax)(tokenData.data);
            tokens.push({
              entity,
              score: scores[topScoreIndex],
              index: j,
              word
            });
          }
          toReturn.push(tokens);
        }
        return isBatched ? toReturn : toReturn[0];
      }
    }

    class QuestionAnsweringPipeline extends Pipeline {
      constructor(options2) {
        super(options2);
      }
      async _call(question, context, {
        top_k = 1
      } = {}) {
        const inputs = this.tokenizer(question, {
          text_pair: context,
          padding: true,
          truncation: true
        });
        const { start_logits, end_logits } = await this.model(inputs);
        const input_ids = inputs.input_ids.tolist();
        const attention_mask = inputs.attention_mask.tolist();
        const special_tokens = this.tokenizer.all_special_ids;
        const toReturn = [];
        for (let j = 0;j < start_logits.dims[0]; ++j) {
          const ids = input_ids[j];
          const sepIndex = ids.findIndex((x) => x == this.tokenizer.sep_token_id);
          const valid_mask = attention_mask[j].map((y, ix) => y == 1 && (ix === 0 || ix > sepIndex && special_tokens.findIndex((x) => x == ids[ix]) === -1));
          const start = start_logits[j].tolist();
          const end = end_logits[j].tolist();
          for (let i = 1;i < start.length; ++i) {
            if (attention_mask[j] == 0 || i <= sepIndex || special_tokens.findIndex((x) => x == ids[i]) !== -1) {
              start[i] = -Infinity;
              end[i] = -Infinity;
            }
          }
          const start_scores = (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_6__.softmax)(start).map((x, i) => [x, i]);
          const end_scores = (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_6__.softmax)(end).map((x, i) => [x, i]);
          start_scores[0][0] = 0;
          end_scores[0][0] = 0;
          const options2 = (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_5__.product)(start_scores, end_scores).filter((x) => x[0][1] <= x[1][1]).map((x) => [x[0][1], x[1][1], x[0][0] * x[1][0]]).sort((a, b) => b[2] - a[2]);
          for (let k = 0;k < Math.min(options2.length, top_k); ++k) {
            const [start2, end2, score] = options2[k];
            const answer_tokens = ids.slice(start2, end2 + 1);
            const answer = this.tokenizer.decode(answer_tokens, {
              skip_special_tokens: true
            });
            toReturn.push({
              answer,
              score
            });
          }
        }
        return top_k === 1 ? toReturn[0] : toReturn;
      }
    }

    class FillMaskPipeline extends Pipeline {
      constructor(options2) {
        super(options2);
      }
      async _call(texts, {
        top_k = 5
      } = {}) {
        const model_inputs = this.tokenizer(texts, {
          padding: true,
          truncation: true
        });
        const { logits } = await this.model(model_inputs);
        const toReturn = [];
        const input_ids = model_inputs.input_ids.tolist();
        for (let i = 0;i < input_ids.length; ++i) {
          const ids = input_ids[i];
          const mask_token_index = ids.findIndex((x) => x == this.tokenizer.mask_token_id);
          if (mask_token_index === -1) {
            throw Error(`Mask token (${this.tokenizer.mask_token}) not found in text.`);
          }
          const itemLogits = logits[i][mask_token_index];
          const scores = await (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.topk)(new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.Tensor("float32", (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_6__.softmax)(itemLogits.data), itemLogits.dims), top_k);
          const values = scores[0].tolist();
          const indices = scores[1].tolist();
          toReturn.push(indices.map((x, i2) => {
            const sequence = ids.slice();
            sequence[mask_token_index] = x;
            return {
              score: values[i2],
              token: Number(x),
              token_str: this.tokenizer.decode([x]),
              sequence: this.tokenizer.decode(sequence, { skip_special_tokens: true })
            };
          }));
        }
        return Array.isArray(texts) ? toReturn : toReturn[0];
      }
    }

    class Text2TextGenerationPipeline extends Pipeline {
      _key = "generated_text";
      constructor(options2) {
        super(options2);
      }
      async _call(texts, generate_kwargs = {}) {
        if (!Array.isArray(texts)) {
          texts = [texts];
        }
        if (this.model.config.prefix) {
          texts = texts.map((x) => this.model.config.prefix + x);
        }
        const task_specific_params = this.model.config.task_specific_params;
        if (task_specific_params && task_specific_params[this.task]) {
          if (task_specific_params[this.task].prefix) {
            texts = texts.map((x) => task_specific_params[this.task].prefix + x);
          }
        }
        const tokenizer = this.tokenizer;
        const tokenizer_options = {
          padding: true,
          truncation: true
        };
        let inputs;
        if (this instanceof TranslationPipeline && "_build_translation_inputs" in tokenizer) {
          inputs = tokenizer._build_translation_inputs(texts, tokenizer_options, generate_kwargs);
        } else {
          inputs = tokenizer(texts, tokenizer_options);
        }
        const outputTokenIds = await this.model.generate({ ...inputs, ...generate_kwargs });
        return tokenizer.batch_decode(outputTokenIds, {
          skip_special_tokens: true
        }).map((text) => ({ [this._key]: text }));
      }
    }

    class SummarizationPipeline extends Text2TextGenerationPipeline {
      _key = "summary_text";
      constructor(options2) {
        super(options2);
      }
    }

    class TranslationPipeline extends Text2TextGenerationPipeline {
      _key = "translation_text";
      constructor(options2) {
        super(options2);
      }
    }
    function isChat(x) {
      return Array.isArray(x) && x.every((x2) => ("role" in x2) && ("content" in x2));
    }

    class TextGenerationPipeline extends Pipeline {
      constructor(options2) {
        super(options2);
      }
      async _call(texts, generate_kwargs = {}) {
        let isBatched = false;
        let isChatInput = false;
        let add_special_tokens = generate_kwargs.add_special_tokens ?? (this.tokenizer.add_bos_token || this.tokenizer.add_eos_token) ?? false;
        let inputs;
        if (typeof texts === "string") {
          inputs = texts = [texts];
        } else if (Array.isArray(texts) && texts.every((x) => typeof x === "string")) {
          isBatched = true;
          inputs = texts;
        } else {
          if (isChat(texts)) {
            texts = [texts];
          } else if (Array.isArray(texts) && texts.every(isChat)) {
            isBatched = true;
          } else {
            throw new Error("Input must be a string, an array of strings, a Chat, or an array of Chats");
          }
          isChatInput = true;
          inputs = texts.map((x) => this.tokenizer.apply_chat_template(x, {
            tokenize: false,
            add_generation_prompt: true
          }));
          add_special_tokens = false;
        }
        const return_full_text = isChatInput ? false : generate_kwargs.return_full_text ?? true;
        this.tokenizer.padding_side = "left";
        const text_inputs = this.tokenizer(inputs, {
          add_special_tokens,
          padding: true,
          truncation: true
        });
        const outputTokenIds = await this.model.generate({
          ...text_inputs,
          ...generate_kwargs
        });
        const decoded = this.tokenizer.batch_decode(outputTokenIds, {
          skip_special_tokens: true
        });
        let promptLengths;
        if (!return_full_text && text_inputs.input_ids.dims.at(-1) > 0) {
          promptLengths = this.tokenizer.batch_decode(text_inputs.input_ids, {
            skip_special_tokens: true
          }).map((x) => x.length);
        }
        const toReturn = Array.from({ length: texts.length }, (_) => []);
        for (let i = 0;i < decoded.length; ++i) {
          const textIndex = Math.floor(i / outputTokenIds.dims[0] * texts.length);
          if (promptLengths) {
            decoded[i] = decoded[i].slice(promptLengths[textIndex]);
          }
          toReturn[textIndex].push({
            generated_text: isChatInput ? [
              ...texts[textIndex],
              { role: "assistant", content: decoded[i] }
            ] : decoded[i]
          });
        }
        return !isBatched && toReturn.length === 1 ? toReturn[0] : toReturn;
      }
    }

    class ZeroShotClassificationPipeline extends Pipeline {
      constructor(options2) {
        super(options2);
        this.label2id = Object.fromEntries(Object.entries(this.model.config.label2id).map(([k, v]) => [k.toLowerCase(), v]));
        this.entailment_id = this.label2id["entailment"];
        if (this.entailment_id === undefined) {
          console.warn("Could not find 'entailment' in label2id mapping. Using 2 as entailment_id.");
          this.entailment_id = 2;
        }
        this.contradiction_id = this.label2id["contradiction"] ?? this.label2id["not_entailment"];
        if (this.contradiction_id === undefined) {
          console.warn("Could not find 'contradiction' in label2id mapping. Using 0 as contradiction_id.");
          this.contradiction_id = 0;
        }
      }
      async _call(texts, candidate_labels, {
        hypothesis_template = "This example is {}.",
        multi_label = false
      } = {}) {
        const isBatched = Array.isArray(texts);
        if (!isBatched) {
          texts = [texts];
        }
        if (!Array.isArray(candidate_labels)) {
          candidate_labels = [candidate_labels];
        }
        const hypotheses = candidate_labels.map((x) => hypothesis_template.replace("{}", x));
        const softmaxEach = multi_label || candidate_labels.length === 1;
        const toReturn = [];
        for (const premise of texts) {
          const entails_logits = [];
          for (const hypothesis of hypotheses) {
            const inputs = this.tokenizer(premise, {
              text_pair: hypothesis,
              padding: true,
              truncation: true
            });
            const outputs = await this.model(inputs);
            if (softmaxEach) {
              entails_logits.push([
                outputs.logits.data[this.contradiction_id],
                outputs.logits.data[this.entailment_id]
              ]);
            } else {
              entails_logits.push(outputs.logits.data[this.entailment_id]);
            }
          }
          const scores = softmaxEach ? entails_logits.map((x) => (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_6__.softmax)(x)[1]) : (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_6__.softmax)(entails_logits);
          const scores_sorted = scores.map((x, i) => [x, i]).sort((a, b) => b[0] - a[0]);
          toReturn.push({
            sequence: premise,
            labels: scores_sorted.map((x) => candidate_labels[x[1]]),
            scores: scores_sorted.map((x) => x[0])
          });
        }
        return isBatched ? toReturn : toReturn[0];
      }
    }

    class FeatureExtractionPipeline extends Pipeline {
      constructor(options2) {
        super(options2);
      }
      async _call(texts, {
        pooling = "none",
        normalize: normalize2 = false,
        quantize = false,
        precision = "binary"
      } = {}) {
        const model_inputs = this.tokenizer(texts, {
          padding: true,
          truncation: true
        });
        const outputs = await this.model(model_inputs);
        let result = outputs.last_hidden_state ?? outputs.logits ?? outputs.token_embeddings;
        switch (pooling) {
          case "none":
            break;
          case "mean":
            result = (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.mean_pooling)(result, model_inputs.attention_mask);
            break;
          case "first_token":
          case "cls":
            result = result.slice(null, 0);
            break;
          case "last_token":
          case "eos":
            result = result.slice(null, -1);
            break;
          default:
            throw Error(`Pooling method '${pooling}' not supported.`);
        }
        if (normalize2) {
          result = result.normalize(2, -1);
        }
        if (quantize) {
          result = (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.quantize_embeddings)(result, precision);
        }
        return result;
      }
    }

    class ImageFeatureExtractionPipeline extends Pipeline {
      constructor(options2) {
        super(options2);
      }
      async _call(images, {
        pool = null
      } = {}) {
        const preparedImages = await prepareImages(images);
        const { pixel_values } = await this.processor(preparedImages);
        const outputs = await this.model({ pixel_values });
        let result;
        if (pool) {
          if (!("pooler_output" in outputs)) {
            throw Error(`No pooled output was returned. Make sure the model has a 'pooler' layer when using the 'pool' option.`);
          }
          result = outputs.pooler_output;
        } else {
          result = outputs.last_hidden_state ?? outputs.logits ?? outputs.image_embeds;
        }
        return result;
      }
    }

    class AudioClassificationPipeline extends Pipeline {
      constructor(options2) {
        super(options2);
      }
      async _call(audio, {
        top_k = 5
      } = {}) {
        const sampling_rate = this.processor.feature_extractor.config.sampling_rate;
        const preparedAudios = await prepareAudios(audio, sampling_rate);
        const id2label = this.model.config.id2label;
        const toReturn = [];
        for (const aud of preparedAudios) {
          const inputs = await this.processor(aud);
          const output = await this.model(inputs);
          const logits = output.logits[0];
          const scores = await (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.topk)(new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.Tensor("float32", (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_6__.softmax)(logits.data), logits.dims), top_k);
          const values = scores[0].tolist();
          const indices = scores[1].tolist();
          const vals = indices.map((x, i) => ({
            label: id2label ? id2label[x] : `LABEL_${x}`,
            score: values[i]
          }));
          toReturn.push(vals);
        }
        return Array.isArray(audio) ? toReturn : toReturn[0];
      }
    }

    class ZeroShotAudioClassificationPipeline extends Pipeline {
      constructor(options2) {
        super(options2);
      }
      async _call(audio, candidate_labels, {
        hypothesis_template = "This is a sound of {}."
      } = {}) {
        const single = !Array.isArray(audio);
        if (single) {
          audio = [audio];
        }
        const texts = candidate_labels.map((x) => hypothesis_template.replace("{}", x));
        const text_inputs = this.tokenizer(texts, {
          padding: true,
          truncation: true
        });
        const sampling_rate = this.processor.feature_extractor.config.sampling_rate;
        const preparedAudios = await prepareAudios(audio, sampling_rate);
        const toReturn = [];
        for (const aud of preparedAudios) {
          const audio_inputs = await this.processor(aud);
          const output = await this.model({ ...text_inputs, ...audio_inputs });
          const probs = (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_6__.softmax)(output.logits_per_audio.data);
          toReturn.push([...probs].map((x, i) => ({
            score: x,
            label: candidate_labels[i]
          })));
        }
        return single ? toReturn[0] : toReturn;
      }
    }

    class AutomaticSpeechRecognitionPipeline extends Pipeline {
      constructor(options2) {
        super(options2);
      }
      async _call(audio, kwargs = {}) {
        switch (this.model.config.model_type) {
          case "whisper":
          case "lite-whisper":
            return this._call_whisper(audio, kwargs);
          case "wav2vec2":
          case "wav2vec2-bert":
          case "unispeech":
          case "unispeech-sat":
          case "hubert":
          case "parakeet_ctc":
            return this._call_wav2vec2(audio, kwargs);
          case "moonshine":
            return this._call_moonshine(audio, kwargs);
          default:
            throw new Error(`AutomaticSpeechRecognitionPipeline does not support model type '${this.model.config.model_type}'.`);
        }
      }
      async _call_wav2vec2(audio, kwargs) {
        if (kwargs.language) {
          console.warn('`language` parameter is not yet supported for `wav2vec2` models, defaulting to "English".');
        }
        if (kwargs.task) {
          console.warn('`task` parameter is not yet supported for `wav2vec2` models, defaulting to "transcribe".');
        }
        const single = !Array.isArray(audio);
        if (single) {
          audio = [audio];
        }
        const sampling_rate = this.processor.feature_extractor.config.sampling_rate;
        const preparedAudios = await prepareAudios(audio, sampling_rate);
        const toReturn = [];
        for (const aud of preparedAudios) {
          const inputs = await this.processor(aud);
          const output = await this.model(inputs);
          const logits = output.logits[0];
          const predicted_ids = [];
          for (const item of logits) {
            predicted_ids.push((0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_6__.max)(item.data)[1]);
          }
          const predicted_sentences = this.tokenizer.decode(predicted_ids, { skip_special_tokens: true }).trim();
          toReturn.push({ text: predicted_sentences });
        }
        return single ? toReturn[0] : toReturn;
      }
      async _call_whisper(audio, kwargs) {
        const return_timestamps = kwargs.return_timestamps ?? false;
        const chunk_length_s = kwargs.chunk_length_s ?? 0;
        const force_full_sequences = kwargs.force_full_sequences ?? false;
        let stride_length_s = kwargs.stride_length_s ?? null;
        const generation_config = { ...kwargs };
        if (return_timestamps === "word") {
          generation_config["return_token_timestamps"] = true;
          generation_config["return_timestamps"] = false;
        }
        const single = !Array.isArray(audio);
        if (single) {
          audio = [audio];
        }
        const time_precision = this.processor.feature_extractor.config.chunk_length / this.model.config.max_source_positions;
        const hop_length = this.processor.feature_extractor.config.hop_length;
        const sampling_rate = this.processor.feature_extractor.config.sampling_rate;
        const preparedAudios = await prepareAudios(audio, sampling_rate);
        const toReturn = [];
        for (const aud of preparedAudios) {
          let chunks = [];
          if (chunk_length_s > 0) {
            if (stride_length_s === null) {
              stride_length_s = chunk_length_s / 6;
            } else if (chunk_length_s <= stride_length_s) {
              throw Error("`chunk_length_s` must be larger than `stride_length_s`.");
            }
            const window2 = sampling_rate * chunk_length_s;
            const stride = sampling_rate * stride_length_s;
            const jump = window2 - 2 * stride;
            let offset = 0;
            while (true) {
              const offset_end = offset + window2;
              const subarr = aud.subarray(offset, offset_end);
              const feature = await this.processor(subarr);
              const is_first = offset === 0;
              const is_last = offset_end >= aud.length;
              chunks.push({
                stride: [
                  subarr.length,
                  is_first ? 0 : stride,
                  is_last ? 0 : stride
                ],
                input_features: feature.input_features,
                is_last
              });
              if (is_last)
                break;
              offset += jump;
            }
          } else {
            chunks = [{
              stride: [aud.length, 0, 0],
              input_features: (await this.processor(aud)).input_features,
              is_last: true
            }];
          }
          for (const chunk of chunks) {
            generation_config.num_frames = Math.floor(chunk.stride[0] / hop_length);
            const data = await this.model.generate({
              inputs: chunk.input_features,
              ...generation_config
            });
            if (return_timestamps === "word") {
              chunk.tokens = data.sequences.tolist()[0];
              chunk.token_timestamps = data.token_timestamps.tolist()[0].map((x) => (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_6__.round)(x, 2));
            } else {
              chunk.tokens = data[0].tolist();
            }
            chunk.stride = chunk.stride.map((x) => x / sampling_rate);
          }
          const [full_text, optional4] = this.tokenizer._decode_asr(chunks, {
            time_precision,
            return_timestamps,
            force_full_sequences
          });
          toReturn.push({ text: full_text, ...optional4 });
        }
        return single ? toReturn[0] : toReturn;
      }
      async _call_moonshine(audio, kwargs) {
        const single = !Array.isArray(audio);
        if (single) {
          audio = [audio];
        }
        const sampling_rate = this.processor.feature_extractor.config.sampling_rate;
        const preparedAudios = await prepareAudios(audio, sampling_rate);
        const toReturn = [];
        for (const aud of preparedAudios) {
          const inputs = await this.processor(aud);
          const max_new_tokens = Math.floor(aud.length / sampling_rate) * 6;
          const outputs = await this.model.generate({ max_new_tokens, ...kwargs, ...inputs });
          const text = this.processor.batch_decode(outputs, { skip_special_tokens: true })[0];
          toReturn.push({ text });
        }
        return single ? toReturn[0] : toReturn;
      }
    }

    class ImageToTextPipeline extends Pipeline {
      constructor(options2) {
        super(options2);
      }
      async _call(images, generate_kwargs = {}) {
        const isBatched = Array.isArray(images);
        const preparedImages = await prepareImages(images);
        const { pixel_values } = await this.processor(preparedImages);
        const toReturn = [];
        for (const batch of pixel_values) {
          batch.dims = [1, ...batch.dims];
          const output = await this.model.generate({ inputs: batch, ...generate_kwargs });
          const decoded = this.tokenizer.batch_decode(output, {
            skip_special_tokens: true
          }).map((x) => ({ generated_text: x.trim() }));
          toReturn.push(decoded);
        }
        return isBatched ? toReturn : toReturn[0];
      }
    }

    class ImageClassificationPipeline extends Pipeline {
      constructor(options2) {
        super(options2);
      }
      async _call(images, {
        top_k = 5
      } = {}) {
        const preparedImages = await prepareImages(images);
        const { pixel_values } = await this.processor(preparedImages);
        const output = await this.model({ pixel_values });
        const id2label = this.model.config.id2label;
        const toReturn = [];
        for (const batch of output.logits) {
          const scores = await (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.topk)(new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.Tensor("float32", (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_6__.softmax)(batch.data), batch.dims), top_k);
          const values = scores[0].tolist();
          const indices = scores[1].tolist();
          const vals = indices.map((x, i) => ({
            label: id2label ? id2label[x] : `LABEL_${x}`,
            score: values[i]
          }));
          toReturn.push(vals);
        }
        return Array.isArray(images) ? toReturn : toReturn[0];
      }
    }

    class ImageSegmentationPipeline extends Pipeline {
      constructor(options2) {
        super(options2);
        this.subtasks_mapping = {
          panoptic: "post_process_panoptic_segmentation",
          instance: "post_process_instance_segmentation",
          semantic: "post_process_semantic_segmentation"
        };
      }
      async _call(images, {
        threshold = 0.5,
        mask_threshold = 0.5,
        overlap_mask_area_threshold = 0.8,
        label_ids_to_fuse = null,
        target_sizes = null,
        subtask = null
      } = {}) {
        const isBatched = Array.isArray(images);
        if (isBatched && images.length !== 1) {
          throw Error("Image segmentation pipeline currently only supports a batch size of 1.");
        }
        const preparedImages = await prepareImages(images);
        const imageSizes = preparedImages.map((x) => [x.height, x.width]);
        const inputs = await this.processor(preparedImages);
        const { inputNames, outputNames } = this.model.sessions["model"];
        if (!inputNames.includes("pixel_values")) {
          if (inputNames.length !== 1) {
            throw Error(`Expected a single input name, but got ${inputNames.length} inputs: ${inputNames}.`);
          }
          const newName = inputNames[0];
          if (newName in inputs) {
            throw Error(`Input name ${newName} already exists in the inputs.`);
          }
          inputs[newName] = inputs.pixel_values;
        }
        const output = await this.model(inputs);
        let fn = null;
        if (subtask !== null) {
          fn = this.subtasks_mapping[subtask];
        } else if (this.processor.image_processor) {
          for (const [task, func] of Object.entries(this.subtasks_mapping)) {
            if (func in this.processor.image_processor) {
              fn = this.processor.image_processor[func].bind(this.processor.image_processor);
              subtask = task;
              break;
            }
          }
        }
        const id2label = this.model.config.id2label;
        const annotation = [];
        if (!subtask) {
          const epsilon = 0.00001;
          const result = output[outputNames[0]];
          for (let i = 0;i < imageSizes.length; ++i) {
            const size = imageSizes[i];
            const item = result[i];
            if (item.data.some((x) => x < -epsilon || x > 1 + epsilon)) {
              item.sigmoid_();
            }
            const mask = await _utils_image_js__WEBPACK_IMPORTED_MODULE_9__.RawImage.fromTensor(item.mul_(255).to("uint8")).resize(size[1], size[0]);
            annotation.push({
              label: null,
              score: null,
              mask
            });
          }
        } else if (subtask === "panoptic" || subtask === "instance") {
          const processed = fn(output, threshold, mask_threshold, overlap_mask_area_threshold, label_ids_to_fuse, target_sizes ?? imageSizes)[0];
          const segmentation = processed.segmentation;
          for (const segment of processed.segments_info) {
            const maskData = new Uint8ClampedArray(segmentation.data.length);
            for (let i = 0;i < segmentation.data.length; ++i) {
              if (segmentation.data[i] === segment.id) {
                maskData[i] = 255;
              }
            }
            const mask = new _utils_image_js__WEBPACK_IMPORTED_MODULE_9__.RawImage(maskData, segmentation.dims[1], segmentation.dims[0], 1);
            annotation.push({
              score: segment.score,
              label: id2label[segment.label_id],
              mask
            });
          }
        } else if (subtask === "semantic") {
          const { segmentation, labels } = fn(output, target_sizes ?? imageSizes)[0];
          for (const label of labels) {
            const maskData = new Uint8ClampedArray(segmentation.data.length);
            for (let i = 0;i < segmentation.data.length; ++i) {
              if (segmentation.data[i] === label) {
                maskData[i] = 255;
              }
            }
            const mask = new _utils_image_js__WEBPACK_IMPORTED_MODULE_9__.RawImage(maskData, segmentation.dims[1], segmentation.dims[0], 1);
            annotation.push({
              score: null,
              label: id2label[label],
              mask
            });
          }
        } else {
          throw Error(`Subtask ${subtask} not supported.`);
        }
        return annotation;
      }
    }

    class BackgroundRemovalPipeline extends ImageSegmentationPipeline {
      constructor(options2) {
        super(options2);
      }
      async _call(images, options2 = {}) {
        const isBatched = Array.isArray(images);
        if (isBatched && images.length !== 1) {
          throw Error("Background removal pipeline currently only supports a batch size of 1.");
        }
        const preparedImages = await prepareImages(images);
        const masks = await super._call(images, options2);
        const result = preparedImages.map((img, i) => {
          const cloned = img.clone();
          cloned.putAlpha(masks[i].mask);
          return cloned;
        });
        return result;
      }
    }

    class ZeroShotImageClassificationPipeline extends Pipeline {
      constructor(options2) {
        super(options2);
      }
      async _call(images, candidate_labels, {
        hypothesis_template = "This is a photo of {}"
      } = {}) {
        const isBatched = Array.isArray(images);
        const preparedImages = await prepareImages(images);
        const texts = candidate_labels.map((x) => hypothesis_template.replace("{}", x));
        const text_inputs = this.tokenizer(texts, {
          padding: this.model.config.model_type === "siglip" ? "max_length" : true,
          truncation: true
        });
        const { pixel_values } = await this.processor(preparedImages);
        const output = await this.model({ ...text_inputs, pixel_values });
        const function_to_apply = this.model.config.model_type === "siglip" ? (batch) => batch.sigmoid().data : (batch) => (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_6__.softmax)(batch.data);
        const toReturn = [];
        for (const batch of output.logits_per_image) {
          const probs = function_to_apply(batch);
          const result = [...probs].map((x, i) => ({
            score: x,
            label: candidate_labels[i]
          }));
          result.sort((a, b) => b.score - a.score);
          toReturn.push(result);
        }
        return isBatched ? toReturn : toReturn[0];
      }
    }

    class ObjectDetectionPipeline extends Pipeline {
      constructor(options2) {
        super(options2);
      }
      async _call(images, {
        threshold = 0.9,
        percentage = false
      } = {}) {
        const isBatched = Array.isArray(images);
        if (isBatched && images.length !== 1) {
          throw Error("Object detection pipeline currently only supports a batch size of 1.");
        }
        const preparedImages = await prepareImages(images);
        const imageSizes = percentage ? null : preparedImages.map((x) => [x.height, x.width]);
        const { pixel_values, pixel_mask } = await this.processor(preparedImages);
        const output = await this.model({ pixel_values, pixel_mask });
        const processed = this.processor.image_processor.post_process_object_detection(output, threshold, imageSizes);
        const id2label = this.model.config.id2label;
        const result = processed.map((batch) => batch.boxes.map((box, i) => ({
          score: batch.scores[i],
          label: id2label[batch.classes[i]],
          box: get_bounding_box(box, !percentage)
        })));
        return isBatched ? result : result[0];
      }
    }

    class ZeroShotObjectDetectionPipeline extends Pipeline {
      constructor(options2) {
        super(options2);
      }
      async _call(images, candidate_labels, {
        threshold = 0.1,
        top_k = null,
        percentage = false
      } = {}) {
        const isBatched = Array.isArray(images);
        const preparedImages = await prepareImages(images);
        const text_inputs = this.tokenizer(candidate_labels, {
          padding: true,
          truncation: true
        });
        const model_inputs = await this.processor(preparedImages);
        const toReturn = [];
        for (let i = 0;i < preparedImages.length; ++i) {
          const image = preparedImages[i];
          const imageSize = percentage ? null : [[image.height, image.width]];
          const pixel_values = model_inputs.pixel_values[i].unsqueeze_(0);
          const output = await this.model({ ...text_inputs, pixel_values });
          let result;
          if ("post_process_grounded_object_detection" in this.processor) {
            const processed = this.processor.post_process_grounded_object_detection(output, text_inputs.input_ids, {
              box_threshold: threshold,
              text_threshold: threshold,
              target_sizes: imageSize
            })[0];
            result = processed.boxes.map((box, i2) => ({
              score: processed.scores[i2],
              label: processed.labels[i2],
              box: get_bounding_box(box, !percentage)
            }));
          } else {
            const processed = this.processor.image_processor.post_process_object_detection(output, threshold, imageSize, true)[0];
            result = processed.boxes.map((box, i2) => ({
              score: processed.scores[i2],
              label: candidate_labels[processed.classes[i2]],
              box: get_bounding_box(box, !percentage)
            }));
          }
          result.sort((a, b) => b.score - a.score);
          if (top_k !== null) {
            result = result.slice(0, top_k);
          }
          toReturn.push(result);
        }
        return isBatched ? toReturn : toReturn[0];
      }
    }

    class DocumentQuestionAnsweringPipeline extends Pipeline {
      constructor(options2) {
        super(options2);
      }
      async _call(image, question, generate_kwargs = {}) {
        const preparedImage = (await prepareImages(image))[0];
        const { pixel_values } = await this.processor(preparedImage);
        const task_prompt = `<s_docvqa><s_question>${question}</s_question><s_answer>`;
        const decoder_input_ids = this.tokenizer(task_prompt, {
          add_special_tokens: false,
          padding: true,
          truncation: true
        }).input_ids;
        const output = await this.model.generate({
          inputs: pixel_values,
          max_length: this.model.config.decoder.max_position_embeddings,
          decoder_input_ids,
          ...generate_kwargs
        });
        const decoded = this.tokenizer.batch_decode(output)[0];
        const match = decoded.match(/<s_answer>(.*?)<\/s_answer>/);
        let answer = null;
        if (match && match.length >= 2) {
          answer = match[1].trim();
        }
        return [{ answer }];
      }
    }

    class TextToAudioPipeline extends Pipeline {
      DEFAULT_VOCODER_ID = "Xenova/speecht5_hifigan";
      constructor(options2) {
        super(options2);
        this.vocoder = options2.vocoder ?? null;
      }
      async _prepare_speaker_embeddings(speaker_embeddings) {
        if (typeof speaker_embeddings === "string" || speaker_embeddings instanceof URL) {
          speaker_embeddings = new Float32Array(await (await fetch(speaker_embeddings)).arrayBuffer());
        }
        if (speaker_embeddings instanceof Float32Array) {
          speaker_embeddings = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.Tensor("float32", speaker_embeddings, [speaker_embeddings.length]);
        } else if (!(speaker_embeddings instanceof _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.Tensor)) {
          throw new Error("Speaker embeddings must be a `Tensor`, `Float32Array`, `string`, or `URL`.");
        }
        return speaker_embeddings;
      }
      async _call(text_inputs, {
        speaker_embeddings = null,
        num_inference_steps,
        speed
      } = {}) {
        if (this.processor) {
          return this._call_text_to_spectrogram(text_inputs, { speaker_embeddings });
        } else if (this.model.config.model_type === "supertonic") {
          return this._call_supertonic(text_inputs, { speaker_embeddings, num_inference_steps, speed });
        } else {
          return this._call_text_to_waveform(text_inputs);
        }
      }
      async _call_supertonic(text_inputs, { speaker_embeddings, num_inference_steps, speed }) {
        if (!speaker_embeddings) {
          throw new Error("Speaker embeddings must be provided for Supertonic models.");
        }
        speaker_embeddings = await this._prepare_speaker_embeddings(speaker_embeddings);
        const { sampling_rate, style_dim } = this.model.config;
        speaker_embeddings = speaker_embeddings.view(1, -1, style_dim);
        const inputs = this.tokenizer(text_inputs, {
          padding: true,
          truncation: true
        });
        const { waveform } = await this.model.generate_speech({
          ...inputs,
          style: speaker_embeddings,
          num_inference_steps,
          speed
        });
        return new _utils_audio_js__WEBPACK_IMPORTED_MODULE_7__.RawAudio(waveform.data, sampling_rate);
      }
      async _call_text_to_waveform(text_inputs) {
        const inputs = this.tokenizer(text_inputs, {
          padding: true,
          truncation: true
        });
        const { waveform } = await this.model(inputs);
        const sampling_rate = this.model.config.sampling_rate;
        return new _utils_audio_js__WEBPACK_IMPORTED_MODULE_7__.RawAudio(waveform.data, sampling_rate);
      }
      async _call_text_to_spectrogram(text_inputs, { speaker_embeddings }) {
        if (!this.vocoder) {
          console.log("No vocoder specified, using default HifiGan vocoder.");
          this.vocoder = await _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModel.from_pretrained(this.DEFAULT_VOCODER_ID, { dtype: "fp32" });
        }
        const { input_ids } = this.tokenizer(text_inputs, {
          padding: true,
          truncation: true
        });
        speaker_embeddings = await this._prepare_speaker_embeddings(speaker_embeddings);
        speaker_embeddings = speaker_embeddings.view(1, -1);
        const { waveform } = await this.model.generate_speech(input_ids, speaker_embeddings, { vocoder: this.vocoder });
        const sampling_rate = this.processor.feature_extractor.config.sampling_rate;
        return new _utils_audio_js__WEBPACK_IMPORTED_MODULE_7__.RawAudio(waveform.data, sampling_rate);
      }
    }

    class ImageToImagePipeline extends Pipeline {
      constructor(options2) {
        super(options2);
      }
      async _call(images) {
        const preparedImages = await prepareImages(images);
        const inputs = await this.processor(preparedImages);
        const outputs = await this.model(inputs);
        const toReturn = [];
        for (const batch of outputs.reconstruction) {
          const output = batch.squeeze().clamp_(0, 1).mul_(255).round_().to("uint8");
          toReturn.push(_utils_image_js__WEBPACK_IMPORTED_MODULE_9__.RawImage.fromTensor(output));
        }
        return toReturn.length > 1 ? toReturn : toReturn[0];
      }
    }

    class DepthEstimationPipeline extends Pipeline {
      constructor(options2) {
        super(options2);
      }
      async _call(images) {
        const preparedImages = await prepareImages(images);
        const inputs = await this.processor(preparedImages);
        const { predicted_depth } = await this.model(inputs);
        const toReturn = [];
        for (let i = 0;i < preparedImages.length; ++i) {
          const batch = predicted_depth[i];
          const [height, width] = batch.dims.slice(-2);
          const [new_width, new_height] = preparedImages[i].size;
          const prediction = (await (0, _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.interpolate_4d)(batch.view(1, 1, height, width), {
            size: [new_height, new_width],
            mode: "bilinear"
          })).view(new_height, new_width);
          const minval = prediction.min().item();
          const maxval = prediction.max().item();
          const formatted = prediction.sub(minval).div_(maxval - minval).mul_(255).to("uint8").unsqueeze(0);
          const depth = _utils_image_js__WEBPACK_IMPORTED_MODULE_9__.RawImage.fromTensor(formatted);
          toReturn.push({
            predicted_depth: prediction,
            depth
          });
        }
        return toReturn.length > 1 ? toReturn : toReturn[0];
      }
    }
    const SUPPORTED_TASKS = Object.freeze({
      "text-classification": {
        tokenizer: _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,
        pipeline: TextClassificationPipeline,
        model: _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForSequenceClassification,
        default: {
          model: "Xenova/distilbert-base-uncased-finetuned-sst-2-english"
        },
        type: "text"
      },
      "token-classification": {
        tokenizer: _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,
        pipeline: TokenClassificationPipeline,
        model: _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForTokenClassification,
        default: {
          model: "Xenova/bert-base-multilingual-cased-ner-hrl"
        },
        type: "text"
      },
      "question-answering": {
        tokenizer: _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,
        pipeline: QuestionAnsweringPipeline,
        model: _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForQuestionAnswering,
        default: {
          model: "Xenova/distilbert-base-cased-distilled-squad"
        },
        type: "text"
      },
      "fill-mask": {
        tokenizer: _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,
        pipeline: FillMaskPipeline,
        model: _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForMaskedLM,
        default: {
          model: "Xenova/bert-base-uncased"
        },
        type: "text"
      },
      summarization: {
        tokenizer: _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,
        pipeline: SummarizationPipeline,
        model: _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForSeq2SeqLM,
        default: {
          model: "Xenova/distilbart-cnn-6-6"
        },
        type: "text"
      },
      translation: {
        tokenizer: _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,
        pipeline: TranslationPipeline,
        model: _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForSeq2SeqLM,
        default: {
          model: "Xenova/t5-small"
        },
        type: "text"
      },
      "text2text-generation": {
        tokenizer: _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,
        pipeline: Text2TextGenerationPipeline,
        model: _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForSeq2SeqLM,
        default: {
          model: "Xenova/flan-t5-small"
        },
        type: "text"
      },
      "text-generation": {
        tokenizer: _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,
        pipeline: TextGenerationPipeline,
        model: _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForCausalLM,
        default: {
          model: "Xenova/gpt2"
        },
        type: "text"
      },
      "zero-shot-classification": {
        tokenizer: _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,
        pipeline: ZeroShotClassificationPipeline,
        model: _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForSequenceClassification,
        default: {
          model: "Xenova/distilbert-base-uncased-mnli"
        },
        type: "text"
      },
      "audio-classification": {
        pipeline: AudioClassificationPipeline,
        model: _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForAudioClassification,
        processor: _models_auto_processing_auto_js__WEBPACK_IMPORTED_MODULE_2__.AutoProcessor,
        default: {
          model: "Xenova/wav2vec2-base-superb-ks"
        },
        type: "audio"
      },
      "zero-shot-audio-classification": {
        tokenizer: _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,
        pipeline: ZeroShotAudioClassificationPipeline,
        model: _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModel,
        processor: _models_auto_processing_auto_js__WEBPACK_IMPORTED_MODULE_2__.AutoProcessor,
        default: {
          model: "Xenova/clap-htsat-unfused"
        },
        type: "multimodal"
      },
      "automatic-speech-recognition": {
        tokenizer: _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,
        pipeline: AutomaticSpeechRecognitionPipeline,
        model: [_models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForSpeechSeq2Seq, _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForCTC],
        processor: _models_auto_processing_auto_js__WEBPACK_IMPORTED_MODULE_2__.AutoProcessor,
        default: {
          model: "Xenova/whisper-tiny.en"
        },
        type: "multimodal"
      },
      "text-to-audio": {
        tokenizer: _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,
        pipeline: TextToAudioPipeline,
        model: [_models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForTextToWaveform, _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForTextToSpectrogram],
        processor: [_models_auto_processing_auto_js__WEBPACK_IMPORTED_MODULE_2__.AutoProcessor, null],
        default: {
          model: "Xenova/speecht5_tts"
        },
        type: "text"
      },
      "image-to-text": {
        tokenizer: _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,
        pipeline: ImageToTextPipeline,
        model: _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForVision2Seq,
        processor: _models_auto_processing_auto_js__WEBPACK_IMPORTED_MODULE_2__.AutoProcessor,
        default: {
          model: "Xenova/vit-gpt2-image-captioning"
        },
        type: "multimodal"
      },
      "image-classification": {
        pipeline: ImageClassificationPipeline,
        model: _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForImageClassification,
        processor: _models_auto_processing_auto_js__WEBPACK_IMPORTED_MODULE_2__.AutoProcessor,
        default: {
          model: "Xenova/vit-base-patch16-224"
        },
        type: "multimodal"
      },
      "image-segmentation": {
        pipeline: ImageSegmentationPipeline,
        model: [_models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForImageSegmentation, _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForSemanticSegmentation, _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForUniversalSegmentation],
        processor: _models_auto_processing_auto_js__WEBPACK_IMPORTED_MODULE_2__.AutoProcessor,
        default: {
          model: "Xenova/detr-resnet-50-panoptic"
        },
        type: "multimodal"
      },
      "background-removal": {
        pipeline: BackgroundRemovalPipeline,
        model: [_models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForImageSegmentation, _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForSemanticSegmentation, _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForUniversalSegmentation],
        processor: _models_auto_processing_auto_js__WEBPACK_IMPORTED_MODULE_2__.AutoProcessor,
        default: {
          model: "Xenova/modnet"
        },
        type: "image"
      },
      "zero-shot-image-classification": {
        tokenizer: _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,
        pipeline: ZeroShotImageClassificationPipeline,
        model: _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModel,
        processor: _models_auto_processing_auto_js__WEBPACK_IMPORTED_MODULE_2__.AutoProcessor,
        default: {
          model: "Xenova/clip-vit-base-patch32"
        },
        type: "multimodal"
      },
      "object-detection": {
        pipeline: ObjectDetectionPipeline,
        model: _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForObjectDetection,
        processor: _models_auto_processing_auto_js__WEBPACK_IMPORTED_MODULE_2__.AutoProcessor,
        default: {
          model: "Xenova/detr-resnet-50"
        },
        type: "multimodal"
      },
      "zero-shot-object-detection": {
        tokenizer: _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,
        pipeline: ZeroShotObjectDetectionPipeline,
        model: _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForZeroShotObjectDetection,
        processor: _models_auto_processing_auto_js__WEBPACK_IMPORTED_MODULE_2__.AutoProcessor,
        default: {
          model: "Xenova/owlvit-base-patch32"
        },
        type: "multimodal"
      },
      "document-question-answering": {
        tokenizer: _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,
        pipeline: DocumentQuestionAnsweringPipeline,
        model: _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForDocumentQuestionAnswering,
        processor: _models_auto_processing_auto_js__WEBPACK_IMPORTED_MODULE_2__.AutoProcessor,
        default: {
          model: "Xenova/donut-base-finetuned-docvqa"
        },
        type: "multimodal"
      },
      "image-to-image": {
        pipeline: ImageToImagePipeline,
        model: _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForImageToImage,
        processor: _models_auto_processing_auto_js__WEBPACK_IMPORTED_MODULE_2__.AutoProcessor,
        default: {
          model: "Xenova/swin2SR-classical-sr-x2-64"
        },
        type: "image"
      },
      "depth-estimation": {
        pipeline: DepthEstimationPipeline,
        model: _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForDepthEstimation,
        processor: _models_auto_processing_auto_js__WEBPACK_IMPORTED_MODULE_2__.AutoProcessor,
        default: {
          model: "Xenova/dpt-large"
        },
        type: "image"
      },
      "feature-extraction": {
        tokenizer: _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,
        pipeline: FeatureExtractionPipeline,
        model: _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModel,
        default: {
          model: "Xenova/all-MiniLM-L6-v2"
        },
        type: "text"
      },
      "image-feature-extraction": {
        processor: _models_auto_processing_auto_js__WEBPACK_IMPORTED_MODULE_2__.AutoProcessor,
        pipeline: ImageFeatureExtractionPipeline,
        model: [_models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForImageFeatureExtraction, _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModel],
        default: {
          model: "Xenova/vit-base-patch16-224-in21k"
        },
        type: "image"
      }
    });
    const TASK_ALIASES = Object.freeze({
      "sentiment-analysis": "text-classification",
      ner: "token-classification",
      asr: "automatic-speech-recognition",
      "text-to-speech": "text-to-audio",
      embeddings: "feature-extraction"
    });
    async function pipeline2(task, model = null, {
      progress_callback = null,
      config: config3 = null,
      cache_dir = null,
      local_files_only = false,
      revision = "main",
      device = null,
      dtype = null,
      subfolder = "onnx",
      use_external_data_format = null,
      model_file_name = null,
      session_options = {}
    } = {}) {
      task = TASK_ALIASES[task] ?? task;
      const pipelineInfo = SUPPORTED_TASKS[task.split("_", 1)[0]];
      if (!pipelineInfo) {
        throw Error(`Unsupported pipeline: ${task}. Must be one of [${Object.keys(SUPPORTED_TASKS)}]`);
      }
      if (!model) {
        model = pipelineInfo.default.model;
        console.log(`No model specified. Using default model: "${model}".`);
      }
      const pretrainedOptions = {
        progress_callback,
        config: config3,
        cache_dir,
        local_files_only,
        revision,
        device,
        dtype,
        subfolder,
        use_external_data_format,
        model_file_name,
        session_options
      };
      const classes = new Map([
        ["tokenizer", pipelineInfo.tokenizer],
        ["model", pipelineInfo.model],
        ["processor", pipelineInfo.processor]
      ]);
      const results = await loadItems(classes, model, pretrainedOptions);
      results.task = task;
      (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_5__.dispatchCallback)(progress_callback, {
        status: "ready",
        task,
        model
      });
      const pipelineClass = pipelineInfo.pipeline;
      return new pipelineClass(results);
    }
    async function loadItems(mapping, model, pretrainedOptions) {
      const result = Object.create(null);
      const promises = [];
      for (const [name, cls] of mapping.entries()) {
        if (!cls)
          continue;
        let promise3;
        if (Array.isArray(cls)) {
          promise3 = new Promise(async (resolve4, reject) => {
            let e;
            for (const c of cls) {
              if (c === null) {
                resolve4(null);
                return;
              }
              try {
                resolve4(await c.from_pretrained(model, pretrainedOptions));
                return;
              } catch (err) {
                if (err.message?.includes("Unsupported model type")) {
                  e = err;
                } else if (err.message?.includes("Could not locate file")) {
                  e = err;
                } else {
                  reject(err);
                  return;
                }
              }
            }
            reject(e);
          });
        } else {
          promise3 = cls.from_pretrained(model, pretrainedOptions);
        }
        result[name] = promise3;
        promises.push(promise3);
      }
      await Promise.all(promises);
      for (const [name, promise3] of Object.entries(result)) {
        result[name] = await promise3;
      }
      return result;
    }
  },
  "./src/tokenizers.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!***************************!*\
      !*** ./src/tokenizers.js ***!
      \***************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      AlbertTokenizer: () => AlbertTokenizer,
      AutoTokenizer: () => AutoTokenizer,
      BartTokenizer: () => BartTokenizer,
      BertTokenizer: () => BertTokenizer,
      BlenderbotSmallTokenizer: () => BlenderbotSmallTokenizer,
      BlenderbotTokenizer: () => BlenderbotTokenizer,
      BloomTokenizer: () => BloomTokenizer,
      CLIPTokenizer: () => CLIPTokenizer,
      CamembertTokenizer: () => CamembertTokenizer,
      CodeGenTokenizer: () => CodeGenTokenizer,
      CodeLlamaTokenizer: () => CodeLlamaTokenizer,
      CohereTokenizer: () => CohereTokenizer,
      ConvBertTokenizer: () => ConvBertTokenizer,
      DebertaTokenizer: () => DebertaTokenizer,
      DebertaV2Tokenizer: () => DebertaV2Tokenizer,
      DistilBertTokenizer: () => DistilBertTokenizer,
      ElectraTokenizer: () => ElectraTokenizer,
      EsmTokenizer: () => EsmTokenizer,
      FalconTokenizer: () => FalconTokenizer,
      GPT2Tokenizer: () => GPT2Tokenizer,
      GPTNeoXTokenizer: () => GPTNeoXTokenizer,
      GemmaTokenizer: () => GemmaTokenizer,
      Grok1Tokenizer: () => Grok1Tokenizer,
      HerbertTokenizer: () => HerbertTokenizer,
      LlamaTokenizer: () => LlamaTokenizer,
      M2M100Tokenizer: () => M2M100Tokenizer,
      MBart50Tokenizer: () => MBart50Tokenizer,
      MBartTokenizer: () => MBartTokenizer,
      MPNetTokenizer: () => MPNetTokenizer,
      MarianTokenizer: () => MarianTokenizer,
      MgpstrTokenizer: () => MgpstrTokenizer,
      MobileBertTokenizer: () => MobileBertTokenizer,
      NllbTokenizer: () => NllbTokenizer,
      NougatTokenizer: () => NougatTokenizer,
      PreTrainedTokenizer: () => PreTrainedTokenizer,
      Qwen2Tokenizer: () => Qwen2Tokenizer,
      RoFormerTokenizer: () => RoFormerTokenizer,
      RobertaTokenizer: () => RobertaTokenizer,
      SiglipTokenizer: () => SiglipTokenizer,
      SpeechT5Tokenizer: () => SpeechT5Tokenizer,
      SqueezeBertTokenizer: () => SqueezeBertTokenizer,
      T5Tokenizer: () => T5Tokenizer,
      TokenizerModel: () => TokenizerModel,
      VitsTokenizer: () => VitsTokenizer,
      Wav2Vec2CTCTokenizer: () => Wav2Vec2CTCTokenizer,
      WhisperTokenizer: () => WhisperTokenizer,
      XLMRobertaTokenizer: () => XLMRobertaTokenizer,
      XLMTokenizer: () => XLMTokenizer,
      is_chinese_char: () => is_chinese_char
    });
    var _utils_generic_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/utils/generic.js");
    /*! ./utils/generic.js */
    var _utils_core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/utils/core.js");
    /*! ./utils/core.js */
    var _utils_hub_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/utils/hub.js");
    /*! ./utils/hub.js */
    var _utils_maths_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/utils/maths.js");
    /*! ./utils/maths.js */
    var _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./src/utils/tensor.js");
    /*! ./utils/tensor.js */
    var _utils_data_structures_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./src/utils/data-structures.js");
    /*! ./utils/data-structures.js */
    var _huggingface_jinja__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/@huggingface/jinja/dist/index.js");
    /*! @huggingface/jinja */
    var _models_whisper_common_whisper_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./src/models/whisper/common_whisper.js");
    /*! ./models/whisper/common_whisper.js */
    async function loadTokenizer(pretrained_model_name_or_path, options2) {
      const info = await Promise.all([
        (0, _utils_hub_js__WEBPACK_IMPORTED_MODULE_2__.getModelJSON)(pretrained_model_name_or_path, "tokenizer.json", true, options2),
        (0, _utils_hub_js__WEBPACK_IMPORTED_MODULE_2__.getModelJSON)(pretrained_model_name_or_path, "tokenizer_config.json", true, options2)
      ]);
      if (options2.legacy !== null) {
        info[1].legacy = options2.legacy;
      }
      return info;
    }
    function regexSplit(text, regex) {
      const result = [];
      let prev = 0;
      for (const match of text.matchAll(regex)) {
        const fullMatch = match[0];
        if (prev < match.index) {
          result.push(text.slice(prev, match.index));
        }
        if (fullMatch.length > 0) {
          result.push(fullMatch);
        }
        prev = match.index + fullMatch.length;
      }
      if (prev < text.length) {
        result.push(text.slice(prev));
      }
      return result;
    }
    function createPattern(pattern, invert = true) {
      if (pattern.Regex !== undefined) {
        let regex = pattern.Regex.replace(/\\([#&~])/g, "$1");
        for (const [key, value] of PROBLEMATIC_REGEX_MAP) {
          regex = regex.replaceAll(key, value);
        }
        return new RegExp(regex, "gu");
      } else if (pattern.String !== undefined) {
        const escaped = (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_1__.escapeRegExp)(pattern.String);
        return new RegExp(invert ? escaped : `(${escaped})`, "gu");
      } else {
        console.warn("Unknown pattern type:", pattern);
        return null;
      }
    }
    function objectToMap(obj) {
      return new Map(Object.entries(obj));
    }
    function prepareTensorForDecode(tensor2) {
      const dims = tensor2.dims;
      switch (dims.length) {
        case 1:
          return tensor2.tolist();
        case 2:
          if (dims[0] !== 1) {
            throw new Error("Unable to decode tensor with `batch size !== 1`. Use `tokenizer.batch_decode(...)` for batched inputs.");
          }
          return tensor2.tolist()[0];
        default:
          throw new Error(`Expected tensor to have 1-2 dimensions, got ${dims.length}.`);
      }
    }
    function clean_up_tokenization(text) {
      return text.replace(/ \./g, ".").replace(/ \?/g, "?").replace(/ \!/g, "!").replace(/ ,/g, ",").replace(/ \' /g, "'").replace(/ n\'t/g, "n't").replace(/ \'m/g, "'m").replace(/ \'s/g, "'s").replace(/ \'ve/g, "'ve").replace(/ \'re/g, "'re");
    }
    function remove_accents(text) {
      return text.replace(/\p{M}/gu, "");
    }
    function lowercase_and_remove_accent(text) {
      return remove_accents(text.toLowerCase());
    }
    function is_chinese_char(cp) {
      return cp >= 19968 && cp <= 40959 || cp >= 13312 && cp <= 19903 || cp >= 131072 && cp <= 173791 || cp >= 173824 && cp <= 177983 || cp >= 177984 && cp <= 178207 || cp >= 178208 && cp <= 183983 || cp >= 63744 && cp <= 64255 || cp >= 194560 && cp <= 195103;
    }
    function fuse_unk(arr, tokens_to_ids, unk_token_id) {
      const fused = [];
      let i = 0;
      while (i < arr.length) {
        fused.push(arr[i]);
        if ((tokens_to_ids.get(arr[i]) ?? unk_token_id) !== unk_token_id) {
          ++i;
          continue;
        }
        while (++i < arr.length && (tokens_to_ids.get(arr[i]) ?? unk_token_id) === unk_token_id) {
          if (tokens_to_ids.get(fused.at(-1)) !== unk_token_id) {
            fused[fused.length - 1] += arr[i];
          }
        }
      }
      return fused;
    }
    function whitespace_split(text) {
      return text.match(/\S+/g) || [];
    }
    const PUNCTUATION_REGEX = "\\p{P}\\u0021-\\u002F\\u003A-\\u0040\\u005B-\\u0060\\u007B-\\u007E";
    const PUNCTUATION_ONLY_REGEX = new RegExp(`^[${PUNCTUATION_REGEX}]+$`, "gu");
    const BLOOM_SPLIT_CHARS = ".,!?\u2026\u3002\uFF0C\u3001\u0964\u06D4\u060C";
    const PROBLEMATIC_REGEX_MAP = new Map([
      ["(?i:'s|'t|'re|'ve|'m|'ll|'d)", "(?:'([sS]|[tT]|[rR][eE]|[vV][eE]|[mM]|[lL][lL]|[dD]))"],
      ["(?i:[sdmt]|ll|ve|re)", "(?:[sS]|[dD]|[mM]|[tT]|[lL][lL]|[vV][eE]|[rR][eE])"],
      ["[^\\r\\n\\p{L}\\p{N}]?+", "[^\\r\\n\\p{L}\\p{N}]?"],
      ["[^\\s\\p{L}\\p{N}]++", "[^\\s\\p{L}\\p{N}]+"],
      [` ?[^(\\s|[${BLOOM_SPLIT_CHARS}])]+`, ` ?[^\\s${BLOOM_SPLIT_CHARS}]+`]
    ]);

    class AddedToken2 {
      constructor(config3) {
        this.content = config3.content;
        this.id = config3.id;
        this.single_word = config3.single_word ?? false;
        this.lstrip = config3.lstrip ?? false;
        this.rstrip = config3.rstrip ?? false;
        this.special = config3.special ?? false;
        this.normalized = config3.normalized ?? null;
      }
    }

    class TokenizerModel extends _utils_generic_js__WEBPACK_IMPORTED_MODULE_0__.Callable {
      constructor(config3) {
        super();
        this.config = config3;
        this.vocab = [];
        this.tokens_to_ids = new Map;
        this.unk_token_id = undefined;
        this.unk_token = undefined;
        this.end_of_word_suffix = undefined;
        this.fuse_unk = this.config.fuse_unk ?? false;
      }
      static fromConfig(config3, ...args) {
        switch (config3.type) {
          case "WordPiece":
            return new WordPieceTokenizer(config3);
          case "Unigram":
            return new Unigram2(config3, ...args);
          case "BPE":
            return new BPE2(config3);
          default:
            if (config3.vocab) {
              if (Array.isArray(config3.vocab)) {
                return new Unigram2(config3, ...args);
              } else if (Object.hasOwn(config3, "continuing_subword_prefix") && Object.hasOwn(config3, "unk_token")) {
                if (Object.hasOwn(config3, "merges")) {
                  return new BPE2(config3);
                } else {
                  return new WordPieceTokenizer(config3);
                }
              } else {
                return new LegacyTokenizerModel(config3, ...args);
              }
            }
            throw new Error(`Unknown TokenizerModel type: ${config3.type}`);
        }
      }
      _call(tokens) {
        tokens = this.encode(tokens);
        if (this.fuse_unk) {
          tokens = fuse_unk(tokens, this.tokens_to_ids, this.unk_token_id);
        }
        return tokens;
      }
      encode(tokens) {
        throw Error("encode should be implemented in subclass.");
      }
      convert_tokens_to_ids(tokens) {
        return tokens.map((t) => this.tokens_to_ids.get(t) ?? this.unk_token_id);
      }
      convert_ids_to_tokens(ids) {
        return ids.map((i) => this.vocab[i] ?? this.unk_token);
      }
    }

    class WordPieceTokenizer extends TokenizerModel {
      constructor(config3) {
        super(config3);
        this.tokens_to_ids = objectToMap(config3.vocab);
        this.unk_token_id = this.tokens_to_ids.get(config3.unk_token);
        this.unk_token = config3.unk_token;
        this.max_input_chars_per_word = config3.max_input_chars_per_word ?? 100;
        this.vocab = new Array(this.tokens_to_ids.size);
        for (const [key, value] of this.tokens_to_ids) {
          this.vocab[value] = key;
        }
      }
      encode(tokens) {
        const outputTokens = [];
        for (const token of tokens) {
          const chars = [...token];
          if (chars.length > this.max_input_chars_per_word) {
            outputTokens.push(this.unk_token);
            continue;
          }
          let isUnknown = false;
          let start = 0;
          const subTokens = [];
          while (start < chars.length) {
            let end = chars.length;
            let currentSubstring = null;
            while (start < end) {
              let substr = chars.slice(start, end).join("");
              if (start > 0) {
                substr = this.config.continuing_subword_prefix + substr;
              }
              if (this.tokens_to_ids.has(substr)) {
                currentSubstring = substr;
                break;
              }
              --end;
            }
            if (currentSubstring === null) {
              isUnknown = true;
              break;
            }
            subTokens.push(currentSubstring);
            start = end;
          }
          if (isUnknown) {
            outputTokens.push(this.unk_token);
          } else {
            outputTokens.push(...subTokens);
          }
        }
        return outputTokens;
      }
    }

    class Unigram2 extends TokenizerModel {
      constructor(config3, moreConfig) {
        super(config3);
        const vocabSize = config3.vocab.length;
        this.vocab = new Array(vocabSize);
        this.scores = new Array(vocabSize);
        for (let i = 0;i < vocabSize; ++i) {
          [this.vocab[i], this.scores[i]] = config3.vocab[i];
        }
        this.unk_token_id = config3.unk_id;
        this.unk_token = this.vocab[config3.unk_id];
        this.tokens_to_ids = new Map(this.vocab.map((x, i) => [x, i]));
        this.bos_token = " ";
        this.bos_token_id = this.tokens_to_ids.get(this.bos_token);
        this.eos_token = moreConfig.eos_token;
        this.eos_token_id = this.tokens_to_ids.get(this.eos_token);
        this.unk_token = this.vocab[this.unk_token_id];
        this.minScore = (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_3__.min)(this.scores)[0];
        this.unk_score = this.minScore - 10;
        this.scores[this.unk_token_id] = this.unk_score;
        this.trie = new _utils_data_structures_js__WEBPACK_IMPORTED_MODULE_5__.CharTrie;
        this.trie.extend(this.vocab);
        this.fuse_unk = true;
      }
      populateNodes(lattice) {
        const chars = lattice.chars;
        const mblen = 1;
        let beginPos = 0;
        while (beginPos < chars.length) {
          let hasSingleNode = false;
          const tokens = [];
          const sliced = chars.slice(beginPos).join("");
          const prefixedTokens = this.trie.commonPrefixSearch(sliced);
          for (const token of prefixedTokens) {
            tokens.push(token);
            const tokenId = this.tokens_to_ids.get(token);
            const tokenScore = this.scores[tokenId];
            const n = (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_1__.len)(token);
            lattice.insert(beginPos, n, tokenScore, tokenId);
            if (!hasSingleNode && n === mblen) {
              hasSingleNode = true;
            }
          }
          if (!hasSingleNode) {
            lattice.insert(beginPos, mblen, this.unk_score, this.unk_token_id);
          }
          beginPos += mblen;
        }
      }
      tokenize(normalized) {
        const lattice = new _utils_data_structures_js__WEBPACK_IMPORTED_MODULE_5__.TokenLattice(normalized, this.bos_token_id, this.eos_token_id);
        this.populateNodes(lattice);
        return lattice.tokens();
      }
      encode(tokens) {
        const toReturn = [];
        for (const token of tokens) {
          const tokenized = this.tokenize(token);
          toReturn.push(...tokenized);
        }
        return toReturn;
      }
    }
    const BYTES_TO_UNICODE = (() => {
      const bs = [
        ...Array.from({ length: 126 - 33 + 1 }, (_, i) => i + 33),
        ...Array.from({ length: "\xAC".charCodeAt(0) - "\xA1".charCodeAt(0) + 1 }, (_, i) => i + "\xA1".charCodeAt(0)),
        ...Array.from({ length: "\xFF".charCodeAt(0) - "\xAE".charCodeAt(0) + 1 }, (_, i) => i + "\xAE".charCodeAt(0))
      ];
      const cs = bs.slice();
      let n = 0;
      for (let b = 0;b < 256; ++b) {
        if (!bs.includes(b)) {
          bs.push(b);
          cs.push(256 + n);
          n += 1;
        }
      }
      const ccs = cs.map((n2) => String.fromCharCode(n2));
      return Object.fromEntries(bs.map((b, i) => [b, ccs[i]]));
    })();
    const UNICODE_TO_BYTES = (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_1__.reverseDictionary)(BYTES_TO_UNICODE);

    class BPE2 extends TokenizerModel {
      constructor(config3) {
        super(config3);
        this.tokens_to_ids = objectToMap(config3.vocab);
        this.unk_token_id = this.tokens_to_ids.get(config3.unk_token);
        this.unk_token = config3.unk_token;
        this.vocab = new Array(this.tokens_to_ids.size);
        for (const [key, value] of this.tokens_to_ids) {
          this.vocab[value] = key;
        }
        const use_new_merge_format = Array.isArray(config3.merges[0]);
        this.merges = use_new_merge_format ? config3.merges : config3.merges.map((x) => x.split(" ", 2));
        this.bpe_ranks = new Map(this.merges.map((x, i) => [JSON.stringify(x), i]));
        this.end_of_word_suffix = config3.end_of_word_suffix;
        this.continuing_subword_suffix = config3.continuing_subword_suffix ?? null;
        this.byte_fallback = this.config.byte_fallback ?? false;
        if (this.byte_fallback) {
          this.text_encoder = new TextEncoder;
        }
        this.ignore_merges = this.config.ignore_merges ?? false;
        this.max_length_to_cache = 256;
        this.cache_capacity = 1e4;
        this.cache = new _utils_data_structures_js__WEBPACK_IMPORTED_MODULE_5__.LRUCache(this.cache_capacity);
      }
      clear_cache() {
        this.cache.clear();
      }
      bpe(token) {
        if (token.length === 0) {
          return [];
        }
        const cached3 = this.cache.get(token);
        if (cached3 !== undefined) {
          return cached3;
        }
        const word = Array.from(token);
        if (this.end_of_word_suffix) {
          word[word.length - 1] += this.end_of_word_suffix;
        }
        let result = [];
        if (word.length > 1) {
          const queue = new _utils_data_structures_js__WEBPACK_IMPORTED_MODULE_5__.PriorityQueue((a, b) => a.score < b.score);
          let startingNode = {
            token: word[0],
            bias: 0,
            prev: null,
            next: null
          };
          let previousNode = startingNode;
          for (let i = 1;i < word.length; ++i) {
            const currentNode = {
              bias: i / word.length,
              token: word[i],
              prev: previousNode,
              next: null
            };
            previousNode.next = currentNode;
            this._add_node(queue, previousNode);
            previousNode = currentNode;
          }
          while (!queue.isEmpty()) {
            const node = queue.pop();
            if (node.deleted || !node.next || node.next.deleted)
              continue;
            node.deleted = true;
            node.next.deleted = true;
            if (node.prev) {
              const newPreviousNode = { ...node.prev };
              node.prev.deleted = true;
              node.prev = newPreviousNode;
              if (newPreviousNode.prev) {
                newPreviousNode.prev.next = newPreviousNode;
              } else {
                startingNode = newPreviousNode;
              }
            }
            const merged = {
              token: node.token + node.next.token,
              bias: node.bias,
              prev: node.prev,
              next: node.next.next
            };
            if (merged.prev) {
              merged.prev.next = merged;
              this._add_node(queue, merged.prev);
            } else {
              startingNode = merged;
            }
            if (merged.next) {
              merged.next.prev = merged;
              this._add_node(queue, merged);
            }
          }
          for (let currentNode = startingNode;currentNode !== null; currentNode = currentNode.next) {
            result.push(currentNode.token);
          }
        } else {
          result = word;
        }
        if (this.continuing_subword_suffix) {
          for (let i = 0;i < result.length - 1; ++i) {
            result[i] += this.continuing_subword_suffix;
          }
        }
        if (token.length < this.max_length_to_cache) {
          this.cache.put(token, result);
        }
        return result;
      }
      _add_node(queue, node) {
        const rank = this.bpe_ranks.get(JSON.stringify([node.token, node.next.token]));
        if (rank !== undefined) {
          node.score = rank + node.bias;
          queue.push(node);
        }
      }
      encode(tokens) {
        const outputTokens = [];
        for (const token of tokens) {
          if (this.ignore_merges && this.tokens_to_ids.has(token)) {
            outputTokens.push(token);
            continue;
          }
          const bpe_token_list = this.bpe(token);
          for (const t of bpe_token_list) {
            if (this.tokens_to_ids.has(t)) {
              outputTokens.push(t);
            } else if (this.byte_fallback) {
              const byteTokens = Array.from(this.text_encoder.encode(t)).map((x) => `<0x${x.toString(16).toUpperCase().padStart(2, "0")}>`);
              if (byteTokens.every((x) => this.tokens_to_ids.has(x))) {
                outputTokens.push(...byteTokens);
              } else {
                outputTokens.push(this.unk_token);
              }
            } else {
              outputTokens.push(this.unk_token);
            }
          }
        }
        return outputTokens;
      }
    }

    class LegacyTokenizerModel extends TokenizerModel {
      constructor(config3, moreConfig) {
        super(config3);
        this.tokens_to_ids = objectToMap(moreConfig.target_lang ? config3.vocab[moreConfig.target_lang] : config3.vocab);
        this.bos_token = moreConfig.bos_token;
        this.bos_token_id = this.tokens_to_ids.get(this.bos_token);
        this.eos_token = moreConfig.eos_token;
        this.eos_token_id = this.tokens_to_ids.get(this.eos_token);
        this.pad_token = moreConfig.pad_token;
        this.pad_token_id = this.tokens_to_ids.get(this.pad_token);
        this.unk_token = moreConfig.unk_token;
        this.unk_token_id = this.tokens_to_ids.get(this.unk_token);
        this.vocab = new Array(this.tokens_to_ids.size);
        for (const [key, value] of this.tokens_to_ids) {
          this.vocab[value] = key;
        }
      }
      encode(tokens) {
        return tokens;
      }
    }

    class Normalizer2 extends _utils_generic_js__WEBPACK_IMPORTED_MODULE_0__.Callable {
      constructor(config3) {
        super();
        this.config = config3;
      }
      static fromConfig(config3) {
        if (config3 === null)
          return null;
        switch (config3.type) {
          case "BertNormalizer":
            return new BertNormalizer(config3);
          case "Precompiled":
            return new Precompiled(config3);
          case "Sequence":
            return new NormalizerSequence(config3);
          case "Replace":
            return new Replace(config3);
          case "NFC":
            return new NFC(config3);
          case "NFD":
            return new NFD(config3);
          case "NFKC":
            return new NFKC(config3);
          case "NFKD":
            return new NFKD(config3);
          case "Strip":
            return new StripNormalizer(config3);
          case "StripAccents":
            return new StripAccents(config3);
          case "Lowercase":
            return new Lowercase(config3);
          case "Prepend":
            return new Prepend(config3);
          default:
            throw new Error(`Unknown Normalizer type: ${config3.type}`);
        }
      }
      normalize(text) {
        throw Error("normalize should be implemented in subclass.");
      }
      _call(text) {
        return this.normalize(text);
      }
    }

    class Replace extends Normalizer2 {
      normalize(text) {
        const pattern = createPattern(this.config.pattern);
        return pattern === null ? text : text.replaceAll(pattern, this.config.content);
      }
    }

    class UnicodeNormalizer extends Normalizer2 {
      form = undefined;
      normalize(text) {
        text = text.normalize(this.form);
        return text;
      }
    }

    class NFC extends UnicodeNormalizer {
      form = "NFC";
    }

    class NFD extends UnicodeNormalizer {
      form = "NFD";
    }

    class NFKC extends UnicodeNormalizer {
      form = "NFKC";
    }

    class NFKD extends UnicodeNormalizer {
      form = "NFKD";
    }

    class StripNormalizer extends Normalizer2 {
      normalize(text) {
        if (this.config.strip_left && this.config.strip_right) {
          text = text.trim();
        } else {
          if (this.config.strip_left) {
            text = text.trimStart();
          }
          if (this.config.strip_right) {
            text = text.trimEnd();
          }
        }
        return text;
      }
    }

    class StripAccents extends Normalizer2 {
      normalize(text) {
        text = remove_accents(text);
        return text;
      }
    }

    class Lowercase extends Normalizer2 {
      normalize(text) {
        text = text.toLowerCase();
        return text;
      }
    }

    class Prepend extends Normalizer2 {
      normalize(text) {
        text = this.config.prepend + text;
        return text;
      }
    }

    class NormalizerSequence extends Normalizer2 {
      constructor(config3) {
        super(config3);
        this.normalizers = config3.normalizers.map((x) => Normalizer2.fromConfig(x));
      }
      normalize(text) {
        return this.normalizers.reduce((t, normalizer) => {
          return normalizer.normalize(t);
        }, text);
      }
    }

    class BertNormalizer extends Normalizer2 {
      _tokenize_chinese_chars(text) {
        const output = [];
        for (let i = 0;i < text.length; ++i) {
          const char = text[i];
          const cp = char.charCodeAt(0);
          if (is_chinese_char(cp)) {
            output.push(" ");
            output.push(char);
            output.push(" ");
          } else {
            output.push(char);
          }
        }
        return output.join("");
      }
      stripAccents(text) {
        return text.normalize("NFD").replace(/\p{Mn}/gu, "");
      }
      _is_control(char) {
        switch (char) {
          case "\t":
          case `
`:
          case "\r":
            return false;
          default:
            return /^\p{Cc}|\p{Cf}|\p{Co}|\p{Cs}$/u.test(char);
        }
      }
      _clean_text(text) {
        const output = [];
        for (const char of text) {
          const cp = char.charCodeAt(0);
          if (cp === 0 || cp === 65533 || this._is_control(char)) {
            continue;
          }
          if (/^\s$/.test(char)) {
            output.push(" ");
          } else {
            output.push(char);
          }
        }
        return output.join("");
      }
      normalize(text) {
        if (this.config.clean_text) {
          text = this._clean_text(text);
        }
        if (this.config.handle_chinese_chars) {
          text = this._tokenize_chinese_chars(text);
        }
        if (this.config.lowercase) {
          text = text.toLowerCase();
          if (this.config.strip_accents !== false) {
            text = this.stripAccents(text);
          }
        } else if (this.config.strip_accents) {
          text = this.stripAccents(text);
        }
        return text;
      }
    }

    class PreTokenizer2 extends _utils_generic_js__WEBPACK_IMPORTED_MODULE_0__.Callable {
      static fromConfig(config3) {
        if (config3 === null)
          return null;
        switch (config3.type) {
          case "BertPreTokenizer":
            return new BertPreTokenizer(config3);
          case "Sequence":
            return new PreTokenizerSequence(config3);
          case "Whitespace":
            return new WhitespacePreTokenizer(config3);
          case "WhitespaceSplit":
            return new WhitespaceSplit(config3);
          case "Metaspace":
            return new MetaspacePreTokenizer(config3);
          case "ByteLevel":
            return new ByteLevelPreTokenizer(config3);
          case "Split":
            return new SplitPreTokenizer(config3);
          case "Punctuation":
            return new PunctuationPreTokenizer(config3);
          case "Digits":
            return new DigitsPreTokenizer(config3);
          case "Replace":
            return new ReplacePreTokenizer(config3);
          case "FixedLength":
            return new FixedLengthPreTokenizer(config3);
          default:
            throw new Error(`Unknown PreTokenizer type: ${config3.type}`);
        }
      }
      pre_tokenize_text(text, options2) {
        throw Error("pre_tokenize_text should be implemented in subclass.");
      }
      pre_tokenize(text, options2) {
        return (Array.isArray(text) ? text.map((x) => this.pre_tokenize_text(x, options2)) : this.pre_tokenize_text(text, options2)).flat();
      }
      _call(text, options2) {
        return this.pre_tokenize(text, options2);
      }
    }

    class BertPreTokenizer extends PreTokenizer2 {
      constructor(config3) {
        super();
        this.pattern = new RegExp(`[^\\s${PUNCTUATION_REGEX}]+|[${PUNCTUATION_REGEX}]`, "gu");
      }
      pre_tokenize_text(text, options2) {
        return text.trim().match(this.pattern) || [];
      }
    }

    class ByteLevelPreTokenizer extends PreTokenizer2 {
      constructor(config3) {
        super();
        this.config = config3;
        this.add_prefix_space = this.config.add_prefix_space;
        this.trim_offsets = this.config.trim_offsets;
        this.use_regex = this.config.use_regex ?? true;
        this.pattern = /'s|'t|'re|'ve|'m|'ll|'d| ?\p{L}+| ?\p{N}+| ?[^\s\p{L}\p{N}]+|\s+(?!\S)|\s+/gu;
        this.byte_encoder = BYTES_TO_UNICODE;
        this.text_encoder = new TextEncoder;
      }
      pre_tokenize_text(text, options2) {
        if (this.add_prefix_space && !text.startsWith(" ")) {
          text = " " + text;
        }
        const tokens = this.use_regex ? text.match(this.pattern) || [] : [text];
        return tokens.map((token) => Array.from(this.text_encoder.encode(token), (byte) => this.byte_encoder[byte]).join(""));
      }
    }

    class SplitPreTokenizer extends PreTokenizer2 {
      constructor(config3) {
        super();
        this.config = config3;
        this.pattern = createPattern(this.config.pattern, this.config.invert);
      }
      pre_tokenize_text(text, options2) {
        if (this.pattern === null) {
          return [];
        }
        if (this.config.invert) {
          return text.match(this.pattern) || [];
        } else if (this.config.behavior?.toLowerCase() === "removed") {
          return text.split(this.pattern).filter((x) => x);
        } else {
          return regexSplit(text, this.pattern);
        }
      }
    }

    class PunctuationPreTokenizer extends PreTokenizer2 {
      constructor(config3) {
        super();
        this.config = config3;
        this.pattern = new RegExp(`[^${PUNCTUATION_REGEX}]+|[${PUNCTUATION_REGEX}]+`, "gu");
      }
      pre_tokenize_text(text, options2) {
        return text.match(this.pattern) || [];
      }
    }

    class DigitsPreTokenizer extends PreTokenizer2 {
      constructor(config3) {
        super();
        this.config = config3;
        const digit_pattern = `[^\\d]+|\\d${this.config.individual_digits ? "" : "+"}`;
        this.pattern = new RegExp(digit_pattern, "gu");
      }
      pre_tokenize_text(text, options2) {
        return text.match(this.pattern) || [];
      }
    }

    class PostProcessor extends _utils_generic_js__WEBPACK_IMPORTED_MODULE_0__.Callable {
      constructor(config3) {
        super();
        this.config = config3;
      }
      static fromConfig(config3) {
        if (config3 === null)
          return null;
        switch (config3.type) {
          case "TemplateProcessing":
            return new TemplateProcessing(config3);
          case "ByteLevel":
            return new ByteLevelPostProcessor(config3);
          case "RobertaProcessing":
            return new RobertaProcessing(config3);
          case "BertProcessing":
            return new BertProcessing(config3);
          case "Sequence":
            return new PostProcessorSequence(config3);
          default:
            throw new Error(`Unknown PostProcessor type: ${config3.type}`);
        }
      }
      post_process(tokens, ...args) {
        throw Error("post_process should be implemented in subclass.");
      }
      _call(tokens, ...args) {
        return this.post_process(tokens, ...args);
      }
    }

    class BertProcessing extends PostProcessor {
      constructor(config3) {
        super(config3);
        this.cls = config3.cls[0];
        this.sep = config3.sep[0];
      }
      post_process(tokens, tokens_pair = null, {
        add_special_tokens = true
      } = {}) {
        if (add_special_tokens) {
          tokens = (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_1__.mergeArrays)([this.cls], tokens, [this.sep]);
        }
        let token_type_ids = new Array(tokens.length).fill(0);
        if (tokens_pair !== null) {
          const middle = add_special_tokens && this instanceof RobertaProcessing ? [this.sep] : [];
          const after = add_special_tokens ? [this.sep] : [];
          tokens = (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_1__.mergeArrays)(tokens, middle, tokens_pair, after);
          token_type_ids = (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_1__.mergeArrays)(token_type_ids, new Array(tokens_pair.length + middle.length + after.length).fill(1));
        }
        return { tokens, token_type_ids };
      }
    }

    class RobertaProcessing extends BertProcessing {
    }

    class TemplateProcessing extends PostProcessor {
      constructor(config3) {
        super(config3);
        this.single = config3.single;
        this.pair = config3.pair;
      }
      post_process(tokens, tokens_pair = null, {
        add_special_tokens = true
      } = {}) {
        const type = tokens_pair === null ? this.single : this.pair;
        let processedTokens = [];
        let types = [];
        for (const item of type) {
          if ("SpecialToken" in item) {
            if (add_special_tokens) {
              processedTokens.push(item.SpecialToken.id);
              types.push(item.SpecialToken.type_id);
            }
          } else if ("Sequence" in item) {
            if (item.Sequence.id === "A") {
              processedTokens = (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_1__.mergeArrays)(processedTokens, tokens);
              types = (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_1__.mergeArrays)(types, new Array(tokens.length).fill(item.Sequence.type_id));
            } else if (item.Sequence.id === "B") {
              processedTokens = (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_1__.mergeArrays)(processedTokens, tokens_pair);
              types = (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_1__.mergeArrays)(types, new Array(tokens_pair.length).fill(item.Sequence.type_id));
            }
          }
        }
        return { tokens: processedTokens, token_type_ids: types };
      }
    }

    class ByteLevelPostProcessor extends PostProcessor {
      post_process(tokens, tokens_pair = null) {
        if (tokens_pair) {
          tokens = (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_1__.mergeArrays)(tokens, tokens_pair);
        }
        return { tokens };
      }
    }

    class PostProcessorSequence extends PostProcessor {
      constructor(config3) {
        super(config3);
        this.processors = config3.processors.map((x) => PostProcessor.fromConfig(x));
      }
      post_process(tokens, tokens_pair = null, options2 = {}) {
        let token_type_ids;
        for (const processor of this.processors) {
          if (processor instanceof ByteLevelPostProcessor) {
            const output = processor.post_process(tokens);
            tokens = output.tokens;
            if (tokens_pair) {
              const pair_output = processor.post_process(tokens_pair);
              tokens_pair = pair_output.tokens;
            }
          } else {
            const output = processor.post_process(tokens, tokens_pair, options2);
            tokens = output.tokens;
            token_type_ids = output.token_type_ids;
          }
        }
        return { tokens, token_type_ids };
      }
    }

    class Decoder2 extends _utils_generic_js__WEBPACK_IMPORTED_MODULE_0__.Callable {
      constructor(config3) {
        super();
        this.config = config3;
        this.added_tokens = [];
        this.end_of_word_suffix = null;
        this.trim_offsets = config3.trim_offsets;
      }
      static fromConfig(config3) {
        if (config3 === null)
          return null;
        switch (config3.type) {
          case "WordPiece":
            return new WordPieceDecoder(config3);
          case "Metaspace":
            return new MetaspaceDecoder(config3);
          case "ByteLevel":
            return new ByteLevelDecoder(config3);
          case "Replace":
            return new ReplaceDecoder(config3);
          case "ByteFallback":
            return new ByteFallback(config3);
          case "Fuse":
            return new FuseDecoder(config3);
          case "Strip":
            return new StripDecoder(config3);
          case "Sequence":
            return new DecoderSequence(config3);
          case "CTC":
            return new CTCDecoder(config3);
          case "BPEDecoder":
            return new BPEDecoder(config3);
          default:
            throw new Error(`Unknown Decoder type: ${config3.type}`);
        }
      }
      _call(tokens) {
        return this.decode(tokens);
      }
      decode(tokens) {
        return this.decode_chain(tokens).join("");
      }
      decode_chain(tokens) {
        throw Error("`decode_chain` should be implemented in subclass.");
      }
    }

    class ReplaceDecoder extends Decoder2 {
      decode_chain(tokens) {
        const pattern = createPattern(this.config.pattern);
        return pattern === null ? tokens : tokens.map((token) => token.replaceAll(pattern, this.config.content));
      }
    }

    class ByteFallback extends Decoder2 {
      constructor(config3) {
        super(config3);
        this.text_decoder = new TextDecoder;
      }
      decode_chain(tokens) {
        const new_tokens = [];
        let previous_byte_tokens = [];
        for (const token of tokens) {
          let bytes = null;
          if (token.length === 6 && token.startsWith("<0x") && token.endsWith(">")) {
            const byte = parseInt(token.slice(3, 5), 16);
            if (!isNaN(byte)) {
              bytes = byte;
            }
          }
          if (bytes !== null) {
            previous_byte_tokens.push(bytes);
          } else {
            if (previous_byte_tokens.length > 0) {
              const string7 = this.text_decoder.decode(Uint8Array.from(previous_byte_tokens));
              new_tokens.push(string7);
              previous_byte_tokens = [];
            }
            new_tokens.push(token);
          }
        }
        if (previous_byte_tokens.length > 0) {
          const string7 = this.text_decoder.decode(Uint8Array.from(previous_byte_tokens));
          new_tokens.push(string7);
          previous_byte_tokens = [];
        }
        return new_tokens;
      }
    }

    class FuseDecoder extends Decoder2 {
      decode_chain(tokens) {
        return [tokens.join("")];
      }
    }

    class StripDecoder extends Decoder2 {
      constructor(config3) {
        super(config3);
        this.content = this.config.content;
        this.start = this.config.start;
        this.stop = this.config.stop;
      }
      decode_chain(tokens) {
        return tokens.map((token) => {
          let start_cut = 0;
          for (let i = 0;i < this.start; ++i) {
            if (token[i] === this.content) {
              start_cut = i + 1;
              continue;
            } else {
              break;
            }
          }
          let stop_cut = token.length;
          for (let i = 0;i < this.stop; ++i) {
            const index = token.length - i - 1;
            if (token[index] === this.content) {
              stop_cut = index;
              continue;
            } else {
              break;
            }
          }
          return token.slice(start_cut, stop_cut);
        });
      }
    }

    class WordPieceDecoder extends Decoder2 {
      constructor(config3) {
        super(config3);
        this.cleanup = config3.cleanup;
      }
      decode_chain(tokens) {
        return tokens.map((token, i) => {
          if (i !== 0) {
            if (token.startsWith(this.config.prefix)) {
              token = token.replace(this.config.prefix, "");
            } else {
              token = " " + token;
            }
          }
          if (this.cleanup) {
            token = clean_up_tokenization(token);
          }
          return token;
        });
      }
    }

    class ByteLevelDecoder extends Decoder2 {
      constructor(config3) {
        super(config3);
        this.byte_decoder = UNICODE_TO_BYTES;
        this.text_decoder = new TextDecoder("utf-8", {
          fatal: false,
          ignoreBOM: true
        });
        this.end_of_word_suffix = null;
      }
      convert_tokens_to_string(tokens) {
        const text = tokens.join("");
        const byteArray = new Uint8Array([...text].map((c) => this.byte_decoder[c]));
        const decoded_text = this.text_decoder.decode(byteArray);
        return decoded_text;
      }
      decode_chain(tokens) {
        const sub_texts = [];
        let current_sub_text = [];
        for (const token of tokens) {
          if (this.added_tokens.find((x) => x.content === token) !== undefined) {
            if (current_sub_text.length > 0) {
              sub_texts.push(this.convert_tokens_to_string(current_sub_text));
              current_sub_text = [];
            }
            sub_texts.push(token);
          } else {
            current_sub_text.push(token);
          }
        }
        if (current_sub_text.length > 0) {
          sub_texts.push(this.convert_tokens_to_string(current_sub_text));
        }
        return sub_texts;
      }
    }

    class CTCDecoder extends Decoder2 {
      constructor(config3) {
        super(config3);
        this.pad_token = this.config.pad_token;
        this.word_delimiter_token = this.config.word_delimiter_token;
        this.cleanup = this.config.cleanup;
      }
      convert_tokens_to_string(tokens) {
        if (tokens.length === 0)
          return "";
        const grouped_tokens = [tokens[0]];
        for (let i = 1;i < tokens.length; ++i) {
          if (tokens[i] !== grouped_tokens.at(-1)) {
            grouped_tokens.push(tokens[i]);
          }
        }
        const filtered_tokens = grouped_tokens.filter((token) => token !== this.pad_token);
        let text = filtered_tokens.join("");
        if (this.cleanup) {
          text = clean_up_tokenization(text).replaceAll(this.word_delimiter_token, " ").trim();
        }
        return text;
      }
      decode_chain(tokens) {
        return [this.convert_tokens_to_string(tokens)];
      }
    }

    class DecoderSequence extends Decoder2 {
      constructor(config3) {
        super(config3);
        this.decoders = config3.decoders.map((x) => Decoder2.fromConfig(x));
      }
      decode_chain(tokens) {
        return this.decoders.reduce((toks, decoder) => {
          return decoder.decode_chain(toks);
        }, tokens);
      }
    }

    class BPEDecoder extends Decoder2 {
      constructor(config3) {
        super(config3);
        this.suffix = this.config.suffix;
      }
      decode_chain(tokens) {
        return tokens.map((token, i) => {
          return token.replaceAll(this.suffix, i === tokens.length - 1 ? "" : " ");
        });
      }
    }

    class VitsDecoder extends Decoder2 {
      decode_chain(tokens) {
        let decoded = "";
        for (let i = 1;i < tokens.length; i += 2) {
          decoded += tokens[i];
        }
        return [decoded];
      }
    }

    class MetaspacePreTokenizer extends PreTokenizer2 {
      constructor(config3) {
        super();
        this.replacement = config3.replacement;
        this.strRep = config3.str_rep || this.replacement;
        this.prepend_scheme = config3.prepend_scheme ?? "always";
      }
      pre_tokenize_text(text, {
        section_index = undefined
      } = {}) {
        let normalized = text.replaceAll(" ", this.strRep);
        if (!normalized.startsWith(this.replacement) && (this.prepend_scheme === "always" || this.prepend_scheme === "first" && section_index === 0)) {
          normalized = this.strRep + normalized;
        }
        return [normalized];
      }
    }

    class MetaspaceDecoder extends Decoder2 {
      constructor(config3) {
        super(config3);
        this.replacement = config3.replacement;
      }
      decode_chain(tokens) {
        const result = [];
        for (let i = 0;i < tokens.length; ++i) {
          let normalized = tokens[i].replaceAll(this.replacement, " ");
          if (i == 0 && normalized.startsWith(" ")) {
            normalized = normalized.substring(1);
          }
          result.push(normalized);
        }
        return result;
      }
    }

    class Precompiled extends Normalizer2 {
      constructor(config3) {
        super(config3);
        this.charsmap = config3.precompiled_charsmap;
      }
      normalize(text) {
        text = text.replace(/[\u0001-\u0008\u000B\u000E-\u001F\u007F\u008F\u009F]/gm, "");
        text = text.replace(/[\u0009\u000A\u000C\u000D\u00A0\u1680\u2000-\u200F\u2028\u2029\u202F\u205F\u2581\u3000\uFEFF\uFFFD]/gm, " ");
        if (text.includes("\uFF5E")) {
          const parts = text.split("\uFF5E");
          text = parts.map((part) => part.normalize("NFKC")).join("\uFF5E");
        } else {
          text = text.normalize("NFKC");
        }
        return text;
      }
    }

    class PreTokenizerSequence extends PreTokenizer2 {
      constructor(config3) {
        super();
        this.tokenizers = config3.pretokenizers.map((x) => PreTokenizer2.fromConfig(x));
      }
      pre_tokenize_text(text, options2) {
        return this.tokenizers.reduce((preTokenizedText, tokenizer) => {
          return tokenizer.pre_tokenize(preTokenizedText, options2);
        }, [text]);
      }
    }

    class WhitespacePreTokenizer extends PreTokenizer2 {
      constructor(config3) {
        super();
      }
      pre_tokenize_text(text, options2) {
        return text.match(/\w+|[^\w\s]+/g) || [];
      }
    }

    class WhitespaceSplit extends PreTokenizer2 {
      constructor(config3) {
        super();
      }
      pre_tokenize_text(text, options2) {
        return whitespace_split(text);
      }
    }

    class ReplacePreTokenizer extends PreTokenizer2 {
      constructor(config3) {
        super();
        this.config = config3;
        this.pattern = createPattern(this.config.pattern);
        this.content = this.config.content;
      }
      pre_tokenize_text(text, options2) {
        if (this.pattern === null) {
          return [text];
        }
        return [text.replaceAll(this.pattern, this.config.content)];
      }
    }

    class FixedLengthPreTokenizer extends PreTokenizer2 {
      constructor(config3) {
        super();
        this._length = config3.length;
      }
      pre_tokenize_text(text, options2) {
        const tokens = [];
        for (let i = 0;i < text.length; i += this._length) {
          tokens.push(text.slice(i, i + this._length));
        }
        return tokens;
      }
    }
    const SPECIAL_TOKEN_ATTRIBUTES = [
      "bos_token",
      "eos_token",
      "unk_token",
      "sep_token",
      "pad_token",
      "cls_token",
      "mask_token"
    ];
    function padHelper(item, length, value_fn, side) {
      for (const key of Object.keys(item)) {
        const diff = length - item[key].length;
        const value = value_fn(key);
        const padData = new Array(diff).fill(value);
        item[key] = side === "right" ? (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_1__.mergeArrays)(item[key], padData) : (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_1__.mergeArrays)(padData, item[key]);
      }
    }
    function truncateHelper(item, length) {
      for (const key of Object.keys(item)) {
        item[key].length = length;
      }
    }

    class PreTrainedTokenizer extends _utils_generic_js__WEBPACK_IMPORTED_MODULE_0__.Callable {
      return_token_type_ids = false;
      padding_side = "right";
      constructor(tokenizerJSON, tokenizerConfig) {
        super();
        this.config = tokenizerConfig;
        this.normalizer = Normalizer2.fromConfig(tokenizerJSON.normalizer);
        this.pre_tokenizer = PreTokenizer2.fromConfig(tokenizerJSON.pre_tokenizer);
        this.model = TokenizerModel.fromConfig(tokenizerJSON.model, tokenizerConfig);
        this.post_processor = PostProcessor.fromConfig(tokenizerJSON.post_processor);
        this.decoder = Decoder2.fromConfig(tokenizerJSON.decoder);
        this.special_tokens = [];
        this.all_special_ids = [];
        this.added_tokens = [];
        for (const addedToken of tokenizerJSON.added_tokens) {
          const token = new AddedToken2(addedToken);
          this.added_tokens.push(token);
          this.model.tokens_to_ids.set(token.content, token.id);
          this.model.vocab[token.id] = token.content;
          if (token.special) {
            this.special_tokens.push(token.content);
            this.all_special_ids.push(token.id);
          }
        }
        this.additional_special_tokens = tokenizerConfig.additional_special_tokens ?? [];
        this.special_tokens.push(...this.additional_special_tokens);
        this.special_tokens = [...new Set(this.special_tokens)];
        if (this.decoder) {
          this.decoder.added_tokens = this.added_tokens;
          this.decoder.end_of_word_suffix = this.model.end_of_word_suffix;
        }
        this.added_tokens_splitter = new _utils_data_structures_js__WEBPACK_IMPORTED_MODULE_5__.DictionarySplitter(this.added_tokens.map((x) => x.content));
        this.added_tokens_map = new Map(this.added_tokens.map((x) => [x.content, x]));
        this.mask_token = this.getToken("mask_token");
        this.mask_token_id = this.model.tokens_to_ids.get(this.mask_token);
        this.pad_token = this.getToken("pad_token", "eos_token");
        this.pad_token_id = this.model.tokens_to_ids.get(this.pad_token);
        this.sep_token = this.getToken("sep_token");
        this.sep_token_id = this.model.tokens_to_ids.get(this.sep_token);
        this.unk_token = this.getToken("unk_token");
        this.unk_token_id = this.model.tokens_to_ids.get(this.unk_token);
        this.bos_token = this.getToken("bos_token");
        this.bos_token_id = this.model.tokens_to_ids.get(this.bos_token);
        this.eos_token = this.getToken("eos_token");
        this.eos_token_id = this.model.tokens_to_ids.get(this.eos_token);
        this.model_max_length = tokenizerConfig.model_max_length;
        this.remove_space = tokenizerConfig.remove_space;
        this.clean_up_tokenization_spaces = tokenizerConfig.clean_up_tokenization_spaces ?? true;
        this.do_lowercase_and_remove_accent = tokenizerConfig.do_lowercase_and_remove_accent ?? false;
        if (tokenizerConfig.padding_side) {
          this.padding_side = tokenizerConfig.padding_side;
        }
        this.add_bos_token = tokenizerConfig.add_bos_token;
        this.add_eos_token = tokenizerConfig.add_eos_token;
        this.legacy = false;
        this.chat_template = tokenizerConfig.chat_template ?? null;
        if (Array.isArray(this.chat_template)) {
          const chat_template = Object.create(null);
          for (const { name, template } of this.chat_template) {
            if (typeof name !== "string" || typeof template !== "string") {
              throw new Error('Chat template must be a list of objects with "name" and "template" properties');
            }
            chat_template[name] = template;
          }
          this.chat_template = chat_template;
        }
        this._compiled_template_cache = new Map;
      }
      getToken(...keys) {
        for (const key of keys) {
          const item = this.config[key];
          if (!item)
            continue;
          if (typeof item === "object") {
            if (item.__type === "AddedToken") {
              return item.content;
            } else {
              throw Error(`Unknown token: ${item}`);
            }
          } else {
            return item;
          }
        }
        return null;
      }
      static async from_pretrained(pretrained_model_name_or_path, {
        progress_callback = null,
        config: config3 = null,
        cache_dir = null,
        local_files_only = false,
        revision = "main",
        legacy = null
      } = {}) {
        const info = await loadTokenizer(pretrained_model_name_or_path, {
          progress_callback,
          config: config3,
          cache_dir,
          local_files_only,
          revision,
          legacy
        });
        return new this(...info);
      }
      _call(text, {
        text_pair = null,
        add_special_tokens = true,
        padding = false,
        truncation = null,
        max_length = null,
        return_tensor = true,
        return_token_type_ids = null
      } = {}) {
        const isBatched = Array.isArray(text);
        let encodedTokens;
        if (isBatched) {
          if (text.length === 0) {
            throw Error("text array must be non-empty");
          }
          if (text_pair !== null) {
            if (!Array.isArray(text_pair)) {
              throw Error("text_pair must also be an array");
            } else if (text.length !== text_pair.length) {
              throw Error("text and text_pair must have the same length");
            }
            encodedTokens = text.map((t, i) => this._encode_plus(t, { text_pair: text_pair[i], add_special_tokens, return_token_type_ids }));
          } else {
            encodedTokens = text.map((x) => this._encode_plus(x, { add_special_tokens, return_token_type_ids }));
          }
        } else {
          if (text === null || text === undefined) {
            throw Error("text may not be null or undefined");
          }
          if (Array.isArray(text_pair)) {
            throw Error("When specifying `text_pair`, since `text` is a string, `text_pair` must also be a string (i.e., not an array).");
          }
          encodedTokens = [this._encode_plus(text, { text_pair, add_special_tokens, return_token_type_ids })];
        }
        if (max_length === null) {
          max_length = this.model_max_length;
        } else if (truncation === null) {
          if (padding === true) {
            console.warn("`max_length` is ignored when `padding: true` and there is no truncation strategy. " + "To pad to max length, use `padding: 'max_length'`.");
            max_length = this.model_max_length;
          } else if (padding === false) {
            console.warn("Truncation was not explicitly activated but `max_length` is provided a specific value, please use `truncation: true` to explicitly truncate examples to max length.");
            truncation = true;
          }
        }
        if (padding === true) {
          max_length = Math.min((0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_3__.max)(encodedTokens.map((x) => x.input_ids.length))[0], max_length ?? Infinity);
        }
        max_length = Math.min(max_length, this.model_max_length ?? Infinity);
        if (padding || truncation) {
          for (let i = 0;i < encodedTokens.length; ++i) {
            if (encodedTokens[i].input_ids.length === max_length) {
              continue;
            } else if (encodedTokens[i].input_ids.length > max_length) {
              if (truncation) {
                truncateHelper(encodedTokens[i], max_length);
              }
            } else {
              if (padding) {
                padHelper(encodedTokens[i], max_length, (key) => key === "input_ids" ? this.pad_token_id : 0, this.padding_side);
              }
            }
          }
        }
        const result = {};
        if (return_tensor) {
          if (!(padding && truncation)) {
            if (encodedTokens.some((x) => {
              for (const key of Object.keys(x)) {
                if (x[key].length !== encodedTokens[0][key]?.length) {
                  return true;
                }
              }
              return false;
            })) {
              throw Error("Unable to create tensor, you should probably activate truncation and/or padding " + "with 'padding=true' and 'truncation=true' to have batched tensors with the same length.");
            }
          }
          const dims = [encodedTokens.length, encodedTokens[0].input_ids.length];
          for (const key of Object.keys(encodedTokens[0])) {
            result[key] = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor("int64", BigInt64Array.from(encodedTokens.flatMap((x) => x[key]).map(BigInt)), dims);
          }
        } else {
          for (const key of Object.keys(encodedTokens[0])) {
            result[key] = encodedTokens.map((x) => x[key]);
          }
          if (!isBatched) {
            for (const key of Object.keys(result)) {
              result[key] = result[key][0];
            }
          }
        }
        return result;
      }
      _encode_text(text) {
        if (text === null)
          return null;
        const sections = this.added_tokens_splitter.split(text);
        for (let i = 0;i < sections.length; ++i) {
          const addedToken = this.added_tokens_map.get(sections[i]);
          if (addedToken) {
            if (addedToken.lstrip && i > 0) {
              sections[i - 1] = sections[i - 1].trimEnd();
            }
            if (addedToken.rstrip && i < sections.length - 1) {
              sections[i + 1] = sections[i + 1].trimStart();
            }
          }
        }
        const tokens = sections.flatMap((x, section_index) => {
          if (x.length === 0)
            return [];
          if (this.added_tokens_map.has(x))
            return [x];
          if (this.remove_space === true) {
            x = x.trim().split(/\s+/).join(" ");
          }
          if (this.do_lowercase_and_remove_accent) {
            x = lowercase_and_remove_accent(x);
          }
          if (this.normalizer !== null) {
            x = this.normalizer(x);
          }
          if (x.length === 0) {
            return [];
          }
          const sectionTokens = this.pre_tokenizer !== null ? this.pre_tokenizer(x, {
            section_index
          }) : [x];
          const tokens2 = this.model(sectionTokens);
          return tokens2;
        });
        return tokens;
      }
      _encode_plus(text, {
        text_pair = null,
        add_special_tokens = true,
        return_token_type_ids = null
      } = {}) {
        const { tokens, token_type_ids } = this._tokenize_helper(text, { pair: text_pair, add_special_tokens });
        const input_ids = this.model.convert_tokens_to_ids(tokens);
        const result = {
          input_ids,
          attention_mask: new Array(input_ids.length).fill(1)
        };
        if ((return_token_type_ids ?? this.return_token_type_ids) && token_type_ids) {
          result.token_type_ids = token_type_ids;
        }
        return result;
      }
      _tokenize_helper(text, {
        pair = null,
        add_special_tokens = false
      } = {}) {
        const tokens = this._encode_text(text);
        const tokens2 = this._encode_text(pair);
        return this.post_processor ? this.post_processor(tokens, tokens2, { add_special_tokens }) : { tokens: (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_1__.mergeArrays)(tokens ?? [], tokens2 ?? []) };
      }
      tokenize(text, {
        pair = null,
        add_special_tokens = false
      } = {}) {
        return this._tokenize_helper(text, { pair, add_special_tokens }).tokens;
      }
      encode(text, {
        text_pair = null,
        add_special_tokens = true,
        return_token_type_ids = null
      } = {}) {
        return this._encode_plus(text, {
          text_pair,
          add_special_tokens,
          return_token_type_ids
        }).input_ids;
      }
      batch_decode(batch, decode_args = {}) {
        if (batch instanceof _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor) {
          batch = batch.tolist();
        }
        return batch.map((x) => this.decode(x, decode_args));
      }
      decode(token_ids, decode_args = {}) {
        if (token_ids instanceof _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor) {
          token_ids = prepareTensorForDecode(token_ids);
        }
        if (!Array.isArray(token_ids) || token_ids.length === 0 || !(0, _utils_core_js__WEBPACK_IMPORTED_MODULE_1__.isIntegralNumber)(token_ids[0])) {
          throw Error("token_ids must be a non-empty array of integers.");
        }
        return this.decode_single(token_ids, decode_args);
      }
      decode_single(token_ids, {
        skip_special_tokens = false,
        clean_up_tokenization_spaces = null
      }) {
        let tokens = this.model.convert_ids_to_tokens(token_ids);
        if (skip_special_tokens) {
          tokens = tokens.filter((x) => !this.special_tokens.includes(x));
        }
        let decoded = this.decoder ? this.decoder(tokens) : tokens.join(" ");
        if (this.decoder && this.decoder.end_of_word_suffix) {
          decoded = decoded.replaceAll(this.decoder.end_of_word_suffix, " ");
          if (skip_special_tokens) {
            decoded = decoded.trim();
          }
        }
        if (clean_up_tokenization_spaces ?? this.clean_up_tokenization_spaces) {
          decoded = clean_up_tokenization(decoded);
        }
        return decoded;
      }
      get_chat_template({
        chat_template = null,
        tools = null
      } = {}) {
        if (this.chat_template && typeof this.chat_template === "object") {
          const template_dict = this.chat_template;
          if (chat_template !== null && Object.hasOwn(template_dict, chat_template)) {
            chat_template = template_dict[chat_template];
          } else if (chat_template === null) {
            if (tools !== null && "tool_use" in template_dict) {
              chat_template = template_dict["tool_use"];
            } else if ("default" in template_dict) {
              chat_template = template_dict["default"];
            } else {
              throw Error(`This model has multiple chat templates with no default specified! Please either pass a chat ` + `template or the name of the template you wish to use to the 'chat_template' argument. Available ` + `template names are ${Object.keys(template_dict).sort()}.`);
            }
          }
        } else if (chat_template === null) {
          if (this.chat_template) {
            chat_template = this.chat_template;
          } else {
            throw Error("Cannot use apply_chat_template() because tokenizer.chat_template is not set and no template " + "argument was passed! For information about writing templates and setting the " + "tokenizer.chat_template attribute, please see the documentation at " + "https://huggingface.co/docs/transformers/main/en/chat_templating");
          }
        }
        return chat_template;
      }
      apply_chat_template(conversation, {
        tools = null,
        documents = null,
        chat_template = null,
        add_generation_prompt = false,
        tokenize = true,
        padding = false,
        truncation = false,
        max_length = null,
        return_tensor = true,
        return_dict = false,
        tokenizer_kwargs = {},
        ...kwargs
      } = {}) {
        chat_template = this.get_chat_template({ chat_template, tools });
        if (typeof chat_template !== "string") {
          throw Error(`chat_template must be a string, but got ${typeof chat_template}`);
        }
        let compiledTemplate = this._compiled_template_cache.get(chat_template);
        if (compiledTemplate === undefined) {
          compiledTemplate = new _huggingface_jinja__WEBPACK_IMPORTED_MODULE_6__.Template(chat_template);
          this._compiled_template_cache.set(chat_template, compiledTemplate);
        }
        const special_tokens_map = Object.create(null);
        for (const key of SPECIAL_TOKEN_ATTRIBUTES) {
          const value = this.getToken(key);
          if (value) {
            special_tokens_map[key] = value;
          }
        }
        const rendered = compiledTemplate.render({
          messages: conversation,
          add_generation_prompt,
          tools,
          documents,
          ...special_tokens_map,
          ...kwargs
        });
        if (tokenize) {
          const out = this._call(rendered, {
            add_special_tokens: false,
            padding,
            truncation,
            max_length,
            return_tensor,
            ...tokenizer_kwargs
          });
          return return_dict ? out : out.input_ids;
        }
        return rendered;
      }
    }

    class BertTokenizer extends PreTrainedTokenizer {
      return_token_type_ids = true;
    }

    class AlbertTokenizer extends PreTrainedTokenizer {
      return_token_type_ids = true;
    }

    class MobileBertTokenizer extends PreTrainedTokenizer {
      return_token_type_ids = true;
    }

    class SqueezeBertTokenizer extends PreTrainedTokenizer {
      return_token_type_ids = true;
    }

    class DebertaTokenizer extends PreTrainedTokenizer {
      return_token_type_ids = true;
    }

    class DebertaV2Tokenizer extends PreTrainedTokenizer {
      return_token_type_ids = true;
    }

    class HerbertTokenizer extends PreTrainedTokenizer {
      return_token_type_ids = true;
    }

    class ConvBertTokenizer extends PreTrainedTokenizer {
      return_token_type_ids = true;
    }

    class RoFormerTokenizer extends PreTrainedTokenizer {
      return_token_type_ids = true;
    }

    class DistilBertTokenizer extends PreTrainedTokenizer {
    }

    class CamembertTokenizer extends PreTrainedTokenizer {
    }

    class XLMTokenizer extends PreTrainedTokenizer {
      return_token_type_ids = true;
      constructor(tokenizerJSON, tokenizerConfig) {
        super(tokenizerJSON, tokenizerConfig);
        console.warn('WARNING: `XLMTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.');
      }
    }

    class ElectraTokenizer extends PreTrainedTokenizer {
      return_token_type_ids = true;
    }

    class T5Tokenizer extends PreTrainedTokenizer {
    }

    class GPT2Tokenizer extends PreTrainedTokenizer {
    }

    class BartTokenizer extends PreTrainedTokenizer {
    }

    class MBartTokenizer extends PreTrainedTokenizer {
      constructor(tokenizerJSON, tokenizerConfig) {
        super(tokenizerJSON, tokenizerConfig);
        this.languageRegex = /^[a-z]{2}_[A-Z]{2}$/;
        this.language_codes = this.special_tokens.filter((x) => this.languageRegex.test(x));
        this.lang_to_token = (x) => x;
      }
      _build_translation_inputs(raw_inputs, tokenizer_options, generate_kwargs) {
        return _build_translation_inputs(this, raw_inputs, tokenizer_options, generate_kwargs);
      }
    }

    class MBart50Tokenizer extends MBartTokenizer {
    }

    class RobertaTokenizer extends PreTrainedTokenizer {
    }

    class BloomTokenizer extends PreTrainedTokenizer {
    }
    const SPIECE_UNDERLINE = "\u2581";

    class LlamaTokenizer extends PreTrainedTokenizer {
      padding_side = "left";
      constructor(tokenizerJSON, tokenizerConfig) {
        super(tokenizerJSON, tokenizerConfig);
        this.legacy = tokenizerConfig.legacy ?? true;
        if (!this.legacy) {
          this.normalizer = null;
          this.pre_tokenizer = new MetaspacePreTokenizer({
            replacement: SPIECE_UNDERLINE,
            prepend_scheme: "first"
          });
        }
      }
      _encode_text(text) {
        if (text === null)
          return null;
        if (this.legacy || text.length === 0) {
          return super._encode_text(text);
        }
        let tokens = super._encode_text(SPIECE_UNDERLINE + text.replaceAll(SPIECE_UNDERLINE, " "));
        if (tokens.length > 1 && tokens[0] === SPIECE_UNDERLINE && this.special_tokens.includes(tokens[1])) {
          tokens = tokens.slice(1);
        }
        return tokens;
      }
    }

    class CodeLlamaTokenizer extends PreTrainedTokenizer {
    }

    class XLMRobertaTokenizer extends PreTrainedTokenizer {
    }

    class MPNetTokenizer extends PreTrainedTokenizer {
    }

    class FalconTokenizer extends PreTrainedTokenizer {
    }

    class GPTNeoXTokenizer extends PreTrainedTokenizer {
    }

    class EsmTokenizer extends PreTrainedTokenizer {
    }

    class Qwen2Tokenizer extends PreTrainedTokenizer {
    }

    class GemmaTokenizer extends PreTrainedTokenizer {
    }

    class Grok1Tokenizer extends PreTrainedTokenizer {
    }
    function _build_translation_inputs(self2, raw_inputs, tokenizer_options, generate_kwargs) {
      if (!("language_codes" in self2) || !Array.isArray(self2.language_codes)) {
        throw new Error("Tokenizer must have `language_codes` attribute set and it should be an array of language ids.");
      }
      if (!("languageRegex" in self2) || !(self2.languageRegex instanceof RegExp)) {
        throw new Error("Tokenizer must have `languageRegex` attribute set and it should be a regular expression.");
      }
      if (!("lang_to_token" in self2) || typeof self2.lang_to_token !== "function") {
        throw new Error("Tokenizer must have `lang_to_token` attribute set and it should be a function.");
      }
      const src_lang_token = generate_kwargs.src_lang;
      const tgt_lang_token = generate_kwargs.tgt_lang;
      if (!self2.language_codes.includes(tgt_lang_token)) {
        throw new Error(`Target language code "${tgt_lang_token}" is not valid. Must be one of: {${self2.language_codes.join(", ")}}`);
      }
      if (src_lang_token !== undefined) {
        if (!self2.language_codes.includes(src_lang_token)) {
          throw new Error(`Source language code "${src_lang_token}" is not valid. Must be one of: {${self2.language_codes.join(", ")}}`);
        }
        for (const item of self2.post_processor.config.single) {
          if ("SpecialToken" in item && self2.languageRegex.test(item.SpecialToken.id)) {
            item.SpecialToken.id = self2.lang_to_token(src_lang_token);
            break;
          }
        }
      }
      generate_kwargs.forced_bos_token_id = self2.model.convert_tokens_to_ids([self2.lang_to_token(tgt_lang_token)])[0];
      return self2._call(raw_inputs, tokenizer_options);
    }

    class NllbTokenizer extends PreTrainedTokenizer {
      constructor(tokenizerJSON, tokenizerConfig) {
        super(tokenizerJSON, tokenizerConfig);
        this.languageRegex = /^[a-z]{3}_[A-Z][a-z]{3}$/;
        this.language_codes = this.special_tokens.filter((x) => this.languageRegex.test(x));
        this.lang_to_token = (x) => x;
      }
      _build_translation_inputs(raw_inputs, tokenizer_options, generate_kwargs) {
        return _build_translation_inputs(this, raw_inputs, tokenizer_options, generate_kwargs);
      }
    }

    class M2M100Tokenizer extends PreTrainedTokenizer {
      constructor(tokenizerJSON, tokenizerConfig) {
        super(tokenizerJSON, tokenizerConfig);
        this.languageRegex = /^__[a-z]{2,3}__$/;
        this.language_codes = this.special_tokens.filter((x) => this.languageRegex.test(x)).map((x) => x.slice(2, -2));
        this.lang_to_token = (x) => `__${x}__`;
      }
      _build_translation_inputs(raw_inputs, tokenizer_options, generate_kwargs) {
        return _build_translation_inputs(this, raw_inputs, tokenizer_options, generate_kwargs);
      }
    }

    class WhisperTokenizer extends PreTrainedTokenizer {
      get timestamp_begin() {
        return this.model.convert_tokens_to_ids(["<|notimestamps|>"])[0] + 1;
      }
      _decode_asr(sequences, {
        return_timestamps = false,
        return_language = false,
        time_precision = null,
        force_full_sequences = true
      } = {}) {
        if (time_precision === null) {
          throw Error("Must specify time_precision");
        }
        let last_language = null;
        const returnWordTimestamps = return_timestamps === "word";
        function new_chunk() {
          return { language: last_language, timestamp: [null, null], text: "" };
        }
        const chunks = [];
        let chunk = new_chunk();
        let time_offset = 0;
        const timestamp_begin = this.timestamp_begin;
        const total_timestamp_tokens = 1500;
        const timestamp_end = timestamp_begin + total_timestamp_tokens;
        let previous_tokens = [];
        let previous_token_timestamps = [];
        let skip = false;
        let right_stride_start = null;
        const all_special_ids = new Set(this.all_special_ids);
        for (const output of sequences) {
          const token_ids = output.tokens;
          const token_timestamps = returnWordTimestamps ? output.token_timestamps : null;
          let last_timestamp = null;
          let first_timestamp = timestamp_begin;
          if ("stride" in output) {
            const [chunk_len, stride_left, stride_right] = output.stride;
            time_offset -= stride_left;
            right_stride_start = chunk_len - stride_right;
            if (stride_left) {
              first_timestamp = stride_left / time_precision + timestamp_begin;
            }
            if (stride_right) {
              for (let i = token_ids.length - 1;i >= 0; --i) {
                const token = Number(token_ids[i]);
                if (token >= timestamp_begin) {
                  if (last_timestamp !== null && (token - timestamp_begin) * time_precision < right_stride_start) {
                    break;
                  }
                  last_timestamp = token;
                }
              }
            }
          }
          let current_tokens = [];
          let current_token_timestamps = [];
          for (let i = 0;i < token_ids.length; ++i) {
            const token = Number(token_ids[i]);
            if (all_special_ids.has(token)) {
              const text = this.decode([token]);
              const language = _models_whisper_common_whisper_js__WEBPACK_IMPORTED_MODULE_7__.WHISPER_LANGUAGE_MAPPING.get(text.slice(2, -2));
              if (language !== undefined) {
                if (last_language !== null && language !== last_language && !return_timestamps) {
                  previous_tokens.push(current_tokens);
                  const resolved_tokens = this.findLongestCommonSequence(previous_tokens)[0];
                  const resolved_text = this.decode(resolved_tokens);
                  chunk.text = resolved_text;
                  chunks.push(chunk);
                  previous_tokens = [];
                  current_tokens = [];
                  chunk = new_chunk();
                }
                last_language = chunk.language = language;
              } else {}
            } else if (token >= timestamp_begin && token <= timestamp_end) {
              const time5 = (token - timestamp_begin) * time_precision + time_offset;
              const rounded_time = (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_3__.round)(time5, 2);
              if (last_timestamp !== null && token >= last_timestamp) {
                skip = true;
              } else if (skip || previous_tokens.length > 0 && token < first_timestamp) {
                skip = false;
              } else if (chunk.timestamp[0] === null) {
                chunk.timestamp[0] = rounded_time;
              } else {
                if (rounded_time === chunk.timestamp[0]) {} else {
                  chunk.timestamp[1] = rounded_time;
                  previous_tokens.push(current_tokens);
                  if (returnWordTimestamps) {
                    previous_token_timestamps.push(current_token_timestamps);
                  }
                  const [resolved_tokens, resolved_token_timestamps] = this.findLongestCommonSequence(previous_tokens, previous_token_timestamps);
                  const resolved_text = this.decode(resolved_tokens);
                  chunk.text = resolved_text;
                  if (returnWordTimestamps) {
                    chunk.words = this.collateWordTimestamps(resolved_tokens, resolved_token_timestamps, last_language);
                  }
                  chunks.push(chunk);
                  previous_tokens = [];
                  current_tokens = [];
                  previous_token_timestamps = [];
                  current_token_timestamps = [];
                  chunk = new_chunk();
                }
              }
            } else {
              current_tokens.push(token);
              if (returnWordTimestamps) {
                let start_time = (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_3__.round)(token_timestamps[i] + time_offset, 2);
                let end_time;
                if (i + 1 < token_timestamps.length) {
                  end_time = (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_3__.round)(token_timestamps[i + 1] + time_offset, 2);
                  const decoded_text = this.decode([token]);
                  if (PUNCTUATION_ONLY_REGEX.test(decoded_text)) {
                    end_time = (0, _utils_maths_js__WEBPACK_IMPORTED_MODULE_3__.round)(Math.min(start_time + time_precision, end_time), 2);
                  }
                } else {
                  end_time = null;
                }
                current_token_timestamps.push([start_time, end_time]);
              }
            }
          }
          if ("stride" in output) {
            const [chunk_len, stride_left, stride_right] = output.stride;
            time_offset += chunk_len - stride_right;
          }
          if (current_tokens.length > 0) {
            previous_tokens.push(current_tokens);
            if (returnWordTimestamps) {
              previous_token_timestamps.push(current_token_timestamps);
            }
          } else if (previous_tokens.every((p) => p.length === 0)) {
            chunk = new_chunk();
            previous_tokens = [];
            current_tokens = [];
            previous_token_timestamps = [];
            current_token_timestamps = [];
          }
        }
        if (previous_tokens.length > 0) {
          if (force_full_sequences && return_timestamps) {
            throw new Error("Whisper did not predict an ending timestamp, which can happen if audio is cut off in the middle of a word. " + "Also make sure WhisperTimeStampLogitsProcessor was used during generation.");
          }
          const [resolved_tokens, resolved_token_timestamps] = this.findLongestCommonSequence(previous_tokens, previous_token_timestamps);
          const resolved_text = this.decode(resolved_tokens);
          chunk.text = resolved_text;
          if (returnWordTimestamps) {
            chunk.words = this.collateWordTimestamps(resolved_tokens, resolved_token_timestamps, last_language);
          }
          chunks.push(chunk);
        }
        let optional4 = Object.create(null);
        const full_text = chunks.map((chunk2) => chunk2.text).join("");
        if (return_timestamps || return_language) {
          for (let i = 0;i < chunks.length; ++i) {
            const chunk2 = chunks[i];
            if (!return_timestamps) {
              delete chunk2["timestamp"];
            }
            if (!return_language) {
              delete chunk2["language"];
            }
          }
          if (returnWordTimestamps) {
            const new_chunks = [];
            for (const chunk2 of chunks) {
              for (const word of chunk2.words) {
                new_chunks.push(word);
              }
            }
            optional4 = { chunks: new_chunks };
          } else {
            optional4 = { chunks };
          }
        }
        return [full_text, optional4];
      }
      findLongestCommonSequence(sequences, token_timestamp_sequences = null) {
        let leftSequence = sequences[0];
        let leftLength = leftSequence.length;
        let totalSequence = [];
        const use_token_timestamp_sequences = Array.isArray(token_timestamp_sequences) && token_timestamp_sequences.length > 0;
        let total_token_timestamp_sequence = use_token_timestamp_sequences ? [] : null;
        let left_token_timestamp_sequence = use_token_timestamp_sequences ? token_timestamp_sequences[0] : null;
        for (let i = 1;i < sequences.length; ++i) {
          const rightSequence = sequences[i];
          let max = 0;
          let maxIndices = [leftLength, leftLength, 0, 0];
          const rightLength = rightSequence.length;
          for (let j = 1;j < leftLength + rightLength; ++j) {
            const leftStart2 = Math.max(0, leftLength - j);
            const leftStop2 = Math.min(leftLength, leftLength + rightLength - j);
            const left = leftSequence.slice(leftStart2, leftStop2);
            const rightStart2 = Math.max(0, j - leftLength);
            const rightStop2 = Math.min(rightLength, j);
            const right = rightSequence.slice(rightStart2, rightStop2);
            if (left.length !== right.length) {
              throw new Error("There is a bug within whisper `decode_asr` function, please report it. Dropping to prevent bad inference.");
            }
            let matches;
            if (use_token_timestamp_sequences) {
              matches = left.filter((elem, idx) => elem === right[idx] && left_token_timestamp_sequence[leftStart2 + idx] <= token_timestamp_sequences[i][rightStart2 + idx]).length;
            } else {
              matches = left.filter((elem, idx) => elem === right[idx]).length;
            }
            const eps = j / 1e4;
            const matching = matches / j + eps;
            if (matches > 1 && matching > max) {
              max = matching;
              maxIndices = [leftStart2, leftStop2, rightStart2, rightStop2];
            }
          }
          const [leftStart, leftStop, rightStart, rightStop] = maxIndices;
          const leftMid = Math.floor((leftStop + leftStart) / 2);
          const rightMid = Math.floor((rightStop + rightStart) / 2);
          totalSequence.push(...leftSequence.slice(0, leftMid));
          leftSequence = rightSequence.slice(rightMid);
          leftLength = leftSequence.length;
          if (use_token_timestamp_sequences) {
            total_token_timestamp_sequence.push(...left_token_timestamp_sequence.slice(0, leftMid));
            left_token_timestamp_sequence = token_timestamp_sequences[i].slice(rightMid);
          }
        }
        totalSequence.push(...leftSequence);
        if (use_token_timestamp_sequences) {
          total_token_timestamp_sequence.push(...left_token_timestamp_sequence);
          return [totalSequence, total_token_timestamp_sequence];
        } else {
          return [totalSequence, []];
        }
      }
      collateWordTimestamps(tokens, token_timestamps, language) {
        const [words, _, token_indices] = this.combineTokensIntoWords(tokens, language);
        const timings = [];
        for (let i = 0;i < words.length; ++i) {
          const indices = token_indices[i];
          timings.push({
            text: words[i],
            timestamp: [
              token_timestamps[indices.at(0)][0],
              token_timestamps[indices.at(-1)][1]
            ]
          });
        }
        return timings;
      }
      combineTokensIntoWords(tokens, language, prepend_punctionations = `"'\u201C\xA1\xBF([{-`, append_punctuations = `"'.\u3002,\uFF0C!\uFF01?\uFF1F:\uFF1A\u201D)]}\u3001`) {
        language = language ?? "english";
        let words, word_tokens, token_indices;
        if (["chinese", "japanese", "thai", "lao", "myanmar"].includes(language)) {
          [words, word_tokens, token_indices] = this.splitTokensOnUnicode(tokens);
        } else {
          [words, word_tokens, token_indices] = this.splitTokensOnSpaces(tokens);
        }
        return this.mergePunctuations(words, word_tokens, token_indices, prepend_punctionations, append_punctuations);
      }
      decode(token_ids, decode_args) {
        let text;
        if (decode_args?.decode_with_timestamps) {
          if (token_ids instanceof _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor) {
            token_ids = prepareTensorForDecode(token_ids);
          }
          text = this.decodeWithTimestamps(token_ids, decode_args);
        } else {
          text = super.decode(token_ids, decode_args);
        }
        return text;
      }
      decodeWithTimestamps(token_ids, decode_args) {
        const time_precision = decode_args?.time_precision ?? 0.02;
        const timestamp_begin = Array.from(this.all_special_ids).at(-1) + 1;
        let outputs = [[]];
        for (let token of token_ids) {
          token = Number(token);
          if (token >= timestamp_begin) {
            const timestamp = ((token - timestamp_begin) * time_precision).toFixed(2);
            outputs.push(`<|${timestamp}|>`);
            outputs.push([]);
          } else {
            outputs[outputs.length - 1].push(token);
          }
        }
        outputs = outputs.map((s) => typeof s === "string" ? s : super.decode(s, decode_args));
        return outputs.join("");
      }
      splitTokensOnUnicode(tokens) {
        const decoded_full = this.decode(tokens, {
          decode_with_timestamps: true
        });
        const replacement_char = "\uFFFD";
        const words = [];
        const word_tokens = [];
        const token_indices = [];
        let current_tokens = [];
        let current_indices = [];
        let unicode_offset = 0;
        for (let token_idx = 0;token_idx < tokens.length; ++token_idx) {
          const token = tokens[token_idx];
          current_tokens.push(token);
          current_indices.push(token_idx);
          const decoded = this.decode(current_tokens, {
            decode_with_timestamps: true
          });
          if (!decoded.includes(replacement_char) || decoded_full[unicode_offset + decoded.indexOf(replacement_char)] === replacement_char) {
            words.push(decoded);
            word_tokens.push(current_tokens);
            token_indices.push(current_indices);
            current_tokens = [];
            current_indices = [];
            unicode_offset += decoded.length;
          }
        }
        return [words, word_tokens, token_indices];
      }
      splitTokensOnSpaces(tokens) {
        const [subwords, subword_tokens_list, subword_indices_list] = this.splitTokensOnUnicode(tokens);
        const words = [];
        const word_tokens = [];
        const token_indices = [];
        const punctuationRegex = new RegExp(`^[${PUNCTUATION_REGEX}]$`, "gu");
        for (let i = 0;i < subwords.length; ++i) {
          const subword = subwords[i];
          const subword_tokens = subword_tokens_list[i];
          const subword_indices = subword_indices_list[i];
          const special = subword_tokens[0] >= this.model.tokens_to_ids.get("<|endoftext|>");
          const with_space = subword.startsWith(" ");
          const trimmed = subword.trim();
          const punctuation = punctuationRegex.test(trimmed);
          if (special || with_space || punctuation || words.length === 0) {
            words.push(subword);
            word_tokens.push(subword_tokens);
            token_indices.push(subword_indices);
          } else {
            const ix = words.length - 1;
            words[ix] += subword;
            word_tokens[ix].push(...subword_tokens);
            token_indices[ix].push(...subword_indices);
          }
        }
        return [words, word_tokens, token_indices];
      }
      mergePunctuations(words, tokens, indices, prepended, appended) {
        const newWords = structuredClone(words);
        const newTokens = structuredClone(tokens);
        const newIndices = structuredClone(indices);
        let i = newWords.length - 2;
        let j = newWords.length - 1;
        while (i >= 0) {
          if (newWords[i].startsWith(" ") && prepended.includes(newWords[i].trim())) {
            newWords[j] = newWords[i] + newWords[j];
            newTokens[j] = (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_1__.mergeArrays)(newTokens[i], newTokens[j]);
            newIndices[j] = (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_1__.mergeArrays)(newIndices[i], newIndices[j]);
            newWords[i] = "";
            newTokens[i] = [];
            newIndices[i] = [];
          } else {
            j = i;
          }
          --i;
        }
        i = 0;
        j = 1;
        while (j < newWords.length) {
          if (!newWords[i].endsWith(" ") && appended.includes(newWords[j])) {
            newWords[i] += newWords[j];
            newTokens[i] = (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_1__.mergeArrays)(newTokens[i], newTokens[j]);
            newIndices[i] = (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_1__.mergeArrays)(newIndices[i], newIndices[j]);
            newWords[j] = "";
            newTokens[j] = [];
            newIndices[j] = [];
          } else {
            i = j;
          }
          ++j;
        }
        return [
          newWords.filter((x) => x),
          newTokens.filter((x) => x.length > 0),
          newIndices.filter((x) => x.length > 0)
        ];
      }
    }

    class CodeGenTokenizer extends PreTrainedTokenizer {
    }

    class CLIPTokenizer extends PreTrainedTokenizer {
    }

    class SiglipTokenizer extends PreTrainedTokenizer {
    }

    class MarianTokenizer extends PreTrainedTokenizer {
      constructor(tokenizerJSON, tokenizerConfig) {
        super(tokenizerJSON, tokenizerConfig);
        this.languageRegex = /^(>>\w+<<)\s*/g;
        this.supported_language_codes = this.model.vocab.filter((x) => this.languageRegex.test(x));
        console.warn('WARNING: `MarianTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.');
      }
      _encode_text(text) {
        if (text === null)
          return null;
        const [matchInfo, ...remainder] = text.trim().split(this.languageRegex);
        if (remainder.length === 0) {
          return super._encode_text(matchInfo);
        } else if (remainder.length === 2) {
          const [language, text2] = remainder;
          if (!this.supported_language_codes.includes(language)) {
            console.warn(`Unsupported language code "${language}" detected, which may lead to unexpected behavior. Should be one of: ${JSON.stringify(this.supported_language_codes)}`);
          }
          return (0, _utils_core_js__WEBPACK_IMPORTED_MODULE_1__.mergeArrays)([language], super._encode_text(text2));
        }
      }
    }

    class Wav2Vec2CTCTokenizer extends PreTrainedTokenizer {
    }

    class BlenderbotTokenizer extends PreTrainedTokenizer {
    }

    class BlenderbotSmallTokenizer extends PreTrainedTokenizer {
    }

    class SpeechT5Tokenizer extends PreTrainedTokenizer {
    }

    class NougatTokenizer extends PreTrainedTokenizer {
    }

    class VitsTokenizer extends PreTrainedTokenizer {
      constructor(tokenizerJSON, tokenizerConfig) {
        super(tokenizerJSON, tokenizerConfig);
        this.decoder = new VitsDecoder({});
      }
    }

    class CohereTokenizer extends PreTrainedTokenizer {
    }

    class MgpstrTokenizer extends PreTrainedTokenizer {
    }

    class AutoTokenizer {
      static TOKENIZER_CLASS_MAPPING = {
        T5Tokenizer,
        DistilBertTokenizer,
        CamembertTokenizer,
        DebertaTokenizer,
        DebertaV2Tokenizer,
        BertTokenizer,
        HerbertTokenizer,
        ConvBertTokenizer,
        RoFormerTokenizer,
        XLMTokenizer,
        ElectraTokenizer,
        MobileBertTokenizer,
        SqueezeBertTokenizer,
        AlbertTokenizer,
        GPT2Tokenizer,
        BartTokenizer,
        MBartTokenizer,
        MBart50Tokenizer,
        RobertaTokenizer,
        WhisperTokenizer,
        CodeGenTokenizer,
        CLIPTokenizer,
        SiglipTokenizer,
        MarianTokenizer,
        BloomTokenizer,
        NllbTokenizer,
        M2M100Tokenizer,
        LlamaTokenizer,
        CodeLlamaTokenizer,
        XLMRobertaTokenizer,
        MPNetTokenizer,
        FalconTokenizer,
        GPTNeoXTokenizer,
        EsmTokenizer,
        Wav2Vec2CTCTokenizer,
        BlenderbotTokenizer,
        BlenderbotSmallTokenizer,
        SpeechT5Tokenizer,
        NougatTokenizer,
        VitsTokenizer,
        Qwen2Tokenizer,
        GemmaTokenizer,
        Grok1Tokenizer,
        CohereTokenizer,
        MgpstrTokenizer,
        PreTrainedTokenizer
      };
      static async from_pretrained(pretrained_model_name_or_path, {
        progress_callback = null,
        config: config3 = null,
        cache_dir = null,
        local_files_only = false,
        revision = "main",
        legacy = null
      } = {}) {
        const [tokenizerJSON, tokenizerConfig] = await loadTokenizer(pretrained_model_name_or_path, {
          progress_callback,
          config: config3,
          cache_dir,
          local_files_only,
          revision,
          legacy
        });
        const tokenizerName = tokenizerConfig.tokenizer_class?.replace(/Fast$/, "") ?? "PreTrainedTokenizer";
        let cls = this.TOKENIZER_CLASS_MAPPING[tokenizerName];
        if (!cls) {
          console.warn(`Unknown tokenizer class "${tokenizerName}", attempting to construct from base class.`);
          cls = PreTrainedTokenizer;
        }
        return new cls(tokenizerJSON, tokenizerConfig);
      }
    }
  },
  "./src/utils/audio.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!****************************!*\
      !*** ./src/utils/audio.js ***!
      \****************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      RawAudio: () => RawAudio,
      hamming: () => hamming,
      hanning: () => hanning,
      mel_filter_bank: () => mel_filter_bank,
      read_audio: () => read_audio,
      spectrogram: () => spectrogram,
      window_function: () => window_function
    });
    var _hub_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/utils/hub.js");
    /*! ./hub.js */
    var _maths_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/utils/maths.js");
    /*! ./maths.js */
    var _core_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/utils/core.js");
    /*! ./core.js */
    var _env_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/env.js");
    /*! ../env.js */
    var _tensor_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./src/utils/tensor.js");
    /*! ./tensor.js */
    var node_fs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("node:fs");
    /*! node:fs */
    async function read_audio(url2, sampling_rate) {
      if (typeof AudioContext === "undefined") {
        throw Error("Unable to load audio from path/URL since `AudioContext` is not available in your environment. " + "Instead, audio data should be passed directly to the pipeline/processor. " + "For more information and some example code, see https://huggingface.co/docs/transformers.js/guides/node-audio-processing.");
      }
      const response = await (await (0, _hub_js__WEBPACK_IMPORTED_MODULE_0__.getFile)(url2)).arrayBuffer();
      const audioCTX = new AudioContext({ sampleRate: sampling_rate });
      if (typeof sampling_rate === "undefined") {
        console.warn(`No sampling rate provided, using default of ${audioCTX.sampleRate}Hz.`);
      }
      const decoded = await audioCTX.decodeAudioData(response);
      let audio;
      if (decoded.numberOfChannels === 2) {
        const SCALING_FACTOR = Math.sqrt(2);
        const left = decoded.getChannelData(0);
        const right = decoded.getChannelData(1);
        audio = new Float32Array(left.length);
        for (let i = 0;i < decoded.length; ++i) {
          audio[i] = SCALING_FACTOR * (left[i] + right[i]) / 2;
        }
      } else {
        audio = decoded.getChannelData(0);
      }
      return audio;
    }
    function generalized_cosine_window(M, a_0) {
      if (M < 1) {
        return new Float64Array;
      }
      if (M === 1) {
        return new Float64Array([1]);
      }
      const a_1 = 1 - a_0;
      const factor = 2 * Math.PI / (M - 1);
      const cos_vals = new Float64Array(M);
      for (let i = 0;i < M; ++i) {
        cos_vals[i] = a_0 - a_1 * Math.cos(i * factor);
      }
      return cos_vals;
    }
    function hanning(M) {
      return generalized_cosine_window(M, 0.5);
    }
    function hamming(M) {
      return generalized_cosine_window(M, 0.54);
    }
    const HERTZ_TO_MEL_MAPPING = {
      htk: (freq) => 2595 * Math.log10(1 + freq / 700),
      kaldi: (freq) => 1127 * Math.log(1 + freq / 700),
      slaney: (freq, min_log_hertz = 1000, min_log_mel = 15, logstep = 27 / Math.log(6.4)) => freq >= min_log_hertz ? min_log_mel + Math.log(freq / min_log_hertz) * logstep : 3 * freq / 200
    };
    function hertz_to_mel(freq, mel_scale = "htk") {
      const fn = HERTZ_TO_MEL_MAPPING[mel_scale];
      if (!fn) {
        throw new Error('mel_scale should be one of "htk", "slaney" or "kaldi".');
      }
      return typeof freq === "number" ? fn(freq) : freq.map((x) => fn(x));
    }
    const MEL_TO_HERTZ_MAPPING = {
      htk: (mels) => 700 * (10 ** (mels / 2595) - 1),
      kaldi: (mels) => 700 * (Math.exp(mels / 1127) - 1),
      slaney: (mels, min_log_hertz = 1000, min_log_mel = 15, logstep = Math.log(6.4) / 27) => mels >= min_log_mel ? min_log_hertz * Math.exp(logstep * (mels - min_log_mel)) : 200 * mels / 3
    };
    function mel_to_hertz(mels, mel_scale = "htk") {
      const fn = MEL_TO_HERTZ_MAPPING[mel_scale];
      if (!fn) {
        throw new Error('mel_scale should be one of "htk", "slaney" or "kaldi".');
      }
      return typeof mels === "number" ? fn(mels) : mels.map((x) => fn(x));
    }
    function _create_triangular_filter_bank(fft_freqs, filter_freqs) {
      const filter_diff = Float64Array.from({ length: filter_freqs.length - 1 }, (_, i) => filter_freqs[i + 1] - filter_freqs[i]);
      const slopes = Array.from({
        length: fft_freqs.length
      }, () => new Array(filter_freqs.length));
      for (let j = 0;j < fft_freqs.length; ++j) {
        const slope = slopes[j];
        for (let i = 0;i < filter_freqs.length; ++i) {
          slope[i] = filter_freqs[i] - fft_freqs[j];
        }
      }
      const numFreqs = filter_freqs.length - 2;
      const ret = Array.from({ length: numFreqs }, () => new Array(fft_freqs.length));
      for (let j = 0;j < fft_freqs.length; ++j) {
        const slope = slopes[j];
        for (let i = 0;i < numFreqs; ++i) {
          const down = -slope[i] / filter_diff[i];
          const up = slope[i + 2] / filter_diff[i + 1];
          ret[i][j] = Math.max(0, Math.min(down, up));
        }
      }
      return ret;
    }
    function linspace(start, end, num) {
      const step = (end - start) / (num - 1);
      return Float64Array.from({ length: num }, (_, i) => start + step * i);
    }
    function mel_filter_bank(num_frequency_bins, num_mel_filters, min_frequency, max_frequency, sampling_rate, norm = null, mel_scale = "htk", triangularize_in_mel_space = false) {
      if (norm !== null && norm !== "slaney") {
        throw new Error('norm must be one of null or "slaney"');
      }
      if (num_frequency_bins < 2) {
        throw new Error(`Require num_frequency_bins: ${num_frequency_bins} >= 2`);
      }
      if (min_frequency > max_frequency) {
        throw new Error(`Require min_frequency: ${min_frequency} <= max_frequency: ${max_frequency}`);
      }
      const mel_min = hertz_to_mel(min_frequency, mel_scale);
      const mel_max = hertz_to_mel(max_frequency, mel_scale);
      const mel_freqs = linspace(mel_min, mel_max, num_mel_filters + 2);
      let filter_freqs = mel_to_hertz(mel_freqs, mel_scale);
      let fft_freqs;
      if (triangularize_in_mel_space) {
        const fft_bin_width = sampling_rate / ((num_frequency_bins - 1) * 2);
        fft_freqs = hertz_to_mel(Float64Array.from({ length: num_frequency_bins }, (_, i) => i * fft_bin_width), mel_scale);
        filter_freqs = mel_freqs;
      } else {
        fft_freqs = linspace(0, Math.floor(sampling_rate / 2), num_frequency_bins);
      }
      const mel_filters = _create_triangular_filter_bank(fft_freqs, filter_freqs);
      if (norm !== null && norm === "slaney") {
        for (let i = 0;i < num_mel_filters; ++i) {
          const filter = mel_filters[i];
          const enorm = 2 / (filter_freqs[i + 2] - filter_freqs[i]);
          for (let j = 0;j < num_frequency_bins; ++j) {
            filter[j] *= enorm;
          }
        }
      }
      return mel_filters;
    }
    function padReflect(array4, left, right) {
      const padded = new array4.constructor(array4.length + left + right);
      const w = array4.length - 1;
      for (let i = 0;i < array4.length; ++i) {
        padded[left + i] = array4[i];
      }
      for (let i = 1;i <= left; ++i) {
        padded[left - i] = array4[(0, _core_js__WEBPACK_IMPORTED_MODULE_2__.calculateReflectOffset)(i, w)];
      }
      for (let i = 1;i <= right; ++i) {
        padded[w + left + i] = array4[(0, _core_js__WEBPACK_IMPORTED_MODULE_2__.calculateReflectOffset)(w - i, w)];
      }
      return padded;
    }
    function _db_conversion_helper(spectrogram2, factor, reference, min_value, db_range) {
      if (reference <= 0) {
        throw new Error("reference must be greater than zero");
      }
      if (min_value <= 0) {
        throw new Error("min_value must be greater than zero");
      }
      reference = Math.max(min_value, reference);
      const logReference = Math.log10(reference);
      for (let i = 0;i < spectrogram2.length; ++i) {
        spectrogram2[i] = factor * Math.log10(Math.max(min_value, spectrogram2[i]) - logReference);
      }
      if (db_range !== null) {
        if (db_range <= 0) {
          throw new Error("db_range must be greater than zero");
        }
        const maxValue = (0, _maths_js__WEBPACK_IMPORTED_MODULE_1__.max)(spectrogram2)[0] - db_range;
        for (let i = 0;i < spectrogram2.length; ++i) {
          spectrogram2[i] = Math.max(spectrogram2[i], maxValue);
        }
      }
      return spectrogram2;
    }
    function amplitude_to_db(spectrogram2, reference = 1, min_value = 0.00001, db_range = null) {
      return _db_conversion_helper(spectrogram2, 20, reference, min_value, db_range);
    }
    function power_to_db(spectrogram2, reference = 1, min_value = 0.0000000001, db_range = null) {
      return _db_conversion_helper(spectrogram2, 10, reference, min_value, db_range);
    }
    async function spectrogram(waveform, window2, frame_length, hop_length, {
      fft_length = null,
      power = 1,
      center = true,
      pad_mode = "reflect",
      onesided = true,
      preemphasis = null,
      preemphasis_htk_flavor = true,
      mel_filters = null,
      mel_floor = 0.0000000001,
      log_mel = null,
      reference = 1,
      min_value = 0.0000000001,
      db_range = null,
      remove_dc_offset = null,
      min_num_frames = null,
      max_num_frames = null,
      do_pad = true,
      transpose = false,
      mel_offset = 0
    } = {}) {
      const window_length = window2.length;
      if (fft_length === null) {
        fft_length = frame_length;
      }
      if (frame_length > fft_length) {
        throw Error(`frame_length (${frame_length}) may not be larger than fft_length (${fft_length})`);
      }
      if (window_length !== frame_length) {
        throw new Error(`Length of the window (${window_length}) must equal frame_length (${frame_length})`);
      }
      if (hop_length <= 0) {
        throw new Error("hop_length must be greater than zero");
      }
      if (power === null && mel_filters !== null) {
        throw new Error("You have provided `mel_filters` but `power` is `None`. Mel spectrogram computation is not yet supported for complex-valued spectrogram. " + "Specify `power` to fix this issue.");
      }
      if (!preemphasis_htk_flavor) {
        throw new Error("`preemphasis_htk_flavor=false` is not currently supported.");
      }
      if (center) {
        switch (pad_mode) {
          case "reflect": {
            const half_window = Math.floor((fft_length - 1) / 2) + 1;
            waveform = padReflect(waveform, half_window, half_window);
            break;
          }
          case "constant": {
            const padding = Math.floor(fft_length / 2);
            const padded = new waveform.constructor(waveform.length + 2 * padding);
            padded.set(waveform, padding);
            waveform = padded;
            break;
          }
          default:
            throw new Error(`pad_mode="${pad_mode}" not implemented yet.`);
        }
      }
      let num_frames = Math.floor(1 + Math.floor((waveform.length - frame_length) / hop_length));
      if (min_num_frames !== null && num_frames < min_num_frames) {
        num_frames = min_num_frames;
      }
      const num_frequency_bins = onesided ? Math.floor(fft_length / 2) + 1 : fft_length;
      let d1 = num_frames;
      let d1Max = num_frames;
      if (max_num_frames !== null) {
        if (max_num_frames > num_frames) {
          if (do_pad) {
            d1Max = max_num_frames;
          }
        } else {
          d1Max = d1 = max_num_frames;
        }
      }
      const fft = new _maths_js__WEBPACK_IMPORTED_MODULE_1__.FFT(fft_length);
      const inputBuffer = new Float64Array(fft_length);
      const outputBuffer = new Float64Array(fft.outputBufferSize);
      const transposedMagnitudeData = new Float32Array(num_frequency_bins * d1Max);
      for (let i = 0;i < d1; ++i) {
        const offset = i * hop_length;
        const buffer_size = Math.min(waveform.length - offset, frame_length);
        if (buffer_size !== frame_length) {
          inputBuffer.fill(0, 0, frame_length);
        }
        for (let j = 0;j < buffer_size; ++j) {
          inputBuffer[j] = waveform[offset + j];
        }
        if (remove_dc_offset) {
          let sum = 0;
          for (let j = 0;j < buffer_size; ++j) {
            sum += inputBuffer[j];
          }
          const mean = sum / buffer_size;
          for (let j = 0;j < buffer_size; ++j) {
            inputBuffer[j] -= mean;
          }
        }
        if (preemphasis !== null) {
          for (let j = buffer_size - 1;j >= 1; --j) {
            inputBuffer[j] -= preemphasis * inputBuffer[j - 1];
          }
          inputBuffer[0] *= 1 - preemphasis;
        }
        for (let j = 0;j < window2.length; ++j) {
          inputBuffer[j] *= window2[j];
        }
        fft.realTransform(outputBuffer, inputBuffer);
        for (let j = 0;j < num_frequency_bins; ++j) {
          const j2 = j << 1;
          transposedMagnitudeData[j * d1Max + i] = outputBuffer[j2] ** 2 + outputBuffer[j2 + 1] ** 2;
        }
      }
      if (power !== null && power !== 2) {
        const pow = power / 2;
        for (let i = 0;i < transposedMagnitudeData.length; ++i) {
          transposedMagnitudeData[i] **= pow;
        }
      }
      const num_mel_filters = mel_filters.length;
      let mel_spec = await (0, _tensor_js__WEBPACK_IMPORTED_MODULE_4__.matmul)(new _tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor("float32", mel_filters.flat(), [num_mel_filters, num_frequency_bins]), new _tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor("float32", transposedMagnitudeData, [num_frequency_bins, d1Max]));
      if (transpose) {
        mel_spec = mel_spec.transpose(1, 0);
      }
      const mel_spec_data = mel_spec.data;
      for (let i = 0;i < mel_spec_data.length; ++i) {
        mel_spec_data[i] = mel_offset + Math.max(mel_floor, mel_spec_data[i]);
      }
      if (power !== null && log_mel !== null) {
        const o = Math.min(mel_spec_data.length, d1 * num_mel_filters);
        switch (log_mel) {
          case "log":
            for (let i = 0;i < o; ++i) {
              mel_spec_data[i] = Math.log(mel_spec_data[i]);
            }
            break;
          case "log10":
            for (let i = 0;i < o; ++i) {
              mel_spec_data[i] = Math.log10(mel_spec_data[i]);
            }
            break;
          case "dB":
            if (power === 1) {
              amplitude_to_db(mel_spec_data, reference, min_value, db_range);
            } else if (power === 2) {
              power_to_db(mel_spec_data, reference, min_value, db_range);
            } else {
              throw new Error(`Cannot use log_mel option '${log_mel}' with power ${power}`);
            }
            break;
          default:
            throw new Error(`log_mel must be one of null, 'log', 'log10' or 'dB'. Got '${log_mel}'`);
        }
      }
      return mel_spec;
    }
    function window_function(window_length, name, {
      periodic = true,
      frame_length = null,
      center = true
    } = {}) {
      const length = periodic ? window_length + 1 : window_length;
      let window2;
      switch (name) {
        case "boxcar":
          window2 = new Float64Array(length).fill(1);
          break;
        case "hann":
        case "hann_window":
          window2 = hanning(length);
          break;
        case "hamming":
          window2 = hamming(length);
          break;
        case "povey":
          window2 = hanning(length).map((x) => Math.pow(x, 0.85));
          break;
        default:
          throw new Error(`Unknown window type ${name}.`);
      }
      if (periodic) {
        window2 = window2.subarray(0, window_length);
      }
      if (frame_length === null) {
        return window2;
      }
      if (window_length > frame_length) {
        throw new Error(`Length of the window (${window_length}) may not be larger than frame_length (${frame_length})`);
      }
      return window2;
    }
    function encodeWAV(samples, rate) {
      let offset = 44;
      const buffer = new ArrayBuffer(offset + samples.length * 4);
      const view = new DataView(buffer);
      writeString(view, 0, "RIFF");
      view.setUint32(4, 36 + samples.length * 4, true);
      writeString(view, 8, "WAVE");
      writeString(view, 12, "fmt ");
      view.setUint32(16, 16, true);
      view.setUint16(20, 3, true);
      view.setUint16(22, 1, true);
      view.setUint32(24, rate, true);
      view.setUint32(28, rate * 4, true);
      view.setUint16(32, 4, true);
      view.setUint16(34, 32, true);
      writeString(view, 36, "data");
      view.setUint32(40, samples.length * 4, true);
      for (let i = 0;i < samples.length; ++i, offset += 4) {
        view.setFloat32(offset, samples[i], true);
      }
      return buffer;
    }
    function writeString(view, offset, string7) {
      for (let i = 0;i < string7.length; ++i) {
        view.setUint8(offset + i, string7.charCodeAt(i));
      }
    }

    class RawAudio {
      constructor(audio, sampling_rate) {
        this.audio = audio;
        this.sampling_rate = sampling_rate;
      }
      toWav() {
        return encodeWAV(this.audio, this.sampling_rate);
      }
      toBlob() {
        const wav = this.toWav();
        const blob = new Blob([wav], { type: "audio/wav" });
        return blob;
      }
      async save(path2) {
        let fn;
        if (_env_js__WEBPACK_IMPORTED_MODULE_3__.apis.IS_BROWSER_ENV) {
          if (_env_js__WEBPACK_IMPORTED_MODULE_3__.apis.IS_WEBWORKER_ENV) {
            throw new Error("Unable to save a file from a Web Worker.");
          }
          fn = _core_js__WEBPACK_IMPORTED_MODULE_2__.saveBlob;
        } else if (_env_js__WEBPACK_IMPORTED_MODULE_3__.apis.IS_FS_AVAILABLE) {
          fn = async (path3, blob) => {
            let buffer = await blob.arrayBuffer();
            node_fs__WEBPACK_IMPORTED_MODULE_5__["default"].writeFileSync(path3, Buffer.from(buffer));
          };
        } else {
          throw new Error("Unable to save because filesystem is disabled in this environment.");
        }
        await fn(path2, this.toBlob());
      }
    }
  },
  "./src/utils/constants.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!********************************!*\
      !*** ./src/utils/constants.js ***!
      \********************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      CHAT_TEMPLATE_NAME: () => CHAT_TEMPLATE_NAME,
      CONFIG_NAME: () => CONFIG_NAME,
      FEATURE_EXTRACTOR_NAME: () => FEATURE_EXTRACTOR_NAME,
      GENERATION_CONFIG_NAME: () => GENERATION_CONFIG_NAME,
      GITHUB_ISSUE_URL: () => GITHUB_ISSUE_URL,
      IMAGE_PROCESSOR_NAME: () => IMAGE_PROCESSOR_NAME,
      PROCESSOR_NAME: () => PROCESSOR_NAME
    });
    const GITHUB_ISSUE_URL = "https://github.com/huggingface/transformers.js/issues/new/choose";
    const CONFIG_NAME = "config.json";
    const FEATURE_EXTRACTOR_NAME = "preprocessor_config.json";
    const IMAGE_PROCESSOR_NAME = FEATURE_EXTRACTOR_NAME;
    const PROCESSOR_NAME = "processor_config.json";
    const CHAT_TEMPLATE_NAME = "chat_template.jinja";
    const GENERATION_CONFIG_NAME = "generation_config.json";
  },
  "./src/utils/core.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!***************************!*\
      !*** ./src/utils/core.js ***!
      \***************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      calculateDimensions: () => calculateDimensions,
      calculateReflectOffset: () => calculateReflectOffset,
      count: () => count,
      dispatchCallback: () => dispatchCallback,
      escapeRegExp: () => escapeRegExp,
      isIntegralNumber: () => isIntegralNumber,
      isNullishDimension: () => isNullishDimension,
      isTypedArray: () => isTypedArray,
      len: () => len,
      mergeArrays: () => mergeArrays,
      pick: () => pick3,
      pop: () => pop,
      product: () => product,
      reverseDictionary: () => reverseDictionary,
      saveBlob: () => saveBlob
    });
    function dispatchCallback(progress_callback, data) {
      if (progress_callback)
        progress_callback(data);
    }
    function reverseDictionary(data) {
      return Object.fromEntries(Object.entries(data).map(([key, value]) => [value, key]));
    }
    function escapeRegExp(string7) {
      return string7.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    function isTypedArray(val) {
      return val?.prototype?.__proto__?.constructor?.name === "TypedArray";
    }
    function isIntegralNumber(x) {
      return Number.isInteger(x) || typeof x === "bigint";
    }
    function isNullishDimension(x) {
      return x === null || x === undefined || x === -1;
    }
    function calculateDimensions(arr) {
      const dimensions = [];
      let current = arr;
      while (Array.isArray(current)) {
        dimensions.push(current.length);
        current = current[0];
      }
      return dimensions;
    }
    function pop(obj, key, defaultValue = undefined) {
      const value = obj[key];
      if (value !== undefined) {
        delete obj[key];
        return value;
      }
      if (defaultValue === undefined) {
        throw Error(`Key ${key} does not exist in object.`);
      }
      return defaultValue;
    }
    function mergeArrays(...arrs) {
      return Array.prototype.concat.apply([], arrs);
    }
    function product(...a) {
      return a.reduce((a2, b) => a2.flatMap((d) => b.map((e) => [d, e])));
    }
    function calculateReflectOffset(i, w) {
      return Math.abs((i + w) % (2 * w) - w);
    }
    function saveBlob(path2, blob) {
      const dataURL = URL.createObjectURL(blob);
      const downloadLink = document.createElement("a");
      downloadLink.href = dataURL;
      downloadLink.download = path2;
      downloadLink.click();
      downloadLink.remove();
      URL.revokeObjectURL(dataURL);
    }
    function pick3(o, props) {
      return Object.assign({}, ...props.map((prop) => {
        if (o[prop] !== undefined) {
          return { [prop]: o[prop] };
        }
      }));
    }
    function len(s) {
      let length = 0;
      for (const c of s)
        ++length;
      return length;
    }
    function count(arr, value) {
      let count2 = 0;
      for (const v of arr) {
        if (v === value)
          ++count2;
      }
      return count2;
    }
  },
  "./src/utils/data-structures.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!**************************************!*\
      !*** ./src/utils/data-structures.js ***!
      \**************************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      CharTrie: () => CharTrie,
      DictionarySplitter: () => DictionarySplitter,
      LRUCache: () => LRUCache,
      PriorityQueue: () => PriorityQueue,
      TokenLattice: () => TokenLattice
    });

    class PriorityQueue {
      constructor(comparator = (a, b) => a > b, maxSize = Infinity) {
        this._heap = [];
        this._comparator = comparator;
        this._maxSize = maxSize;
      }
      get size() {
        return this._heap.length;
      }
      isEmpty() {
        return this.size === 0;
      }
      peek() {
        return this._heap[0];
      }
      push(...values) {
        return this.extend(values);
      }
      extend(values) {
        for (const value of values) {
          if (this.size < this._maxSize) {
            this._heap.push(value);
            this._siftUp();
          } else {
            const smallest = this._smallest();
            if (this._comparator(value, this._heap[smallest])) {
              this._heap[smallest] = value;
              this._siftUpFrom(smallest);
            }
          }
        }
        return this.size;
      }
      pop() {
        const poppedValue = this.peek();
        const bottom = this.size - 1;
        if (bottom > 0) {
          this._swap(0, bottom);
        }
        this._heap.pop();
        this._siftDown();
        return poppedValue;
      }
      replace(value) {
        const replacedValue = this.peek();
        this._heap[0] = value;
        this._siftDown();
        return replacedValue;
      }
      _parent(i) {
        return (i + 1 >>> 1) - 1;
      }
      _left(i) {
        return (i << 1) + 1;
      }
      _right(i) {
        return i + 1 << 1;
      }
      _greater(i, j) {
        return this._comparator(this._heap[i], this._heap[j]);
      }
      _swap(i, j) {
        const temp = this._heap[i];
        this._heap[i] = this._heap[j];
        this._heap[j] = temp;
      }
      _siftUp() {
        this._siftUpFrom(this.size - 1);
      }
      _siftUpFrom(node) {
        while (node > 0 && this._greater(node, this._parent(node))) {
          this._swap(node, this._parent(node));
          node = this._parent(node);
        }
      }
      _siftDown() {
        let node = 0;
        while (this._left(node) < this.size && this._greater(this._left(node), node) || this._right(node) < this.size && this._greater(this._right(node), node)) {
          const maxChild = this._right(node) < this.size && this._greater(this._right(node), this._left(node)) ? this._right(node) : this._left(node);
          this._swap(node, maxChild);
          node = maxChild;
        }
      }
      _smallest() {
        return 2 ** Math.floor(Math.log2(this.size)) - 1;
      }
    }

    class CharTrie {
      constructor() {
        this.root = CharTrieNode.default();
      }
      extend(texts) {
        for (const text of texts) {
          this.push(text);
        }
      }
      push(text) {
        let node = this.root;
        for (const ch of text) {
          let child = node.children.get(ch);
          if (child === undefined) {
            child = CharTrieNode.default();
            node.children.set(ch, child);
          }
          node = child;
        }
        node.isLeaf = true;
      }
      *commonPrefixSearch(text) {
        let node = this.root;
        if (node === undefined)
          return;
        let prefix = "";
        for (const ch of text) {
          prefix += ch;
          node = node.children.get(ch);
          if (node === undefined)
            return;
          if (node.isLeaf) {
            yield prefix;
          }
        }
      }
    }

    class CharTrieNode {
      constructor(isLeaf, children) {
        this.isLeaf = isLeaf;
        this.children = children;
      }
      static default() {
        return new CharTrieNode(false, new Map);
      }
    }

    class TokenLattice {
      constructor(sentence, bosTokenId, eosTokenId) {
        this.chars = Array.from(sentence);
        this.len = this.chars.length;
        this.bosTokenId = bosTokenId;
        this.eosTokenId = eosTokenId;
        this.nodes = [];
        this.beginNodes = Array.from({ length: this.len + 1 }, () => []);
        this.endNodes = Array.from({ length: this.len + 1 }, () => []);
        const bos = new TokenLatticeNode(this.bosTokenId, 0, 0, 0, 0);
        const eos = new TokenLatticeNode(this.eosTokenId, 1, this.len, 0, 0);
        this.nodes.push(bos.clone());
        this.nodes.push(eos.clone());
        this.beginNodes[this.len].push(eos);
        this.endNodes[0].push(bos);
      }
      insert(pos, length, score, tokenId) {
        const nodeId = this.nodes.length;
        const node = new TokenLatticeNode(tokenId, nodeId, pos, length, score);
        this.beginNodes[pos].push(node);
        this.endNodes[pos + length].push(node);
        this.nodes.push(node);
      }
      viterbi() {
        const len = this.len;
        let pos = 0;
        while (pos <= len) {
          if (this.beginNodes[pos].length == 0) {
            return [];
          }
          for (let rnode of this.beginNodes[pos]) {
            rnode.prev = null;
            let bestScore = 0;
            let bestNode = null;
            for (let lnode of this.endNodes[pos]) {
              const score = lnode.backtraceScore + rnode.score;
              if (bestNode === null || score > bestScore) {
                bestNode = lnode.clone();
                bestScore = score;
              }
            }
            if (bestNode !== null) {
              rnode.prev = bestNode;
              rnode.backtraceScore = bestScore;
            } else {
              return [];
            }
          }
          ++pos;
        }
        const results = [];
        const root = this.beginNodes[len][0];
        const prev = root.prev;
        if (prev === null) {
          return [];
        }
        let node = prev.clone();
        while (node.prev !== null) {
          results.push(node.clone());
          const n = node.clone();
          node = n.prev.clone();
        }
        results.reverse();
        return results;
      }
      piece(node) {
        return this.chars.slice(node.pos, node.pos + node.length).join("");
      }
      tokens() {
        const nodes = this.viterbi();
        return nodes.map((x) => this.piece(x));
      }
      tokenIds() {
        const nodes = this.viterbi();
        return nodes.map((x) => x.tokenId);
      }
    }

    class TokenLatticeNode {
      constructor(tokenId, nodeId, pos, length, score) {
        this.tokenId = tokenId;
        this.nodeId = nodeId;
        this.pos = pos;
        this.length = length;
        this.score = score;
        this.prev = null;
        this.backtraceScore = 0;
      }
      clone() {
        const n = new TokenLatticeNode(this.tokenId, this.nodeId, this.pos, this.length, this.score);
        n.prev = this.prev;
        n.backtraceScore = this.backtraceScore;
        return n;
      }
    }

    class DictionarySplitter {
      constructor(dictionary) {
        this.trie = this._buildTrie(dictionary);
      }
      _buildTrie(dictionary) {
        const trie = Object.create(null);
        for (const word of dictionary) {
          let node = trie;
          for (let i = 0;i < word.length; ++i) {
            node = node[word[i]] ??= Object.create(null);
          }
          node.end = word;
        }
        return trie;
      }
      split(text) {
        const result = [];
        const n = text.length;
        let start = 0;
        let i = 0;
        while (i < n) {
          let node = this.trie;
          let match = null;
          let j = i;
          while (j < n && (node = node[text[j]])) {
            if (node.end) {
              match = node.end;
            }
            ++j;
          }
          if (match) {
            if (i > start) {
              result.push(text.slice(start, i));
            }
            result.push(match);
            i += match.length;
            start = i;
          } else {
            ++i;
          }
        }
        if (start < n) {
          result.push(text.slice(start));
        }
        return result;
      }
    }

    class LRUCache {
      constructor(capacity) {
        this.capacity = capacity;
        this.cache = new Map;
      }
      get(key) {
        if (!this.cache.has(key))
          return;
        const value = this.cache.get(key);
        this.cache.delete(key);
        this.cache.set(key, value);
        return value;
      }
      put(key, value) {
        if (this.cache.has(key)) {
          this.cache.delete(key);
        }
        this.cache.set(key, value);
        if (this.cache.size > this.capacity) {
          this.cache.delete(this.cache.keys().next().value);
        }
      }
      clear() {
        this.cache.clear();
      }
    }
  },
  "./src/utils/devices.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!******************************!*\
      !*** ./src/utils/devices.js ***!
      \******************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      DEVICE_TYPES: () => DEVICE_TYPES
    });
    const DEVICE_TYPES = Object.freeze({
      auto: "auto",
      gpu: "gpu",
      cpu: "cpu",
      wasm: "wasm",
      webgpu: "webgpu",
      cuda: "cuda",
      dml: "dml",
      webnn: "webnn",
      "webnn-npu": "webnn-npu",
      "webnn-gpu": "webnn-gpu",
      "webnn-cpu": "webnn-cpu"
    });
  },
  "./src/utils/dtypes.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!*****************************!*\
      !*** ./src/utils/dtypes.js ***!
      \*****************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      DATA_TYPES: () => DATA_TYPES,
      DEFAULT_DEVICE_DTYPE_MAPPING: () => DEFAULT_DEVICE_DTYPE_MAPPING,
      DEFAULT_DTYPE_SUFFIX_MAPPING: () => DEFAULT_DTYPE_SUFFIX_MAPPING,
      isWebGpuFp16Supported: () => isWebGpuFp16Supported
    });
    var _env_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/env.js");
    /*! ../env.js */
    var _devices_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/utils/devices.js");
    /*! ./devices.js */
    const isWebGpuFp16Supported = function() {
      let cachedResult;
      return async function() {
        if (cachedResult === undefined) {
          if (!_env_js__WEBPACK_IMPORTED_MODULE_0__.apis.IS_WEBGPU_AVAILABLE) {
            cachedResult = false;
          } else {
            try {
              const adapter = await navigator.gpu.requestAdapter();
              cachedResult = adapter.features.has("shader-f16");
            } catch (e) {
              cachedResult = false;
            }
          }
        }
        return cachedResult;
      };
    }();
    const DATA_TYPES = Object.freeze({
      auto: "auto",
      fp32: "fp32",
      fp16: "fp16",
      q8: "q8",
      int8: "int8",
      uint8: "uint8",
      q4: "q4",
      bnb4: "bnb4",
      q4f16: "q4f16"
    });
    const DEFAULT_DEVICE_DTYPE_MAPPING = Object.freeze({
      [_devices_js__WEBPACK_IMPORTED_MODULE_1__.DEVICE_TYPES.wasm]: DATA_TYPES.q8
    });
    const DEFAULT_DTYPE_SUFFIX_MAPPING = Object.freeze({
      [DATA_TYPES.fp32]: "",
      [DATA_TYPES.fp16]: "_fp16",
      [DATA_TYPES.int8]: "_int8",
      [DATA_TYPES.uint8]: "_uint8",
      [DATA_TYPES.q8]: "_quantized",
      [DATA_TYPES.q4]: "_q4",
      [DATA_TYPES.q4f16]: "_q4f16",
      [DATA_TYPES.bnb4]: "_bnb4"
    });
  },
  "./src/utils/generic.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!******************************!*\
      !*** ./src/utils/generic.js ***!
      \******************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      Callable: () => Callable
    });
    const Callable = class {
      constructor() {
        let closure = function(...args) {
          return closure._call(...args);
        };
        return Object.setPrototypeOf(closure, new.target.prototype);
      }
      _call(...args) {
        throw Error("Must implement _call method in subclass");
      }
    };
  },
  "./src/utils/hub.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!**************************!*\
      !*** ./src/utils/hub.js ***!
      \**************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      MAX_EXTERNAL_DATA_CHUNKS: () => MAX_EXTERNAL_DATA_CHUNKS,
      getFile: () => getFile,
      getModelFile: () => getModelFile,
      getModelJSON: () => getModelJSON,
      getModelText: () => getModelText
    });
    var node_fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("node:fs");
    /*! node:fs */
    var node_path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("node:path");
    /*! node:path */
    var _env_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/env.js");
    /*! ../env.js */
    var _core_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/utils/core.js");
    /*! ./core.js */
    const MAX_EXTERNAL_DATA_CHUNKS = 100;
    const CONTENT_TYPE_MAP = {
      txt: "text/plain",
      html: "text/html",
      css: "text/css",
      js: "text/javascript",
      json: "application/json",
      png: "image/png",
      jpg: "image/jpeg",
      jpeg: "image/jpeg",
      gif: "image/gif"
    };

    class FileResponse {
      constructor(filePath) {
        this.filePath = filePath;
        this.headers = new Headers;
        this.exists = node_fs__WEBPACK_IMPORTED_MODULE_0__["default"].existsSync(filePath);
        if (this.exists) {
          this.status = 200;
          this.statusText = "OK";
          let stats = node_fs__WEBPACK_IMPORTED_MODULE_0__["default"].statSync(filePath);
          this.headers.set("content-length", stats.size.toString());
          this.updateContentType();
          const stream = node_fs__WEBPACK_IMPORTED_MODULE_0__["default"].createReadStream(filePath);
          this.body = new ReadableStream({
            start(controller) {
              stream.on("data", (chunk) => controller.enqueue(chunk));
              stream.on("end", () => controller.close());
              stream.on("error", (err) => controller.error(err));
            },
            cancel() {
              stream.destroy();
            }
          });
        } else {
          this.status = 404;
          this.statusText = "Not Found";
          this.body = null;
        }
      }
      updateContentType() {
        const extension = this.filePath.toString().split(".").pop().toLowerCase();
        this.headers.set("content-type", CONTENT_TYPE_MAP[extension] ?? "application/octet-stream");
      }
      clone() {
        let response = new FileResponse(this.filePath);
        response.exists = this.exists;
        response.status = this.status;
        response.statusText = this.statusText;
        response.headers = new Headers(this.headers);
        return response;
      }
      async arrayBuffer() {
        const data = await node_fs__WEBPACK_IMPORTED_MODULE_0__["default"].promises.readFile(this.filePath);
        return data.buffer;
      }
      async blob() {
        const data = await node_fs__WEBPACK_IMPORTED_MODULE_0__["default"].promises.readFile(this.filePath);
        return new Blob([data], { type: this.headers.get("content-type") });
      }
      async text() {
        const data = await node_fs__WEBPACK_IMPORTED_MODULE_0__["default"].promises.readFile(this.filePath, "utf8");
        return data;
      }
      async json() {
        return JSON.parse(await this.text());
      }
    }
    function isValidUrl(string7, protocols = null, validHosts = null) {
      let url2;
      try {
        url2 = new URL(string7);
      } catch (_) {
        return false;
      }
      if (protocols && !protocols.includes(url2.protocol)) {
        return false;
      }
      if (validHosts && !validHosts.includes(url2.hostname)) {
        return false;
      }
      return true;
    }
    const REPO_ID_REGEX = /^(\b[\w\-.]+\b\/)?\b[\w\-.]{1,96}\b$/;
    function isValidHfModelId(string7) {
      if (!REPO_ID_REGEX.test(string7))
        return false;
      if (string7.includes("..") || string7.includes("--"))
        return false;
      if (string7.endsWith(".git") || string7.endsWith(".ipynb"))
        return false;
      return true;
    }
    async function getFile(urlOrPath) {
      if (_env_js__WEBPACK_IMPORTED_MODULE_2__.env.useFS && !isValidUrl(urlOrPath, ["http:", "https:", "blob:"])) {
        return new FileResponse(urlOrPath instanceof URL ? urlOrPath.protocol === "file:" ? urlOrPath.pathname : urlOrPath.toString() : urlOrPath);
      } else if (typeof process !== "undefined" && process?.release?.name === "node") {
        const IS_CI = !!process.env?.TESTING_REMOTELY;
        const version5 = _env_js__WEBPACK_IMPORTED_MODULE_2__.env.version;
        const headers = new Headers;
        headers.set("User-Agent", `transformers.js/${version5}; is_ci/${IS_CI};`);
        const isHFURL = isValidUrl(urlOrPath, ["http:", "https:"], ["huggingface.co", "hf.co"]);
        if (isHFURL) {
          const token = process.env?.HF_TOKEN ?? process.env?.HF_ACCESS_TOKEN;
          if (token) {
            headers.set("Authorization", `Bearer ${token}`);
          }
        }
        return fetch(urlOrPath, { headers });
      } else {
        return fetch(urlOrPath);
      }
    }
    const ERROR_MAPPING = {
      400: "Bad request error occurred while trying to load file",
      401: "Unauthorized access to file",
      403: "Forbidden access to file",
      404: "Could not locate file",
      408: "Request timeout error occurred while trying to load file",
      500: "Internal server error error occurred while trying to load file",
      502: "Bad gateway error occurred while trying to load file",
      503: "Service unavailable error occurred while trying to load file",
      504: "Gateway timeout error occurred while trying to load file"
    };
    function handleError(status, remoteURL, fatal) {
      if (!fatal) {
        return null;
      }
      const message = ERROR_MAPPING[status] ?? `Error (${status}) occurred while trying to load file`;
      throw Error(`${message}: "${remoteURL}".`);
    }

    class FileCache {
      constructor(path2) {
        this.path = path2;
      }
      async match(request) {
        let filePath = node_path__WEBPACK_IMPORTED_MODULE_1__["default"].join(this.path, request);
        let file2 = new FileResponse(filePath);
        if (file2.exists) {
          return file2;
        } else {
          return;
        }
      }
      async put(request, response, progress_callback = undefined) {
        let filePath = node_path__WEBPACK_IMPORTED_MODULE_1__["default"].join(this.path, request);
        try {
          const contentLength = response.headers.get("Content-Length");
          const total = parseInt(contentLength ?? "0");
          let loaded = 0;
          await node_fs__WEBPACK_IMPORTED_MODULE_0__["default"].promises.mkdir(node_path__WEBPACK_IMPORTED_MODULE_1__["default"].dirname(filePath), { recursive: true });
          const fileStream = node_fs__WEBPACK_IMPORTED_MODULE_0__["default"].createWriteStream(filePath);
          const reader = response.body.getReader();
          while (true) {
            const { done, value } = await reader.read();
            if (done) {
              break;
            }
            await new Promise((resolve4, reject) => {
              fileStream.write(value, (err) => {
                if (err) {
                  reject(err);
                  return;
                }
                resolve4();
              });
            });
            loaded += value.length;
            const progress = total ? loaded / total * 100 : 0;
            progress_callback?.({ progress, loaded, total });
          }
          fileStream.close();
        } catch (error49) {
          try {
            await node_fs__WEBPACK_IMPORTED_MODULE_0__["default"].promises.unlink(filePath);
          } catch {}
          throw error49;
        }
      }
    }
    async function tryCache(cache, ...names) {
      for (let name of names) {
        try {
          let result = await cache.match(name);
          if (result)
            return result;
        } catch (e) {
          continue;
        }
      }
      return;
    }
    async function getModelFile(path_or_repo_id, filename, fatal = true, options2 = {}, return_path = false) {
      if (!_env_js__WEBPACK_IMPORTED_MODULE_2__.env.allowLocalModels) {
        if (options2.local_files_only) {
          throw Error("Invalid configuration detected: local models are disabled (`env.allowLocalModels=false`) but you have requested to only use local models (`local_files_only=true`).");
        } else if (!_env_js__WEBPACK_IMPORTED_MODULE_2__.env.allowRemoteModels) {
          throw Error("Invalid configuration detected: both local and remote models are disabled. Fix by setting `env.allowLocalModels` or `env.allowRemoteModels` to `true`.");
        }
      }
      (0, _core_js__WEBPACK_IMPORTED_MODULE_3__.dispatchCallback)(options2.progress_callback, {
        status: "initiate",
        name: path_or_repo_id,
        file: filename
      });
      let cache;
      if (!cache && _env_js__WEBPACK_IMPORTED_MODULE_2__.env.useCustomCache) {
        if (!_env_js__WEBPACK_IMPORTED_MODULE_2__.env.customCache) {
          throw Error("`env.useCustomCache=true`, but `env.customCache` is not defined.");
        }
        if (!_env_js__WEBPACK_IMPORTED_MODULE_2__.env.customCache.match || !_env_js__WEBPACK_IMPORTED_MODULE_2__.env.customCache.put) {
          throw new Error("`env.customCache` must be an object which implements the `match` and `put` functions of the Web Cache API. " + "For more information, see https://developer.mozilla.org/en-US/docs/Web/API/Cache");
        }
        cache = _env_js__WEBPACK_IMPORTED_MODULE_2__.env.customCache;
      }
      if (!cache && _env_js__WEBPACK_IMPORTED_MODULE_2__.env.useBrowserCache) {
        if (typeof caches === "undefined") {
          throw Error("Browser cache is not available in this environment.");
        }
        try {
          cache = await caches.open("transformers-cache");
        } catch (e) {
          console.warn("An error occurred while opening the browser cache:", e);
        }
      }
      if (!cache && _env_js__WEBPACK_IMPORTED_MODULE_2__.env.useFSCache) {
        if (!_env_js__WEBPACK_IMPORTED_MODULE_2__.apis.IS_FS_AVAILABLE) {
          throw Error("File System Cache is not available in this environment.");
        }
        cache = new FileCache(options2.cache_dir ?? _env_js__WEBPACK_IMPORTED_MODULE_2__.env.cacheDir);
      }
      const revision = options2.revision ?? "main";
      const requestURL = pathJoin(path_or_repo_id, filename);
      const validModelId = isValidHfModelId(path_or_repo_id);
      const localPath = validModelId ? pathJoin(_env_js__WEBPACK_IMPORTED_MODULE_2__.env.localModelPath, requestURL) : requestURL;
      const remoteURL = pathJoin(_env_js__WEBPACK_IMPORTED_MODULE_2__.env.remoteHost, _env_js__WEBPACK_IMPORTED_MODULE_2__.env.remotePathTemplate.replaceAll("{model}", path_or_repo_id).replaceAll("{revision}", encodeURIComponent(revision)), filename);
      let cacheKey;
      const proposedCacheKey = cache instanceof FileCache ? revision === "main" ? requestURL : pathJoin(path_or_repo_id, revision, filename) : remoteURL;
      let toCacheResponse = false;
      let response;
      if (cache) {
        response = await tryCache(cache, localPath, proposedCacheKey);
      }
      const cacheHit = response !== undefined;
      if (response === undefined) {
        if (_env_js__WEBPACK_IMPORTED_MODULE_2__.env.allowLocalModels) {
          const isURL = isValidUrl(requestURL, ["http:", "https:"]);
          if (!isURL) {
            try {
              response = await getFile(localPath);
              cacheKey = localPath;
            } catch (e) {
              console.warn(`Unable to load from local path "${localPath}": "${e}"`);
            }
          } else if (options2.local_files_only) {
            throw new Error(`\`local_files_only=true\`, but attempted to load a remote file from: ${requestURL}.`);
          } else if (!_env_js__WEBPACK_IMPORTED_MODULE_2__.env.allowRemoteModels) {
            throw new Error(`\`env.allowRemoteModels=false\`, but attempted to load a remote file from: ${requestURL}.`);
          }
        }
        if (response === undefined || response.status === 404) {
          if (options2.local_files_only || !_env_js__WEBPACK_IMPORTED_MODULE_2__.env.allowRemoteModels) {
            if (fatal) {
              throw Error(`\`local_files_only=true\` or \`env.allowRemoteModels=false\` and file was not found locally at "${localPath}".`);
            } else {
              return null;
            }
          }
          if (!validModelId) {
            throw Error(`Local file missing at "${localPath}" and download aborted due to invalid model ID "${path_or_repo_id}".`);
          }
          response = await getFile(remoteURL);
          if (response.status !== 200) {
            return handleError(response.status, remoteURL, fatal);
          }
          cacheKey = proposedCacheKey;
        }
        toCacheResponse = cache && typeof Response !== "undefined" && response instanceof Response && response.status === 200;
      }
      (0, _core_js__WEBPACK_IMPORTED_MODULE_3__.dispatchCallback)(options2.progress_callback, {
        status: "download",
        name: path_or_repo_id,
        file: filename
      });
      let result;
      if (!(_env_js__WEBPACK_IMPORTED_MODULE_2__.apis.IS_NODE_ENV && return_path)) {
        let buffer;
        if (!options2.progress_callback) {
          buffer = new Uint8Array(await response.arrayBuffer());
        } else if (cacheHit && typeof navigator !== "undefined" && /firefox/i.test(navigator.userAgent)) {
          buffer = new Uint8Array(await response.arrayBuffer());
          (0, _core_js__WEBPACK_IMPORTED_MODULE_3__.dispatchCallback)(options2.progress_callback, {
            status: "progress",
            name: path_or_repo_id,
            file: filename,
            progress: 100,
            loaded: buffer.length,
            total: buffer.length
          });
        } else {
          buffer = await readResponse(response, (data) => {
            (0, _core_js__WEBPACK_IMPORTED_MODULE_3__.dispatchCallback)(options2.progress_callback, {
              status: "progress",
              name: path_or_repo_id,
              file: filename,
              ...data
            });
          });
        }
        result = buffer;
      }
      if (toCacheResponse && cacheKey && await cache.match(cacheKey) === undefined) {
        if (!result) {
          const wrapped_progress = options2.progress_callback ? (data) => (0, _core_js__WEBPACK_IMPORTED_MODULE_3__.dispatchCallback)(options2.progress_callback, {
            status: "progress",
            name: path_or_repo_id,
            file: filename,
            ...data
          }) : undefined;
          await cache.put(cacheKey, response, wrapped_progress);
        } else {
          await cache.put(cacheKey, new Response(result, {
            headers: response.headers
          })).catch((err) => {
            console.warn(`Unable to add response to browser cache: ${err}.`);
          });
        }
      }
      (0, _core_js__WEBPACK_IMPORTED_MODULE_3__.dispatchCallback)(options2.progress_callback, {
        status: "done",
        name: path_or_repo_id,
        file: filename
      });
      if (result) {
        if (!_env_js__WEBPACK_IMPORTED_MODULE_2__.apis.IS_NODE_ENV && return_path) {
          throw new Error("Cannot return path in a browser environment.");
        }
        return result;
      }
      if (response instanceof FileResponse) {
        return response.filePath;
      }
      const cachedResponse = await cache?.match(cacheKey);
      if (cachedResponse instanceof FileResponse) {
        return cachedResponse.filePath;
      } else if (cachedResponse instanceof Response) {
        return new Uint8Array(await cachedResponse.arrayBuffer());
      } else if (typeof cachedResponse === "string") {
        return cachedResponse;
      }
      throw new Error("Unable to get model file path or buffer.");
    }
    async function getModelText(modelPath, fileName, fatal = true, options2 = {}) {
      const buffer = await getModelFile(modelPath, fileName, fatal, options2, false);
      if (buffer === null) {
        return null;
      }
      const decoder = new TextDecoder("utf-8");
      return decoder.decode(buffer);
    }
    async function getModelJSON(modelPath, fileName, fatal = true, options2 = {}) {
      const text = await getModelText(modelPath, fileName, fatal, options2);
      if (text === null) {
        return {};
      }
      return JSON.parse(text);
    }
    async function readResponse(response, progress_callback) {
      const contentLength = response.headers.get("Content-Length");
      if (contentLength === null) {
        console.warn("Unable to determine content-length from response headers. Will expand buffer when needed.");
      }
      let total = parseInt(contentLength ?? "0");
      let buffer = new Uint8Array(total);
      let loaded = 0;
      const reader = response.body.getReader();
      async function read() {
        const { done, value } = await reader.read();
        if (done)
          return;
        const newLoaded = loaded + value.length;
        if (newLoaded > total) {
          total = newLoaded;
          const newBuffer = new Uint8Array(total);
          newBuffer.set(buffer);
          buffer = newBuffer;
        }
        buffer.set(value, loaded);
        loaded = newLoaded;
        const progress = loaded / total * 100;
        progress_callback({ progress, loaded, total });
        return read();
      }
      await read();
      return buffer;
    }
    function pathJoin(...parts) {
      parts = parts.map((part, index) => {
        if (index) {
          part = part.replace(new RegExp("^/"), "");
        }
        if (index !== parts.length - 1) {
          part = part.replace(new RegExp("/$"), "");
        }
        return part;
      });
      return parts.join("/");
    }
  },
  "./src/utils/image.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!****************************!*\
      !*** ./src/utils/image.js ***!
      \****************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      RawImage: () => RawImage,
      load_image: () => load_image
    });
    var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/utils/core.js");
    /*! ./core.js */
    var _hub_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/utils/hub.js");
    /*! ./hub.js */
    var _env_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/env.js");
    /*! ../env.js */
    var _tensor_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/utils/tensor.js");
    /*! ./tensor.js */
    var sharp__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("sharp");
    /*! sharp */
    let createCanvasFunction;
    let ImageDataClass;
    let loadImageFunction;
    const IS_BROWSER_OR_WEBWORKER = _env_js__WEBPACK_IMPORTED_MODULE_2__.apis.IS_BROWSER_ENV || _env_js__WEBPACK_IMPORTED_MODULE_2__.apis.IS_WEBWORKER_ENV;
    if (IS_BROWSER_OR_WEBWORKER) {
      createCanvasFunction = (width, height) => {
        if (!self.OffscreenCanvas) {
          throw new Error("OffscreenCanvas not supported by this browser.");
        }
        return new self.OffscreenCanvas(width, height);
      };
      loadImageFunction = self.createImageBitmap;
      ImageDataClass = self.ImageData;
    } else if (sharp__WEBPACK_IMPORTED_MODULE_4__["default"]) {
      loadImageFunction = async (img) => {
        const metadata = await img.metadata();
        const rawChannels = metadata.channels;
        const { data, info } = await img.rotate().raw().toBuffer({ resolveWithObject: true });
        const newImage = new RawImage(new Uint8ClampedArray(data), info.width, info.height, info.channels);
        if (rawChannels !== undefined && rawChannels !== info.channels) {
          newImage.convert(rawChannels);
        }
        return newImage;
      };
    } else {
      throw new Error("Unable to load image processing library.");
    }
    const RESAMPLING_MAPPING = {
      0: "nearest",
      1: "lanczos",
      2: "bilinear",
      3: "bicubic",
      4: "box",
      5: "hamming"
    };
    const CONTENT_TYPE_MAP = new Map([
      ["png", "image/png"],
      ["jpg", "image/jpeg"],
      ["jpeg", "image/jpeg"],
      ["gif", "image/gif"]
    ]);

    class RawImage {
      constructor(data, width, height, channels) {
        this.data = data;
        this.width = width;
        this.height = height;
        this.channels = channels;
      }
      get size() {
        return [this.width, this.height];
      }
      static async read(input) {
        if (input instanceof RawImage) {
          return input;
        } else if (typeof input === "string" || input instanceof URL) {
          return await this.fromURL(input);
        } else if (input instanceof Blob) {
          return await this.fromBlob(input);
        } else if (typeof HTMLCanvasElement !== "undefined" && input instanceof HTMLCanvasElement || typeof OffscreenCanvas !== "undefined" && input instanceof OffscreenCanvas) {
          return this.fromCanvas(input);
        } else {
          throw new Error(`Unsupported input type: ${typeof input}`);
        }
      }
      static fromCanvas(canvas) {
        if (!IS_BROWSER_OR_WEBWORKER) {
          throw new Error("fromCanvas() is only supported in browser environments.");
        }
        const ctx = canvas.getContext("2d");
        const data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
        return new RawImage(data, canvas.width, canvas.height, 4);
      }
      static async fromURL(url2) {
        const response = await (0, _hub_js__WEBPACK_IMPORTED_MODULE_1__.getFile)(url2);
        if (response.status !== 200) {
          throw new Error(`Unable to read image from "${url2}" (${response.status} ${response.statusText})`);
        }
        const blob = await response.blob();
        return this.fromBlob(blob);
      }
      static async fromBlob(blob) {
        if (IS_BROWSER_OR_WEBWORKER) {
          const img = await loadImageFunction(blob);
          const ctx = createCanvasFunction(img.width, img.height).getContext("2d");
          ctx.drawImage(img, 0, 0);
          return new this(ctx.getImageData(0, 0, img.width, img.height).data, img.width, img.height, 4);
        } else {
          const img = (0, sharp__WEBPACK_IMPORTED_MODULE_4__["default"])(await blob.arrayBuffer());
          return await loadImageFunction(img);
        }
      }
      static fromTensor(tensor2, channel_format = "CHW") {
        if (tensor2.dims.length !== 3) {
          throw new Error(`Tensor should have 3 dimensions, but has ${tensor2.dims.length} dimensions.`);
        }
        if (channel_format === "CHW") {
          tensor2 = tensor2.transpose(1, 2, 0);
        } else if (channel_format === "HWC") {} else {
          throw new Error(`Unsupported channel format: ${channel_format}`);
        }
        if (!(tensor2.data instanceof Uint8ClampedArray || tensor2.data instanceof Uint8Array)) {
          throw new Error(`Unsupported tensor type: ${tensor2.type}`);
        }
        switch (tensor2.dims[2]) {
          case 1:
          case 2:
          case 3:
          case 4:
            return new RawImage(tensor2.data, tensor2.dims[1], tensor2.dims[0], tensor2.dims[2]);
          default:
            throw new Error(`Unsupported number of channels: ${tensor2.dims[2]}`);
        }
      }
      grayscale() {
        if (this.channels === 1) {
          return this;
        }
        const newData = new Uint8ClampedArray(this.width * this.height * 1);
        switch (this.channels) {
          case 3:
          case 4:
            for (let i = 0, offset = 0;i < this.data.length; i += this.channels) {
              const red = this.data[i];
              const green = this.data[i + 1];
              const blue = this.data[i + 2];
              newData[offset++] = Math.round(0.2989 * red + 0.587 * green + 0.114 * blue);
            }
            break;
          default:
            throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`);
        }
        return this._update(newData, this.width, this.height, 1);
      }
      rgb() {
        if (this.channels === 3) {
          return this;
        }
        const newData = new Uint8ClampedArray(this.width * this.height * 3);
        switch (this.channels) {
          case 1:
            for (let i = 0, offset = 0;i < this.data.length; ++i) {
              newData[offset++] = this.data[i];
              newData[offset++] = this.data[i];
              newData[offset++] = this.data[i];
            }
            break;
          case 4:
            for (let i = 0, offset = 0;i < this.data.length; i += 4) {
              newData[offset++] = this.data[i];
              newData[offset++] = this.data[i + 1];
              newData[offset++] = this.data[i + 2];
            }
            break;
          default:
            throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`);
        }
        return this._update(newData, this.width, this.height, 3);
      }
      rgba() {
        if (this.channels === 4) {
          return this;
        }
        const newData = new Uint8ClampedArray(this.width * this.height * 4);
        switch (this.channels) {
          case 1:
            for (let i = 0, offset = 0;i < this.data.length; ++i) {
              newData[offset++] = this.data[i];
              newData[offset++] = this.data[i];
              newData[offset++] = this.data[i];
              newData[offset++] = 255;
            }
            break;
          case 3:
            for (let i = 0, offset = 0;i < this.data.length; i += 3) {
              newData[offset++] = this.data[i];
              newData[offset++] = this.data[i + 1];
              newData[offset++] = this.data[i + 2];
              newData[offset++] = 255;
            }
            break;
          default:
            throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`);
        }
        return this._update(newData, this.width, this.height, 4);
      }
      putAlpha(mask) {
        if (mask.width !== this.width || mask.height !== this.height) {
          throw new Error(`Expected mask size to be ${this.width}x${this.height}, but got ${mask.width}x${mask.height}`);
        }
        if (mask.channels !== 1) {
          throw new Error(`Expected mask to have 1 channel, but got ${mask.channels}`);
        }
        const this_data = this.data;
        const mask_data = mask.data;
        const num_pixels = this.width * this.height;
        if (this.channels === 3) {
          const newData = new Uint8ClampedArray(num_pixels * 4);
          for (let i = 0, in_offset = 0, out_offset = 0;i < num_pixels; ++i) {
            newData[out_offset++] = this_data[in_offset++];
            newData[out_offset++] = this_data[in_offset++];
            newData[out_offset++] = this_data[in_offset++];
            newData[out_offset++] = mask_data[i];
          }
          return this._update(newData, this.width, this.height, 4);
        } else if (this.channels === 4) {
          for (let i = 0;i < num_pixels; ++i) {
            this_data[4 * i + 3] = mask_data[i];
          }
          return this;
        }
        throw new Error(`Expected image to have 3 or 4 channels, but got ${this.channels}`);
      }
      async resize(width, height, {
        resample = 2
      } = {}) {
        if (this.width === width && this.height === height) {
          return this;
        }
        let resampleMethod = RESAMPLING_MAPPING[resample] ?? resample;
        const nullish_width = (0, _core_js__WEBPACK_IMPORTED_MODULE_0__.isNullishDimension)(width);
        const nullish_height = (0, _core_js__WEBPACK_IMPORTED_MODULE_0__.isNullishDimension)(height);
        if (nullish_width && nullish_height) {
          return this;
        } else if (nullish_width) {
          width = height / this.height * this.width;
        } else if (nullish_height) {
          height = width / this.width * this.height;
        }
        if (IS_BROWSER_OR_WEBWORKER) {
          const numChannels = this.channels;
          const canvas = this.toCanvas();
          const ctx = createCanvasFunction(width, height).getContext("2d");
          ctx.drawImage(canvas, 0, 0, width, height);
          const resizedImage = new RawImage(ctx.getImageData(0, 0, width, height).data, width, height, 4);
          return resizedImage.convert(numChannels);
        } else {
          let img = this.toSharp();
          switch (resampleMethod) {
            case "box":
            case "hamming":
              if (resampleMethod === "box" || resampleMethod === "hamming") {
                console.warn(`Resampling method ${resampleMethod} is not yet supported. Using bilinear instead.`);
                resampleMethod = "bilinear";
              }
            case "nearest":
            case "bilinear":
            case "bicubic":
              img = img.affine([width / this.width, 0, 0, height / this.height], {
                interpolator: resampleMethod
              });
              break;
            case "lanczos":
              img = img.resize({
                width,
                height,
                fit: "fill",
                kernel: "lanczos3"
              });
              break;
            default:
              throw new Error(`Resampling method ${resampleMethod} is not supported.`);
          }
          return await loadImageFunction(img);
        }
      }
      async pad([left, right, top, bottom]) {
        left = Math.max(left, 0);
        right = Math.max(right, 0);
        top = Math.max(top, 0);
        bottom = Math.max(bottom, 0);
        if (left === 0 && right === 0 && top === 0 && bottom === 0) {
          return this;
        }
        if (IS_BROWSER_OR_WEBWORKER) {
          const numChannels = this.channels;
          const canvas = this.toCanvas();
          const newWidth = this.width + left + right;
          const newHeight = this.height + top + bottom;
          const ctx = createCanvasFunction(newWidth, newHeight).getContext("2d");
          ctx.drawImage(canvas, 0, 0, this.width, this.height, left, top, this.width, this.height);
          const paddedImage = new RawImage(ctx.getImageData(0, 0, newWidth, newHeight).data, newWidth, newHeight, 4);
          return paddedImage.convert(numChannels);
        } else {
          const img = this.toSharp().extend({ left, right, top, bottom });
          return await loadImageFunction(img);
        }
      }
      async crop([x_min, y_min, x_max, y_max]) {
        x_min = Math.max(x_min, 0);
        y_min = Math.max(y_min, 0);
        x_max = Math.min(x_max, this.width - 1);
        y_max = Math.min(y_max, this.height - 1);
        if (x_min === 0 && y_min === 0 && x_max === this.width - 1 && y_max === this.height - 1) {
          return this;
        }
        const crop_width = x_max - x_min + 1;
        const crop_height = y_max - y_min + 1;
        if (IS_BROWSER_OR_WEBWORKER) {
          const numChannels = this.channels;
          const canvas = this.toCanvas();
          const ctx = createCanvasFunction(crop_width, crop_height).getContext("2d");
          ctx.drawImage(canvas, x_min, y_min, crop_width, crop_height, 0, 0, crop_width, crop_height);
          const resizedImage = new RawImage(ctx.getImageData(0, 0, crop_width, crop_height).data, crop_width, crop_height, 4);
          return resizedImage.convert(numChannels);
        } else {
          const img = this.toSharp().extract({
            left: x_min,
            top: y_min,
            width: crop_width,
            height: crop_height
          });
          return await loadImageFunction(img);
        }
      }
      async center_crop(crop_width, crop_height) {
        if (this.width === crop_width && this.height === crop_height) {
          return this;
        }
        const width_offset = (this.width - crop_width) / 2;
        const height_offset = (this.height - crop_height) / 2;
        if (IS_BROWSER_OR_WEBWORKER) {
          const numChannels = this.channels;
          const canvas = this.toCanvas();
          const ctx = createCanvasFunction(crop_width, crop_height).getContext("2d");
          let sourceX = 0;
          let sourceY = 0;
          let destX = 0;
          let destY = 0;
          if (width_offset >= 0) {
            sourceX = width_offset;
          } else {
            destX = -width_offset;
          }
          if (height_offset >= 0) {
            sourceY = height_offset;
          } else {
            destY = -height_offset;
          }
          ctx.drawImage(canvas, sourceX, sourceY, crop_width, crop_height, destX, destY, crop_width, crop_height);
          const resizedImage = new RawImage(ctx.getImageData(0, 0, crop_width, crop_height).data, crop_width, crop_height, 4);
          return resizedImage.convert(numChannels);
        } else {
          let img = this.toSharp();
          if (width_offset >= 0 && height_offset >= 0) {
            img = img.extract({
              left: Math.floor(width_offset),
              top: Math.floor(height_offset),
              width: crop_width,
              height: crop_height
            });
          } else if (width_offset <= 0 && height_offset <= 0) {
            const top = Math.floor(-height_offset);
            const left = Math.floor(-width_offset);
            img = img.extend({
              top,
              left,
              right: crop_width - this.width - left,
              bottom: crop_height - this.height - top
            });
          } else {
            let y_padding = [0, 0];
            let y_extract = 0;
            if (height_offset < 0) {
              y_padding[0] = Math.floor(-height_offset);
              y_padding[1] = crop_height - this.height - y_padding[0];
            } else {
              y_extract = Math.floor(height_offset);
            }
            let x_padding = [0, 0];
            let x_extract = 0;
            if (width_offset < 0) {
              x_padding[0] = Math.floor(-width_offset);
              x_padding[1] = crop_width - this.width - x_padding[0];
            } else {
              x_extract = Math.floor(width_offset);
            }
            img = img.extend({
              top: y_padding[0],
              bottom: y_padding[1],
              left: x_padding[0],
              right: x_padding[1]
            }).extract({
              left: x_extract,
              top: y_extract,
              width: crop_width,
              height: crop_height
            });
          }
          return await loadImageFunction(img);
        }
      }
      async toBlob(type = "image/png", quality = 1) {
        if (!IS_BROWSER_OR_WEBWORKER) {
          throw new Error("toBlob() is only supported in browser environments.");
        }
        const canvas = this.toCanvas();
        return await canvas.convertToBlob({ type, quality });
      }
      toTensor(channel_format = "CHW") {
        let tensor2 = new _tensor_js__WEBPACK_IMPORTED_MODULE_3__.Tensor("uint8", new Uint8Array(this.data), [this.height, this.width, this.channels]);
        if (channel_format === "HWC") {} else if (channel_format === "CHW") {
          tensor2 = tensor2.permute(2, 0, 1);
        } else {
          throw new Error(`Unsupported channel format: ${channel_format}`);
        }
        return tensor2;
      }
      toCanvas() {
        if (!IS_BROWSER_OR_WEBWORKER) {
          throw new Error("toCanvas() is only supported in browser environments.");
        }
        const cloned = this.clone().rgba();
        const clonedCanvas = createCanvasFunction(cloned.width, cloned.height);
        const data = new ImageDataClass(cloned.data, cloned.width, cloned.height);
        clonedCanvas.getContext("2d").putImageData(data, 0, 0);
        return clonedCanvas;
      }
      split() {
        const { data, width, height, channels } = this;
        const data_type = data.constructor;
        const per_channel_length = data.length / channels;
        const split_data = Array.from({ length: channels }, () => new data_type(per_channel_length));
        for (let i = 0;i < per_channel_length; ++i) {
          const data_offset = channels * i;
          for (let j = 0;j < channels; ++j) {
            split_data[j][i] = data[data_offset + j];
          }
        }
        return split_data.map((data2) => new RawImage(data2, width, height, 1));
      }
      _update(data, width, height, channels = null) {
        this.data = data;
        this.width = width;
        this.height = height;
        if (channels !== null) {
          this.channels = channels;
        }
        return this;
      }
      clone() {
        return new RawImage(this.data.slice(), this.width, this.height, this.channels);
      }
      convert(numChannels) {
        if (this.channels === numChannels)
          return this;
        switch (numChannels) {
          case 1:
            this.grayscale();
            break;
          case 3:
            this.rgb();
            break;
          case 4:
            this.rgba();
            break;
          default:
            throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`);
        }
        return this;
      }
      async save(path2) {
        if (IS_BROWSER_OR_WEBWORKER) {
          if (_env_js__WEBPACK_IMPORTED_MODULE_2__.apis.IS_WEBWORKER_ENV) {
            throw new Error("Unable to save an image from a Web Worker.");
          }
          const extension = path2.split(".").pop().toLowerCase();
          const mime = CONTENT_TYPE_MAP.get(extension) ?? "image/png";
          const blob = await this.toBlob(mime);
          (0, _core_js__WEBPACK_IMPORTED_MODULE_0__.saveBlob)(path2, blob);
        } else if (!_env_js__WEBPACK_IMPORTED_MODULE_2__.apis.IS_FS_AVAILABLE) {
          throw new Error("Unable to save the image because filesystem is disabled in this environment.");
        } else {
          const img = this.toSharp();
          return await img.toFile(path2);
        }
      }
      toSharp() {
        if (IS_BROWSER_OR_WEBWORKER) {
          throw new Error("toSharp() is only supported in server-side environments.");
        }
        return (0, sharp__WEBPACK_IMPORTED_MODULE_4__["default"])(this.data, {
          raw: {
            width: this.width,
            height: this.height,
            channels: this.channels
          }
        });
      }
    }
    const load_image = RawImage.read.bind(RawImage);
  },
  "./src/utils/maths.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!****************************!*\
      !*** ./src/utils/maths.js ***!
      \****************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      FFT: () => FFT,
      bankers_round: () => bankers_round,
      cos_sim: () => cos_sim,
      dot: () => dot,
      dynamic_time_warping: () => dynamic_time_warping,
      interpolate_data: () => interpolate_data,
      log_softmax: () => log_softmax,
      magnitude: () => magnitude2,
      max: () => max,
      medianFilter: () => medianFilter,
      min: () => min,
      permute_data: () => permute_data,
      round: () => round,
      softmax: () => softmax
    });
    function interpolate_data(input, [in_channels, in_height, in_width], [out_height, out_width], mode = "bilinear", align_corners = false) {
      const x_scale = out_width / in_width;
      const y_scale = out_height / in_height;
      const out_img = new input.constructor(out_height * out_width * in_channels);
      const inStride = in_height * in_width;
      const outStride = out_height * out_width;
      for (let i = 0;i < out_height; ++i) {
        for (let j = 0;j < out_width; ++j) {
          const outOffset = i * out_width + j;
          const x = (j + 0.5) / x_scale - 0.5;
          const y = (i + 0.5) / y_scale - 0.5;
          let x1 = Math.floor(x);
          let y1 = Math.floor(y);
          const x2 = Math.min(x1 + 1, in_width - 1);
          const y2 = Math.min(y1 + 1, in_height - 1);
          x1 = Math.max(x1, 0);
          y1 = Math.max(y1, 0);
          const s = x - x1;
          const t = y - y1;
          const w1 = (1 - s) * (1 - t);
          const w2 = s * (1 - t);
          const w3 = (1 - s) * t;
          const w4 = s * t;
          const yStride = y1 * in_width;
          const xStride = y2 * in_width;
          const idx1 = yStride + x1;
          const idx2 = yStride + x2;
          const idx3 = xStride + x1;
          const idx4 = xStride + x2;
          for (let k = 0;k < in_channels; ++k) {
            const cOffset = k * inStride;
            out_img[k * outStride + outOffset] = w1 * input[cOffset + idx1] + w2 * input[cOffset + idx2] + w3 * input[cOffset + idx3] + w4 * input[cOffset + idx4];
          }
        }
      }
      return out_img;
    }
    function permute_data(array4, dims, axes) {
      const shape = new Array(axes.length);
      const stride = new Array(axes.length);
      for (let i = axes.length - 1, s = 1;i >= 0; --i) {
        stride[i] = s;
        shape[i] = dims[axes[i]];
        s *= shape[i];
      }
      const invStride = axes.map((_, i) => stride[axes.indexOf(i)]);
      const permutedData = new array4.constructor(array4.length);
      for (let i = 0;i < array4.length; ++i) {
        let newIndex = 0;
        for (let j = dims.length - 1, k = i;j >= 0; --j) {
          newIndex += k % dims[j] * invStride[j];
          k = Math.floor(k / dims[j]);
        }
        permutedData[newIndex] = array4[i];
      }
      return [permutedData, shape];
    }
    function softmax(arr) {
      const maxVal = max(arr)[0];
      const exps = arr.map((x) => Math.exp(x - maxVal));
      const sumExps = exps.reduce((acc, val) => acc + val, 0);
      const softmaxArr = exps.map((x) => x / sumExps);
      return softmaxArr;
    }
    function log_softmax(arr) {
      const maxVal = max(arr)[0];
      let sumExps = 0;
      for (let i = 0;i < arr.length; ++i) {
        sumExps += Math.exp(arr[i] - maxVal);
      }
      const logSum = Math.log(sumExps);
      const logSoftmaxArr = arr.map((x) => x - maxVal - logSum);
      return logSoftmaxArr;
    }
    function dot(arr1, arr2) {
      let result = 0;
      for (let i = 0;i < arr1.length; ++i) {
        result += arr1[i] * arr2[i];
      }
      return result;
    }
    function cos_sim(arr1, arr2) {
      const dotProduct2 = dot(arr1, arr2);
      const magnitudeA = magnitude2(arr1);
      const magnitudeB = magnitude2(arr2);
      const cosineSimilarity = dotProduct2 / (magnitudeA * magnitudeB);
      return cosineSimilarity;
    }
    function magnitude2(arr) {
      return Math.sqrt(arr.reduce((acc, val) => acc + val * val, 0));
    }
    function min(arr) {
      if (arr.length === 0)
        throw Error("Array must not be empty");
      let min2 = arr[0];
      let indexOfMin = 0;
      for (let i = 1;i < arr.length; ++i) {
        if (arr[i] < min2) {
          min2 = arr[i];
          indexOfMin = i;
        }
      }
      return [min2, indexOfMin];
    }
    function max(arr) {
      if (arr.length === 0)
        throw Error("Array must not be empty");
      let max2 = arr[0];
      let indexOfMax = 0;
      for (let i = 1;i < arr.length; ++i) {
        if (arr[i] > max2) {
          max2 = arr[i];
          indexOfMax = i;
        }
      }
      return [max2, indexOfMax];
    }
    function isPowerOfTwo(number7) {
      return number7 > 0 && (number7 & number7 - 1) === 0;
    }

    class P2FFT {
      constructor(size) {
        this.size = size | 0;
        if (this.size <= 1 || !isPowerOfTwo(this.size))
          throw new Error("FFT size must be a power of two larger than 1");
        this._csize = size << 1;
        this.table = new Float64Array(this.size * 2);
        for (let i = 0;i < this.table.length; i += 2) {
          const angle = Math.PI * i / this.size;
          this.table[i] = Math.cos(angle);
          this.table[i + 1] = -Math.sin(angle);
        }
        let power = 0;
        for (let t = 1;this.size > t; t <<= 1)
          ++power;
        this._width = power % 2 === 0 ? power - 1 : power;
        this._bitrev = new Int32Array(1 << this._width);
        for (let j = 0;j < this._bitrev.length; ++j) {
          this._bitrev[j] = 0;
          for (let shift = 0;shift < this._width; shift += 2) {
            const revShift = this._width - shift - 2;
            this._bitrev[j] |= (j >>> shift & 3) << revShift;
          }
        }
      }
      createComplexArray() {
        return new Float64Array(this._csize);
      }
      fromComplexArray(complex, storage) {
        const res = storage || new Array(complex.length >>> 1);
        for (let i = 0;i < complex.length; i += 2)
          res[i >>> 1] = complex[i];
        return res;
      }
      toComplexArray(input, storage) {
        const res = storage || this.createComplexArray();
        for (let i = 0;i < res.length; i += 2) {
          res[i] = input[i >>> 1];
          res[i + 1] = 0;
        }
        return res;
      }
      transform(out, data) {
        if (out === data)
          throw new Error("Input and output buffers must be different");
        this._transform4(out, data, 1);
      }
      realTransform(out, data) {
        if (out === data)
          throw new Error("Input and output buffers must be different");
        this._realTransform4(out, data, 1);
      }
      inverseTransform(out, data) {
        if (out === data)
          throw new Error("Input and output buffers must be different");
        this._transform4(out, data, -1);
        for (let i = 0;i < out.length; ++i)
          out[i] /= this.size;
      }
      _transform4(out, data, inv) {
        const size = this._csize;
        const width = this._width;
        let step = 1 << width;
        let len = size / step << 1;
        let outOff;
        let t;
        const bitrev = this._bitrev;
        if (len === 4) {
          for (outOff = 0, t = 0;outOff < size; outOff += len, ++t) {
            const off = bitrev[t];
            this._singleTransform2(data, out, outOff, off, step);
          }
        } else {
          for (outOff = 0, t = 0;outOff < size; outOff += len, ++t) {
            const off = bitrev[t];
            this._singleTransform4(data, out, outOff, off, step, inv);
          }
        }
        const table = this.table;
        for (step >>= 2;step >= 2; step >>= 2) {
          len = size / step << 1;
          const quarterLen = len >>> 2;
          for (outOff = 0;outOff < size; outOff += len) {
            const limit = outOff + quarterLen - 1;
            for (let i = outOff, k = 0;i < limit; i += 2, k += step) {
              const A = i;
              const B = A + quarterLen;
              const C = B + quarterLen;
              const D = C + quarterLen;
              const Ar = out[A];
              const Ai = out[A + 1];
              const Br = out[B];
              const Bi = out[B + 1];
              const Cr = out[C];
              const Ci = out[C + 1];
              const Dr = out[D];
              const Di = out[D + 1];
              const tableBr = table[k];
              const tableBi = inv * table[k + 1];
              const MBr = Br * tableBr - Bi * tableBi;
              const MBi = Br * tableBi + Bi * tableBr;
              const tableCr = table[2 * k];
              const tableCi = inv * table[2 * k + 1];
              const MCr = Cr * tableCr - Ci * tableCi;
              const MCi = Cr * tableCi + Ci * tableCr;
              const tableDr = table[3 * k];
              const tableDi = inv * table[3 * k + 1];
              const MDr = Dr * tableDr - Di * tableDi;
              const MDi = Dr * tableDi + Di * tableDr;
              const T0r = Ar + MCr;
              const T0i = Ai + MCi;
              const T1r = Ar - MCr;
              const T1i = Ai - MCi;
              const T2r = MBr + MDr;
              const T2i = MBi + MDi;
              const T3r = inv * (MBr - MDr);
              const T3i = inv * (MBi - MDi);
              out[A] = T0r + T2r;
              out[A + 1] = T0i + T2i;
              out[B] = T1r + T3i;
              out[B + 1] = T1i - T3r;
              out[C] = T0r - T2r;
              out[C + 1] = T0i - T2i;
              out[D] = T1r - T3i;
              out[D + 1] = T1i + T3r;
            }
          }
        }
      }
      _singleTransform2(data, out, outOff, off, step) {
        const evenR = data[off];
        const evenI = data[off + 1];
        const oddR = data[off + step];
        const oddI = data[off + step + 1];
        out[outOff] = evenR + oddR;
        out[outOff + 1] = evenI + oddI;
        out[outOff + 2] = evenR - oddR;
        out[outOff + 3] = evenI - oddI;
      }
      _singleTransform4(data, out, outOff, off, step, inv) {
        const step2 = step * 2;
        const step3 = step * 3;
        const Ar = data[off];
        const Ai = data[off + 1];
        const Br = data[off + step];
        const Bi = data[off + step + 1];
        const Cr = data[off + step2];
        const Ci = data[off + step2 + 1];
        const Dr = data[off + step3];
        const Di = data[off + step3 + 1];
        const T0r = Ar + Cr;
        const T0i = Ai + Ci;
        const T1r = Ar - Cr;
        const T1i = Ai - Ci;
        const T2r = Br + Dr;
        const T2i = Bi + Di;
        const T3r = inv * (Br - Dr);
        const T3i = inv * (Bi - Di);
        out[outOff] = T0r + T2r;
        out[outOff + 1] = T0i + T2i;
        out[outOff + 2] = T1r + T3i;
        out[outOff + 3] = T1i - T3r;
        out[outOff + 4] = T0r - T2r;
        out[outOff + 5] = T0i - T2i;
        out[outOff + 6] = T1r - T3i;
        out[outOff + 7] = T1i + T3r;
      }
      _realTransform4(out, data, inv) {
        const size = this._csize;
        const width = this._width;
        let step = 1 << width;
        let len = size / step << 1;
        let outOff;
        let t;
        const bitrev = this._bitrev;
        if (len === 4) {
          for (outOff = 0, t = 0;outOff < size; outOff += len, ++t) {
            const off = bitrev[t];
            this._singleRealTransform2(data, out, outOff, off >>> 1, step >>> 1);
          }
        } else {
          for (outOff = 0, t = 0;outOff < size; outOff += len, ++t) {
            const off = bitrev[t];
            this._singleRealTransform4(data, out, outOff, off >>> 1, step >>> 1, inv);
          }
        }
        const table = this.table;
        for (step >>= 2;step >= 2; step >>= 2) {
          len = size / step << 1;
          const halfLen = len >>> 1;
          const quarterLen = halfLen >>> 1;
          const hquarterLen = quarterLen >>> 1;
          for (outOff = 0;outOff < size; outOff += len) {
            for (let i = 0, k = 0;i <= hquarterLen; i += 2, k += step) {
              const A = outOff + i;
              const B = A + quarterLen;
              const C = B + quarterLen;
              const D = C + quarterLen;
              const Ar = out[A];
              const Ai = out[A + 1];
              const Br = out[B];
              const Bi = out[B + 1];
              const Cr = out[C];
              const Ci = out[C + 1];
              const Dr = out[D];
              const Di = out[D + 1];
              const MAr = Ar;
              const MAi = Ai;
              const tableBr = table[k];
              const tableBi = inv * table[k + 1];
              const MBr = Br * tableBr - Bi * tableBi;
              const MBi = Br * tableBi + Bi * tableBr;
              const tableCr = table[2 * k];
              const tableCi = inv * table[2 * k + 1];
              const MCr = Cr * tableCr - Ci * tableCi;
              const MCi = Cr * tableCi + Ci * tableCr;
              const tableDr = table[3 * k];
              const tableDi = inv * table[3 * k + 1];
              const MDr = Dr * tableDr - Di * tableDi;
              const MDi = Dr * tableDi + Di * tableDr;
              const T0r = MAr + MCr;
              const T0i = MAi + MCi;
              const T1r = MAr - MCr;
              const T1i = MAi - MCi;
              const T2r = MBr + MDr;
              const T2i = MBi + MDi;
              const T3r = inv * (MBr - MDr);
              const T3i = inv * (MBi - MDi);
              out[A] = T0r + T2r;
              out[A + 1] = T0i + T2i;
              out[B] = T1r + T3i;
              out[B + 1] = T1i - T3r;
              if (i === 0) {
                out[C] = T0r - T2r;
                out[C + 1] = T0i - T2i;
                continue;
              }
              if (i === hquarterLen)
                continue;
              const SA = outOff + quarterLen - i;
              const SB = outOff + halfLen - i;
              out[SA] = T1r - inv * T3i;
              out[SA + 1] = -T1i - inv * T3r;
              out[SB] = T0r - inv * T2r;
              out[SB + 1] = -T0i + inv * T2i;
            }
          }
        }
        const half = size >>> 1;
        for (let i = 2;i < half; i += 2) {
          out[size - i] = out[i];
          out[size - i + 1] = -out[i + 1];
        }
      }
      _singleRealTransform2(data, out, outOff, off, step) {
        const evenR = data[off];
        const oddR = data[off + step];
        out[outOff] = evenR + oddR;
        out[outOff + 1] = 0;
        out[outOff + 2] = evenR - oddR;
        out[outOff + 3] = 0;
      }
      _singleRealTransform4(data, out, outOff, off, step, inv) {
        const step2 = step * 2;
        const step3 = step * 3;
        const Ar = data[off];
        const Br = data[off + step];
        const Cr = data[off + step2];
        const Dr = data[off + step3];
        const T0r = Ar + Cr;
        const T1r = Ar - Cr;
        const T2r = Br + Dr;
        const T3r = inv * (Br - Dr);
        out[outOff] = T0r + T2r;
        out[outOff + 1] = 0;
        out[outOff + 2] = T1r;
        out[outOff + 3] = -T3r;
        out[outOff + 4] = T0r - T2r;
        out[outOff + 5] = 0;
        out[outOff + 6] = T1r;
        out[outOff + 7] = T3r;
      }
    }

    class NP2FFT {
      constructor(fft_length) {
        const a = 2 * (fft_length - 1);
        const b = 2 * (2 * fft_length - 1);
        const nextP2 = 2 ** Math.ceil(Math.log2(b));
        this.bufferSize = nextP2;
        this._a = a;
        const chirp = new Float64Array(b);
        const ichirp = new Float64Array(nextP2);
        this._chirpBuffer = new Float64Array(nextP2);
        this._buffer1 = new Float64Array(nextP2);
        this._buffer2 = new Float64Array(nextP2);
        this._outBuffer1 = new Float64Array(nextP2);
        this._outBuffer2 = new Float64Array(nextP2);
        const theta = -2 * Math.PI / fft_length;
        const baseR = Math.cos(theta);
        const baseI = Math.sin(theta);
        for (let i = 0;i < b >> 1; ++i) {
          const e = (i + 1 - fft_length) ** 2 / 2;
          const result_mod = Math.sqrt(baseR ** 2 + baseI ** 2) ** e;
          const result_arg = e * Math.atan2(baseI, baseR);
          const i2 = 2 * i;
          chirp[i2] = result_mod * Math.cos(result_arg);
          chirp[i2 + 1] = result_mod * Math.sin(result_arg);
          ichirp[i2] = chirp[i2];
          ichirp[i2 + 1] = -chirp[i2 + 1];
        }
        this._slicedChirpBuffer = chirp.subarray(a, b);
        this._f = new P2FFT(nextP2 >> 1);
        this._f.transform(this._chirpBuffer, ichirp);
      }
      _transform(output, input, real) {
        const ib1 = this._buffer1;
        const ib2 = this._buffer2;
        const ob2 = this._outBuffer1;
        const ob3 = this._outBuffer2;
        const cb = this._chirpBuffer;
        const sb = this._slicedChirpBuffer;
        const a = this._a;
        if (real) {
          for (let j = 0;j < sb.length; j += 2) {
            const j2 = j + 1;
            const j3 = j >> 1;
            const a_real = input[j3];
            ib1[j] = a_real * sb[j];
            ib1[j2] = a_real * sb[j2];
          }
        } else {
          for (let j = 0;j < sb.length; j += 2) {
            const j2 = j + 1;
            ib1[j] = input[j] * sb[j] - input[j2] * sb[j2];
            ib1[j2] = input[j] * sb[j2] + input[j2] * sb[j];
          }
        }
        this._f.transform(ob2, ib1);
        for (let j = 0;j < cb.length; j += 2) {
          const j2 = j + 1;
          ib2[j] = ob2[j] * cb[j] - ob2[j2] * cb[j2];
          ib2[j2] = ob2[j] * cb[j2] + ob2[j2] * cb[j];
        }
        this._f.inverseTransform(ob3, ib2);
        for (let j = 0;j < ob3.length; j += 2) {
          const a_real = ob3[j + a];
          const a_imag = ob3[j + a + 1];
          const b_real = sb[j];
          const b_imag = sb[j + 1];
          output[j] = a_real * b_real - a_imag * b_imag;
          output[j + 1] = a_real * b_imag + a_imag * b_real;
        }
      }
      transform(output, input) {
        this._transform(output, input, false);
      }
      realTransform(output, input) {
        this._transform(output, input, true);
      }
    }

    class FFT {
      constructor(fft_length) {
        this.fft_length = fft_length;
        this.isPowerOfTwo = isPowerOfTwo(fft_length);
        if (this.isPowerOfTwo) {
          this.fft = new P2FFT(fft_length);
          this.outputBufferSize = 2 * fft_length;
        } else {
          this.fft = new NP2FFT(fft_length);
          this.outputBufferSize = this.fft.bufferSize;
        }
      }
      realTransform(out, input) {
        this.fft.realTransform(out, input);
      }
      transform(out, input) {
        this.fft.transform(out, input);
      }
    }
    function medianFilter(data, windowSize) {
      if (windowSize % 2 === 0 || windowSize <= 0) {
        throw new Error("Window size must be a positive odd number");
      }
      const outputArray = new data.constructor(data.length);
      const buffer = new data.constructor(windowSize);
      const halfWindowSize = Math.floor(windowSize / 2);
      for (let i = 0;i < data.length; ++i) {
        let valuesIndex = 0;
        for (let j = -halfWindowSize;j <= halfWindowSize; ++j) {
          let index = i + j;
          if (index < 0) {
            index = Math.abs(index);
          } else if (index >= data.length) {
            index = 2 * (data.length - 1) - index;
          }
          buffer[valuesIndex++] = data[index];
        }
        buffer.sort();
        outputArray[i] = buffer[halfWindowSize];
      }
      return outputArray;
    }
    function round(num, decimals) {
      const pow = Math.pow(10, decimals);
      return Math.round(num * pow) / pow;
    }
    function bankers_round(x) {
      const r = Math.round(x);
      const br = Math.abs(x) % 1 === 0.5 ? r % 2 === 0 ? r : r - 1 : r;
      return br;
    }
    function dynamic_time_warping(matrix) {
      const output_length = matrix.length;
      const input_length = matrix[0].length;
      const outputShape = [output_length + 1, input_length + 1];
      const cost = Array.from({ length: outputShape[0] }, () => Array(outputShape[1]).fill(Infinity));
      cost[0][0] = 0;
      const trace2 = Array.from({ length: outputShape[0] }, () => Array(outputShape[1]).fill(-1));
      for (let j2 = 1;j2 < outputShape[1]; ++j2) {
        for (let i2 = 1;i2 < outputShape[0]; ++i2) {
          const c0 = cost[i2 - 1][j2 - 1];
          const c1 = cost[i2 - 1][j2];
          const c2 = cost[i2][j2 - 1];
          let c, t;
          if (c0 < c1 && c0 < c2) {
            c = c0;
            t = 0;
          } else if (c1 < c0 && c1 < c2) {
            c = c1;
            t = 1;
          } else {
            c = c2;
            t = 2;
          }
          cost[i2][j2] = matrix[i2 - 1][j2 - 1] + c;
          trace2[i2][j2] = t;
        }
      }
      for (let i2 = 0;i2 < outputShape[1]; ++i2) {
        trace2[0][i2] = 2;
      }
      for (let i2 = 0;i2 < outputShape[0]; ++i2) {
        trace2[i2][0] = 1;
      }
      let i = output_length;
      let j = input_length;
      let text_indices = [];
      let time_indices = [];
      while (i > 0 || j > 0) {
        text_indices.push(i - 1);
        time_indices.push(j - 1);
        switch (trace2[i][j]) {
          case 0:
            --i;
            --j;
            break;
          case 1:
            --i;
            break;
          case 2:
            --j;
            break;
          default:
            throw new Error(`Internal error in dynamic time warping. Unexpected trace[${i}, ${j}]. Please file a bug report.`);
        }
      }
      text_indices.reverse();
      time_indices.reverse();
      return [text_indices, time_indices];
    }
  },
  "./src/utils/tensor.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!*****************************!*\
      !*** ./src/utils/tensor.js ***!
      \*****************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      DataTypeMap: () => DataTypeMap,
      Tensor: () => Tensor4,
      cat: () => cat,
      full: () => full,
      full_like: () => full_like,
      interpolate: () => interpolate,
      interpolate_4d: () => interpolate_4d,
      layer_norm: () => layer_norm,
      matmul: () => matmul,
      mean: () => mean,
      mean_pooling: () => mean_pooling,
      ones: () => ones,
      ones_like: () => ones_like,
      permute: () => permute,
      quantize_embeddings: () => quantize_embeddings,
      rand: () => rand,
      randn: () => randn,
      rfft: () => rfft,
      slice: () => slice2,
      stack: () => stack,
      std_mean: () => std_mean,
      topk: () => topk,
      zeros: () => zeros,
      zeros_like: () => zeros_like
    });
    var _maths_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/utils/maths.js");
    /*! ./maths.js */
    var _backends_onnx_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/backends/onnx.js");
    /*! ../backends/onnx.js */
    var _ops_registry_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/ops/registry.js");
    /*! ../ops/registry.js */
    const DataTypeMap = Object.freeze({
      float32: Float32Array,
      float16: typeof Float16Array !== "undefined" ? Float16Array : Uint16Array,
      float64: Float64Array,
      string: Array,
      int8: Int8Array,
      uint8: Uint8Array,
      int16: Int16Array,
      uint16: Uint16Array,
      int32: Int32Array,
      uint32: Uint32Array,
      int64: BigInt64Array,
      uint64: BigUint64Array,
      bool: Uint8Array,
      uint4: Uint8Array,
      int4: Int8Array
    });

    class Tensor4 {
      get dims() {
        return this.ort_tensor.dims;
      }
      set dims(value) {
        this.ort_tensor.dims = value;
      }
      get type() {
        return this.ort_tensor.type;
      }
      get data() {
        return this.ort_tensor.data;
      }
      get size() {
        return this.ort_tensor.size;
      }
      get location() {
        return this.ort_tensor.location;
      }
      ort_tensor;
      constructor(...args) {
        if ((0, _backends_onnx_js__WEBPACK_IMPORTED_MODULE_1__.isONNXTensor)(args[0])) {
          this.ort_tensor = args[0];
        } else {
          this.ort_tensor = new _backends_onnx_js__WEBPACK_IMPORTED_MODULE_1__.Tensor(args[0], args[1], args[2]);
        }
        return new Proxy(this, {
          get: (obj, key) => {
            if (typeof key === "string") {
              let index = Number(key);
              if (Number.isInteger(index)) {
                return obj._getitem(index);
              }
            }
            return obj[key];
          },
          set: (obj, key, value) => {
            return obj[key] = value;
          }
        });
      }
      dispose() {
        this.ort_tensor.dispose();
      }
      *[Symbol.iterator]() {
        const [iterLength, ...iterDims] = this.dims;
        if (iterDims.length > 0) {
          const iterSize = iterDims.reduce((a, b) => a * b);
          for (let i = 0;i < iterLength; ++i) {
            yield this._subarray(i, iterSize, iterDims);
          }
        } else {
          yield* this.data;
        }
      }
      _getitem(index) {
        const [iterLength, ...iterDims] = this.dims;
        index = safeIndex(index, iterLength);
        if (iterDims.length > 0) {
          const iterSize = iterDims.reduce((a, b) => a * b);
          return this._subarray(index, iterSize, iterDims);
        } else {
          return new Tensor4(this.type, [this.data[index]], iterDims);
        }
      }
      indexOf(item) {
        const this_data = this.data;
        for (let index = 0;index < this_data.length; ++index) {
          if (this_data[index] == item) {
            return index;
          }
        }
        return -1;
      }
      _subarray(index, iterSize, iterDims) {
        const o1 = index * iterSize;
        const o2 = (index + 1) * iterSize;
        const data = "subarray" in this.data ? this.data.subarray(o1, o2) : this.data.slice(o1, o2);
        return new Tensor4(this.type, data, iterDims);
      }
      item() {
        const this_data = this.data;
        if (this_data.length !== 1) {
          throw new Error(`a Tensor with ${this_data.length} elements cannot be converted to Scalar`);
        }
        return this_data[0];
      }
      tolist() {
        return reshape(this.data, this.dims);
      }
      sigmoid() {
        return this.clone().sigmoid_();
      }
      sigmoid_() {
        const this_data = this.data;
        for (let i = 0;i < this_data.length; ++i) {
          this_data[i] = 1 / (1 + Math.exp(-this_data[i]));
        }
        return this;
      }
      map(callback) {
        return this.clone().map_(callback);
      }
      map_(callback) {
        const this_data = this.data;
        for (let i = 0;i < this_data.length; ++i) {
          this_data[i] = callback(this_data[i], i, this_data);
        }
        return this;
      }
      mul(val) {
        return this.clone().mul_(val);
      }
      mul_(val) {
        const this_data = this.data;
        for (let i = 0;i < this_data.length; ++i) {
          this_data[i] *= val;
        }
        return this;
      }
      div(val) {
        return this.clone().div_(val);
      }
      div_(val) {
        const this_data = this.data;
        for (let i = 0;i < this_data.length; ++i) {
          this_data[i] /= val;
        }
        return this;
      }
      add(val) {
        return this.clone().add_(val);
      }
      add_(val) {
        const this_data = this.data;
        for (let i = 0;i < this_data.length; ++i) {
          this_data[i] += val;
        }
        return this;
      }
      sub(val) {
        return this.clone().sub_(val);
      }
      sub_(val) {
        const this_data = this.data;
        for (let i = 0;i < this_data.length; ++i) {
          this_data[i] -= val;
        }
        return this;
      }
      clone() {
        return new Tensor4(this.type, this.data.slice(), this.dims.slice());
      }
      slice(...slices) {
        const newTensorDims = [];
        const newOffsets = [];
        for (let sliceIndex = 0;sliceIndex < this.dims.length; ++sliceIndex) {
          let slice3 = slices[sliceIndex];
          if (slice3 === null || slice3 === undefined) {
            newOffsets.push([0, this.dims[sliceIndex]]);
            newTensorDims.push(this.dims[sliceIndex]);
          } else if (typeof slice3 === "number") {
            slice3 = safeIndex(slice3, this.dims[sliceIndex], sliceIndex);
            newOffsets.push([slice3, slice3 + 1]);
          } else if (Array.isArray(slice3) && slice3.length === 2) {
            let [start, end] = slice3;
            start = start === null ? 0 : safeIndex(start, this.dims[sliceIndex], sliceIndex, false);
            end = end === null ? this.dims[sliceIndex] : safeIndex(end, this.dims[sliceIndex], sliceIndex, false);
            if (start > end) {
              throw new Error(`Invalid slice: ${slice3}`);
            }
            const offsets = [
              Math.max(start, 0),
              Math.min(end, this.dims[sliceIndex])
            ];
            newOffsets.push(offsets);
            newTensorDims.push(offsets[1] - offsets[0]);
          } else {
            throw new Error(`Invalid slice: ${slice3}`);
          }
        }
        const newDims = newOffsets.map(([start, end]) => end - start);
        const newBufferSize = newDims.reduce((a, b) => a * b);
        const this_data = this.data;
        const data = new this_data.constructor(newBufferSize);
        const stride = this.stride();
        let isContiguous = true;
        for (let i = 1;i < newDims.length; ++i) {
          if (newOffsets[i][0] !== 0 || newOffsets[i][1] !== this.dims[i]) {
            isContiguous = false;
            break;
          }
        }
        if (isContiguous) {
          const start = newOffsets[0][0] * stride[0];
          const end = newOffsets[0][1] * stride[0];
          if (ArrayBuffer.isView(this_data)) {
            data.set(this_data.subarray(start, end));
          } else if (Array.isArray(this_data)) {
            const slicedData = this_data.slice(start, end);
            for (let i = 0;i < slicedData.length; ++i) {
              data[i] = slicedData[i];
            }
          } else {
            throw new Error("Unsupported data type for slicing");
          }
        } else {
          for (let i = 0;i < newBufferSize; ++i) {
            let originalIndex = 0;
            for (let j = newDims.length - 1, num = i;j >= 0; --j) {
              const size = newDims[j];
              originalIndex += (num % size + newOffsets[j][0]) * stride[j];
              num = Math.floor(num / size);
            }
            data[i] = this_data[originalIndex];
          }
        }
        return new Tensor4(this.type, data, newTensorDims);
      }
      permute(...dims) {
        return permute(this, dims);
      }
      transpose(...dims) {
        return this.permute(...dims);
      }
      sum(dim = null, keepdim = false) {
        return this.norm(1, dim, keepdim);
      }
      norm(p = "fro", dim = null, keepdim = false) {
        if (p === "fro") {
          p = 2;
        } else if (typeof p === "string") {
          throw Error(`Unsupported norm: ${p}`);
        }
        const this_data = this.data;
        const fn = (a, b) => a + b ** p;
        if (dim === null) {
          const val = this_data.reduce(fn, 0) ** (1 / p);
          return new Tensor4(this.type, [val], []);
        }
        const [type, result, resultDims] = reduce_helper(fn, this, dim, keepdim);
        if (p !== 1) {
          for (let i = 0;i < result.length; ++i) {
            result[i] = result[i] ** (1 / p);
          }
        }
        return new Tensor4(type, result, resultDims);
      }
      normalize_(p = 2, dim = 1) {
        dim = safeIndex(dim, this.dims.length);
        const norm = this.norm(p, dim, true);
        const this_data = this.data;
        const norm_data = norm.data;
        for (let i = 0;i < this_data.length; ++i) {
          let resultIndex = 0;
          for (let j = this.dims.length - 1, num = i, resultMultiplier = 1;j >= 0; --j) {
            const size = this.dims[j];
            if (j !== dim) {
              const index = num % size;
              resultIndex += index * resultMultiplier;
              resultMultiplier *= this.dims[j];
            }
            num = Math.floor(num / size);
          }
          this_data[i] /= norm_data[resultIndex];
        }
        return this;
      }
      normalize(p = 2, dim = 1) {
        return this.clone().normalize_(p, dim);
      }
      stride() {
        return dimsToStride(this.dims);
      }
      squeeze(dim = null) {
        return new Tensor4(this.type, this.data, calc_squeeze_dims(this.dims, dim));
      }
      squeeze_(dim = null) {
        this.dims = calc_squeeze_dims(this.dims, dim);
        return this;
      }
      unsqueeze(dim = null) {
        return new Tensor4(this.type, this.data, calc_unsqueeze_dims(this.dims, dim));
      }
      unsqueeze_(dim = null) {
        this.dims = calc_unsqueeze_dims(this.dims, dim);
        return this;
      }
      flatten_(start_dim = 0, end_dim = -1) {
        end_dim = (end_dim + this.dims.length) % this.dims.length;
        let dimsToKeepBefore = this.dims.slice(0, start_dim);
        let dimsToFlatten = this.dims.slice(start_dim, end_dim + 1);
        let dimsToKeepAfter = this.dims.slice(end_dim + 1);
        this.dims = [...dimsToKeepBefore, dimsToFlatten.reduce((a, b) => a * b, 1), ...dimsToKeepAfter];
        return this;
      }
      flatten(start_dim = 0, end_dim = -1) {
        return this.clone().flatten_(start_dim, end_dim);
      }
      view(...dims) {
        let inferredIndex = -1;
        for (let i = 0;i < dims.length; ++i) {
          if (dims[i] === -1) {
            if (inferredIndex !== -1) {
              throw new Error("Only one dimension can be inferred");
            }
            inferredIndex = i;
          }
        }
        const this_data = this.data;
        if (inferredIndex !== -1) {
          const productOther = dims.reduce((product, curr, index) => {
            return index !== inferredIndex ? product * curr : product;
          }, 1);
          dims[inferredIndex] = this_data.length / productOther;
        }
        return new Tensor4(this.type, this_data, dims);
      }
      neg_() {
        const this_data = this.data;
        for (let i = 0;i < this_data.length; ++i) {
          this_data[i] = -this_data[i];
        }
        return this;
      }
      neg() {
        return this.clone().neg_();
      }
      gt(val) {
        const mask = new Uint8Array(this.data.length);
        const this_data = this.data;
        for (let i = 0;i < this_data.length; ++i) {
          mask[i] = this_data[i] > val ? 1 : 0;
        }
        return new Tensor4("bool", mask, this.dims);
      }
      lt(val) {
        const mask = new Uint8Array(this.data.length);
        const this_data = this.data;
        for (let i = 0;i < this_data.length; ++i) {
          mask[i] = this_data[i] < val ? 1 : 0;
        }
        return new Tensor4("bool", mask, this.dims);
      }
      clamp_(min, max) {
        const this_data = this.data;
        for (let i = 0;i < this_data.length; ++i) {
          this_data[i] = Math.min(Math.max(this_data[i], min), max);
        }
        return this;
      }
      clamp(min, max) {
        return this.clone().clamp_(min, max);
      }
      round_() {
        const this_data = this.data;
        for (let i = 0;i < this_data.length; ++i) {
          this_data[i] = Math.round(this_data[i]);
        }
        return this;
      }
      round() {
        return this.clone().round_();
      }
      mean(dim = null, keepdim = false) {
        return mean(this, dim, keepdim);
      }
      min(dim = null, keepdim = false) {
        if (dim === null) {
          const val = (0, _maths_js__WEBPACK_IMPORTED_MODULE_0__.min)(this.data)[0];
          return new Tensor4(this.type, [val], []);
        }
        const [type, result, resultDims] = reduce_helper((a, b) => Math.min(a, b), this, dim, keepdim, Infinity);
        return new Tensor4(type, result, resultDims);
      }
      max(dim = null, keepdim = false) {
        if (dim === null) {
          const val = (0, _maths_js__WEBPACK_IMPORTED_MODULE_0__.max)(this.data)[0];
          return new Tensor4(this.type, [val], []);
        }
        const [type, result, resultDims] = reduce_helper((a, b) => Math.max(a, b), this, dim, keepdim, -Infinity);
        return new Tensor4(type, result, resultDims);
      }
      argmin(dim = null, keepdim = false) {
        if (dim !== null) {
          throw new Error("`dim !== null` not yet implemented.");
        }
        const index = (0, _maths_js__WEBPACK_IMPORTED_MODULE_0__.min)(this.data)[1];
        return new Tensor4("int64", [BigInt(index)], []);
      }
      argmax(dim = null, keepdim = false) {
        if (dim !== null) {
          throw new Error("`dim !== null` not yet implemented.");
        }
        const index = (0, _maths_js__WEBPACK_IMPORTED_MODULE_0__.max)(this.data)[1];
        return new Tensor4("int64", [BigInt(index)], []);
      }
      to(type) {
        if (this.type === type)
          return this;
        if (!DataTypeMap.hasOwnProperty(type)) {
          throw new Error(`Unsupported type: ${type}`);
        }
        let map_fn;
        const is_source_bigint = ["int64", "uint64"].includes(this.type);
        const is_dest_bigint = ["int64", "uint64"].includes(type);
        if (is_source_bigint && !is_dest_bigint) {
          map_fn = Number;
        } else if (!is_source_bigint && is_dest_bigint) {
          if (["float16", "float32", "float64"].includes(this.type)) {
            map_fn = (x) => BigInt(Math.floor(x));
          } else {
            map_fn = BigInt;
          }
        }
        return new Tensor4(type, DataTypeMap[type].from(this.data, map_fn), this.dims);
      }
    }
    function reshape(data, dimensions) {
      const totalElements = data.length;
      const dimensionSize = dimensions.reduce((a, b) => a * b);
      if (totalElements !== dimensionSize) {
        throw Error(`cannot reshape array of size ${totalElements} into shape (${dimensions})`);
      }
      let reshapedArray = data;
      for (let i = dimensions.length - 1;i >= 0; i--) {
        reshapedArray = reshapedArray.reduce((acc, val) => {
          let lastArray = acc[acc.length - 1];
          if (lastArray.length < dimensions[i]) {
            lastArray.push(val);
          } else {
            acc.push([val]);
          }
          return acc;
        }, [[]]);
      }
      return reshapedArray[0];
    }
    function permute(tensor2, axes) {
      const [permutedData, shape] = (0, _maths_js__WEBPACK_IMPORTED_MODULE_0__.permute_data)(tensor2.data, tensor2.dims, axes);
      return new Tensor4(tensor2.type, permutedData, shape);
    }
    function interpolate(input, [out_height, out_width], mode = "bilinear", align_corners = false) {
      const in_channels = input.dims.at(-3) ?? 1;
      const in_height = input.dims.at(-2);
      const in_width = input.dims.at(-1);
      let output = (0, _maths_js__WEBPACK_IMPORTED_MODULE_0__.interpolate_data)(input.data, [in_channels, in_height, in_width], [out_height, out_width], mode, align_corners);
      return new Tensor4(input.type, output, [in_channels, out_height, out_width]);
    }
    async function interpolate_4d(input, {
      size = null,
      mode = "bilinear"
    } = {}) {
      if (input.dims.length !== 4) {
        throw new Error("`interpolate_4d` currently only supports 4D input.");
      }
      if (!size) {
        throw new Error("`interpolate_4d` requires a `size` argument.");
      }
      let targetDims;
      if (size.length === 2) {
        targetDims = [...input.dims.slice(0, 2), ...size];
      } else if (size.length === 3) {
        targetDims = [input.dims[0], ...size];
      } else if (size.length === 4) {
        targetDims = size;
      } else {
        throw new Error("`size` must be of length 2, 3, or 4.");
      }
      let op;
      if (mode === "nearest") {
        op = await _ops_registry_js__WEBPACK_IMPORTED_MODULE_2__.TensorOpRegistry.nearest_interpolate_4d;
      } else if (mode === "bilinear") {
        op = await _ops_registry_js__WEBPACK_IMPORTED_MODULE_2__.TensorOpRegistry.bilinear_interpolate_4d;
      } else if (mode === "bicubic") {
        op = await _ops_registry_js__WEBPACK_IMPORTED_MODULE_2__.TensorOpRegistry.bicubic_interpolate_4d;
      } else {
        throw new Error(`Unsupported mode: ${mode}`);
      }
      const sizeTensor = new Tensor4("int64", new BigInt64Array(targetDims.map(BigInt)), [targetDims.length]);
      return await op({ x: input, s: sizeTensor });
    }
    async function matmul(a, b) {
      const op = await _ops_registry_js__WEBPACK_IMPORTED_MODULE_2__.TensorOpRegistry.matmul;
      return await op({ a, b });
    }
    async function rfft(x, a) {
      const op = await _ops_registry_js__WEBPACK_IMPORTED_MODULE_2__.TensorOpRegistry.rfft;
      return await op({ x, a });
    }
    async function topk(x, k) {
      const op = await _ops_registry_js__WEBPACK_IMPORTED_MODULE_2__.TensorOpRegistry.top_k;
      if (k == null) {
        k = x.dims.at(-1);
      } else {
        k = Math.min(k, x.dims.at(-1));
      }
      return await op({
        x,
        k: new Tensor4("int64", [BigInt(k)], [1])
      });
    }
    const arrayToIndexTensor = (array4) => new Tensor4("int64", array4, [array4.length]);
    async function slice2(data, starts, ends, axes, steps) {
      const op = await _ops_registry_js__WEBPACK_IMPORTED_MODULE_2__.TensorOpRegistry.slice;
      return await op({
        x: data,
        s: arrayToIndexTensor(starts),
        e: arrayToIndexTensor(ends),
        a: arrayToIndexTensor(axes),
        t: arrayToIndexTensor(steps ?? new Array(axes.length).fill(1))
      });
    }
    function mean_pooling(last_hidden_state, attention_mask) {
      const lastHiddenStateData = last_hidden_state.data;
      const attentionMaskData = attention_mask.data;
      const shape = [last_hidden_state.dims[0], last_hidden_state.dims[2]];
      const returnedData = new lastHiddenStateData.constructor(shape[0] * shape[1]);
      const [batchSize, seqLength, embedDim] = last_hidden_state.dims;
      let outIndex = 0;
      for (let i = 0;i < batchSize; ++i) {
        const offset = i * embedDim * seqLength;
        for (let k = 0;k < embedDim; ++k) {
          let sum = 0;
          let count = 0;
          const attnMaskOffset = i * seqLength;
          const offset2 = offset + k;
          for (let j = 0;j < seqLength; ++j) {
            const attn = Number(attentionMaskData[attnMaskOffset + j]);
            count += attn;
            sum += lastHiddenStateData[offset2 + j * embedDim] * attn;
          }
          const avg = sum / count;
          returnedData[outIndex++] = avg;
        }
      }
      return new Tensor4(last_hidden_state.type, returnedData, shape);
    }
    function layer_norm(input, normalized_shape, {
      eps = 0.00001
    } = {}) {
      if (input.dims.length !== 2) {
        throw new Error("`layer_norm` currently only supports 2D input.");
      }
      const [batchSize, featureDim] = input.dims;
      if (normalized_shape.length !== 1 && normalized_shape[0] !== featureDim) {
        throw new Error("`normalized_shape` must be a 1D array with shape `[input.dims[1]]`.");
      }
      const [std, mean2] = std_mean(input, 1, 0, true);
      const stdData = std.data;
      const meanData = mean2.data;
      const inputData = input.data;
      const returnedData = new inputData.constructor(inputData.length);
      for (let i = 0;i < batchSize; ++i) {
        const offset = i * featureDim;
        for (let j = 0;j < featureDim; ++j) {
          const offset2 = offset + j;
          returnedData[offset2] = (inputData[offset2] - meanData[i]) / (stdData[i] + eps);
        }
      }
      return new Tensor4(input.type, returnedData, input.dims);
    }
    function calc_squeeze_dims(dims, dim) {
      dims = dims.slice();
      if (dim === null) {
        dims = dims.filter((d) => d !== 1);
      } else if (typeof dim === "number") {
        if (dims[dim] === 1) {
          dims.splice(dim, 1);
        }
      } else if (Array.isArray(dim)) {
        dims = dims.filter((x, i) => {
          return x !== 1 || !dim.includes(i);
        });
      }
      return dims;
    }
    function calc_unsqueeze_dims(dims, dim) {
      dim = safeIndex(dim, dims.length + 1);
      dims = dims.slice();
      dims.splice(dim, 0, 1);
      return dims;
    }
    function safeIndex(index, size, dimension = null, boundsCheck = true) {
      if (index < -size || index >= size) {
        if (boundsCheck) {
          throw new Error(`IndexError: index ${index} is out of bounds for dimension${dimension === null ? "" : " " + dimension} with size ${size}`);
        } else {
          return index < -size ? 0 : size;
        }
      }
      if (index < 0) {
        index = (index % size + size) % size;
      }
      return index;
    }
    function cat(tensors, dim = 0) {
      dim = safeIndex(dim, tensors[0].dims.length);
      const resultDims = tensors[0].dims.slice();
      resultDims[dim] = tensors.reduce((a, b) => a + b.dims[dim], 0);
      const resultSize = resultDims.reduce((a, b) => a * b, 1);
      const result = new tensors[0].data.constructor(resultSize);
      const resultType = tensors[0].type;
      if (dim === 0) {
        let offset = 0;
        for (const tensor2 of tensors) {
          const tensorData = tensor2.data;
          result.set(tensorData, offset);
          offset += tensorData.length;
        }
      } else {
        let currentDim = 0;
        for (let t = 0;t < tensors.length; ++t) {
          const { data, dims } = tensors[t];
          for (let i = 0;i < data.length; ++i) {
            let resultIndex = 0;
            for (let j = dims.length - 1, num = i, resultMultiplier = 1;j >= 0; --j) {
              const size = dims[j];
              let index = num % size;
              if (j === dim) {
                index += currentDim;
              }
              resultIndex += index * resultMultiplier;
              resultMultiplier *= resultDims[j];
              num = Math.floor(num / size);
            }
            result[resultIndex] = data[i];
          }
          currentDim += dims[dim];
        }
      }
      return new Tensor4(resultType, result, resultDims);
    }
    function stack(tensors, dim = 0) {
      return cat(tensors.map((t) => t.unsqueeze(dim)), dim);
    }
    function reduce_helper(callbackfn, input, dim = null, keepdim = false, initialValue = null) {
      const inputData = input.data;
      const inputDims = input.dims;
      dim = safeIndex(dim, inputDims.length);
      const resultDims = inputDims.slice();
      resultDims[dim] = 1;
      const result = new inputData.constructor(inputData.length / inputDims[dim]);
      if (initialValue !== null) {
        result.fill(initialValue);
      }
      for (let i = 0;i < inputData.length; ++i) {
        let resultIndex = 0;
        for (let j = inputDims.length - 1, num = i, resultMultiplier = 1;j >= 0; --j) {
          const size = inputDims[j];
          if (j !== dim) {
            const index = num % size;
            resultIndex += index * resultMultiplier;
            resultMultiplier *= resultDims[j];
          }
          num = Math.floor(num / size);
        }
        result[resultIndex] = callbackfn(result[resultIndex], inputData[i], i, resultIndex);
      }
      if (!keepdim)
        resultDims.splice(dim, 1);
      return [input.type, result, resultDims];
    }
    function std_mean(input, dim = null, correction = 1, keepdim = false) {
      const inputData = input.data;
      const inputDims = input.dims;
      if (dim === null) {
        const sum = inputData.reduce((a, b) => a + b, 0);
        const mean2 = sum / inputData.length;
        const std = Math.sqrt(inputData.reduce((a, b) => a + (b - mean2) ** 2, 0) / (inputData.length - correction));
        const meanTensor2 = new Tensor4(input.type, [mean2], []);
        const stdTensor2 = new Tensor4(input.type, [std], []);
        return [stdTensor2, meanTensor2];
      }
      dim = safeIndex(dim, inputDims.length);
      const meanTensor = mean(input, dim, keepdim);
      const meanTensorData = meanTensor.data;
      const [type, result, resultDims] = reduce_helper((a, b, i, j) => a + (b - meanTensorData[j]) ** 2, input, dim, keepdim);
      for (let i = 0;i < result.length; ++i) {
        result[i] = Math.sqrt(result[i] / (inputDims[dim] - correction));
      }
      const stdTensor = new Tensor4(type, result, resultDims);
      return [stdTensor, meanTensor];
    }
    function mean(input, dim = null, keepdim = false) {
      const inputDims = input.dims;
      const inputData = input.data;
      if (dim === null) {
        const val = inputData.reduce((a, b) => a + b, 0);
        return new Tensor4(input.type, [val / inputData.length], []);
      }
      dim = safeIndex(dim, inputDims.length);
      const [type, result, resultDims] = reduce_helper((a, b) => a + b, input, dim, keepdim);
      if (inputDims[dim] !== 1) {
        for (let i = 0;i < result.length; ++i) {
          result[i] /= inputDims[dim];
        }
      }
      return new Tensor4(type, result, resultDims);
    }
    function dimsToStride(dims) {
      const stride = new Array(dims.length);
      for (let i = dims.length - 1, s2 = 1;i >= 0; --i) {
        stride[i] = s2;
        s2 *= dims[i];
      }
      return stride;
    }
    function fullHelper(size, fill_value, dtype, cls) {
      const numElements = size.reduce((a, b) => a * b, 1);
      return new Tensor4(dtype, new cls(numElements).fill(fill_value), size);
    }
    function full(size, fill_value) {
      let dtype;
      let typedArrayCls;
      if (typeof fill_value === "number") {
        dtype = "float32";
        typedArrayCls = Float32Array;
      } else if (typeof fill_value === "bigint") {
        dtype = "int64";
        typedArrayCls = BigInt64Array;
      } else if (typeof fill_value === "boolean") {
        dtype = "bool";
        typedArrayCls = Uint8Array;
      } else {
        throw new Error(`Unsupported data type: ${typeof fill_value}`);
      }
      return fullHelper(size, fill_value, dtype, typedArrayCls);
    }
    function full_like(tensor2, fill_value) {
      return full(tensor2.dims, fill_value);
    }
    function ones(size) {
      return fullHelper(size, 1n, "int64", BigInt64Array);
    }
    function ones_like(tensor2) {
      return ones(tensor2.dims);
    }
    function zeros(size) {
      return fullHelper(size, 0n, "int64", BigInt64Array);
    }
    function zeros_like(tensor2) {
      return zeros(tensor2.dims);
    }
    function rand(size) {
      const length = size.reduce((a, b) => a * b, 1);
      return new Tensor4("float32", Float32Array.from({ length }, () => Math.random()), size);
    }
    function randn(size) {
      const length = size.reduce((a, b) => a * b, 1);
      function boxMullerRandom() {
        const u = 1 - Math.random();
        const v = 1 - Math.random();
        return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
      }
      return new Tensor4("float32", Float32Array.from({ length }, () => boxMullerRandom()), size);
    }
    function quantize_embeddings(tensor2, precision) {
      if (tensor2.dims.length !== 2) {
        throw new Error("The tensor must have 2 dimensions");
      }
      if (tensor2.dims.at(-1) % 8 !== 0) {
        throw new Error("The last dimension of the tensor must be a multiple of 8");
      }
      if (!["binary", "ubinary"].includes(precision)) {
        throw new Error("The precision must be either 'binary' or 'ubinary'");
      }
      const signed = precision === "binary";
      const dtype = signed ? "int8" : "uint8";
      const cls = signed ? Int8Array : Uint8Array;
      const inputData = tensor2.data;
      const outputData = new cls(inputData.length / 8);
      for (let i = 0;i < inputData.length; ++i) {
        const bit = inputData[i] > 0 ? 1 : 0;
        const arrayIndex = Math.floor(i / 8);
        const bitPosition = i % 8;
        outputData[arrayIndex] |= bit << 7 - bitPosition;
        if (signed && bitPosition === 0) {
          outputData[arrayIndex] -= 128;
        }
      }
      return new Tensor4(dtype, outputData, [tensor2.dims[0], tensor2.dims[1] / 8]);
    }
  },
  "./src/utils/video.js": (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    /*!****************************!*\
      !*** ./src/utils/video.js ***!
      \****************************/
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
      RawVideo: () => RawVideo,
      RawVideoFrame: () => RawVideoFrame,
      load_video: () => load_video
    });
    var _image_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/utils/image.js");
    /*! ./image.js */
    var _env_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/env.js");
    /*! ../env.js */

    class RawVideoFrame {
      constructor(image, timestamp) {
        this.image = image;
        this.timestamp = timestamp;
      }
    }

    class RawVideo {
      constructor(frames, duration5) {
        if (frames.length > 0 && frames[0] instanceof _image_js__WEBPACK_IMPORTED_MODULE_0__.RawImage) {
          frames = frames.map((image, i) => new RawVideoFrame(image, (i + 1) / (frames.length + 1) * duration5));
        }
        this.frames = frames;
        this.duration = duration5;
      }
      get width() {
        return this.frames[0].image.width;
      }
      get height() {
        return this.frames[0].image.height;
      }
      get fps() {
        return this.frames.length / this.duration;
      }
    }
    async function load_video(src, { num_frames = null, fps = null } = {}) {
      if (!_env_js__WEBPACK_IMPORTED_MODULE_1__.apis.IS_BROWSER_ENV) {
        throw new Error("`load_video` is currently only supported in browser environments.");
      }
      if (num_frames == null && fps == null) {
        throw new Error("Either num_frames or fps must be provided.");
      }
      const frames = [];
      const video = document.createElement("video");
      video.crossOrigin = "anonymous";
      video.muted = true;
      if (typeof src === "string") {
        video.src = src;
      } else if (src instanceof Blob) {
        video.src = URL.createObjectURL(src);
      } else if (src instanceof HTMLVideoElement) {
        video.src = src.src;
      } else {
        throw new Error("Invalid URL or video element provided.");
      }
      await new Promise((resolve4) => video.onloadedmetadata = resolve4);
      if (video.seekable.start(0) === video.seekable.end(0)) {
        const response = await fetch(video.src);
        const blob = await response.blob();
        video.src = URL.createObjectURL(blob);
        await new Promise((resolve4) => video.onloadedmetadata = resolve4);
      }
      const duration5 = video.duration;
      let count, step;
      if (num_frames != null) {
        count = num_frames;
        step = num_frames === 1 ? 0 : duration5 / (num_frames - 1);
      } else {
        step = 1 / fps;
        count = Math.floor(duration5 / step);
      }
      let sampleTimes = [];
      for (let i = 0;i < count; ++i) {
        sampleTimes.push(num_frames === 1 ? duration5 / 2 : i * step);
      }
      const canvas = document.createElement("canvas");
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      const ctx = canvas.getContext("2d", { willReadFrequently: true });
      for (const t of sampleTimes) {
        video.currentTime = t;
        await new Promise((resolve4) => {
          video.onseeked = resolve4;
        });
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const frameData = new _image_js__WEBPACK_IMPORTED_MODULE_0__.RawImage(imageData.data, canvas.width, canvas.height, 4);
        const frame = new RawVideoFrame(frameData, t);
        frames.push(frame);
      }
      video.remove();
      return new RawVideo(frames, duration5);
    }
  }
};
var __webpack_module_cache__ = {};
function __webpack_require__(moduleId) {
  var cachedModule = __webpack_module_cache__[moduleId];
  if (cachedModule !== undefined) {
    return cachedModule.exports;
  }
  var module = __webpack_module_cache__[moduleId] = {
    exports: {}
  };
  __webpack_modules__[moduleId](module, module.exports, __webpack_require__);
  return module.exports;
}
(() => {
  var getProto = Object.getPrototypeOf ? (obj) => Object.getPrototypeOf(obj) : (obj) => obj.__proto__;
  var leafPrototypes;
  __webpack_require__.t = function(value, mode) {
    if (mode & 1)
      value = this(value);
    if (mode & 8)
      return value;
    if (typeof value === "object" && value) {
      if (mode & 4 && value.__esModule)
        return value;
      if (mode & 16 && typeof value.then === "function")
        return value;
    }
    var ns = Object.create(null);
    __webpack_require__.r(ns);
    var def = {};
    leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
    for (var current = mode & 2 && value;typeof current == "object" && !~leafPrototypes.indexOf(current); current = getProto(current)) {
      Object.getOwnPropertyNames(current).forEach((key) => def[key] = () => value[key]);
    }
    def["default"] = () => value;
    __webpack_require__.d(ns, def);
    return ns;
  };
})();
(() => {
  __webpack_require__.d = (exports, definition) => {
    for (var key in definition) {
      if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
        Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
      }
    }
  };
})();
(() => {
  __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
})();
(() => {
  __webpack_require__.r = (exports) => {
    if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
      Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    }
    Object.defineProperty(exports, "__esModule", { value: true });
  };
})();
var __webpack_exports__ = {};
(() => {
  /*!*****************************!*\
    !*** ./src/transformers.js ***!
    \*****************************/
  __webpack_require__.r(__webpack_exports__);
  __webpack_require__.d(__webpack_exports__, {
    ASTFeatureExtractor: () => _models_feature_extractors_js__WEBPACK_IMPORTED_MODULE_11__.ASTFeatureExtractor,
    ASTForAudioClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.ASTForAudioClassification,
    ASTModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.ASTModel,
    ASTPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.ASTPreTrainedModel,
    AlbertForMaskedLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.AlbertForMaskedLM,
    AlbertForQuestionAnswering: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.AlbertForQuestionAnswering,
    AlbertForSequenceClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.AlbertForSequenceClassification,
    AlbertModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.AlbertModel,
    AlbertPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.AlbertPreTrainedModel,
    AlbertTokenizer: () => _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.AlbertTokenizer,
    ArceeForCausalLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.ArceeForCausalLM,
    ArceeModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.ArceeModel,
    ArceePreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.ArceePreTrainedModel,
    AudioClassificationPipeline: () => _pipelines_js__WEBPACK_IMPORTED_MODULE_1__.AudioClassificationPipeline,
    AutoConfig: () => _configs_js__WEBPACK_IMPORTED_MODULE_4__.AutoConfig,
    AutoFeatureExtractor: () => _models_auto_feature_extraction_auto_js__WEBPACK_IMPORTED_MODULE_12__.AutoFeatureExtractor,
    AutoImageProcessor: () => _models_auto_image_processing_auto_js__WEBPACK_IMPORTED_MODULE_15__.AutoImageProcessor,
    AutoModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModel,
    AutoModelForAudioClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForAudioClassification,
    AutoModelForAudioFrameClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForAudioFrameClassification,
    AutoModelForAudioTextToText: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForAudioTextToText,
    AutoModelForCTC: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForCTC,
    AutoModelForCausalLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForCausalLM,
    AutoModelForDepthEstimation: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForDepthEstimation,
    AutoModelForDocumentQuestionAnswering: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForDocumentQuestionAnswering,
    AutoModelForImageClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForImageClassification,
    AutoModelForImageFeatureExtraction: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForImageFeatureExtraction,
    AutoModelForImageMatting: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForImageMatting,
    AutoModelForImageSegmentation: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForImageSegmentation,
    AutoModelForImageTextToText: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForImageTextToText,
    AutoModelForImageToImage: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForImageToImage,
    AutoModelForMaskGeneration: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForMaskGeneration,
    AutoModelForMaskedLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForMaskedLM,
    AutoModelForNormalEstimation: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForNormalEstimation,
    AutoModelForObjectDetection: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForObjectDetection,
    AutoModelForPoseEstimation: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForPoseEstimation,
    AutoModelForQuestionAnswering: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForQuestionAnswering,
    AutoModelForSemanticSegmentation: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForSemanticSegmentation,
    AutoModelForSeq2SeqLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForSeq2SeqLM,
    AutoModelForSequenceClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForSequenceClassification,
    AutoModelForSpeechSeq2Seq: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForSpeechSeq2Seq,
    AutoModelForTextToSpectrogram: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForTextToSpectrogram,
    AutoModelForTextToWaveform: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForTextToWaveform,
    AutoModelForTokenClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForTokenClassification,
    AutoModelForUniversalSegmentation: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForUniversalSegmentation,
    AutoModelForVision2Seq: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForVision2Seq,
    AutoModelForXVector: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForXVector,
    AutoModelForZeroShotObjectDetection: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForZeroShotObjectDetection,
    AutoProcessor: () => _models_auto_processing_auto_js__WEBPACK_IMPORTED_MODULE_18__.AutoProcessor,
    AutoTokenizer: () => _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.AutoTokenizer,
    AutomaticSpeechRecognitionPipeline: () => _pipelines_js__WEBPACK_IMPORTED_MODULE_1__.AutomaticSpeechRecognitionPipeline,
    BackgroundRemovalPipeline: () => _pipelines_js__WEBPACK_IMPORTED_MODULE_1__.BackgroundRemovalPipeline,
    BartForConditionalGeneration: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.BartForConditionalGeneration,
    BartForSequenceClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.BartForSequenceClassification,
    BartModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.BartModel,
    BartPretrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.BartPretrainedModel,
    BartTokenizer: () => _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.BartTokenizer,
    BaseModelOutput: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.BaseModelOutput,
    BaseStreamer: () => _generation_streamers_js__WEBPACK_IMPORTED_MODULE_19__.BaseStreamer,
    BeitFeatureExtractor: () => _models_image_processors_js__WEBPACK_IMPORTED_MODULE_14__.BeitFeatureExtractor,
    BeitForImageClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.BeitForImageClassification,
    BeitModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.BeitModel,
    BeitPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.BeitPreTrainedModel,
    BertForMaskedLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.BertForMaskedLM,
    BertForQuestionAnswering: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.BertForQuestionAnswering,
    BertForSequenceClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.BertForSequenceClassification,
    BertForTokenClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.BertForTokenClassification,
    BertModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.BertModel,
    BertPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.BertPreTrainedModel,
    BertTokenizer: () => _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.BertTokenizer,
    BitImageProcessor: () => _models_image_processors_js__WEBPACK_IMPORTED_MODULE_14__.BitImageProcessor,
    BlenderbotForConditionalGeneration: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.BlenderbotForConditionalGeneration,
    BlenderbotModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.BlenderbotModel,
    BlenderbotPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.BlenderbotPreTrainedModel,
    BlenderbotSmallForConditionalGeneration: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.BlenderbotSmallForConditionalGeneration,
    BlenderbotSmallModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.BlenderbotSmallModel,
    BlenderbotSmallPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.BlenderbotSmallPreTrainedModel,
    BlenderbotSmallTokenizer: () => _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.BlenderbotSmallTokenizer,
    BlenderbotTokenizer: () => _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.BlenderbotTokenizer,
    BloomForCausalLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.BloomForCausalLM,
    BloomModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.BloomModel,
    BloomPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.BloomPreTrainedModel,
    BloomTokenizer: () => _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.BloomTokenizer,
    CLIPFeatureExtractor: () => _models_image_processors_js__WEBPACK_IMPORTED_MODULE_14__.CLIPFeatureExtractor,
    CLIPImageProcessor: () => _models_image_processors_js__WEBPACK_IMPORTED_MODULE_14__.CLIPImageProcessor,
    CLIPModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.CLIPModel,
    CLIPPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.CLIPPreTrainedModel,
    CLIPSegForImageSegmentation: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.CLIPSegForImageSegmentation,
    CLIPSegModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.CLIPSegModel,
    CLIPSegPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.CLIPSegPreTrainedModel,
    CLIPTextModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.CLIPTextModel,
    CLIPTextModelWithProjection: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.CLIPTextModelWithProjection,
    CLIPTokenizer: () => _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.CLIPTokenizer,
    CLIPVisionModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.CLIPVisionModel,
    CLIPVisionModelWithProjection: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.CLIPVisionModelWithProjection,
    CamembertForMaskedLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.CamembertForMaskedLM,
    CamembertForQuestionAnswering: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.CamembertForQuestionAnswering,
    CamembertForSequenceClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.CamembertForSequenceClassification,
    CamembertForTokenClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.CamembertForTokenClassification,
    CamembertModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.CamembertModel,
    CamembertPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.CamembertPreTrainedModel,
    CamembertTokenizer: () => _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.CamembertTokenizer,
    CausalLMOutput: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.CausalLMOutput,
    CausalLMOutputWithPast: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.CausalLMOutputWithPast,
    ChineseCLIPFeatureExtractor: () => _models_image_processors_js__WEBPACK_IMPORTED_MODULE_14__.ChineseCLIPFeatureExtractor,
    ChineseCLIPModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.ChineseCLIPModel,
    ChineseCLIPPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.ChineseCLIPPreTrainedModel,
    ClapAudioModelWithProjection: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.ClapAudioModelWithProjection,
    ClapFeatureExtractor: () => _models_feature_extractors_js__WEBPACK_IMPORTED_MODULE_11__.ClapFeatureExtractor,
    ClapModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.ClapModel,
    ClapPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.ClapPreTrainedModel,
    ClapTextModelWithProjection: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.ClapTextModelWithProjection,
    ClassifierFreeGuidanceLogitsProcessor: () => _generation_logits_process_js__WEBPACK_IMPORTED_MODULE_21__.ClassifierFreeGuidanceLogitsProcessor,
    CodeGenForCausalLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.CodeGenForCausalLM,
    CodeGenModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.CodeGenModel,
    CodeGenPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.CodeGenPreTrainedModel,
    CodeGenTokenizer: () => _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.CodeGenTokenizer,
    CodeLlamaTokenizer: () => _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.CodeLlamaTokenizer,
    CohereForCausalLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.CohereForCausalLM,
    CohereModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.CohereModel,
    CoherePreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.CoherePreTrainedModel,
    CohereTokenizer: () => _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.CohereTokenizer,
    ConvBertForMaskedLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.ConvBertForMaskedLM,
    ConvBertForQuestionAnswering: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.ConvBertForQuestionAnswering,
    ConvBertForSequenceClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.ConvBertForSequenceClassification,
    ConvBertForTokenClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.ConvBertForTokenClassification,
    ConvBertModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.ConvBertModel,
    ConvBertPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.ConvBertPreTrainedModel,
    ConvBertTokenizer: () => _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.ConvBertTokenizer,
    ConvNextFeatureExtractor: () => _models_image_processors_js__WEBPACK_IMPORTED_MODULE_14__.ConvNextFeatureExtractor,
    ConvNextForImageClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.ConvNextForImageClassification,
    ConvNextImageProcessor: () => _models_image_processors_js__WEBPACK_IMPORTED_MODULE_14__.ConvNextImageProcessor,
    ConvNextModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.ConvNextModel,
    ConvNextPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.ConvNextPreTrainedModel,
    ConvNextV2ForImageClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.ConvNextV2ForImageClassification,
    ConvNextV2Model: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.ConvNextV2Model,
    ConvNextV2PreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.ConvNextV2PreTrainedModel,
    DFineForObjectDetection: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.DFineForObjectDetection,
    DFineModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.DFineModel,
    DFinePreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.DFinePreTrainedModel,
    DINOv3ConvNextModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.DINOv3ConvNextModel,
    DINOv3ConvNextPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.DINOv3ConvNextPreTrainedModel,
    DINOv3ViTImageProcessor: () => _models_image_processors_js__WEBPACK_IMPORTED_MODULE_14__.DINOv3ViTImageProcessor,
    DINOv3ViTModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.DINOv3ViTModel,
    DINOv3ViTPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.DINOv3ViTPreTrainedModel,
    DPTFeatureExtractor: () => _models_image_processors_js__WEBPACK_IMPORTED_MODULE_14__.DPTFeatureExtractor,
    DPTForDepthEstimation: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.DPTForDepthEstimation,
    DPTImageProcessor: () => _models_image_processors_js__WEBPACK_IMPORTED_MODULE_14__.DPTImageProcessor,
    DPTModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.DPTModel,
    DPTPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.DPTPreTrainedModel,
    DacDecoderModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.DacDecoderModel,
    DacDecoderOutput: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.DacDecoderOutput,
    DacEncoderModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.DacEncoderModel,
    DacEncoderOutput: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.DacEncoderOutput,
    DacFeatureExtractor: () => _models_feature_extractors_js__WEBPACK_IMPORTED_MODULE_11__.DacFeatureExtractor,
    DacModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.DacModel,
    DacPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.DacPreTrainedModel,
    DataTypeMap: () => _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.DataTypeMap,
    DebertaForMaskedLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.DebertaForMaskedLM,
    DebertaForQuestionAnswering: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.DebertaForQuestionAnswering,
    DebertaForSequenceClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.DebertaForSequenceClassification,
    DebertaForTokenClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.DebertaForTokenClassification,
    DebertaModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.DebertaModel,
    DebertaPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.DebertaPreTrainedModel,
    DebertaTokenizer: () => _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.DebertaTokenizer,
    DebertaV2ForMaskedLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.DebertaV2ForMaskedLM,
    DebertaV2ForQuestionAnswering: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.DebertaV2ForQuestionAnswering,
    DebertaV2ForSequenceClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.DebertaV2ForSequenceClassification,
    DebertaV2ForTokenClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.DebertaV2ForTokenClassification,
    DebertaV2Model: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.DebertaV2Model,
    DebertaV2PreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.DebertaV2PreTrainedModel,
    DebertaV2Tokenizer: () => _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.DebertaV2Tokenizer,
    DecisionTransformerModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.DecisionTransformerModel,
    DecisionTransformerPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.DecisionTransformerPreTrainedModel,
    DeiTFeatureExtractor: () => _models_image_processors_js__WEBPACK_IMPORTED_MODULE_14__.DeiTFeatureExtractor,
    DeiTForImageClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.DeiTForImageClassification,
    DeiTImageProcessor: () => _models_image_processors_js__WEBPACK_IMPORTED_MODULE_14__.DeiTImageProcessor,
    DeiTModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.DeiTModel,
    DeiTPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.DeiTPreTrainedModel,
    DepthAnythingForDepthEstimation: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.DepthAnythingForDepthEstimation,
    DepthAnythingPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.DepthAnythingPreTrainedModel,
    DepthEstimationPipeline: () => _pipelines_js__WEBPACK_IMPORTED_MODULE_1__.DepthEstimationPipeline,
    DepthProForDepthEstimation: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.DepthProForDepthEstimation,
    DepthProPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.DepthProPreTrainedModel,
    DetrFeatureExtractor: () => _models_image_processors_js__WEBPACK_IMPORTED_MODULE_14__.DetrFeatureExtractor,
    DetrForObjectDetection: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.DetrForObjectDetection,
    DetrForSegmentation: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.DetrForSegmentation,
    DetrImageProcessor: () => _models_image_processors_js__WEBPACK_IMPORTED_MODULE_14__.DetrImageProcessor,
    DetrModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.DetrModel,
    DetrObjectDetectionOutput: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.DetrObjectDetectionOutput,
    DetrPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.DetrPreTrainedModel,
    DetrSegmentationOutput: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.DetrSegmentationOutput,
    Dinov2ForImageClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Dinov2ForImageClassification,
    Dinov2Model: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Dinov2Model,
    Dinov2PreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Dinov2PreTrainedModel,
    Dinov2WithRegistersForImageClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Dinov2WithRegistersForImageClassification,
    Dinov2WithRegistersModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Dinov2WithRegistersModel,
    Dinov2WithRegistersPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Dinov2WithRegistersPreTrainedModel,
    DistilBertForMaskedLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.DistilBertForMaskedLM,
    DistilBertForQuestionAnswering: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.DistilBertForQuestionAnswering,
    DistilBertForSequenceClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.DistilBertForSequenceClassification,
    DistilBertForTokenClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.DistilBertForTokenClassification,
    DistilBertModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.DistilBertModel,
    DistilBertPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.DistilBertPreTrainedModel,
    DistilBertTokenizer: () => _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.DistilBertTokenizer,
    DocumentQuestionAnsweringPipeline: () => _pipelines_js__WEBPACK_IMPORTED_MODULE_1__.DocumentQuestionAnsweringPipeline,
    DonutFeatureExtractor: () => _models_image_processors_js__WEBPACK_IMPORTED_MODULE_14__.DonutFeatureExtractor,
    DonutImageProcessor: () => _models_image_processors_js__WEBPACK_IMPORTED_MODULE_14__.DonutImageProcessor,
    DonutSwinModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.DonutSwinModel,
    DonutSwinPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.DonutSwinPreTrainedModel,
    EdgeTamModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.EdgeTamModel,
    EfficientNetForImageClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.EfficientNetForImageClassification,
    EfficientNetImageProcessor: () => _models_image_processors_js__WEBPACK_IMPORTED_MODULE_14__.EfficientNetImageProcessor,
    EfficientNetModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.EfficientNetModel,
    EfficientNetPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.EfficientNetPreTrainedModel,
    ElectraForMaskedLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.ElectraForMaskedLM,
    ElectraForQuestionAnswering: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.ElectraForQuestionAnswering,
    ElectraForSequenceClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.ElectraForSequenceClassification,
    ElectraForTokenClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.ElectraForTokenClassification,
    ElectraModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.ElectraModel,
    ElectraPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.ElectraPreTrainedModel,
    ElectraTokenizer: () => _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.ElectraTokenizer,
    EncodecFeatureExtractor: () => _models_feature_extractors_js__WEBPACK_IMPORTED_MODULE_11__.EncodecFeatureExtractor,
    EosTokenCriteria: () => _generation_stopping_criteria_js__WEBPACK_IMPORTED_MODULE_20__.EosTokenCriteria,
    Ernie4_5ForCausalLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Ernie4_5ForCausalLM,
    Ernie4_5Model: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Ernie4_5Model,
    Ernie4_5PreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Ernie4_5PreTrainedModel,
    EsmForMaskedLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.EsmForMaskedLM,
    EsmForSequenceClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.EsmForSequenceClassification,
    EsmForTokenClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.EsmForTokenClassification,
    EsmModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.EsmModel,
    EsmPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.EsmPreTrainedModel,
    EsmTokenizer: () => _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.EsmTokenizer,
    ExaoneForCausalLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.ExaoneForCausalLM,
    ExaoneModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.ExaoneModel,
    ExaonePreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.ExaonePreTrainedModel,
    FFT: () => _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.FFT,
    FalconForCausalLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.FalconForCausalLM,
    FalconModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.FalconModel,
    FalconPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.FalconPreTrainedModel,
    FalconTokenizer: () => _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.FalconTokenizer,
    FastViTForImageClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.FastViTForImageClassification,
    FastViTModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.FastViTModel,
    FastViTPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.FastViTPreTrainedModel,
    FeatureExtractionPipeline: () => _pipelines_js__WEBPACK_IMPORTED_MODULE_1__.FeatureExtractionPipeline,
    FeatureExtractor: () => _base_feature_extraction_utils_js__WEBPACK_IMPORTED_MODULE_10__.FeatureExtractor,
    FillMaskPipeline: () => _pipelines_js__WEBPACK_IMPORTED_MODULE_1__.FillMaskPipeline,
    Florence2ForConditionalGeneration: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Florence2ForConditionalGeneration,
    Florence2PreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Florence2PreTrainedModel,
    Florence2Processor: () => _models_processors_js__WEBPACK_IMPORTED_MODULE_17__.Florence2Processor,
    ForcedBOSTokenLogitsProcessor: () => _generation_logits_process_js__WEBPACK_IMPORTED_MODULE_21__.ForcedBOSTokenLogitsProcessor,
    ForcedEOSTokenLogitsProcessor: () => _generation_logits_process_js__WEBPACK_IMPORTED_MODULE_21__.ForcedEOSTokenLogitsProcessor,
    GLPNFeatureExtractor: () => _models_image_processors_js__WEBPACK_IMPORTED_MODULE_14__.GLPNFeatureExtractor,
    GLPNForDepthEstimation: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.GLPNForDepthEstimation,
    GLPNModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.GLPNModel,
    GLPNPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.GLPNPreTrainedModel,
    GPT2LMHeadModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.GPT2LMHeadModel,
    GPT2Model: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.GPT2Model,
    GPT2PreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.GPT2PreTrainedModel,
    GPT2Tokenizer: () => _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.GPT2Tokenizer,
    GPTBigCodeForCausalLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.GPTBigCodeForCausalLM,
    GPTBigCodeModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.GPTBigCodeModel,
    GPTBigCodePreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.GPTBigCodePreTrainedModel,
    GPTJForCausalLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.GPTJForCausalLM,
    GPTJModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.GPTJModel,
    GPTJPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.GPTJPreTrainedModel,
    GPTNeoForCausalLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.GPTNeoForCausalLM,
    GPTNeoModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.GPTNeoModel,
    GPTNeoPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.GPTNeoPreTrainedModel,
    GPTNeoXForCausalLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.GPTNeoXForCausalLM,
    GPTNeoXModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.GPTNeoXModel,
    GPTNeoXPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.GPTNeoXPreTrainedModel,
    GPTNeoXTokenizer: () => _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.GPTNeoXTokenizer,
    Gemma2ForCausalLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Gemma2ForCausalLM,
    Gemma2Model: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Gemma2Model,
    Gemma2PreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Gemma2PreTrainedModel,
    Gemma3ForCausalLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Gemma3ForCausalLM,
    Gemma3Model: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Gemma3Model,
    Gemma3PreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Gemma3PreTrainedModel,
    Gemma3nAudioFeatureExtractor: () => _models_feature_extractors_js__WEBPACK_IMPORTED_MODULE_11__.Gemma3nAudioFeatureExtractor,
    Gemma3nForConditionalGeneration: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Gemma3nForConditionalGeneration,
    Gemma3nPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Gemma3nPreTrainedModel,
    Gemma3nProcessor: () => _models_processors_js__WEBPACK_IMPORTED_MODULE_17__.Gemma3nProcessor,
    GemmaForCausalLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.GemmaForCausalLM,
    GemmaModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.GemmaModel,
    GemmaPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.GemmaPreTrainedModel,
    GemmaTokenizer: () => _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.GemmaTokenizer,
    GlmForCausalLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.GlmForCausalLM,
    GlmModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.GlmModel,
    GlmPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.GlmPreTrainedModel,
    GraniteForCausalLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.GraniteForCausalLM,
    GraniteModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.GraniteModel,
    GraniteMoeHybridForCausalLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.GraniteMoeHybridForCausalLM,
    GraniteMoeHybridModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.GraniteMoeHybridModel,
    GraniteMoeHybridPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.GraniteMoeHybridPreTrainedModel,
    GranitePreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.GranitePreTrainedModel,
    Grok1Tokenizer: () => _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.Grok1Tokenizer,
    GroundingDinoForObjectDetection: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.GroundingDinoForObjectDetection,
    GroundingDinoImageProcessor: () => _models_image_processors_js__WEBPACK_IMPORTED_MODULE_14__.GroundingDinoImageProcessor,
    GroundingDinoPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.GroundingDinoPreTrainedModel,
    GroundingDinoProcessor: () => _models_processors_js__WEBPACK_IMPORTED_MODULE_17__.GroundingDinoProcessor,
    GroupViTModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.GroupViTModel,
    GroupViTPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.GroupViTPreTrainedModel,
    HeliumForCausalLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.HeliumForCausalLM,
    HeliumModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.HeliumModel,
    HeliumPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.HeliumPreTrainedModel,
    HerbertTokenizer: () => _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.HerbertTokenizer,
    HieraForImageClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.HieraForImageClassification,
    HieraModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.HieraModel,
    HieraPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.HieraPreTrainedModel,
    HubertForCTC: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.HubertForCTC,
    HubertForSequenceClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.HubertForSequenceClassification,
    HubertModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.HubertModel,
    HubertPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.HubertPreTrainedModel,
    IJepaForImageClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.IJepaForImageClassification,
    IJepaModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.IJepaModel,
    IJepaPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.IJepaPreTrainedModel,
    Idefics3ForConditionalGeneration: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Idefics3ForConditionalGeneration,
    Idefics3ImageProcessor: () => _models_image_processors_js__WEBPACK_IMPORTED_MODULE_14__.Idefics3ImageProcessor,
    Idefics3PreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Idefics3PreTrainedModel,
    Idefics3Processor: () => _models_processors_js__WEBPACK_IMPORTED_MODULE_17__.Idefics3Processor,
    ImageClassificationPipeline: () => _pipelines_js__WEBPACK_IMPORTED_MODULE_1__.ImageClassificationPipeline,
    ImageFeatureExtractionPipeline: () => _pipelines_js__WEBPACK_IMPORTED_MODULE_1__.ImageFeatureExtractionPipeline,
    ImageFeatureExtractor: () => _models_feature_extractors_js__WEBPACK_IMPORTED_MODULE_11__.ImageFeatureExtractor,
    ImageMattingOutput: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.ImageMattingOutput,
    ImageProcessor: () => _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_13__.ImageProcessor,
    ImageSegmentationPipeline: () => _pipelines_js__WEBPACK_IMPORTED_MODULE_1__.ImageSegmentationPipeline,
    ImageToImagePipeline: () => _pipelines_js__WEBPACK_IMPORTED_MODULE_1__.ImageToImagePipeline,
    ImageToTextPipeline: () => _pipelines_js__WEBPACK_IMPORTED_MODULE_1__.ImageToTextPipeline,
    InterruptableStoppingCriteria: () => _generation_stopping_criteria_js__WEBPACK_IMPORTED_MODULE_20__.InterruptableStoppingCriteria,
    JAISLMHeadModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.JAISLMHeadModel,
    JAISModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.JAISModel,
    JAISPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.JAISPreTrainedModel,
    JinaCLIPImageProcessor: () => _models_image_processors_js__WEBPACK_IMPORTED_MODULE_14__.JinaCLIPImageProcessor,
    JinaCLIPModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.JinaCLIPModel,
    JinaCLIPPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.JinaCLIPPreTrainedModel,
    JinaCLIPProcessor: () => _models_processors_js__WEBPACK_IMPORTED_MODULE_17__.JinaCLIPProcessor,
    JinaCLIPTextModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.JinaCLIPTextModel,
    JinaCLIPVisionModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.JinaCLIPVisionModel,
    Lfm2ForCausalLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Lfm2ForCausalLM,
    Lfm2Model: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Lfm2Model,
    Lfm2PreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Lfm2PreTrainedModel,
    LiteWhisperForConditionalGeneration: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.LiteWhisperForConditionalGeneration,
    Llama4ForCausalLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Llama4ForCausalLM,
    Llama4PreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Llama4PreTrainedModel,
    LlamaForCausalLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.LlamaForCausalLM,
    LlamaModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.LlamaModel,
    LlamaPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.LlamaPreTrainedModel,
    LlamaTokenizer: () => _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.LlamaTokenizer,
    LlavaForConditionalGeneration: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.LlavaForConditionalGeneration,
    LlavaOnevisionForConditionalGeneration: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.LlavaOnevisionForConditionalGeneration,
    LlavaOnevisionImageProcessor: () => _models_image_processors_js__WEBPACK_IMPORTED_MODULE_14__.LlavaOnevisionImageProcessor,
    LlavaPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.LlavaPreTrainedModel,
    LlavaProcessor: () => _models_processors_js__WEBPACK_IMPORTED_MODULE_17__.LlavaProcessor,
    LlavaQwen2ForCausalLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.LlavaQwen2ForCausalLM,
    LogitsProcessor: () => _generation_logits_process_js__WEBPACK_IMPORTED_MODULE_21__.LogitsProcessor,
    LogitsProcessorList: () => _generation_logits_process_js__WEBPACK_IMPORTED_MODULE_21__.LogitsProcessorList,
    LogitsWarper: () => _generation_logits_process_js__WEBPACK_IMPORTED_MODULE_21__.LogitsWarper,
    LongT5ForConditionalGeneration: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.LongT5ForConditionalGeneration,
    LongT5Model: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.LongT5Model,
    LongT5PreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.LongT5PreTrainedModel,
    M2M100ForConditionalGeneration: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.M2M100ForConditionalGeneration,
    M2M100Model: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.M2M100Model,
    M2M100PreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.M2M100PreTrainedModel,
    M2M100Tokenizer: () => _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.M2M100Tokenizer,
    MBart50Tokenizer: () => _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.MBart50Tokenizer,
    MBartForCausalLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MBartForCausalLM,
    MBartForConditionalGeneration: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MBartForConditionalGeneration,
    MBartForSequenceClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MBartForSequenceClassification,
    MBartModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MBartModel,
    MBartPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MBartPreTrainedModel,
    MBartTokenizer: () => _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.MBartTokenizer,
    MPNetForMaskedLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MPNetForMaskedLM,
    MPNetForQuestionAnswering: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MPNetForQuestionAnswering,
    MPNetForSequenceClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MPNetForSequenceClassification,
    MPNetForTokenClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MPNetForTokenClassification,
    MPNetModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MPNetModel,
    MPNetPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MPNetPreTrainedModel,
    MPNetTokenizer: () => _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.MPNetTokenizer,
    MT5ForConditionalGeneration: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MT5ForConditionalGeneration,
    MT5Model: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MT5Model,
    MT5PreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MT5PreTrainedModel,
    MarianMTModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MarianMTModel,
    MarianModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MarianModel,
    MarianPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MarianPreTrainedModel,
    MarianTokenizer: () => _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.MarianTokenizer,
    Mask2FormerImageProcessor: () => _models_image_processors_js__WEBPACK_IMPORTED_MODULE_14__.Mask2FormerImageProcessor,
    MaskFormerFeatureExtractor: () => _models_image_processors_js__WEBPACK_IMPORTED_MODULE_14__.MaskFormerFeatureExtractor,
    MaskFormerForInstanceSegmentation: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MaskFormerForInstanceSegmentation,
    MaskFormerImageProcessor: () => _models_image_processors_js__WEBPACK_IMPORTED_MODULE_14__.MaskFormerImageProcessor,
    MaskFormerModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MaskFormerModel,
    MaskFormerPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MaskFormerPreTrainedModel,
    MaskedLMOutput: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MaskedLMOutput,
    MaxLengthCriteria: () => _generation_stopping_criteria_js__WEBPACK_IMPORTED_MODULE_20__.MaxLengthCriteria,
    Metric3DForDepthEstimation: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Metric3DForDepthEstimation,
    Metric3DPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Metric3DPreTrainedModel,
    Metric3Dv2ForDepthEstimation: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Metric3Dv2ForDepthEstimation,
    Metric3Dv2PreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Metric3Dv2PreTrainedModel,
    MgpstrForSceneTextRecognition: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MgpstrForSceneTextRecognition,
    MgpstrModelOutput: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MgpstrModelOutput,
    MgpstrPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MgpstrPreTrainedModel,
    MgpstrProcessor: () => _models_processors_js__WEBPACK_IMPORTED_MODULE_17__.MgpstrProcessor,
    MgpstrTokenizer: () => _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.MgpstrTokenizer,
    MimiDecoderModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MimiDecoderModel,
    MimiDecoderOutput: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MimiDecoderOutput,
    MimiEncoderModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MimiEncoderModel,
    MimiEncoderOutput: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MimiEncoderOutput,
    MimiModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MimiModel,
    MimiPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MimiPreTrainedModel,
    MinLengthLogitsProcessor: () => _generation_logits_process_js__WEBPACK_IMPORTED_MODULE_21__.MinLengthLogitsProcessor,
    MinNewTokensLengthLogitsProcessor: () => _generation_logits_process_js__WEBPACK_IMPORTED_MODULE_21__.MinNewTokensLengthLogitsProcessor,
    Ministral3ForCausalLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Ministral3ForCausalLM,
    Ministral3Model: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Ministral3Model,
    Ministral3PreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Ministral3PreTrainedModel,
    MinistralForCausalLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MinistralForCausalLM,
    MinistralModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MinistralModel,
    MinistralPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MinistralPreTrainedModel,
    Mistral3ForConditionalGeneration: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Mistral3ForConditionalGeneration,
    MistralForCausalLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MistralForCausalLM,
    MistralModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MistralModel,
    MistralPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MistralPreTrainedModel,
    MobileBertForMaskedLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileBertForMaskedLM,
    MobileBertForQuestionAnswering: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileBertForQuestionAnswering,
    MobileBertForSequenceClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileBertForSequenceClassification,
    MobileBertModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileBertModel,
    MobileBertPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileBertPreTrainedModel,
    MobileBertTokenizer: () => _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.MobileBertTokenizer,
    MobileLLMForCausalLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileLLMForCausalLM,
    MobileLLMModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileLLMModel,
    MobileLLMPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileLLMPreTrainedModel,
    MobileNetV1FeatureExtractor: () => _models_image_processors_js__WEBPACK_IMPORTED_MODULE_14__.MobileNetV1FeatureExtractor,
    MobileNetV1ForImageClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileNetV1ForImageClassification,
    MobileNetV1ForSemanticSegmentation: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileNetV1ForSemanticSegmentation,
    MobileNetV1ImageProcessor: () => _models_image_processors_js__WEBPACK_IMPORTED_MODULE_14__.MobileNetV1ImageProcessor,
    MobileNetV1Model: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileNetV1Model,
    MobileNetV1PreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileNetV1PreTrainedModel,
    MobileNetV2FeatureExtractor: () => _models_image_processors_js__WEBPACK_IMPORTED_MODULE_14__.MobileNetV2FeatureExtractor,
    MobileNetV2ForImageClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileNetV2ForImageClassification,
    MobileNetV2ForSemanticSegmentation: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileNetV2ForSemanticSegmentation,
    MobileNetV2ImageProcessor: () => _models_image_processors_js__WEBPACK_IMPORTED_MODULE_14__.MobileNetV2ImageProcessor,
    MobileNetV2Model: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileNetV2Model,
    MobileNetV2PreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileNetV2PreTrainedModel,
    MobileNetV3FeatureExtractor: () => _models_image_processors_js__WEBPACK_IMPORTED_MODULE_14__.MobileNetV3FeatureExtractor,
    MobileNetV3ForImageClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileNetV3ForImageClassification,
    MobileNetV3ForSemanticSegmentation: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileNetV3ForSemanticSegmentation,
    MobileNetV3ImageProcessor: () => _models_image_processors_js__WEBPACK_IMPORTED_MODULE_14__.MobileNetV3ImageProcessor,
    MobileNetV3Model: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileNetV3Model,
    MobileNetV3PreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileNetV3PreTrainedModel,
    MobileNetV4FeatureExtractor: () => _models_image_processors_js__WEBPACK_IMPORTED_MODULE_14__.MobileNetV4FeatureExtractor,
    MobileNetV4ForImageClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileNetV4ForImageClassification,
    MobileNetV4ForSemanticSegmentation: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileNetV4ForSemanticSegmentation,
    MobileNetV4ImageProcessor: () => _models_image_processors_js__WEBPACK_IMPORTED_MODULE_14__.MobileNetV4ImageProcessor,
    MobileNetV4Model: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileNetV4Model,
    MobileNetV4PreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileNetV4PreTrainedModel,
    MobileViTFeatureExtractor: () => _models_image_processors_js__WEBPACK_IMPORTED_MODULE_14__.MobileViTFeatureExtractor,
    MobileViTForImageClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileViTForImageClassification,
    MobileViTImageProcessor: () => _models_image_processors_js__WEBPACK_IMPORTED_MODULE_14__.MobileViTImageProcessor,
    MobileViTModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileViTModel,
    MobileViTPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileViTPreTrainedModel,
    MobileViTV2ForImageClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileViTV2ForImageClassification,
    MobileViTV2Model: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileViTV2Model,
    MobileViTV2PreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileViTV2PreTrainedModel,
    ModelOutput: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.ModelOutput,
    ModernBertDecoderForCausalLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.ModernBertDecoderForCausalLM,
    ModernBertDecoderModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.ModernBertDecoderModel,
    ModernBertDecoderPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.ModernBertDecoderPreTrainedModel,
    ModernBertForMaskedLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.ModernBertForMaskedLM,
    ModernBertForSequenceClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.ModernBertForSequenceClassification,
    ModernBertForTokenClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.ModernBertForTokenClassification,
    ModernBertModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.ModernBertModel,
    ModernBertPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.ModernBertPreTrainedModel,
    Moondream1ForConditionalGeneration: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Moondream1ForConditionalGeneration,
    MoonshineFeatureExtractor: () => _models_feature_extractors_js__WEBPACK_IMPORTED_MODULE_11__.MoonshineFeatureExtractor,
    MoonshineForConditionalGeneration: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MoonshineForConditionalGeneration,
    MoonshineModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MoonshineModel,
    MoonshinePreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MoonshinePreTrainedModel,
    MoonshineProcessor: () => _models_processors_js__WEBPACK_IMPORTED_MODULE_17__.MoonshineProcessor,
    MptForCausalLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MptForCausalLM,
    MptModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MptModel,
    MptPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MptPreTrainedModel,
    MultiModalityCausalLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MultiModalityCausalLM,
    MultiModalityPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MultiModalityPreTrainedModel,
    MusicgenForCausalLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MusicgenForCausalLM,
    MusicgenForConditionalGeneration: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MusicgenForConditionalGeneration,
    MusicgenModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MusicgenModel,
    MusicgenPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.MusicgenPreTrainedModel,
    NanoChatForCausalLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.NanoChatForCausalLM,
    NanoChatModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.NanoChatModel,
    NanoChatPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.NanoChatPreTrainedModel,
    NeoBertForMaskedLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.NeoBertForMaskedLM,
    NeoBertForQuestionAnswering: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.NeoBertForQuestionAnswering,
    NeoBertForSequenceClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.NeoBertForSequenceClassification,
    NeoBertForTokenClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.NeoBertForTokenClassification,
    NeoBertModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.NeoBertModel,
    NeoBertPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.NeoBertPreTrainedModel,
    NllbTokenizer: () => _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.NllbTokenizer,
    NoBadWordsLogitsProcessor: () => _generation_logits_process_js__WEBPACK_IMPORTED_MODULE_21__.NoBadWordsLogitsProcessor,
    NoRepeatNGramLogitsProcessor: () => _generation_logits_process_js__WEBPACK_IMPORTED_MODULE_21__.NoRepeatNGramLogitsProcessor,
    NomicBertModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.NomicBertModel,
    NomicBertPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.NomicBertPreTrainedModel,
    NougatImageProcessor: () => _models_image_processors_js__WEBPACK_IMPORTED_MODULE_14__.NougatImageProcessor,
    NougatTokenizer: () => _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.NougatTokenizer,
    OPTForCausalLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.OPTForCausalLM,
    OPTModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.OPTModel,
    OPTPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.OPTPreTrainedModel,
    ObjectDetectionPipeline: () => _pipelines_js__WEBPACK_IMPORTED_MODULE_1__.ObjectDetectionPipeline,
    Olmo2ForCausalLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Olmo2ForCausalLM,
    Olmo2Model: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Olmo2Model,
    Olmo2PreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Olmo2PreTrainedModel,
    OlmoForCausalLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.OlmoForCausalLM,
    OlmoModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.OlmoModel,
    OlmoPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.OlmoPreTrainedModel,
    OpenELMForCausalLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.OpenELMForCausalLM,
    OpenELMModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.OpenELMModel,
    OpenELMPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.OpenELMPreTrainedModel,
    OwlViTFeatureExtractor: () => _models_image_processors_js__WEBPACK_IMPORTED_MODULE_14__.OwlViTFeatureExtractor,
    OwlViTForObjectDetection: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.OwlViTForObjectDetection,
    OwlViTImageProcessor: () => _models_image_processors_js__WEBPACK_IMPORTED_MODULE_14__.OwlViTImageProcessor,
    OwlViTModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.OwlViTModel,
    OwlViTPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.OwlViTPreTrainedModel,
    OwlViTProcessor: () => _models_processors_js__WEBPACK_IMPORTED_MODULE_17__.OwlViTProcessor,
    Owlv2ForObjectDetection: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Owlv2ForObjectDetection,
    Owlv2ImageProcessor: () => _models_image_processors_js__WEBPACK_IMPORTED_MODULE_14__.Owlv2ImageProcessor,
    Owlv2Model: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Owlv2Model,
    Owlv2PreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Owlv2PreTrainedModel,
    PaliGemmaForConditionalGeneration: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.PaliGemmaForConditionalGeneration,
    PaliGemmaPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.PaliGemmaPreTrainedModel,
    PaliGemmaProcessor: () => _models_processors_js__WEBPACK_IMPORTED_MODULE_17__.PaliGemmaProcessor,
    ParakeetFeatureExtractor: () => _models_feature_extractors_js__WEBPACK_IMPORTED_MODULE_11__.ParakeetFeatureExtractor,
    ParakeetForCTC: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.ParakeetForCTC,
    ParakeetPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.ParakeetPreTrainedModel,
    PatchTSMixerForPrediction: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.PatchTSMixerForPrediction,
    PatchTSMixerModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.PatchTSMixerModel,
    PatchTSMixerPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.PatchTSMixerPreTrainedModel,
    PatchTSTForPrediction: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.PatchTSTForPrediction,
    PatchTSTModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.PatchTSTModel,
    PatchTSTPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.PatchTSTPreTrainedModel,
    Phi3ForCausalLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Phi3ForCausalLM,
    Phi3Model: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Phi3Model,
    Phi3PreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Phi3PreTrainedModel,
    Phi3VForCausalLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Phi3VForCausalLM,
    Phi3VImageProcessor: () => _models_image_processors_js__WEBPACK_IMPORTED_MODULE_14__.Phi3VImageProcessor,
    Phi3VPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Phi3VPreTrainedModel,
    Phi3VProcessor: () => _models_processors_js__WEBPACK_IMPORTED_MODULE_17__.Phi3VProcessor,
    PhiForCausalLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.PhiForCausalLM,
    PhiModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.PhiModel,
    PhiPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.PhiPreTrainedModel,
    Pipeline: () => _pipelines_js__WEBPACK_IMPORTED_MODULE_1__.Pipeline,
    PixtralImageProcessor: () => _models_image_processors_js__WEBPACK_IMPORTED_MODULE_14__.PixtralImageProcessor,
    PixtralProcessor: () => _models_processors_js__WEBPACK_IMPORTED_MODULE_17__.PixtralProcessor,
    PreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.PreTrainedModel,
    PreTrainedTokenizer: () => _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.PreTrainedTokenizer,
    PretrainedConfig: () => _configs_js__WEBPACK_IMPORTED_MODULE_4__.PretrainedConfig,
    PretrainedMixin: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.PretrainedMixin,
    Processor: () => _base_processing_utils_js__WEBPACK_IMPORTED_MODULE_16__.Processor,
    PvtForImageClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.PvtForImageClassification,
    PvtImageProcessor: () => _models_image_processors_js__WEBPACK_IMPORTED_MODULE_14__.PvtImageProcessor,
    PvtModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.PvtModel,
    PvtPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.PvtPreTrainedModel,
    PyAnnoteFeatureExtractor: () => _models_feature_extractors_js__WEBPACK_IMPORTED_MODULE_11__.PyAnnoteFeatureExtractor,
    PyAnnoteForAudioFrameClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.PyAnnoteForAudioFrameClassification,
    PyAnnoteModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.PyAnnoteModel,
    PyAnnotePreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.PyAnnotePreTrainedModel,
    PyAnnoteProcessor: () => _models_processors_js__WEBPACK_IMPORTED_MODULE_17__.PyAnnoteProcessor,
    QuestionAnsweringModelOutput: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.QuestionAnsweringModelOutput,
    QuestionAnsweringPipeline: () => _pipelines_js__WEBPACK_IMPORTED_MODULE_1__.QuestionAnsweringPipeline,
    Qwen2ForCausalLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Qwen2ForCausalLM,
    Qwen2Model: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Qwen2Model,
    Qwen2PreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Qwen2PreTrainedModel,
    Qwen2Tokenizer: () => _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.Qwen2Tokenizer,
    Qwen2VLForConditionalGeneration: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Qwen2VLForConditionalGeneration,
    Qwen2VLImageProcessor: () => _models_image_processors_js__WEBPACK_IMPORTED_MODULE_14__.Qwen2VLImageProcessor,
    Qwen2VLPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Qwen2VLPreTrainedModel,
    Qwen2VLProcessor: () => _models_processors_js__WEBPACK_IMPORTED_MODULE_17__.Qwen2VLProcessor,
    Qwen3ForCausalLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Qwen3ForCausalLM,
    Qwen3Model: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Qwen3Model,
    Qwen3PreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Qwen3PreTrainedModel,
    RFDetrForObjectDetection: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.RFDetrForObjectDetection,
    RFDetrModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.RFDetrModel,
    RFDetrObjectDetectionOutput: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.RFDetrObjectDetectionOutput,
    RFDetrPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.RFDetrPreTrainedModel,
    RTDetrForObjectDetection: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.RTDetrForObjectDetection,
    RTDetrImageProcessor: () => _models_image_processors_js__WEBPACK_IMPORTED_MODULE_14__.RTDetrImageProcessor,
    RTDetrModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.RTDetrModel,
    RTDetrObjectDetectionOutput: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.RTDetrObjectDetectionOutput,
    RTDetrPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.RTDetrPreTrainedModel,
    RTDetrV2ForObjectDetection: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.RTDetrV2ForObjectDetection,
    RTDetrV2Model: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.RTDetrV2Model,
    RTDetrV2ObjectDetectionOutput: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.RTDetrV2ObjectDetectionOutput,
    RTDetrV2PreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.RTDetrV2PreTrainedModel,
    RawAudio: () => _utils_audio_js__WEBPACK_IMPORTED_MODULE_5__.RawAudio,
    RawImage: () => _utils_image_js__WEBPACK_IMPORTED_MODULE_6__.RawImage,
    RawVideo: () => _utils_video_js__WEBPACK_IMPORTED_MODULE_7__.RawVideo,
    RawVideoFrame: () => _utils_video_js__WEBPACK_IMPORTED_MODULE_7__.RawVideoFrame,
    RepetitionPenaltyLogitsProcessor: () => _generation_logits_process_js__WEBPACK_IMPORTED_MODULE_21__.RepetitionPenaltyLogitsProcessor,
    ResNetForImageClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.ResNetForImageClassification,
    ResNetModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.ResNetModel,
    ResNetPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.ResNetPreTrainedModel,
    RoFormerForMaskedLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.RoFormerForMaskedLM,
    RoFormerForQuestionAnswering: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.RoFormerForQuestionAnswering,
    RoFormerForSequenceClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.RoFormerForSequenceClassification,
    RoFormerForTokenClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.RoFormerForTokenClassification,
    RoFormerModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.RoFormerModel,
    RoFormerPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.RoFormerPreTrainedModel,
    RoFormerTokenizer: () => _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.RoFormerTokenizer,
    RobertaForMaskedLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.RobertaForMaskedLM,
    RobertaForQuestionAnswering: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.RobertaForQuestionAnswering,
    RobertaForSequenceClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.RobertaForSequenceClassification,
    RobertaForTokenClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.RobertaForTokenClassification,
    RobertaModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.RobertaModel,
    RobertaPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.RobertaPreTrainedModel,
    RobertaTokenizer: () => _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.RobertaTokenizer,
    Sam2ImageProcessor: () => _models_image_processors_js__WEBPACK_IMPORTED_MODULE_14__.Sam2ImageProcessor,
    Sam2ImageSegmentationOutput: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Sam2ImageSegmentationOutput,
    Sam2Model: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Sam2Model,
    Sam2PreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Sam2PreTrainedModel,
    Sam2Processor: () => _models_processors_js__WEBPACK_IMPORTED_MODULE_17__.Sam2Processor,
    Sam2VideoProcessor: () => _models_processors_js__WEBPACK_IMPORTED_MODULE_17__.Sam2VideoProcessor,
    Sam3ImageProcessor: () => _models_image_processors_js__WEBPACK_IMPORTED_MODULE_14__.Sam3ImageProcessor,
    Sam3TrackerModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Sam3TrackerModel,
    SamImageProcessor: () => _models_image_processors_js__WEBPACK_IMPORTED_MODULE_14__.SamImageProcessor,
    SamImageSegmentationOutput: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.SamImageSegmentationOutput,
    SamModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.SamModel,
    SamPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.SamPreTrainedModel,
    SamProcessor: () => _models_processors_js__WEBPACK_IMPORTED_MODULE_17__.SamProcessor,
    SapiensForDepthEstimation: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.SapiensForDepthEstimation,
    SapiensForNormalEstimation: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.SapiensForNormalEstimation,
    SapiensForSemanticSegmentation: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.SapiensForSemanticSegmentation,
    SapiensPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.SapiensPreTrainedModel,
    SeamlessM4TFeatureExtractor: () => _models_feature_extractors_js__WEBPACK_IMPORTED_MODULE_11__.SeamlessM4TFeatureExtractor,
    SegformerFeatureExtractor: () => _models_image_processors_js__WEBPACK_IMPORTED_MODULE_14__.SegformerFeatureExtractor,
    SegformerForImageClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.SegformerForImageClassification,
    SegformerForSemanticSegmentation: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.SegformerForSemanticSegmentation,
    SegformerImageProcessor: () => _models_image_processors_js__WEBPACK_IMPORTED_MODULE_14__.SegformerImageProcessor,
    SegformerModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.SegformerModel,
    SegformerPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.SegformerPreTrainedModel,
    Seq2SeqLMOutput: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Seq2SeqLMOutput,
    SequenceClassifierOutput: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.SequenceClassifierOutput,
    SiglipImageProcessor: () => _models_image_processors_js__WEBPACK_IMPORTED_MODULE_14__.SiglipImageProcessor,
    SiglipModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.SiglipModel,
    SiglipPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.SiglipPreTrainedModel,
    SiglipTextModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.SiglipTextModel,
    SiglipTokenizer: () => _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.SiglipTokenizer,
    SiglipVisionModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.SiglipVisionModel,
    SmolLM3ForCausalLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.SmolLM3ForCausalLM,
    SmolLM3Model: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.SmolLM3Model,
    SmolLM3PreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.SmolLM3PreTrainedModel,
    SmolVLMForConditionalGeneration: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.SmolVLMForConditionalGeneration,
    SmolVLMImageProcessor: () => _models_image_processors_js__WEBPACK_IMPORTED_MODULE_14__.SmolVLMImageProcessor,
    SmolVLMProcessor: () => _models_processors_js__WEBPACK_IMPORTED_MODULE_17__.SmolVLMProcessor,
    SnacDecoderModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.SnacDecoderModel,
    SnacEncoderModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.SnacEncoderModel,
    SnacFeatureExtractor: () => _models_feature_extractors_js__WEBPACK_IMPORTED_MODULE_11__.SnacFeatureExtractor,
    SnacModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.SnacModel,
    SnacPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.SnacPreTrainedModel,
    SpeechT5FeatureExtractor: () => _models_feature_extractors_js__WEBPACK_IMPORTED_MODULE_11__.SpeechT5FeatureExtractor,
    SpeechT5ForSpeechToText: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.SpeechT5ForSpeechToText,
    SpeechT5ForTextToSpeech: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.SpeechT5ForTextToSpeech,
    SpeechT5HifiGan: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.SpeechT5HifiGan,
    SpeechT5Model: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.SpeechT5Model,
    SpeechT5PreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.SpeechT5PreTrainedModel,
    SpeechT5Processor: () => _models_processors_js__WEBPACK_IMPORTED_MODULE_17__.SpeechT5Processor,
    SpeechT5Tokenizer: () => _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.SpeechT5Tokenizer,
    SqueezeBertForMaskedLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.SqueezeBertForMaskedLM,
    SqueezeBertForQuestionAnswering: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.SqueezeBertForQuestionAnswering,
    SqueezeBertForSequenceClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.SqueezeBertForSequenceClassification,
    SqueezeBertModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.SqueezeBertModel,
    SqueezeBertPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.SqueezeBertPreTrainedModel,
    SqueezeBertTokenizer: () => _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.SqueezeBertTokenizer,
    StableLmForCausalLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.StableLmForCausalLM,
    StableLmModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.StableLmModel,
    StableLmPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.StableLmPreTrainedModel,
    Starcoder2ForCausalLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Starcoder2ForCausalLM,
    Starcoder2Model: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Starcoder2Model,
    Starcoder2PreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Starcoder2PreTrainedModel,
    StoppingCriteria: () => _generation_stopping_criteria_js__WEBPACK_IMPORTED_MODULE_20__.StoppingCriteria,
    StoppingCriteriaList: () => _generation_stopping_criteria_js__WEBPACK_IMPORTED_MODULE_20__.StoppingCriteriaList,
    StyleTextToSpeech2Model: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.StyleTextToSpeech2Model,
    StyleTextToSpeech2PreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.StyleTextToSpeech2PreTrainedModel,
    SummarizationPipeline: () => _pipelines_js__WEBPACK_IMPORTED_MODULE_1__.SummarizationPipeline,
    SupertonicForConditionalGeneration: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.SupertonicForConditionalGeneration,
    SupertonicPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.SupertonicPreTrainedModel,
    SuppressTokensAtBeginLogitsProcessor: () => _generation_logits_process_js__WEBPACK_IMPORTED_MODULE_21__.SuppressTokensAtBeginLogitsProcessor,
    Swin2SRForImageSuperResolution: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Swin2SRForImageSuperResolution,
    Swin2SRImageProcessor: () => _models_image_processors_js__WEBPACK_IMPORTED_MODULE_14__.Swin2SRImageProcessor,
    Swin2SRModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Swin2SRModel,
    Swin2SRPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Swin2SRPreTrainedModel,
    SwinForImageClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.SwinForImageClassification,
    SwinForSemanticSegmentation: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.SwinForSemanticSegmentation,
    SwinModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.SwinModel,
    SwinPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.SwinPreTrainedModel,
    T5ForConditionalGeneration: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.T5ForConditionalGeneration,
    T5Model: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.T5Model,
    T5PreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.T5PreTrainedModel,
    T5Tokenizer: () => _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.T5Tokenizer,
    TableTransformerForObjectDetection: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.TableTransformerForObjectDetection,
    TableTransformerModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.TableTransformerModel,
    TableTransformerObjectDetectionOutput: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.TableTransformerObjectDetectionOutput,
    TableTransformerPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.TableTransformerPreTrainedModel,
    TemperatureLogitsWarper: () => _generation_logits_process_js__WEBPACK_IMPORTED_MODULE_21__.TemperatureLogitsWarper,
    Tensor: () => _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.Tensor,
    Text2TextGenerationPipeline: () => _pipelines_js__WEBPACK_IMPORTED_MODULE_1__.Text2TextGenerationPipeline,
    TextClassificationPipeline: () => _pipelines_js__WEBPACK_IMPORTED_MODULE_1__.TextClassificationPipeline,
    TextGenerationPipeline: () => _pipelines_js__WEBPACK_IMPORTED_MODULE_1__.TextGenerationPipeline,
    TextStreamer: () => _generation_streamers_js__WEBPACK_IMPORTED_MODULE_19__.TextStreamer,
    TextToAudioPipeline: () => _pipelines_js__WEBPACK_IMPORTED_MODULE_1__.TextToAudioPipeline,
    TokenClassificationPipeline: () => _pipelines_js__WEBPACK_IMPORTED_MODULE_1__.TokenClassificationPipeline,
    TokenClassifierOutput: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.TokenClassifierOutput,
    TokenizerModel: () => _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.TokenizerModel,
    TopKLogitsWarper: () => _generation_logits_process_js__WEBPACK_IMPORTED_MODULE_21__.TopKLogitsWarper,
    TopPLogitsWarper: () => _generation_logits_process_js__WEBPACK_IMPORTED_MODULE_21__.TopPLogitsWarper,
    TrOCRForCausalLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.TrOCRForCausalLM,
    TrOCRPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.TrOCRPreTrainedModel,
    TranslationPipeline: () => _pipelines_js__WEBPACK_IMPORTED_MODULE_1__.TranslationPipeline,
    UltravoxModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.UltravoxModel,
    UltravoxPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.UltravoxPreTrainedModel,
    UltravoxProcessor: () => _models_processors_js__WEBPACK_IMPORTED_MODULE_17__.UltravoxProcessor,
    UniSpeechForCTC: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.UniSpeechForCTC,
    UniSpeechForSequenceClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.UniSpeechForSequenceClassification,
    UniSpeechModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.UniSpeechModel,
    UniSpeechPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.UniSpeechPreTrainedModel,
    UniSpeechSatForAudioFrameClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.UniSpeechSatForAudioFrameClassification,
    UniSpeechSatForCTC: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.UniSpeechSatForCTC,
    UniSpeechSatForSequenceClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.UniSpeechSatForSequenceClassification,
    UniSpeechSatModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.UniSpeechSatModel,
    UniSpeechSatPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.UniSpeechSatPreTrainedModel,
    VLChatProcessor: () => _models_processors_js__WEBPACK_IMPORTED_MODULE_17__.VLChatProcessor,
    VLMImageProcessor: () => _models_image_processors_js__WEBPACK_IMPORTED_MODULE_14__.VLMImageProcessor,
    VaultGemmaForCausalLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.VaultGemmaForCausalLM,
    VaultGemmaModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.VaultGemmaModel,
    VaultGemmaPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.VaultGemmaPreTrainedModel,
    ViTFeatureExtractor: () => _models_image_processors_js__WEBPACK_IMPORTED_MODULE_14__.ViTFeatureExtractor,
    ViTForImageClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.ViTForImageClassification,
    ViTImageProcessor: () => _models_image_processors_js__WEBPACK_IMPORTED_MODULE_14__.ViTImageProcessor,
    ViTMAEModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.ViTMAEModel,
    ViTMAEPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.ViTMAEPreTrainedModel,
    ViTMSNForImageClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.ViTMSNForImageClassification,
    ViTMSNModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.ViTMSNModel,
    ViTMSNPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.ViTMSNPreTrainedModel,
    ViTModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.ViTModel,
    ViTPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.ViTPreTrainedModel,
    VisionEncoderDecoderModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.VisionEncoderDecoderModel,
    VitMatteForImageMatting: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.VitMatteForImageMatting,
    VitMatteImageProcessor: () => _models_image_processors_js__WEBPACK_IMPORTED_MODULE_14__.VitMatteImageProcessor,
    VitMattePreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.VitMattePreTrainedModel,
    VitPoseForPoseEstimation: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.VitPoseForPoseEstimation,
    VitPoseImageProcessor: () => _models_image_processors_js__WEBPACK_IMPORTED_MODULE_14__.VitPoseImageProcessor,
    VitPosePreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.VitPosePreTrainedModel,
    VitsModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.VitsModel,
    VitsModelOutput: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.VitsModelOutput,
    VitsPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.VitsPreTrainedModel,
    VitsTokenizer: () => _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.VitsTokenizer,
    VoxtralForConditionalGeneration: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.VoxtralForConditionalGeneration,
    VoxtralProcessor: () => _models_processors_js__WEBPACK_IMPORTED_MODULE_17__.VoxtralProcessor,
    Wav2Vec2BertForCTC: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Wav2Vec2BertForCTC,
    Wav2Vec2BertForSequenceClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Wav2Vec2BertForSequenceClassification,
    Wav2Vec2BertModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Wav2Vec2BertModel,
    Wav2Vec2BertPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Wav2Vec2BertPreTrainedModel,
    Wav2Vec2CTCTokenizer: () => _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.Wav2Vec2CTCTokenizer,
    Wav2Vec2FeatureExtractor: () => _models_feature_extractors_js__WEBPACK_IMPORTED_MODULE_11__.Wav2Vec2FeatureExtractor,
    Wav2Vec2ForAudioFrameClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Wav2Vec2ForAudioFrameClassification,
    Wav2Vec2ForCTC: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Wav2Vec2ForCTC,
    Wav2Vec2ForSequenceClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Wav2Vec2ForSequenceClassification,
    Wav2Vec2Model: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Wav2Vec2Model,
    Wav2Vec2PreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.Wav2Vec2PreTrainedModel,
    Wav2Vec2Processor: () => _models_processors_js__WEBPACK_IMPORTED_MODULE_17__.Wav2Vec2Processor,
    Wav2Vec2ProcessorWithLM: () => _models_processors_js__WEBPACK_IMPORTED_MODULE_17__.Wav2Vec2ProcessorWithLM,
    WavLMForAudioFrameClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.WavLMForAudioFrameClassification,
    WavLMForCTC: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.WavLMForCTC,
    WavLMForSequenceClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.WavLMForSequenceClassification,
    WavLMForXVector: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.WavLMForXVector,
    WavLMModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.WavLMModel,
    WavLMPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.WavLMPreTrainedModel,
    WeSpeakerFeatureExtractor: () => _models_feature_extractors_js__WEBPACK_IMPORTED_MODULE_11__.WeSpeakerFeatureExtractor,
    WeSpeakerResNetModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.WeSpeakerResNetModel,
    WeSpeakerResNetPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.WeSpeakerResNetPreTrainedModel,
    WhisperFeatureExtractor: () => _models_feature_extractors_js__WEBPACK_IMPORTED_MODULE_11__.WhisperFeatureExtractor,
    WhisperForConditionalGeneration: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.WhisperForConditionalGeneration,
    WhisperModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.WhisperModel,
    WhisperPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.WhisperPreTrainedModel,
    WhisperProcessor: () => _models_processors_js__WEBPACK_IMPORTED_MODULE_17__.WhisperProcessor,
    WhisperTextStreamer: () => _generation_streamers_js__WEBPACK_IMPORTED_MODULE_19__.WhisperTextStreamer,
    WhisperTimeStampLogitsProcessor: () => _generation_logits_process_js__WEBPACK_IMPORTED_MODULE_21__.WhisperTimeStampLogitsProcessor,
    WhisperTokenizer: () => _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.WhisperTokenizer,
    XLMForQuestionAnswering: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.XLMForQuestionAnswering,
    XLMForSequenceClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.XLMForSequenceClassification,
    XLMForTokenClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.XLMForTokenClassification,
    XLMModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.XLMModel,
    XLMPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.XLMPreTrainedModel,
    XLMRobertaForMaskedLM: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.XLMRobertaForMaskedLM,
    XLMRobertaForQuestionAnswering: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.XLMRobertaForQuestionAnswering,
    XLMRobertaForSequenceClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.XLMRobertaForSequenceClassification,
    XLMRobertaForTokenClassification: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.XLMRobertaForTokenClassification,
    XLMRobertaModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.XLMRobertaModel,
    XLMRobertaPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.XLMRobertaPreTrainedModel,
    XLMRobertaTokenizer: () => _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.XLMRobertaTokenizer,
    XLMTokenizer: () => _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.XLMTokenizer,
    XLMWithLMHeadModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.XLMWithLMHeadModel,
    XVectorOutput: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.XVectorOutput,
    YolosFeatureExtractor: () => _models_image_processors_js__WEBPACK_IMPORTED_MODULE_14__.YolosFeatureExtractor,
    YolosForObjectDetection: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.YolosForObjectDetection,
    YolosImageProcessor: () => _models_image_processors_js__WEBPACK_IMPORTED_MODULE_14__.YolosImageProcessor,
    YolosModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.YolosModel,
    YolosObjectDetectionOutput: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.YolosObjectDetectionOutput,
    YolosPreTrainedModel: () => _models_js__WEBPACK_IMPORTED_MODULE_2__.YolosPreTrainedModel,
    ZeroShotAudioClassificationPipeline: () => _pipelines_js__WEBPACK_IMPORTED_MODULE_1__.ZeroShotAudioClassificationPipeline,
    ZeroShotClassificationPipeline: () => _pipelines_js__WEBPACK_IMPORTED_MODULE_1__.ZeroShotClassificationPipeline,
    ZeroShotImageClassificationPipeline: () => _pipelines_js__WEBPACK_IMPORTED_MODULE_1__.ZeroShotImageClassificationPipeline,
    ZeroShotObjectDetectionPipeline: () => _pipelines_js__WEBPACK_IMPORTED_MODULE_1__.ZeroShotObjectDetectionPipeline,
    bankers_round: () => _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.bankers_round,
    cat: () => _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.cat,
    cos_sim: () => _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.cos_sim,
    dot: () => _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.dot,
    dynamic_time_warping: () => _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.dynamic_time_warping,
    env: () => _env_js__WEBPACK_IMPORTED_MODULE_0__.env,
    full: () => _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.full,
    full_like: () => _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.full_like,
    getCacheShapes: () => _configs_js__WEBPACK_IMPORTED_MODULE_4__.getCacheShapes,
    hamming: () => _utils_audio_js__WEBPACK_IMPORTED_MODULE_5__.hamming,
    hanning: () => _utils_audio_js__WEBPACK_IMPORTED_MODULE_5__.hanning,
    interpolate: () => _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.interpolate,
    interpolate_4d: () => _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.interpolate_4d,
    interpolate_data: () => _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.interpolate_data,
    is_chinese_char: () => _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.is_chinese_char,
    layer_norm: () => _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.layer_norm,
    load_image: () => _utils_image_js__WEBPACK_IMPORTED_MODULE_6__.load_image,
    load_video: () => _utils_video_js__WEBPACK_IMPORTED_MODULE_7__.load_video,
    log_softmax: () => _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.log_softmax,
    magnitude: () => _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.magnitude,
    matmul: () => _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.matmul,
    max: () => _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.max,
    mean: () => _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.mean,
    mean_pooling: () => _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.mean_pooling,
    medianFilter: () => _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.medianFilter,
    mel_filter_bank: () => _utils_audio_js__WEBPACK_IMPORTED_MODULE_5__.mel_filter_bank,
    min: () => _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.min,
    ones: () => _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.ones,
    ones_like: () => _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.ones_like,
    permute: () => _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.permute,
    permute_data: () => _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.permute_data,
    pipeline: () => _pipelines_js__WEBPACK_IMPORTED_MODULE_1__.pipeline,
    quantize_embeddings: () => _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.quantize_embeddings,
    rand: () => _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.rand,
    randn: () => _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.randn,
    read_audio: () => _utils_audio_js__WEBPACK_IMPORTED_MODULE_5__.read_audio,
    rfft: () => _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.rfft,
    round: () => _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.round,
    slice: () => _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.slice,
    softmax: () => _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.softmax,
    spectrogram: () => _utils_audio_js__WEBPACK_IMPORTED_MODULE_5__.spectrogram,
    stack: () => _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.stack,
    std_mean: () => _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.std_mean,
    topk: () => _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.topk,
    window_function: () => _utils_audio_js__WEBPACK_IMPORTED_MODULE_5__.window_function,
    zeros: () => _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.zeros,
    zeros_like: () => _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.zeros_like
  });
  var _env_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/env.js");
  /*! ./env.js */
  var _pipelines_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/pipelines.js");
  /*! ./pipelines.js */
  var _models_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/models.js");
  /*! ./models.js */
  var _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/tokenizers.js");
  /*! ./tokenizers.js */
  var _configs_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./src/configs.js");
  /*! ./configs.js */
  var _utils_audio_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./src/utils/audio.js");
  /*! ./utils/audio.js */
  var _utils_image_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./src/utils/image.js");
  /*! ./utils/image.js */
  var _utils_video_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./src/utils/video.js");
  /*! ./utils/video.js */
  var _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./src/utils/tensor.js");
  /*! ./utils/tensor.js */
  var _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./src/utils/maths.js");
  /*! ./utils/maths.js */
  var _base_feature_extraction_utils_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./src/base/feature_extraction_utils.js");
  /*! ./base/feature_extraction_utils.js */
  var _models_feature_extractors_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./src/models/feature_extractors.js");
  /*! ./models/feature_extractors.js */
  var _models_auto_feature_extraction_auto_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./src/models/auto/feature_extraction_auto.js");
  /*! ./models/auto/feature_extraction_auto.js */
  var _base_image_processors_utils_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./src/base/image_processors_utils.js");
  /*! ./base/image_processors_utils.js */
  var _models_image_processors_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("./src/models/image_processors.js");
  /*! ./models/image_processors.js */
  var _models_auto_image_processing_auto_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__("./src/models/auto/image_processing_auto.js");
  /*! ./models/auto/image_processing_auto.js */
  var _base_processing_utils_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__("./src/base/processing_utils.js");
  /*! ./base/processing_utils.js */
  var _models_processors_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__("./src/models/processors.js");
  /*! ./models/processors.js */
  var _models_auto_processing_auto_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__("./src/models/auto/processing_auto.js");
  /*! ./models/auto/processing_auto.js */
  var _generation_streamers_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__("./src/generation/streamers.js");
  /*! ./generation/streamers.js */
  var _generation_stopping_criteria_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__("./src/generation/stopping_criteria.js");
  /*! ./generation/stopping_criteria.js */
  var _generation_logits_process_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__("./src/generation/logits_process.js");
  /*! ./generation/logits_process.js */
})();
var __webpack_exports__ASTFeatureExtractor = __webpack_exports__.ASTFeatureExtractor;
var __webpack_exports__ASTForAudioClassification = __webpack_exports__.ASTForAudioClassification;
var __webpack_exports__ASTModel = __webpack_exports__.ASTModel;
var __webpack_exports__ASTPreTrainedModel = __webpack_exports__.ASTPreTrainedModel;
var __webpack_exports__AlbertForMaskedLM = __webpack_exports__.AlbertForMaskedLM;
var __webpack_exports__AlbertForQuestionAnswering = __webpack_exports__.AlbertForQuestionAnswering;
var __webpack_exports__AlbertForSequenceClassification = __webpack_exports__.AlbertForSequenceClassification;
var __webpack_exports__AlbertModel = __webpack_exports__.AlbertModel;
var __webpack_exports__AlbertPreTrainedModel = __webpack_exports__.AlbertPreTrainedModel;
var __webpack_exports__AlbertTokenizer = __webpack_exports__.AlbertTokenizer;
var __webpack_exports__ArceeForCausalLM = __webpack_exports__.ArceeForCausalLM;
var __webpack_exports__ArceeModel = __webpack_exports__.ArceeModel;
var __webpack_exports__ArceePreTrainedModel = __webpack_exports__.ArceePreTrainedModel;
var __webpack_exports__AudioClassificationPipeline = __webpack_exports__.AudioClassificationPipeline;
var __webpack_exports__AutoConfig = __webpack_exports__.AutoConfig;
var __webpack_exports__AutoFeatureExtractor = __webpack_exports__.AutoFeatureExtractor;
var __webpack_exports__AutoImageProcessor = __webpack_exports__.AutoImageProcessor;
var __webpack_exports__AutoModel = __webpack_exports__.AutoModel;
var __webpack_exports__AutoModelForAudioClassification = __webpack_exports__.AutoModelForAudioClassification;
var __webpack_exports__AutoModelForAudioFrameClassification = __webpack_exports__.AutoModelForAudioFrameClassification;
var __webpack_exports__AutoModelForAudioTextToText = __webpack_exports__.AutoModelForAudioTextToText;
var __webpack_exports__AutoModelForCTC = __webpack_exports__.AutoModelForCTC;
var __webpack_exports__AutoModelForCausalLM = __webpack_exports__.AutoModelForCausalLM;
var __webpack_exports__AutoModelForDepthEstimation = __webpack_exports__.AutoModelForDepthEstimation;
var __webpack_exports__AutoModelForDocumentQuestionAnswering = __webpack_exports__.AutoModelForDocumentQuestionAnswering;
var __webpack_exports__AutoModelForImageClassification = __webpack_exports__.AutoModelForImageClassification;
var __webpack_exports__AutoModelForImageFeatureExtraction = __webpack_exports__.AutoModelForImageFeatureExtraction;
var __webpack_exports__AutoModelForImageMatting = __webpack_exports__.AutoModelForImageMatting;
var __webpack_exports__AutoModelForImageSegmentation = __webpack_exports__.AutoModelForImageSegmentation;
var __webpack_exports__AutoModelForImageTextToText = __webpack_exports__.AutoModelForImageTextToText;
var __webpack_exports__AutoModelForImageToImage = __webpack_exports__.AutoModelForImageToImage;
var __webpack_exports__AutoModelForMaskGeneration = __webpack_exports__.AutoModelForMaskGeneration;
var __webpack_exports__AutoModelForMaskedLM = __webpack_exports__.AutoModelForMaskedLM;
var __webpack_exports__AutoModelForNormalEstimation = __webpack_exports__.AutoModelForNormalEstimation;
var __webpack_exports__AutoModelForObjectDetection = __webpack_exports__.AutoModelForObjectDetection;
var __webpack_exports__AutoModelForPoseEstimation = __webpack_exports__.AutoModelForPoseEstimation;
var __webpack_exports__AutoModelForQuestionAnswering = __webpack_exports__.AutoModelForQuestionAnswering;
var __webpack_exports__AutoModelForSemanticSegmentation = __webpack_exports__.AutoModelForSemanticSegmentation;
var __webpack_exports__AutoModelForSeq2SeqLM = __webpack_exports__.AutoModelForSeq2SeqLM;
var __webpack_exports__AutoModelForSequenceClassification = __webpack_exports__.AutoModelForSequenceClassification;
var __webpack_exports__AutoModelForSpeechSeq2Seq = __webpack_exports__.AutoModelForSpeechSeq2Seq;
var __webpack_exports__AutoModelForTextToSpectrogram = __webpack_exports__.AutoModelForTextToSpectrogram;
var __webpack_exports__AutoModelForTextToWaveform = __webpack_exports__.AutoModelForTextToWaveform;
var __webpack_exports__AutoModelForTokenClassification = __webpack_exports__.AutoModelForTokenClassification;
var __webpack_exports__AutoModelForUniversalSegmentation = __webpack_exports__.AutoModelForUniversalSegmentation;
var __webpack_exports__AutoModelForVision2Seq = __webpack_exports__.AutoModelForVision2Seq;
var __webpack_exports__AutoModelForXVector = __webpack_exports__.AutoModelForXVector;
var __webpack_exports__AutoModelForZeroShotObjectDetection = __webpack_exports__.AutoModelForZeroShotObjectDetection;
var __webpack_exports__AutoProcessor = __webpack_exports__.AutoProcessor;
var __webpack_exports__AutoTokenizer = __webpack_exports__.AutoTokenizer;
var __webpack_exports__AutomaticSpeechRecognitionPipeline = __webpack_exports__.AutomaticSpeechRecognitionPipeline;
var __webpack_exports__BackgroundRemovalPipeline = __webpack_exports__.BackgroundRemovalPipeline;
var __webpack_exports__BartForConditionalGeneration = __webpack_exports__.BartForConditionalGeneration;
var __webpack_exports__BartForSequenceClassification = __webpack_exports__.BartForSequenceClassification;
var __webpack_exports__BartModel = __webpack_exports__.BartModel;
var __webpack_exports__BartPretrainedModel = __webpack_exports__.BartPretrainedModel;
var __webpack_exports__BartTokenizer = __webpack_exports__.BartTokenizer;
var __webpack_exports__BaseModelOutput = __webpack_exports__.BaseModelOutput;
var __webpack_exports__BaseStreamer = __webpack_exports__.BaseStreamer;
var __webpack_exports__BeitFeatureExtractor = __webpack_exports__.BeitFeatureExtractor;
var __webpack_exports__BeitForImageClassification = __webpack_exports__.BeitForImageClassification;
var __webpack_exports__BeitModel = __webpack_exports__.BeitModel;
var __webpack_exports__BeitPreTrainedModel = __webpack_exports__.BeitPreTrainedModel;
var __webpack_exports__BertForMaskedLM = __webpack_exports__.BertForMaskedLM;
var __webpack_exports__BertForQuestionAnswering = __webpack_exports__.BertForQuestionAnswering;
var __webpack_exports__BertForSequenceClassification = __webpack_exports__.BertForSequenceClassification;
var __webpack_exports__BertForTokenClassification = __webpack_exports__.BertForTokenClassification;
var __webpack_exports__BertModel = __webpack_exports__.BertModel;
var __webpack_exports__BertPreTrainedModel = __webpack_exports__.BertPreTrainedModel;
var __webpack_exports__BertTokenizer = __webpack_exports__.BertTokenizer;
var __webpack_exports__BitImageProcessor = __webpack_exports__.BitImageProcessor;
var __webpack_exports__BlenderbotForConditionalGeneration = __webpack_exports__.BlenderbotForConditionalGeneration;
var __webpack_exports__BlenderbotModel = __webpack_exports__.BlenderbotModel;
var __webpack_exports__BlenderbotPreTrainedModel = __webpack_exports__.BlenderbotPreTrainedModel;
var __webpack_exports__BlenderbotSmallForConditionalGeneration = __webpack_exports__.BlenderbotSmallForConditionalGeneration;
var __webpack_exports__BlenderbotSmallModel = __webpack_exports__.BlenderbotSmallModel;
var __webpack_exports__BlenderbotSmallPreTrainedModel = __webpack_exports__.BlenderbotSmallPreTrainedModel;
var __webpack_exports__BlenderbotSmallTokenizer = __webpack_exports__.BlenderbotSmallTokenizer;
var __webpack_exports__BlenderbotTokenizer = __webpack_exports__.BlenderbotTokenizer;
var __webpack_exports__BloomForCausalLM = __webpack_exports__.BloomForCausalLM;
var __webpack_exports__BloomModel = __webpack_exports__.BloomModel;
var __webpack_exports__BloomPreTrainedModel = __webpack_exports__.BloomPreTrainedModel;
var __webpack_exports__BloomTokenizer = __webpack_exports__.BloomTokenizer;
var __webpack_exports__CLIPFeatureExtractor = __webpack_exports__.CLIPFeatureExtractor;
var __webpack_exports__CLIPImageProcessor = __webpack_exports__.CLIPImageProcessor;
var __webpack_exports__CLIPModel = __webpack_exports__.CLIPModel;
var __webpack_exports__CLIPPreTrainedModel = __webpack_exports__.CLIPPreTrainedModel;
var __webpack_exports__CLIPSegForImageSegmentation = __webpack_exports__.CLIPSegForImageSegmentation;
var __webpack_exports__CLIPSegModel = __webpack_exports__.CLIPSegModel;
var __webpack_exports__CLIPSegPreTrainedModel = __webpack_exports__.CLIPSegPreTrainedModel;
var __webpack_exports__CLIPTextModel = __webpack_exports__.CLIPTextModel;
var __webpack_exports__CLIPTextModelWithProjection = __webpack_exports__.CLIPTextModelWithProjection;
var __webpack_exports__CLIPTokenizer = __webpack_exports__.CLIPTokenizer;
var __webpack_exports__CLIPVisionModel = __webpack_exports__.CLIPVisionModel;
var __webpack_exports__CLIPVisionModelWithProjection = __webpack_exports__.CLIPVisionModelWithProjection;
var __webpack_exports__CamembertForMaskedLM = __webpack_exports__.CamembertForMaskedLM;
var __webpack_exports__CamembertForQuestionAnswering = __webpack_exports__.CamembertForQuestionAnswering;
var __webpack_exports__CamembertForSequenceClassification = __webpack_exports__.CamembertForSequenceClassification;
var __webpack_exports__CamembertForTokenClassification = __webpack_exports__.CamembertForTokenClassification;
var __webpack_exports__CamembertModel = __webpack_exports__.CamembertModel;
var __webpack_exports__CamembertPreTrainedModel = __webpack_exports__.CamembertPreTrainedModel;
var __webpack_exports__CamembertTokenizer = __webpack_exports__.CamembertTokenizer;
var __webpack_exports__CausalLMOutput = __webpack_exports__.CausalLMOutput;
var __webpack_exports__CausalLMOutputWithPast = __webpack_exports__.CausalLMOutputWithPast;
var __webpack_exports__ChineseCLIPFeatureExtractor = __webpack_exports__.ChineseCLIPFeatureExtractor;
var __webpack_exports__ChineseCLIPModel = __webpack_exports__.ChineseCLIPModel;
var __webpack_exports__ChineseCLIPPreTrainedModel = __webpack_exports__.ChineseCLIPPreTrainedModel;
var __webpack_exports__ClapAudioModelWithProjection = __webpack_exports__.ClapAudioModelWithProjection;
var __webpack_exports__ClapFeatureExtractor = __webpack_exports__.ClapFeatureExtractor;
var __webpack_exports__ClapModel = __webpack_exports__.ClapModel;
var __webpack_exports__ClapPreTrainedModel = __webpack_exports__.ClapPreTrainedModel;
var __webpack_exports__ClapTextModelWithProjection = __webpack_exports__.ClapTextModelWithProjection;
var __webpack_exports__ClassifierFreeGuidanceLogitsProcessor = __webpack_exports__.ClassifierFreeGuidanceLogitsProcessor;
var __webpack_exports__CodeGenForCausalLM = __webpack_exports__.CodeGenForCausalLM;
var __webpack_exports__CodeGenModel = __webpack_exports__.CodeGenModel;
var __webpack_exports__CodeGenPreTrainedModel = __webpack_exports__.CodeGenPreTrainedModel;
var __webpack_exports__CodeGenTokenizer = __webpack_exports__.CodeGenTokenizer;
var __webpack_exports__CodeLlamaTokenizer = __webpack_exports__.CodeLlamaTokenizer;
var __webpack_exports__CohereForCausalLM = __webpack_exports__.CohereForCausalLM;
var __webpack_exports__CohereModel = __webpack_exports__.CohereModel;
var __webpack_exports__CoherePreTrainedModel = __webpack_exports__.CoherePreTrainedModel;
var __webpack_exports__CohereTokenizer = __webpack_exports__.CohereTokenizer;
var __webpack_exports__ConvBertForMaskedLM = __webpack_exports__.ConvBertForMaskedLM;
var __webpack_exports__ConvBertForQuestionAnswering = __webpack_exports__.ConvBertForQuestionAnswering;
var __webpack_exports__ConvBertForSequenceClassification = __webpack_exports__.ConvBertForSequenceClassification;
var __webpack_exports__ConvBertForTokenClassification = __webpack_exports__.ConvBertForTokenClassification;
var __webpack_exports__ConvBertModel = __webpack_exports__.ConvBertModel;
var __webpack_exports__ConvBertPreTrainedModel = __webpack_exports__.ConvBertPreTrainedModel;
var __webpack_exports__ConvBertTokenizer = __webpack_exports__.ConvBertTokenizer;
var __webpack_exports__ConvNextFeatureExtractor = __webpack_exports__.ConvNextFeatureExtractor;
var __webpack_exports__ConvNextForImageClassification = __webpack_exports__.ConvNextForImageClassification;
var __webpack_exports__ConvNextImageProcessor = __webpack_exports__.ConvNextImageProcessor;
var __webpack_exports__ConvNextModel = __webpack_exports__.ConvNextModel;
var __webpack_exports__ConvNextPreTrainedModel = __webpack_exports__.ConvNextPreTrainedModel;
var __webpack_exports__ConvNextV2ForImageClassification = __webpack_exports__.ConvNextV2ForImageClassification;
var __webpack_exports__ConvNextV2Model = __webpack_exports__.ConvNextV2Model;
var __webpack_exports__ConvNextV2PreTrainedModel = __webpack_exports__.ConvNextV2PreTrainedModel;
var __webpack_exports__DFineForObjectDetection = __webpack_exports__.DFineForObjectDetection;
var __webpack_exports__DFineModel = __webpack_exports__.DFineModel;
var __webpack_exports__DFinePreTrainedModel = __webpack_exports__.DFinePreTrainedModel;
var __webpack_exports__DINOv3ConvNextModel = __webpack_exports__.DINOv3ConvNextModel;
var __webpack_exports__DINOv3ConvNextPreTrainedModel = __webpack_exports__.DINOv3ConvNextPreTrainedModel;
var __webpack_exports__DINOv3ViTImageProcessor = __webpack_exports__.DINOv3ViTImageProcessor;
var __webpack_exports__DINOv3ViTModel = __webpack_exports__.DINOv3ViTModel;
var __webpack_exports__DINOv3ViTPreTrainedModel = __webpack_exports__.DINOv3ViTPreTrainedModel;
var __webpack_exports__DPTFeatureExtractor = __webpack_exports__.DPTFeatureExtractor;
var __webpack_exports__DPTForDepthEstimation = __webpack_exports__.DPTForDepthEstimation;
var __webpack_exports__DPTImageProcessor = __webpack_exports__.DPTImageProcessor;
var __webpack_exports__DPTModel = __webpack_exports__.DPTModel;
var __webpack_exports__DPTPreTrainedModel = __webpack_exports__.DPTPreTrainedModel;
var __webpack_exports__DacDecoderModel = __webpack_exports__.DacDecoderModel;
var __webpack_exports__DacDecoderOutput = __webpack_exports__.DacDecoderOutput;
var __webpack_exports__DacEncoderModel = __webpack_exports__.DacEncoderModel;
var __webpack_exports__DacEncoderOutput = __webpack_exports__.DacEncoderOutput;
var __webpack_exports__DacFeatureExtractor = __webpack_exports__.DacFeatureExtractor;
var __webpack_exports__DacModel = __webpack_exports__.DacModel;
var __webpack_exports__DacPreTrainedModel = __webpack_exports__.DacPreTrainedModel;
var __webpack_exports__DataTypeMap = __webpack_exports__.DataTypeMap;
var __webpack_exports__DebertaForMaskedLM = __webpack_exports__.DebertaForMaskedLM;
var __webpack_exports__DebertaForQuestionAnswering = __webpack_exports__.DebertaForQuestionAnswering;
var __webpack_exports__DebertaForSequenceClassification = __webpack_exports__.DebertaForSequenceClassification;
var __webpack_exports__DebertaForTokenClassification = __webpack_exports__.DebertaForTokenClassification;
var __webpack_exports__DebertaModel = __webpack_exports__.DebertaModel;
var __webpack_exports__DebertaPreTrainedModel = __webpack_exports__.DebertaPreTrainedModel;
var __webpack_exports__DebertaTokenizer = __webpack_exports__.DebertaTokenizer;
var __webpack_exports__DebertaV2ForMaskedLM = __webpack_exports__.DebertaV2ForMaskedLM;
var __webpack_exports__DebertaV2ForQuestionAnswering = __webpack_exports__.DebertaV2ForQuestionAnswering;
var __webpack_exports__DebertaV2ForSequenceClassification = __webpack_exports__.DebertaV2ForSequenceClassification;
var __webpack_exports__DebertaV2ForTokenClassification = __webpack_exports__.DebertaV2ForTokenClassification;
var __webpack_exports__DebertaV2Model = __webpack_exports__.DebertaV2Model;
var __webpack_exports__DebertaV2PreTrainedModel = __webpack_exports__.DebertaV2PreTrainedModel;
var __webpack_exports__DebertaV2Tokenizer = __webpack_exports__.DebertaV2Tokenizer;
var __webpack_exports__DecisionTransformerModel = __webpack_exports__.DecisionTransformerModel;
var __webpack_exports__DecisionTransformerPreTrainedModel = __webpack_exports__.DecisionTransformerPreTrainedModel;
var __webpack_exports__DeiTFeatureExtractor = __webpack_exports__.DeiTFeatureExtractor;
var __webpack_exports__DeiTForImageClassification = __webpack_exports__.DeiTForImageClassification;
var __webpack_exports__DeiTImageProcessor = __webpack_exports__.DeiTImageProcessor;
var __webpack_exports__DeiTModel = __webpack_exports__.DeiTModel;
var __webpack_exports__DeiTPreTrainedModel = __webpack_exports__.DeiTPreTrainedModel;
var __webpack_exports__DepthAnythingForDepthEstimation = __webpack_exports__.DepthAnythingForDepthEstimation;
var __webpack_exports__DepthAnythingPreTrainedModel = __webpack_exports__.DepthAnythingPreTrainedModel;
var __webpack_exports__DepthEstimationPipeline = __webpack_exports__.DepthEstimationPipeline;
var __webpack_exports__DepthProForDepthEstimation = __webpack_exports__.DepthProForDepthEstimation;
var __webpack_exports__DepthProPreTrainedModel = __webpack_exports__.DepthProPreTrainedModel;
var __webpack_exports__DetrFeatureExtractor = __webpack_exports__.DetrFeatureExtractor;
var __webpack_exports__DetrForObjectDetection = __webpack_exports__.DetrForObjectDetection;
var __webpack_exports__DetrForSegmentation = __webpack_exports__.DetrForSegmentation;
var __webpack_exports__DetrImageProcessor = __webpack_exports__.DetrImageProcessor;
var __webpack_exports__DetrModel = __webpack_exports__.DetrModel;
var __webpack_exports__DetrObjectDetectionOutput = __webpack_exports__.DetrObjectDetectionOutput;
var __webpack_exports__DetrPreTrainedModel = __webpack_exports__.DetrPreTrainedModel;
var __webpack_exports__DetrSegmentationOutput = __webpack_exports__.DetrSegmentationOutput;
var __webpack_exports__Dinov2ForImageClassification = __webpack_exports__.Dinov2ForImageClassification;
var __webpack_exports__Dinov2Model = __webpack_exports__.Dinov2Model;
var __webpack_exports__Dinov2PreTrainedModel = __webpack_exports__.Dinov2PreTrainedModel;
var __webpack_exports__Dinov2WithRegistersForImageClassification = __webpack_exports__.Dinov2WithRegistersForImageClassification;
var __webpack_exports__Dinov2WithRegistersModel = __webpack_exports__.Dinov2WithRegistersModel;
var __webpack_exports__Dinov2WithRegistersPreTrainedModel = __webpack_exports__.Dinov2WithRegistersPreTrainedModel;
var __webpack_exports__DistilBertForMaskedLM = __webpack_exports__.DistilBertForMaskedLM;
var __webpack_exports__DistilBertForQuestionAnswering = __webpack_exports__.DistilBertForQuestionAnswering;
var __webpack_exports__DistilBertForSequenceClassification = __webpack_exports__.DistilBertForSequenceClassification;
var __webpack_exports__DistilBertForTokenClassification = __webpack_exports__.DistilBertForTokenClassification;
var __webpack_exports__DistilBertModel = __webpack_exports__.DistilBertModel;
var __webpack_exports__DistilBertPreTrainedModel = __webpack_exports__.DistilBertPreTrainedModel;
var __webpack_exports__DistilBertTokenizer = __webpack_exports__.DistilBertTokenizer;
var __webpack_exports__DocumentQuestionAnsweringPipeline = __webpack_exports__.DocumentQuestionAnsweringPipeline;
var __webpack_exports__DonutFeatureExtractor = __webpack_exports__.DonutFeatureExtractor;
var __webpack_exports__DonutImageProcessor = __webpack_exports__.DonutImageProcessor;
var __webpack_exports__DonutSwinModel = __webpack_exports__.DonutSwinModel;
var __webpack_exports__DonutSwinPreTrainedModel = __webpack_exports__.DonutSwinPreTrainedModel;
var __webpack_exports__EdgeTamModel = __webpack_exports__.EdgeTamModel;
var __webpack_exports__EfficientNetForImageClassification = __webpack_exports__.EfficientNetForImageClassification;
var __webpack_exports__EfficientNetImageProcessor = __webpack_exports__.EfficientNetImageProcessor;
var __webpack_exports__EfficientNetModel = __webpack_exports__.EfficientNetModel;
var __webpack_exports__EfficientNetPreTrainedModel = __webpack_exports__.EfficientNetPreTrainedModel;
var __webpack_exports__ElectraForMaskedLM = __webpack_exports__.ElectraForMaskedLM;
var __webpack_exports__ElectraForQuestionAnswering = __webpack_exports__.ElectraForQuestionAnswering;
var __webpack_exports__ElectraForSequenceClassification = __webpack_exports__.ElectraForSequenceClassification;
var __webpack_exports__ElectraForTokenClassification = __webpack_exports__.ElectraForTokenClassification;
var __webpack_exports__ElectraModel = __webpack_exports__.ElectraModel;
var __webpack_exports__ElectraPreTrainedModel = __webpack_exports__.ElectraPreTrainedModel;
var __webpack_exports__ElectraTokenizer = __webpack_exports__.ElectraTokenizer;
var __webpack_exports__EncodecFeatureExtractor = __webpack_exports__.EncodecFeatureExtractor;
var __webpack_exports__EosTokenCriteria = __webpack_exports__.EosTokenCriteria;
var __webpack_exports__Ernie4_5ForCausalLM = __webpack_exports__.Ernie4_5ForCausalLM;
var __webpack_exports__Ernie4_5Model = __webpack_exports__.Ernie4_5Model;
var __webpack_exports__Ernie4_5PreTrainedModel = __webpack_exports__.Ernie4_5PreTrainedModel;
var __webpack_exports__EsmForMaskedLM = __webpack_exports__.EsmForMaskedLM;
var __webpack_exports__EsmForSequenceClassification = __webpack_exports__.EsmForSequenceClassification;
var __webpack_exports__EsmForTokenClassification = __webpack_exports__.EsmForTokenClassification;
var __webpack_exports__EsmModel = __webpack_exports__.EsmModel;
var __webpack_exports__EsmPreTrainedModel = __webpack_exports__.EsmPreTrainedModel;
var __webpack_exports__EsmTokenizer = __webpack_exports__.EsmTokenizer;
var __webpack_exports__ExaoneForCausalLM = __webpack_exports__.ExaoneForCausalLM;
var __webpack_exports__ExaoneModel = __webpack_exports__.ExaoneModel;
var __webpack_exports__ExaonePreTrainedModel = __webpack_exports__.ExaonePreTrainedModel;
var __webpack_exports__FFT = __webpack_exports__.FFT;
var __webpack_exports__FalconForCausalLM = __webpack_exports__.FalconForCausalLM;
var __webpack_exports__FalconModel = __webpack_exports__.FalconModel;
var __webpack_exports__FalconPreTrainedModel = __webpack_exports__.FalconPreTrainedModel;
var __webpack_exports__FalconTokenizer = __webpack_exports__.FalconTokenizer;
var __webpack_exports__FastViTForImageClassification = __webpack_exports__.FastViTForImageClassification;
var __webpack_exports__FastViTModel = __webpack_exports__.FastViTModel;
var __webpack_exports__FastViTPreTrainedModel = __webpack_exports__.FastViTPreTrainedModel;
var __webpack_exports__FeatureExtractionPipeline = __webpack_exports__.FeatureExtractionPipeline;
var __webpack_exports__FeatureExtractor = __webpack_exports__.FeatureExtractor;
var __webpack_exports__FillMaskPipeline = __webpack_exports__.FillMaskPipeline;
var __webpack_exports__Florence2ForConditionalGeneration = __webpack_exports__.Florence2ForConditionalGeneration;
var __webpack_exports__Florence2PreTrainedModel = __webpack_exports__.Florence2PreTrainedModel;
var __webpack_exports__Florence2Processor = __webpack_exports__.Florence2Processor;
var __webpack_exports__ForcedBOSTokenLogitsProcessor = __webpack_exports__.ForcedBOSTokenLogitsProcessor;
var __webpack_exports__ForcedEOSTokenLogitsProcessor = __webpack_exports__.ForcedEOSTokenLogitsProcessor;
var __webpack_exports__GLPNFeatureExtractor = __webpack_exports__.GLPNFeatureExtractor;
var __webpack_exports__GLPNForDepthEstimation = __webpack_exports__.GLPNForDepthEstimation;
var __webpack_exports__GLPNModel = __webpack_exports__.GLPNModel;
var __webpack_exports__GLPNPreTrainedModel = __webpack_exports__.GLPNPreTrainedModel;
var __webpack_exports__GPT2LMHeadModel = __webpack_exports__.GPT2LMHeadModel;
var __webpack_exports__GPT2Model = __webpack_exports__.GPT2Model;
var __webpack_exports__GPT2PreTrainedModel = __webpack_exports__.GPT2PreTrainedModel;
var __webpack_exports__GPT2Tokenizer = __webpack_exports__.GPT2Tokenizer;
var __webpack_exports__GPTBigCodeForCausalLM = __webpack_exports__.GPTBigCodeForCausalLM;
var __webpack_exports__GPTBigCodeModel = __webpack_exports__.GPTBigCodeModel;
var __webpack_exports__GPTBigCodePreTrainedModel = __webpack_exports__.GPTBigCodePreTrainedModel;
var __webpack_exports__GPTJForCausalLM = __webpack_exports__.GPTJForCausalLM;
var __webpack_exports__GPTJModel = __webpack_exports__.GPTJModel;
var __webpack_exports__GPTJPreTrainedModel = __webpack_exports__.GPTJPreTrainedModel;
var __webpack_exports__GPTNeoForCausalLM = __webpack_exports__.GPTNeoForCausalLM;
var __webpack_exports__GPTNeoModel = __webpack_exports__.GPTNeoModel;
var __webpack_exports__GPTNeoPreTrainedModel = __webpack_exports__.GPTNeoPreTrainedModel;
var __webpack_exports__GPTNeoXForCausalLM = __webpack_exports__.GPTNeoXForCausalLM;
var __webpack_exports__GPTNeoXModel = __webpack_exports__.GPTNeoXModel;
var __webpack_exports__GPTNeoXPreTrainedModel = __webpack_exports__.GPTNeoXPreTrainedModel;
var __webpack_exports__GPTNeoXTokenizer = __webpack_exports__.GPTNeoXTokenizer;
var __webpack_exports__Gemma2ForCausalLM = __webpack_exports__.Gemma2ForCausalLM;
var __webpack_exports__Gemma2Model = __webpack_exports__.Gemma2Model;
var __webpack_exports__Gemma2PreTrainedModel = __webpack_exports__.Gemma2PreTrainedModel;
var __webpack_exports__Gemma3ForCausalLM = __webpack_exports__.Gemma3ForCausalLM;
var __webpack_exports__Gemma3Model = __webpack_exports__.Gemma3Model;
var __webpack_exports__Gemma3PreTrainedModel = __webpack_exports__.Gemma3PreTrainedModel;
var __webpack_exports__Gemma3nAudioFeatureExtractor = __webpack_exports__.Gemma3nAudioFeatureExtractor;
var __webpack_exports__Gemma3nForConditionalGeneration = __webpack_exports__.Gemma3nForConditionalGeneration;
var __webpack_exports__Gemma3nPreTrainedModel = __webpack_exports__.Gemma3nPreTrainedModel;
var __webpack_exports__Gemma3nProcessor = __webpack_exports__.Gemma3nProcessor;
var __webpack_exports__GemmaForCausalLM = __webpack_exports__.GemmaForCausalLM;
var __webpack_exports__GemmaModel = __webpack_exports__.GemmaModel;
var __webpack_exports__GemmaPreTrainedModel = __webpack_exports__.GemmaPreTrainedModel;
var __webpack_exports__GemmaTokenizer = __webpack_exports__.GemmaTokenizer;
var __webpack_exports__GlmForCausalLM = __webpack_exports__.GlmForCausalLM;
var __webpack_exports__GlmModel = __webpack_exports__.GlmModel;
var __webpack_exports__GlmPreTrainedModel = __webpack_exports__.GlmPreTrainedModel;
var __webpack_exports__GraniteForCausalLM = __webpack_exports__.GraniteForCausalLM;
var __webpack_exports__GraniteModel = __webpack_exports__.GraniteModel;
var __webpack_exports__GraniteMoeHybridForCausalLM = __webpack_exports__.GraniteMoeHybridForCausalLM;
var __webpack_exports__GraniteMoeHybridModel = __webpack_exports__.GraniteMoeHybridModel;
var __webpack_exports__GraniteMoeHybridPreTrainedModel = __webpack_exports__.GraniteMoeHybridPreTrainedModel;
var __webpack_exports__GranitePreTrainedModel = __webpack_exports__.GranitePreTrainedModel;
var __webpack_exports__Grok1Tokenizer = __webpack_exports__.Grok1Tokenizer;
var __webpack_exports__GroundingDinoForObjectDetection = __webpack_exports__.GroundingDinoForObjectDetection;
var __webpack_exports__GroundingDinoImageProcessor = __webpack_exports__.GroundingDinoImageProcessor;
var __webpack_exports__GroundingDinoPreTrainedModel = __webpack_exports__.GroundingDinoPreTrainedModel;
var __webpack_exports__GroundingDinoProcessor = __webpack_exports__.GroundingDinoProcessor;
var __webpack_exports__GroupViTModel = __webpack_exports__.GroupViTModel;
var __webpack_exports__GroupViTPreTrainedModel = __webpack_exports__.GroupViTPreTrainedModel;
var __webpack_exports__HeliumForCausalLM = __webpack_exports__.HeliumForCausalLM;
var __webpack_exports__HeliumModel = __webpack_exports__.HeliumModel;
var __webpack_exports__HeliumPreTrainedModel = __webpack_exports__.HeliumPreTrainedModel;
var __webpack_exports__HerbertTokenizer = __webpack_exports__.HerbertTokenizer;
var __webpack_exports__HieraForImageClassification = __webpack_exports__.HieraForImageClassification;
var __webpack_exports__HieraModel = __webpack_exports__.HieraModel;
var __webpack_exports__HieraPreTrainedModel = __webpack_exports__.HieraPreTrainedModel;
var __webpack_exports__HubertForCTC = __webpack_exports__.HubertForCTC;
var __webpack_exports__HubertForSequenceClassification = __webpack_exports__.HubertForSequenceClassification;
var __webpack_exports__HubertModel = __webpack_exports__.HubertModel;
var __webpack_exports__HubertPreTrainedModel = __webpack_exports__.HubertPreTrainedModel;
var __webpack_exports__IJepaForImageClassification = __webpack_exports__.IJepaForImageClassification;
var __webpack_exports__IJepaModel = __webpack_exports__.IJepaModel;
var __webpack_exports__IJepaPreTrainedModel = __webpack_exports__.IJepaPreTrainedModel;
var __webpack_exports__Idefics3ForConditionalGeneration = __webpack_exports__.Idefics3ForConditionalGeneration;
var __webpack_exports__Idefics3ImageProcessor = __webpack_exports__.Idefics3ImageProcessor;
var __webpack_exports__Idefics3PreTrainedModel = __webpack_exports__.Idefics3PreTrainedModel;
var __webpack_exports__Idefics3Processor = __webpack_exports__.Idefics3Processor;
var __webpack_exports__ImageClassificationPipeline = __webpack_exports__.ImageClassificationPipeline;
var __webpack_exports__ImageFeatureExtractionPipeline = __webpack_exports__.ImageFeatureExtractionPipeline;
var __webpack_exports__ImageFeatureExtractor = __webpack_exports__.ImageFeatureExtractor;
var __webpack_exports__ImageMattingOutput = __webpack_exports__.ImageMattingOutput;
var __webpack_exports__ImageProcessor = __webpack_exports__.ImageProcessor;
var __webpack_exports__ImageSegmentationPipeline = __webpack_exports__.ImageSegmentationPipeline;
var __webpack_exports__ImageToImagePipeline = __webpack_exports__.ImageToImagePipeline;
var __webpack_exports__ImageToTextPipeline = __webpack_exports__.ImageToTextPipeline;
var __webpack_exports__InterruptableStoppingCriteria = __webpack_exports__.InterruptableStoppingCriteria;
var __webpack_exports__JAISLMHeadModel = __webpack_exports__.JAISLMHeadModel;
var __webpack_exports__JAISModel = __webpack_exports__.JAISModel;
var __webpack_exports__JAISPreTrainedModel = __webpack_exports__.JAISPreTrainedModel;
var __webpack_exports__JinaCLIPImageProcessor = __webpack_exports__.JinaCLIPImageProcessor;
var __webpack_exports__JinaCLIPModel = __webpack_exports__.JinaCLIPModel;
var __webpack_exports__JinaCLIPPreTrainedModel = __webpack_exports__.JinaCLIPPreTrainedModel;
var __webpack_exports__JinaCLIPProcessor = __webpack_exports__.JinaCLIPProcessor;
var __webpack_exports__JinaCLIPTextModel = __webpack_exports__.JinaCLIPTextModel;
var __webpack_exports__JinaCLIPVisionModel = __webpack_exports__.JinaCLIPVisionModel;
var __webpack_exports__Lfm2ForCausalLM = __webpack_exports__.Lfm2ForCausalLM;
var __webpack_exports__Lfm2Model = __webpack_exports__.Lfm2Model;
var __webpack_exports__Lfm2PreTrainedModel = __webpack_exports__.Lfm2PreTrainedModel;
var __webpack_exports__LiteWhisperForConditionalGeneration = __webpack_exports__.LiteWhisperForConditionalGeneration;
var __webpack_exports__Llama4ForCausalLM = __webpack_exports__.Llama4ForCausalLM;
var __webpack_exports__Llama4PreTrainedModel = __webpack_exports__.Llama4PreTrainedModel;
var __webpack_exports__LlamaForCausalLM = __webpack_exports__.LlamaForCausalLM;
var __webpack_exports__LlamaModel = __webpack_exports__.LlamaModel;
var __webpack_exports__LlamaPreTrainedModel = __webpack_exports__.LlamaPreTrainedModel;
var __webpack_exports__LlamaTokenizer = __webpack_exports__.LlamaTokenizer;
var __webpack_exports__LlavaForConditionalGeneration = __webpack_exports__.LlavaForConditionalGeneration;
var __webpack_exports__LlavaOnevisionForConditionalGeneration = __webpack_exports__.LlavaOnevisionForConditionalGeneration;
var __webpack_exports__LlavaOnevisionImageProcessor = __webpack_exports__.LlavaOnevisionImageProcessor;
var __webpack_exports__LlavaPreTrainedModel = __webpack_exports__.LlavaPreTrainedModel;
var __webpack_exports__LlavaProcessor = __webpack_exports__.LlavaProcessor;
var __webpack_exports__LlavaQwen2ForCausalLM = __webpack_exports__.LlavaQwen2ForCausalLM;
var __webpack_exports__LogitsProcessor = __webpack_exports__.LogitsProcessor;
var __webpack_exports__LogitsProcessorList = __webpack_exports__.LogitsProcessorList;
var __webpack_exports__LogitsWarper = __webpack_exports__.LogitsWarper;
var __webpack_exports__LongT5ForConditionalGeneration = __webpack_exports__.LongT5ForConditionalGeneration;
var __webpack_exports__LongT5Model = __webpack_exports__.LongT5Model;
var __webpack_exports__LongT5PreTrainedModel = __webpack_exports__.LongT5PreTrainedModel;
var __webpack_exports__M2M100ForConditionalGeneration = __webpack_exports__.M2M100ForConditionalGeneration;
var __webpack_exports__M2M100Model = __webpack_exports__.M2M100Model;
var __webpack_exports__M2M100PreTrainedModel = __webpack_exports__.M2M100PreTrainedModel;
var __webpack_exports__M2M100Tokenizer = __webpack_exports__.M2M100Tokenizer;
var __webpack_exports__MBart50Tokenizer = __webpack_exports__.MBart50Tokenizer;
var __webpack_exports__MBartForCausalLM = __webpack_exports__.MBartForCausalLM;
var __webpack_exports__MBartForConditionalGeneration = __webpack_exports__.MBartForConditionalGeneration;
var __webpack_exports__MBartForSequenceClassification = __webpack_exports__.MBartForSequenceClassification;
var __webpack_exports__MBartModel = __webpack_exports__.MBartModel;
var __webpack_exports__MBartPreTrainedModel = __webpack_exports__.MBartPreTrainedModel;
var __webpack_exports__MBartTokenizer = __webpack_exports__.MBartTokenizer;
var __webpack_exports__MPNetForMaskedLM = __webpack_exports__.MPNetForMaskedLM;
var __webpack_exports__MPNetForQuestionAnswering = __webpack_exports__.MPNetForQuestionAnswering;
var __webpack_exports__MPNetForSequenceClassification = __webpack_exports__.MPNetForSequenceClassification;
var __webpack_exports__MPNetForTokenClassification = __webpack_exports__.MPNetForTokenClassification;
var __webpack_exports__MPNetModel = __webpack_exports__.MPNetModel;
var __webpack_exports__MPNetPreTrainedModel = __webpack_exports__.MPNetPreTrainedModel;
var __webpack_exports__MPNetTokenizer = __webpack_exports__.MPNetTokenizer;
var __webpack_exports__MT5ForConditionalGeneration = __webpack_exports__.MT5ForConditionalGeneration;
var __webpack_exports__MT5Model = __webpack_exports__.MT5Model;
var __webpack_exports__MT5PreTrainedModel = __webpack_exports__.MT5PreTrainedModel;
var __webpack_exports__MarianMTModel = __webpack_exports__.MarianMTModel;
var __webpack_exports__MarianModel = __webpack_exports__.MarianModel;
var __webpack_exports__MarianPreTrainedModel = __webpack_exports__.MarianPreTrainedModel;
var __webpack_exports__MarianTokenizer = __webpack_exports__.MarianTokenizer;
var __webpack_exports__Mask2FormerImageProcessor = __webpack_exports__.Mask2FormerImageProcessor;
var __webpack_exports__MaskFormerFeatureExtractor = __webpack_exports__.MaskFormerFeatureExtractor;
var __webpack_exports__MaskFormerForInstanceSegmentation = __webpack_exports__.MaskFormerForInstanceSegmentation;
var __webpack_exports__MaskFormerImageProcessor = __webpack_exports__.MaskFormerImageProcessor;
var __webpack_exports__MaskFormerModel = __webpack_exports__.MaskFormerModel;
var __webpack_exports__MaskFormerPreTrainedModel = __webpack_exports__.MaskFormerPreTrainedModel;
var __webpack_exports__MaskedLMOutput = __webpack_exports__.MaskedLMOutput;
var __webpack_exports__MaxLengthCriteria = __webpack_exports__.MaxLengthCriteria;
var __webpack_exports__Metric3DForDepthEstimation = __webpack_exports__.Metric3DForDepthEstimation;
var __webpack_exports__Metric3DPreTrainedModel = __webpack_exports__.Metric3DPreTrainedModel;
var __webpack_exports__Metric3Dv2ForDepthEstimation = __webpack_exports__.Metric3Dv2ForDepthEstimation;
var __webpack_exports__Metric3Dv2PreTrainedModel = __webpack_exports__.Metric3Dv2PreTrainedModel;
var __webpack_exports__MgpstrForSceneTextRecognition = __webpack_exports__.MgpstrForSceneTextRecognition;
var __webpack_exports__MgpstrModelOutput = __webpack_exports__.MgpstrModelOutput;
var __webpack_exports__MgpstrPreTrainedModel = __webpack_exports__.MgpstrPreTrainedModel;
var __webpack_exports__MgpstrProcessor = __webpack_exports__.MgpstrProcessor;
var __webpack_exports__MgpstrTokenizer = __webpack_exports__.MgpstrTokenizer;
var __webpack_exports__MimiDecoderModel = __webpack_exports__.MimiDecoderModel;
var __webpack_exports__MimiDecoderOutput = __webpack_exports__.MimiDecoderOutput;
var __webpack_exports__MimiEncoderModel = __webpack_exports__.MimiEncoderModel;
var __webpack_exports__MimiEncoderOutput = __webpack_exports__.MimiEncoderOutput;
var __webpack_exports__MimiModel = __webpack_exports__.MimiModel;
var __webpack_exports__MimiPreTrainedModel = __webpack_exports__.MimiPreTrainedModel;
var __webpack_exports__MinLengthLogitsProcessor = __webpack_exports__.MinLengthLogitsProcessor;
var __webpack_exports__MinNewTokensLengthLogitsProcessor = __webpack_exports__.MinNewTokensLengthLogitsProcessor;
var __webpack_exports__Ministral3ForCausalLM = __webpack_exports__.Ministral3ForCausalLM;
var __webpack_exports__Ministral3Model = __webpack_exports__.Ministral3Model;
var __webpack_exports__Ministral3PreTrainedModel = __webpack_exports__.Ministral3PreTrainedModel;
var __webpack_exports__MinistralForCausalLM = __webpack_exports__.MinistralForCausalLM;
var __webpack_exports__MinistralModel = __webpack_exports__.MinistralModel;
var __webpack_exports__MinistralPreTrainedModel = __webpack_exports__.MinistralPreTrainedModel;
var __webpack_exports__Mistral3ForConditionalGeneration = __webpack_exports__.Mistral3ForConditionalGeneration;
var __webpack_exports__MistralForCausalLM = __webpack_exports__.MistralForCausalLM;
var __webpack_exports__MistralModel = __webpack_exports__.MistralModel;
var __webpack_exports__MistralPreTrainedModel = __webpack_exports__.MistralPreTrainedModel;
var __webpack_exports__MobileBertForMaskedLM = __webpack_exports__.MobileBertForMaskedLM;
var __webpack_exports__MobileBertForQuestionAnswering = __webpack_exports__.MobileBertForQuestionAnswering;
var __webpack_exports__MobileBertForSequenceClassification = __webpack_exports__.MobileBertForSequenceClassification;
var __webpack_exports__MobileBertModel = __webpack_exports__.MobileBertModel;
var __webpack_exports__MobileBertPreTrainedModel = __webpack_exports__.MobileBertPreTrainedModel;
var __webpack_exports__MobileBertTokenizer = __webpack_exports__.MobileBertTokenizer;
var __webpack_exports__MobileLLMForCausalLM = __webpack_exports__.MobileLLMForCausalLM;
var __webpack_exports__MobileLLMModel = __webpack_exports__.MobileLLMModel;
var __webpack_exports__MobileLLMPreTrainedModel = __webpack_exports__.MobileLLMPreTrainedModel;
var __webpack_exports__MobileNetV1FeatureExtractor = __webpack_exports__.MobileNetV1FeatureExtractor;
var __webpack_exports__MobileNetV1ForImageClassification = __webpack_exports__.MobileNetV1ForImageClassification;
var __webpack_exports__MobileNetV1ForSemanticSegmentation = __webpack_exports__.MobileNetV1ForSemanticSegmentation;
var __webpack_exports__MobileNetV1ImageProcessor = __webpack_exports__.MobileNetV1ImageProcessor;
var __webpack_exports__MobileNetV1Model = __webpack_exports__.MobileNetV1Model;
var __webpack_exports__MobileNetV1PreTrainedModel = __webpack_exports__.MobileNetV1PreTrainedModel;
var __webpack_exports__MobileNetV2FeatureExtractor = __webpack_exports__.MobileNetV2FeatureExtractor;
var __webpack_exports__MobileNetV2ForImageClassification = __webpack_exports__.MobileNetV2ForImageClassification;
var __webpack_exports__MobileNetV2ForSemanticSegmentation = __webpack_exports__.MobileNetV2ForSemanticSegmentation;
var __webpack_exports__MobileNetV2ImageProcessor = __webpack_exports__.MobileNetV2ImageProcessor;
var __webpack_exports__MobileNetV2Model = __webpack_exports__.MobileNetV2Model;
var __webpack_exports__MobileNetV2PreTrainedModel = __webpack_exports__.MobileNetV2PreTrainedModel;
var __webpack_exports__MobileNetV3FeatureExtractor = __webpack_exports__.MobileNetV3FeatureExtractor;
var __webpack_exports__MobileNetV3ForImageClassification = __webpack_exports__.MobileNetV3ForImageClassification;
var __webpack_exports__MobileNetV3ForSemanticSegmentation = __webpack_exports__.MobileNetV3ForSemanticSegmentation;
var __webpack_exports__MobileNetV3ImageProcessor = __webpack_exports__.MobileNetV3ImageProcessor;
var __webpack_exports__MobileNetV3Model = __webpack_exports__.MobileNetV3Model;
var __webpack_exports__MobileNetV3PreTrainedModel = __webpack_exports__.MobileNetV3PreTrainedModel;
var __webpack_exports__MobileNetV4FeatureExtractor = __webpack_exports__.MobileNetV4FeatureExtractor;
var __webpack_exports__MobileNetV4ForImageClassification = __webpack_exports__.MobileNetV4ForImageClassification;
var __webpack_exports__MobileNetV4ForSemanticSegmentation = __webpack_exports__.MobileNetV4ForSemanticSegmentation;
var __webpack_exports__MobileNetV4ImageProcessor = __webpack_exports__.MobileNetV4ImageProcessor;
var __webpack_exports__MobileNetV4Model = __webpack_exports__.MobileNetV4Model;
var __webpack_exports__MobileNetV4PreTrainedModel = __webpack_exports__.MobileNetV4PreTrainedModel;
var __webpack_exports__MobileViTFeatureExtractor = __webpack_exports__.MobileViTFeatureExtractor;
var __webpack_exports__MobileViTForImageClassification = __webpack_exports__.MobileViTForImageClassification;
var __webpack_exports__MobileViTImageProcessor = __webpack_exports__.MobileViTImageProcessor;
var __webpack_exports__MobileViTModel = __webpack_exports__.MobileViTModel;
var __webpack_exports__MobileViTPreTrainedModel = __webpack_exports__.MobileViTPreTrainedModel;
var __webpack_exports__MobileViTV2ForImageClassification = __webpack_exports__.MobileViTV2ForImageClassification;
var __webpack_exports__MobileViTV2Model = __webpack_exports__.MobileViTV2Model;
var __webpack_exports__MobileViTV2PreTrainedModel = __webpack_exports__.MobileViTV2PreTrainedModel;
var __webpack_exports__ModelOutput = __webpack_exports__.ModelOutput;
var __webpack_exports__ModernBertDecoderForCausalLM = __webpack_exports__.ModernBertDecoderForCausalLM;
var __webpack_exports__ModernBertDecoderModel = __webpack_exports__.ModernBertDecoderModel;
var __webpack_exports__ModernBertDecoderPreTrainedModel = __webpack_exports__.ModernBertDecoderPreTrainedModel;
var __webpack_exports__ModernBertForMaskedLM = __webpack_exports__.ModernBertForMaskedLM;
var __webpack_exports__ModernBertForSequenceClassification = __webpack_exports__.ModernBertForSequenceClassification;
var __webpack_exports__ModernBertForTokenClassification = __webpack_exports__.ModernBertForTokenClassification;
var __webpack_exports__ModernBertModel = __webpack_exports__.ModernBertModel;
var __webpack_exports__ModernBertPreTrainedModel = __webpack_exports__.ModernBertPreTrainedModel;
var __webpack_exports__Moondream1ForConditionalGeneration = __webpack_exports__.Moondream1ForConditionalGeneration;
var __webpack_exports__MoonshineFeatureExtractor = __webpack_exports__.MoonshineFeatureExtractor;
var __webpack_exports__MoonshineForConditionalGeneration = __webpack_exports__.MoonshineForConditionalGeneration;
var __webpack_exports__MoonshineModel = __webpack_exports__.MoonshineModel;
var __webpack_exports__MoonshinePreTrainedModel = __webpack_exports__.MoonshinePreTrainedModel;
var __webpack_exports__MoonshineProcessor = __webpack_exports__.MoonshineProcessor;
var __webpack_exports__MptForCausalLM = __webpack_exports__.MptForCausalLM;
var __webpack_exports__MptModel = __webpack_exports__.MptModel;
var __webpack_exports__MptPreTrainedModel = __webpack_exports__.MptPreTrainedModel;
var __webpack_exports__MultiModalityCausalLM = __webpack_exports__.MultiModalityCausalLM;
var __webpack_exports__MultiModalityPreTrainedModel = __webpack_exports__.MultiModalityPreTrainedModel;
var __webpack_exports__MusicgenForCausalLM = __webpack_exports__.MusicgenForCausalLM;
var __webpack_exports__MusicgenForConditionalGeneration = __webpack_exports__.MusicgenForConditionalGeneration;
var __webpack_exports__MusicgenModel = __webpack_exports__.MusicgenModel;
var __webpack_exports__MusicgenPreTrainedModel = __webpack_exports__.MusicgenPreTrainedModel;
var __webpack_exports__NanoChatForCausalLM = __webpack_exports__.NanoChatForCausalLM;
var __webpack_exports__NanoChatModel = __webpack_exports__.NanoChatModel;
var __webpack_exports__NanoChatPreTrainedModel = __webpack_exports__.NanoChatPreTrainedModel;
var __webpack_exports__NeoBertForMaskedLM = __webpack_exports__.NeoBertForMaskedLM;
var __webpack_exports__NeoBertForQuestionAnswering = __webpack_exports__.NeoBertForQuestionAnswering;
var __webpack_exports__NeoBertForSequenceClassification = __webpack_exports__.NeoBertForSequenceClassification;
var __webpack_exports__NeoBertForTokenClassification = __webpack_exports__.NeoBertForTokenClassification;
var __webpack_exports__NeoBertModel = __webpack_exports__.NeoBertModel;
var __webpack_exports__NeoBertPreTrainedModel = __webpack_exports__.NeoBertPreTrainedModel;
var __webpack_exports__NllbTokenizer = __webpack_exports__.NllbTokenizer;
var __webpack_exports__NoBadWordsLogitsProcessor = __webpack_exports__.NoBadWordsLogitsProcessor;
var __webpack_exports__NoRepeatNGramLogitsProcessor = __webpack_exports__.NoRepeatNGramLogitsProcessor;
var __webpack_exports__NomicBertModel = __webpack_exports__.NomicBertModel;
var __webpack_exports__NomicBertPreTrainedModel = __webpack_exports__.NomicBertPreTrainedModel;
var __webpack_exports__NougatImageProcessor = __webpack_exports__.NougatImageProcessor;
var __webpack_exports__NougatTokenizer = __webpack_exports__.NougatTokenizer;
var __webpack_exports__OPTForCausalLM = __webpack_exports__.OPTForCausalLM;
var __webpack_exports__OPTModel = __webpack_exports__.OPTModel;
var __webpack_exports__OPTPreTrainedModel = __webpack_exports__.OPTPreTrainedModel;
var __webpack_exports__ObjectDetectionPipeline = __webpack_exports__.ObjectDetectionPipeline;
var __webpack_exports__Olmo2ForCausalLM = __webpack_exports__.Olmo2ForCausalLM;
var __webpack_exports__Olmo2Model = __webpack_exports__.Olmo2Model;
var __webpack_exports__Olmo2PreTrainedModel = __webpack_exports__.Olmo2PreTrainedModel;
var __webpack_exports__OlmoForCausalLM = __webpack_exports__.OlmoForCausalLM;
var __webpack_exports__OlmoModel = __webpack_exports__.OlmoModel;
var __webpack_exports__OlmoPreTrainedModel = __webpack_exports__.OlmoPreTrainedModel;
var __webpack_exports__OpenELMForCausalLM = __webpack_exports__.OpenELMForCausalLM;
var __webpack_exports__OpenELMModel = __webpack_exports__.OpenELMModel;
var __webpack_exports__OpenELMPreTrainedModel = __webpack_exports__.OpenELMPreTrainedModel;
var __webpack_exports__OwlViTFeatureExtractor = __webpack_exports__.OwlViTFeatureExtractor;
var __webpack_exports__OwlViTForObjectDetection = __webpack_exports__.OwlViTForObjectDetection;
var __webpack_exports__OwlViTImageProcessor = __webpack_exports__.OwlViTImageProcessor;
var __webpack_exports__OwlViTModel = __webpack_exports__.OwlViTModel;
var __webpack_exports__OwlViTPreTrainedModel = __webpack_exports__.OwlViTPreTrainedModel;
var __webpack_exports__OwlViTProcessor = __webpack_exports__.OwlViTProcessor;
var __webpack_exports__Owlv2ForObjectDetection = __webpack_exports__.Owlv2ForObjectDetection;
var __webpack_exports__Owlv2ImageProcessor = __webpack_exports__.Owlv2ImageProcessor;
var __webpack_exports__Owlv2Model = __webpack_exports__.Owlv2Model;
var __webpack_exports__Owlv2PreTrainedModel = __webpack_exports__.Owlv2PreTrainedModel;
var __webpack_exports__PaliGemmaForConditionalGeneration = __webpack_exports__.PaliGemmaForConditionalGeneration;
var __webpack_exports__PaliGemmaPreTrainedModel = __webpack_exports__.PaliGemmaPreTrainedModel;
var __webpack_exports__PaliGemmaProcessor = __webpack_exports__.PaliGemmaProcessor;
var __webpack_exports__ParakeetFeatureExtractor = __webpack_exports__.ParakeetFeatureExtractor;
var __webpack_exports__ParakeetForCTC = __webpack_exports__.ParakeetForCTC;
var __webpack_exports__ParakeetPreTrainedModel = __webpack_exports__.ParakeetPreTrainedModel;
var __webpack_exports__PatchTSMixerForPrediction = __webpack_exports__.PatchTSMixerForPrediction;
var __webpack_exports__PatchTSMixerModel = __webpack_exports__.PatchTSMixerModel;
var __webpack_exports__PatchTSMixerPreTrainedModel = __webpack_exports__.PatchTSMixerPreTrainedModel;
var __webpack_exports__PatchTSTForPrediction = __webpack_exports__.PatchTSTForPrediction;
var __webpack_exports__PatchTSTModel = __webpack_exports__.PatchTSTModel;
var __webpack_exports__PatchTSTPreTrainedModel = __webpack_exports__.PatchTSTPreTrainedModel;
var __webpack_exports__Phi3ForCausalLM = __webpack_exports__.Phi3ForCausalLM;
var __webpack_exports__Phi3Model = __webpack_exports__.Phi3Model;
var __webpack_exports__Phi3PreTrainedModel = __webpack_exports__.Phi3PreTrainedModel;
var __webpack_exports__Phi3VForCausalLM = __webpack_exports__.Phi3VForCausalLM;
var __webpack_exports__Phi3VImageProcessor = __webpack_exports__.Phi3VImageProcessor;
var __webpack_exports__Phi3VPreTrainedModel = __webpack_exports__.Phi3VPreTrainedModel;
var __webpack_exports__Phi3VProcessor = __webpack_exports__.Phi3VProcessor;
var __webpack_exports__PhiForCausalLM = __webpack_exports__.PhiForCausalLM;
var __webpack_exports__PhiModel = __webpack_exports__.PhiModel;
var __webpack_exports__PhiPreTrainedModel = __webpack_exports__.PhiPreTrainedModel;
var __webpack_exports__Pipeline = __webpack_exports__.Pipeline;
var __webpack_exports__PixtralImageProcessor = __webpack_exports__.PixtralImageProcessor;
var __webpack_exports__PixtralProcessor = __webpack_exports__.PixtralProcessor;
var __webpack_exports__PreTrainedModel = __webpack_exports__.PreTrainedModel;
var __webpack_exports__PreTrainedTokenizer = __webpack_exports__.PreTrainedTokenizer;
var __webpack_exports__PretrainedConfig = __webpack_exports__.PretrainedConfig;
var __webpack_exports__PretrainedMixin = __webpack_exports__.PretrainedMixin;
var __webpack_exports__Processor = __webpack_exports__.Processor;
var __webpack_exports__PvtForImageClassification = __webpack_exports__.PvtForImageClassification;
var __webpack_exports__PvtImageProcessor = __webpack_exports__.PvtImageProcessor;
var __webpack_exports__PvtModel = __webpack_exports__.PvtModel;
var __webpack_exports__PvtPreTrainedModel = __webpack_exports__.PvtPreTrainedModel;
var __webpack_exports__PyAnnoteFeatureExtractor = __webpack_exports__.PyAnnoteFeatureExtractor;
var __webpack_exports__PyAnnoteForAudioFrameClassification = __webpack_exports__.PyAnnoteForAudioFrameClassification;
var __webpack_exports__PyAnnoteModel = __webpack_exports__.PyAnnoteModel;
var __webpack_exports__PyAnnotePreTrainedModel = __webpack_exports__.PyAnnotePreTrainedModel;
var __webpack_exports__PyAnnoteProcessor = __webpack_exports__.PyAnnoteProcessor;
var __webpack_exports__QuestionAnsweringModelOutput = __webpack_exports__.QuestionAnsweringModelOutput;
var __webpack_exports__QuestionAnsweringPipeline = __webpack_exports__.QuestionAnsweringPipeline;
var __webpack_exports__Qwen2ForCausalLM = __webpack_exports__.Qwen2ForCausalLM;
var __webpack_exports__Qwen2Model = __webpack_exports__.Qwen2Model;
var __webpack_exports__Qwen2PreTrainedModel = __webpack_exports__.Qwen2PreTrainedModel;
var __webpack_exports__Qwen2Tokenizer = __webpack_exports__.Qwen2Tokenizer;
var __webpack_exports__Qwen2VLForConditionalGeneration = __webpack_exports__.Qwen2VLForConditionalGeneration;
var __webpack_exports__Qwen2VLImageProcessor = __webpack_exports__.Qwen2VLImageProcessor;
var __webpack_exports__Qwen2VLPreTrainedModel = __webpack_exports__.Qwen2VLPreTrainedModel;
var __webpack_exports__Qwen2VLProcessor = __webpack_exports__.Qwen2VLProcessor;
var __webpack_exports__Qwen3ForCausalLM = __webpack_exports__.Qwen3ForCausalLM;
var __webpack_exports__Qwen3Model = __webpack_exports__.Qwen3Model;
var __webpack_exports__Qwen3PreTrainedModel = __webpack_exports__.Qwen3PreTrainedModel;
var __webpack_exports__RFDetrForObjectDetection = __webpack_exports__.RFDetrForObjectDetection;
var __webpack_exports__RFDetrModel = __webpack_exports__.RFDetrModel;
var __webpack_exports__RFDetrObjectDetectionOutput = __webpack_exports__.RFDetrObjectDetectionOutput;
var __webpack_exports__RFDetrPreTrainedModel = __webpack_exports__.RFDetrPreTrainedModel;
var __webpack_exports__RTDetrForObjectDetection = __webpack_exports__.RTDetrForObjectDetection;
var __webpack_exports__RTDetrImageProcessor = __webpack_exports__.RTDetrImageProcessor;
var __webpack_exports__RTDetrModel = __webpack_exports__.RTDetrModel;
var __webpack_exports__RTDetrObjectDetectionOutput = __webpack_exports__.RTDetrObjectDetectionOutput;
var __webpack_exports__RTDetrPreTrainedModel = __webpack_exports__.RTDetrPreTrainedModel;
var __webpack_exports__RTDetrV2ForObjectDetection = __webpack_exports__.RTDetrV2ForObjectDetection;
var __webpack_exports__RTDetrV2Model = __webpack_exports__.RTDetrV2Model;
var __webpack_exports__RTDetrV2ObjectDetectionOutput = __webpack_exports__.RTDetrV2ObjectDetectionOutput;
var __webpack_exports__RTDetrV2PreTrainedModel = __webpack_exports__.RTDetrV2PreTrainedModel;
var __webpack_exports__RawAudio = __webpack_exports__.RawAudio;
var __webpack_exports__RawImage = __webpack_exports__.RawImage;
var __webpack_exports__RawVideo = __webpack_exports__.RawVideo;
var __webpack_exports__RawVideoFrame = __webpack_exports__.RawVideoFrame;
var __webpack_exports__RepetitionPenaltyLogitsProcessor = __webpack_exports__.RepetitionPenaltyLogitsProcessor;
var __webpack_exports__ResNetForImageClassification = __webpack_exports__.ResNetForImageClassification;
var __webpack_exports__ResNetModel = __webpack_exports__.ResNetModel;
var __webpack_exports__ResNetPreTrainedModel = __webpack_exports__.ResNetPreTrainedModel;
var __webpack_exports__RoFormerForMaskedLM = __webpack_exports__.RoFormerForMaskedLM;
var __webpack_exports__RoFormerForQuestionAnswering = __webpack_exports__.RoFormerForQuestionAnswering;
var __webpack_exports__RoFormerForSequenceClassification = __webpack_exports__.RoFormerForSequenceClassification;
var __webpack_exports__RoFormerForTokenClassification = __webpack_exports__.RoFormerForTokenClassification;
var __webpack_exports__RoFormerModel = __webpack_exports__.RoFormerModel;
var __webpack_exports__RoFormerPreTrainedModel = __webpack_exports__.RoFormerPreTrainedModel;
var __webpack_exports__RoFormerTokenizer = __webpack_exports__.RoFormerTokenizer;
var __webpack_exports__RobertaForMaskedLM = __webpack_exports__.RobertaForMaskedLM;
var __webpack_exports__RobertaForQuestionAnswering = __webpack_exports__.RobertaForQuestionAnswering;
var __webpack_exports__RobertaForSequenceClassification = __webpack_exports__.RobertaForSequenceClassification;
var __webpack_exports__RobertaForTokenClassification = __webpack_exports__.RobertaForTokenClassification;
var __webpack_exports__RobertaModel = __webpack_exports__.RobertaModel;
var __webpack_exports__RobertaPreTrainedModel = __webpack_exports__.RobertaPreTrainedModel;
var __webpack_exports__RobertaTokenizer = __webpack_exports__.RobertaTokenizer;
var __webpack_exports__Sam2ImageProcessor = __webpack_exports__.Sam2ImageProcessor;
var __webpack_exports__Sam2ImageSegmentationOutput = __webpack_exports__.Sam2ImageSegmentationOutput;
var __webpack_exports__Sam2Model = __webpack_exports__.Sam2Model;
var __webpack_exports__Sam2PreTrainedModel = __webpack_exports__.Sam2PreTrainedModel;
var __webpack_exports__Sam2Processor = __webpack_exports__.Sam2Processor;
var __webpack_exports__Sam2VideoProcessor = __webpack_exports__.Sam2VideoProcessor;
var __webpack_exports__Sam3ImageProcessor = __webpack_exports__.Sam3ImageProcessor;
var __webpack_exports__Sam3TrackerModel = __webpack_exports__.Sam3TrackerModel;
var __webpack_exports__SamImageProcessor = __webpack_exports__.SamImageProcessor;
var __webpack_exports__SamImageSegmentationOutput = __webpack_exports__.SamImageSegmentationOutput;
var __webpack_exports__SamModel = __webpack_exports__.SamModel;
var __webpack_exports__SamPreTrainedModel = __webpack_exports__.SamPreTrainedModel;
var __webpack_exports__SamProcessor = __webpack_exports__.SamProcessor;
var __webpack_exports__SapiensForDepthEstimation = __webpack_exports__.SapiensForDepthEstimation;
var __webpack_exports__SapiensForNormalEstimation = __webpack_exports__.SapiensForNormalEstimation;
var __webpack_exports__SapiensForSemanticSegmentation = __webpack_exports__.SapiensForSemanticSegmentation;
var __webpack_exports__SapiensPreTrainedModel = __webpack_exports__.SapiensPreTrainedModel;
var __webpack_exports__SeamlessM4TFeatureExtractor = __webpack_exports__.SeamlessM4TFeatureExtractor;
var __webpack_exports__SegformerFeatureExtractor = __webpack_exports__.SegformerFeatureExtractor;
var __webpack_exports__SegformerForImageClassification = __webpack_exports__.SegformerForImageClassification;
var __webpack_exports__SegformerForSemanticSegmentation = __webpack_exports__.SegformerForSemanticSegmentation;
var __webpack_exports__SegformerImageProcessor = __webpack_exports__.SegformerImageProcessor;
var __webpack_exports__SegformerModel = __webpack_exports__.SegformerModel;
var __webpack_exports__SegformerPreTrainedModel = __webpack_exports__.SegformerPreTrainedModel;
var __webpack_exports__Seq2SeqLMOutput = __webpack_exports__.Seq2SeqLMOutput;
var __webpack_exports__SequenceClassifierOutput = __webpack_exports__.SequenceClassifierOutput;
var __webpack_exports__SiglipImageProcessor = __webpack_exports__.SiglipImageProcessor;
var __webpack_exports__SiglipModel = __webpack_exports__.SiglipModel;
var __webpack_exports__SiglipPreTrainedModel = __webpack_exports__.SiglipPreTrainedModel;
var __webpack_exports__SiglipTextModel = __webpack_exports__.SiglipTextModel;
var __webpack_exports__SiglipTokenizer = __webpack_exports__.SiglipTokenizer;
var __webpack_exports__SiglipVisionModel = __webpack_exports__.SiglipVisionModel;
var __webpack_exports__SmolLM3ForCausalLM = __webpack_exports__.SmolLM3ForCausalLM;
var __webpack_exports__SmolLM3Model = __webpack_exports__.SmolLM3Model;
var __webpack_exports__SmolLM3PreTrainedModel = __webpack_exports__.SmolLM3PreTrainedModel;
var __webpack_exports__SmolVLMForConditionalGeneration = __webpack_exports__.SmolVLMForConditionalGeneration;
var __webpack_exports__SmolVLMImageProcessor = __webpack_exports__.SmolVLMImageProcessor;
var __webpack_exports__SmolVLMProcessor = __webpack_exports__.SmolVLMProcessor;
var __webpack_exports__SnacDecoderModel = __webpack_exports__.SnacDecoderModel;
var __webpack_exports__SnacEncoderModel = __webpack_exports__.SnacEncoderModel;
var __webpack_exports__SnacFeatureExtractor = __webpack_exports__.SnacFeatureExtractor;
var __webpack_exports__SnacModel = __webpack_exports__.SnacModel;
var __webpack_exports__SnacPreTrainedModel = __webpack_exports__.SnacPreTrainedModel;
var __webpack_exports__SpeechT5FeatureExtractor = __webpack_exports__.SpeechT5FeatureExtractor;
var __webpack_exports__SpeechT5ForSpeechToText = __webpack_exports__.SpeechT5ForSpeechToText;
var __webpack_exports__SpeechT5ForTextToSpeech = __webpack_exports__.SpeechT5ForTextToSpeech;
var __webpack_exports__SpeechT5HifiGan = __webpack_exports__.SpeechT5HifiGan;
var __webpack_exports__SpeechT5Model = __webpack_exports__.SpeechT5Model;
var __webpack_exports__SpeechT5PreTrainedModel = __webpack_exports__.SpeechT5PreTrainedModel;
var __webpack_exports__SpeechT5Processor = __webpack_exports__.SpeechT5Processor;
var __webpack_exports__SpeechT5Tokenizer = __webpack_exports__.SpeechT5Tokenizer;
var __webpack_exports__SqueezeBertForMaskedLM = __webpack_exports__.SqueezeBertForMaskedLM;
var __webpack_exports__SqueezeBertForQuestionAnswering = __webpack_exports__.SqueezeBertForQuestionAnswering;
var __webpack_exports__SqueezeBertForSequenceClassification = __webpack_exports__.SqueezeBertForSequenceClassification;
var __webpack_exports__SqueezeBertModel = __webpack_exports__.SqueezeBertModel;
var __webpack_exports__SqueezeBertPreTrainedModel = __webpack_exports__.SqueezeBertPreTrainedModel;
var __webpack_exports__SqueezeBertTokenizer = __webpack_exports__.SqueezeBertTokenizer;
var __webpack_exports__StableLmForCausalLM = __webpack_exports__.StableLmForCausalLM;
var __webpack_exports__StableLmModel = __webpack_exports__.StableLmModel;
var __webpack_exports__StableLmPreTrainedModel = __webpack_exports__.StableLmPreTrainedModel;
var __webpack_exports__Starcoder2ForCausalLM = __webpack_exports__.Starcoder2ForCausalLM;
var __webpack_exports__Starcoder2Model = __webpack_exports__.Starcoder2Model;
var __webpack_exports__Starcoder2PreTrainedModel = __webpack_exports__.Starcoder2PreTrainedModel;
var __webpack_exports__StoppingCriteria = __webpack_exports__.StoppingCriteria;
var __webpack_exports__StoppingCriteriaList = __webpack_exports__.StoppingCriteriaList;
var __webpack_exports__StyleTextToSpeech2Model = __webpack_exports__.StyleTextToSpeech2Model;
var __webpack_exports__StyleTextToSpeech2PreTrainedModel = __webpack_exports__.StyleTextToSpeech2PreTrainedModel;
var __webpack_exports__SummarizationPipeline = __webpack_exports__.SummarizationPipeline;
var __webpack_exports__SupertonicForConditionalGeneration = __webpack_exports__.SupertonicForConditionalGeneration;
var __webpack_exports__SupertonicPreTrainedModel = __webpack_exports__.SupertonicPreTrainedModel;
var __webpack_exports__SuppressTokensAtBeginLogitsProcessor = __webpack_exports__.SuppressTokensAtBeginLogitsProcessor;
var __webpack_exports__Swin2SRForImageSuperResolution = __webpack_exports__.Swin2SRForImageSuperResolution;
var __webpack_exports__Swin2SRImageProcessor = __webpack_exports__.Swin2SRImageProcessor;
var __webpack_exports__Swin2SRModel = __webpack_exports__.Swin2SRModel;
var __webpack_exports__Swin2SRPreTrainedModel = __webpack_exports__.Swin2SRPreTrainedModel;
var __webpack_exports__SwinForImageClassification = __webpack_exports__.SwinForImageClassification;
var __webpack_exports__SwinForSemanticSegmentation = __webpack_exports__.SwinForSemanticSegmentation;
var __webpack_exports__SwinModel = __webpack_exports__.SwinModel;
var __webpack_exports__SwinPreTrainedModel = __webpack_exports__.SwinPreTrainedModel;
var __webpack_exports__T5ForConditionalGeneration = __webpack_exports__.T5ForConditionalGeneration;
var __webpack_exports__T5Model = __webpack_exports__.T5Model;
var __webpack_exports__T5PreTrainedModel = __webpack_exports__.T5PreTrainedModel;
var __webpack_exports__T5Tokenizer = __webpack_exports__.T5Tokenizer;
var __webpack_exports__TableTransformerForObjectDetection = __webpack_exports__.TableTransformerForObjectDetection;
var __webpack_exports__TableTransformerModel = __webpack_exports__.TableTransformerModel;
var __webpack_exports__TableTransformerObjectDetectionOutput = __webpack_exports__.TableTransformerObjectDetectionOutput;
var __webpack_exports__TableTransformerPreTrainedModel = __webpack_exports__.TableTransformerPreTrainedModel;
var __webpack_exports__TemperatureLogitsWarper = __webpack_exports__.TemperatureLogitsWarper;
var __webpack_exports__Tensor = __webpack_exports__.Tensor;
var __webpack_exports__Text2TextGenerationPipeline = __webpack_exports__.Text2TextGenerationPipeline;
var __webpack_exports__TextClassificationPipeline = __webpack_exports__.TextClassificationPipeline;
var __webpack_exports__TextGenerationPipeline = __webpack_exports__.TextGenerationPipeline;
var __webpack_exports__TextStreamer = __webpack_exports__.TextStreamer;
var __webpack_exports__TextToAudioPipeline = __webpack_exports__.TextToAudioPipeline;
var __webpack_exports__TokenClassificationPipeline = __webpack_exports__.TokenClassificationPipeline;
var __webpack_exports__TokenClassifierOutput = __webpack_exports__.TokenClassifierOutput;
var __webpack_exports__TokenizerModel = __webpack_exports__.TokenizerModel;
var __webpack_exports__TopKLogitsWarper = __webpack_exports__.TopKLogitsWarper;
var __webpack_exports__TopPLogitsWarper = __webpack_exports__.TopPLogitsWarper;
var __webpack_exports__TrOCRForCausalLM = __webpack_exports__.TrOCRForCausalLM;
var __webpack_exports__TrOCRPreTrainedModel = __webpack_exports__.TrOCRPreTrainedModel;
var __webpack_exports__TranslationPipeline = __webpack_exports__.TranslationPipeline;
var __webpack_exports__UltravoxModel = __webpack_exports__.UltravoxModel;
var __webpack_exports__UltravoxPreTrainedModel = __webpack_exports__.UltravoxPreTrainedModel;
var __webpack_exports__UltravoxProcessor = __webpack_exports__.UltravoxProcessor;
var __webpack_exports__UniSpeechForCTC = __webpack_exports__.UniSpeechForCTC;
var __webpack_exports__UniSpeechForSequenceClassification = __webpack_exports__.UniSpeechForSequenceClassification;
var __webpack_exports__UniSpeechModel = __webpack_exports__.UniSpeechModel;
var __webpack_exports__UniSpeechPreTrainedModel = __webpack_exports__.UniSpeechPreTrainedModel;
var __webpack_exports__UniSpeechSatForAudioFrameClassification = __webpack_exports__.UniSpeechSatForAudioFrameClassification;
var __webpack_exports__UniSpeechSatForCTC = __webpack_exports__.UniSpeechSatForCTC;
var __webpack_exports__UniSpeechSatForSequenceClassification = __webpack_exports__.UniSpeechSatForSequenceClassification;
var __webpack_exports__UniSpeechSatModel = __webpack_exports__.UniSpeechSatModel;
var __webpack_exports__UniSpeechSatPreTrainedModel = __webpack_exports__.UniSpeechSatPreTrainedModel;
var __webpack_exports__VLChatProcessor = __webpack_exports__.VLChatProcessor;
var __webpack_exports__VLMImageProcessor = __webpack_exports__.VLMImageProcessor;
var __webpack_exports__VaultGemmaForCausalLM = __webpack_exports__.VaultGemmaForCausalLM;
var __webpack_exports__VaultGemmaModel = __webpack_exports__.VaultGemmaModel;
var __webpack_exports__VaultGemmaPreTrainedModel = __webpack_exports__.VaultGemmaPreTrainedModel;
var __webpack_exports__ViTFeatureExtractor = __webpack_exports__.ViTFeatureExtractor;
var __webpack_exports__ViTForImageClassification = __webpack_exports__.ViTForImageClassification;
var __webpack_exports__ViTImageProcessor = __webpack_exports__.ViTImageProcessor;
var __webpack_exports__ViTMAEModel = __webpack_exports__.ViTMAEModel;
var __webpack_exports__ViTMAEPreTrainedModel = __webpack_exports__.ViTMAEPreTrainedModel;
var __webpack_exports__ViTMSNForImageClassification = __webpack_exports__.ViTMSNForImageClassification;
var __webpack_exports__ViTMSNModel = __webpack_exports__.ViTMSNModel;
var __webpack_exports__ViTMSNPreTrainedModel = __webpack_exports__.ViTMSNPreTrainedModel;
var __webpack_exports__ViTModel = __webpack_exports__.ViTModel;
var __webpack_exports__ViTPreTrainedModel = __webpack_exports__.ViTPreTrainedModel;
var __webpack_exports__VisionEncoderDecoderModel = __webpack_exports__.VisionEncoderDecoderModel;
var __webpack_exports__VitMatteForImageMatting = __webpack_exports__.VitMatteForImageMatting;
var __webpack_exports__VitMatteImageProcessor = __webpack_exports__.VitMatteImageProcessor;
var __webpack_exports__VitMattePreTrainedModel = __webpack_exports__.VitMattePreTrainedModel;
var __webpack_exports__VitPoseForPoseEstimation = __webpack_exports__.VitPoseForPoseEstimation;
var __webpack_exports__VitPoseImageProcessor = __webpack_exports__.VitPoseImageProcessor;
var __webpack_exports__VitPosePreTrainedModel = __webpack_exports__.VitPosePreTrainedModel;
var __webpack_exports__VitsModel = __webpack_exports__.VitsModel;
var __webpack_exports__VitsModelOutput = __webpack_exports__.VitsModelOutput;
var __webpack_exports__VitsPreTrainedModel = __webpack_exports__.VitsPreTrainedModel;
var __webpack_exports__VitsTokenizer = __webpack_exports__.VitsTokenizer;
var __webpack_exports__VoxtralForConditionalGeneration = __webpack_exports__.VoxtralForConditionalGeneration;
var __webpack_exports__VoxtralProcessor = __webpack_exports__.VoxtralProcessor;
var __webpack_exports__Wav2Vec2BertForCTC = __webpack_exports__.Wav2Vec2BertForCTC;
var __webpack_exports__Wav2Vec2BertForSequenceClassification = __webpack_exports__.Wav2Vec2BertForSequenceClassification;
var __webpack_exports__Wav2Vec2BertModel = __webpack_exports__.Wav2Vec2BertModel;
var __webpack_exports__Wav2Vec2BertPreTrainedModel = __webpack_exports__.Wav2Vec2BertPreTrainedModel;
var __webpack_exports__Wav2Vec2CTCTokenizer = __webpack_exports__.Wav2Vec2CTCTokenizer;
var __webpack_exports__Wav2Vec2FeatureExtractor = __webpack_exports__.Wav2Vec2FeatureExtractor;
var __webpack_exports__Wav2Vec2ForAudioFrameClassification = __webpack_exports__.Wav2Vec2ForAudioFrameClassification;
var __webpack_exports__Wav2Vec2ForCTC = __webpack_exports__.Wav2Vec2ForCTC;
var __webpack_exports__Wav2Vec2ForSequenceClassification = __webpack_exports__.Wav2Vec2ForSequenceClassification;
var __webpack_exports__Wav2Vec2Model = __webpack_exports__.Wav2Vec2Model;
var __webpack_exports__Wav2Vec2PreTrainedModel = __webpack_exports__.Wav2Vec2PreTrainedModel;
var __webpack_exports__Wav2Vec2Processor = __webpack_exports__.Wav2Vec2Processor;
var __webpack_exports__Wav2Vec2ProcessorWithLM = __webpack_exports__.Wav2Vec2ProcessorWithLM;
var __webpack_exports__WavLMForAudioFrameClassification = __webpack_exports__.WavLMForAudioFrameClassification;
var __webpack_exports__WavLMForCTC = __webpack_exports__.WavLMForCTC;
var __webpack_exports__WavLMForSequenceClassification = __webpack_exports__.WavLMForSequenceClassification;
var __webpack_exports__WavLMForXVector = __webpack_exports__.WavLMForXVector;
var __webpack_exports__WavLMModel = __webpack_exports__.WavLMModel;
var __webpack_exports__WavLMPreTrainedModel = __webpack_exports__.WavLMPreTrainedModel;
var __webpack_exports__WeSpeakerFeatureExtractor = __webpack_exports__.WeSpeakerFeatureExtractor;
var __webpack_exports__WeSpeakerResNetModel = __webpack_exports__.WeSpeakerResNetModel;
var __webpack_exports__WeSpeakerResNetPreTrainedModel = __webpack_exports__.WeSpeakerResNetPreTrainedModel;
var __webpack_exports__WhisperFeatureExtractor = __webpack_exports__.WhisperFeatureExtractor;
var __webpack_exports__WhisperForConditionalGeneration = __webpack_exports__.WhisperForConditionalGeneration;
var __webpack_exports__WhisperModel = __webpack_exports__.WhisperModel;
var __webpack_exports__WhisperPreTrainedModel = __webpack_exports__.WhisperPreTrainedModel;
var __webpack_exports__WhisperProcessor = __webpack_exports__.WhisperProcessor;
var __webpack_exports__WhisperTextStreamer = __webpack_exports__.WhisperTextStreamer;
var __webpack_exports__WhisperTimeStampLogitsProcessor = __webpack_exports__.WhisperTimeStampLogitsProcessor;
var __webpack_exports__WhisperTokenizer = __webpack_exports__.WhisperTokenizer;
var __webpack_exports__XLMForQuestionAnswering = __webpack_exports__.XLMForQuestionAnswering;
var __webpack_exports__XLMForSequenceClassification = __webpack_exports__.XLMForSequenceClassification;
var __webpack_exports__XLMForTokenClassification = __webpack_exports__.XLMForTokenClassification;
var __webpack_exports__XLMModel = __webpack_exports__.XLMModel;
var __webpack_exports__XLMPreTrainedModel = __webpack_exports__.XLMPreTrainedModel;
var __webpack_exports__XLMRobertaForMaskedLM = __webpack_exports__.XLMRobertaForMaskedLM;
var __webpack_exports__XLMRobertaForQuestionAnswering = __webpack_exports__.XLMRobertaForQuestionAnswering;
var __webpack_exports__XLMRobertaForSequenceClassification = __webpack_exports__.XLMRobertaForSequenceClassification;
var __webpack_exports__XLMRobertaForTokenClassification = __webpack_exports__.XLMRobertaForTokenClassification;
var __webpack_exports__XLMRobertaModel = __webpack_exports__.XLMRobertaModel;
var __webpack_exports__XLMRobertaPreTrainedModel = __webpack_exports__.XLMRobertaPreTrainedModel;
var __webpack_exports__XLMRobertaTokenizer = __webpack_exports__.XLMRobertaTokenizer;
var __webpack_exports__XLMTokenizer = __webpack_exports__.XLMTokenizer;
var __webpack_exports__XLMWithLMHeadModel = __webpack_exports__.XLMWithLMHeadModel;
var __webpack_exports__XVectorOutput = __webpack_exports__.XVectorOutput;
var __webpack_exports__YolosFeatureExtractor = __webpack_exports__.YolosFeatureExtractor;
var __webpack_exports__YolosForObjectDetection = __webpack_exports__.YolosForObjectDetection;
var __webpack_exports__YolosImageProcessor = __webpack_exports__.YolosImageProcessor;
var __webpack_exports__YolosModel = __webpack_exports__.YolosModel;
var __webpack_exports__YolosObjectDetectionOutput = __webpack_exports__.YolosObjectDetectionOutput;
var __webpack_exports__YolosPreTrainedModel = __webpack_exports__.YolosPreTrainedModel;
var __webpack_exports__ZeroShotAudioClassificationPipeline = __webpack_exports__.ZeroShotAudioClassificationPipeline;
var __webpack_exports__ZeroShotClassificationPipeline = __webpack_exports__.ZeroShotClassificationPipeline;
var __webpack_exports__ZeroShotImageClassificationPipeline = __webpack_exports__.ZeroShotImageClassificationPipeline;
var __webpack_exports__ZeroShotObjectDetectionPipeline = __webpack_exports__.ZeroShotObjectDetectionPipeline;
var __webpack_exports__bankers_round = __webpack_exports__.bankers_round;
var __webpack_exports__cat = __webpack_exports__.cat;
var __webpack_exports__cos_sim = __webpack_exports__.cos_sim;
var __webpack_exports__dot = __webpack_exports__.dot;
var __webpack_exports__dynamic_time_warping = __webpack_exports__.dynamic_time_warping;
var __webpack_exports__env = __webpack_exports__.env;
var __webpack_exports__full = __webpack_exports__.full;
var __webpack_exports__full_like = __webpack_exports__.full_like;
var __webpack_exports__getCacheShapes = __webpack_exports__.getCacheShapes;
var __webpack_exports__hamming = __webpack_exports__.hamming;
var __webpack_exports__hanning = __webpack_exports__.hanning;
var __webpack_exports__interpolate = __webpack_exports__.interpolate;
var __webpack_exports__interpolate_4d = __webpack_exports__.interpolate_4d;
var __webpack_exports__interpolate_data = __webpack_exports__.interpolate_data;
var __webpack_exports__is_chinese_char = __webpack_exports__.is_chinese_char;
var __webpack_exports__layer_norm = __webpack_exports__.layer_norm;
var __webpack_exports__load_image = __webpack_exports__.load_image;
var __webpack_exports__load_video = __webpack_exports__.load_video;
var __webpack_exports__log_softmax = __webpack_exports__.log_softmax;
var __webpack_exports__magnitude = __webpack_exports__.magnitude;
var __webpack_exports__matmul = __webpack_exports__.matmul;
var __webpack_exports__max = __webpack_exports__.max;
var __webpack_exports__mean = __webpack_exports__.mean;
var __webpack_exports__mean_pooling = __webpack_exports__.mean_pooling;
var __webpack_exports__medianFilter = __webpack_exports__.medianFilter;
var __webpack_exports__mel_filter_bank = __webpack_exports__.mel_filter_bank;
var __webpack_exports__min = __webpack_exports__.min;
var __webpack_exports__ones = __webpack_exports__.ones;
var __webpack_exports__ones_like = __webpack_exports__.ones_like;
var __webpack_exports__permute = __webpack_exports__.permute;
var __webpack_exports__permute_data = __webpack_exports__.permute_data;
var __webpack_exports__pipeline = __webpack_exports__.pipeline;
var __webpack_exports__quantize_embeddings = __webpack_exports__.quantize_embeddings;
var __webpack_exports__rand = __webpack_exports__.rand;
var __webpack_exports__randn = __webpack_exports__.randn;
var __webpack_exports__read_audio = __webpack_exports__.read_audio;
var __webpack_exports__rfft = __webpack_exports__.rfft;
var __webpack_exports__round = __webpack_exports__.round;
var __webpack_exports__slice = __webpack_exports__.slice;
var __webpack_exports__softmax = __webpack_exports__.softmax;
var __webpack_exports__spectrogram = __webpack_exports__.spectrogram;
var __webpack_exports__stack = __webpack_exports__.stack;
var __webpack_exports__std_mean = __webpack_exports__.std_mean;
var __webpack_exports__topk = __webpack_exports__.topk;
var __webpack_exports__window_function = __webpack_exports__.window_function;
var __webpack_exports__zeros = __webpack_exports__.zeros;
var __webpack_exports__zeros_like = __webpack_exports__.zeros_like;

// src/services/reranker-hf.ts
class HfBgeReranker {
  static instance;
  tokenizer = null;
  model = null;
  modelId = "Xenova/bge-reranker-base";
  constructor() {}
  static async getInstance() {
    if (!HfBgeReranker.instance) {
      HfBgeReranker.instance = new HfBgeReranker;
      await HfBgeReranker.instance.init();
    }
    return HfBgeReranker.instance;
  }
  async init() {
    console.log(`[Reranker] Initializing ${this.modelId} (ONNX via Transformers.js)...`);
    try {
      this.tokenizer = await __webpack_exports__AutoTokenizer.from_pretrained(this.modelId);
      this.model = await __webpack_exports__AutoModelForSequenceClassification.from_pretrained(this.modelId, {
        dtype: "q8"
      });
      console.log("[Reranker] Model operational.");
    } catch (err) {
      console.error("[Reranker] Initialization failed:", err);
      throw err;
    }
  }
  async rerank(query, documents, topK, threshold = 0) {
    if (!this.tokenizer || !this.model)
      throw new Error("Reranker not initialized. Call getInstance() first.");
    if (documents.length === 0)
      return [];
    try {
      const pairs = documents.map((doc3) => `${query} [SEP] ${doc3}`);
      const inputs = await this.tokenizer(pairs, {
        padding: true,
        truncation: true,
        return_tensors: "pt"
      });
      const { logits } = await this.model(inputs);
      const logitValues = Array.from(logits.data);
      const scored = documents.map((doc3, index) => {
        const logit = logitValues[index] ?? 0;
        const score = 1 / (1 + Math.exp(-logit));
        return {
          text: doc3,
          score,
          originalIndex: index
        };
      });
      const filtered = scored.filter((r) => r.score >= threshold).sort((a, b) => b.score - a.score);
      return topK ? filtered.slice(0, topK) : filtered;
    } catch (error49) {
      console.error("[Reranker] Reranking failed:", error49);
      throw error49;
    }
  }
}

// src/utils/reranker-client.ts
var rerankerInstance = null;
var initializationPromise = null;
var initializationFailed = false;
var RERANKER_DAEMON_URL = "http://localhost:3011";
async function rerankViaDaemon(query, documents, topK) {
  try {
    const response = await fetch(`${RERANKER_DAEMON_URL}/rerank`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        query,
        documents: documents.map((d) => d.content)
      }),
      signal: AbortSignal.timeout(5000)
    });
    if (!response.ok) {
      return null;
    }
    const daemonResult = await response.json();
    const rerankedDocs = daemonResult.results.slice(0, topK).map((result) => {
      const original = documents[result.originalIndex];
      if (!original) {
        throw new Error(`Invalid originalIndex ${result.originalIndex} in daemon rerank results`);
      }
      return {
        id: original.id,
        content: original.content,
        score: result.score,
        rerankScore: result.score
      };
    });
    log.info({
      query,
      docCount: documents.length,
      topK,
      method: "daemon"
    }, "Daemon reranking complete");
    return rerankedDocs;
  } catch (error49) {
    log.debug({ error: error49 }, "Daemon reranker unavailable");
    return null;
  }
}
async function getReranker() {
  if (initializationFailed) {
    return null;
  }
  if (rerankerInstance) {
    return rerankerInstance;
  }
  if (initializationPromise) {
    try {
      return await initializationPromise;
    } catch {
      return null;
    }
  }
  initializationPromise = HfBgeReranker.getInstance();
  try {
    rerankerInstance = await initializationPromise;
    log.info("Reranker initialized successfully");
    return rerankerInstance;
  } catch (error49) {
    initializationFailed = true;
    log.warn({ error: error49 }, "Reranker initialization failed - will skip reranking");
    return null;
  } finally {
    initializationPromise = null;
  }
}
async function rerankDocuments(query, documents, topK = 20) {
  try {
    const daemonResult = await rerankViaDaemon(query, documents, topK);
    if (daemonResult) {
      return daemonResult;
    }
  } catch (error49) {
    log.debug({ error: error49 }, "Daemon reranker failed, trying local");
  }
  const reranker = await getReranker();
  if (!reranker) {
    log.debug("Reranker not available, skipping reranking");
    return documents;
  }
  if (documents.length === 0) {
    return documents;
  }
  try {
    const startTime = Date.now();
    const contents = documents.map((doc3) => doc3.content);
    const rerankedResults = await reranker.rerank(query, contents, topK);
    const elapsedMs = Date.now() - startTime;
    log.info({
      query,
      docCount: documents.length,
      topK,
      elapsedMs
    }, "Reranking complete");
    const rerankedDocs = rerankedResults.map((result) => {
      const originalDoc = documents[result.originalIndex];
      if (!originalDoc) {
        throw new Error(`Invalid originalIndex ${result.originalIndex} in rerank results`);
      }
      return {
        ...originalDoc,
        rerankScore: result.score,
        score: result.score
      };
    });
    return rerankedDocs;
  } catch (error49) {
    log.error({ error: error49, query }, "Reranking failed, returning original order");
    return documents;
  }
}

// src/cli/commands/search.ts
async function cmdSearch(args) {
  const query = args.find((arg) => !arg.startsWith("--"));
  let limit = 20;
  const limitEqIdx = args.findIndex((arg) => arg.startsWith("--limit="));
  const limitSpaceIdx = args.indexOf("--limit");
  if (limitEqIdx !== -1) {
    limit = Number.parseInt(args[limitEqIdx]?.split("=")[1] || "20", 10);
  } else if (limitSpaceIdx !== -1 && args[limitSpaceIdx + 1]) {
    limit = Number.parseInt(args[limitSpaceIdx + 1] || "20", 10);
  }
  const jsonOutput = args.includes("--json");
  const useReranker = args.includes("--rerank");
  if (!query) {
    if (jsonOutput) {
      console.error(JSON.stringify({
        error: "Missing query argument",
        usage: "amalfa search <query> [--limit N] [--rerank] [--json]"
      }));
    } else {
      console.error("\u274C Error: Missing query argument");
      console.error(`
Usage: amalfa search <query> [--limit N] [--rerank] [--json]`);
      console.error(`
Examples:`);
      console.error('  amalfa search "oauth patterns"');
      console.error('  amalfa search "database migrations" --limit 5');
      console.error('  amalfa search "context" --rerank');
      console.error('  amalfa search "auth" --json');
    }
    process.exit(1);
  }
  if (!await checkDatabase()) {
    if (jsonOutput) {
      console.error(JSON.stringify({
        error: "Database not found",
        suggestion: "Run 'amalfa init' first"
      }));
    } else {
      console.error("\u274C Database not found. Run 'amalfa init' first.");
    }
    process.exit(1);
  }
  const dbPath = await getDbPath();
  const db = new ResonanceDB(dbPath);
  const vectorEngine = new VectorEngine(db.getRawDb());
  const grepEngine = new GrepEngine;
  grepEngine.setDb(db.getRawDb());
  const graphEngine = new GraphEngine;
  await graphEngine.load(db.getRawDb());
  const gardener = new GraphGardener(db, graphEngine, vectorEngine);
  const hydrator = new ContentHydrator(gardener);
  try {
    const fetchLimit = useReranker ? Math.min(limit * 3, 50) : limit;
    if (!jsonOutput)
      console.log(`\uD83D\uDD0D Searching for "${query}"...`);
    const [vectorResults, grepResults] = await Promise.all([
      vectorEngine.search(query, fetchLimit),
      grepEngine.search(query, fetchLimit)
    ]);
    const candidates = new Map;
    for (const r of vectorResults) {
      candidates.set(r.id, {
        id: r.id,
        score: r.score,
        title: r.title || r.id,
        source: "vector",
        preview: r.title || r.id
      });
    }
    for (const r of grepResults) {
      const existing = candidates.get(r.id);
      if (existing) {
        existing.source = "hybrid";
        existing.preview = `[Match: ${r.content.substring(0, 40)}...] ${existing.title}`;
      } else {
        candidates.set(r.id, {
          id: r.id,
          score: 0.9,
          title: r.id,
          source: "grep",
          preview: `[Match] ${r.content.substring(0, 50)}...`
        });
      }
    }
    let results = Array.from(candidates.values());
    if (useReranker) {
      if (!jsonOutput)
        console.log("\uD83D\uDD04 Reranking hybrid results...");
      const hydrated = await hydrator.hydrateMany(results.map((r) => ({ ...r, content: "" })));
      const reranked = await rerankDocuments(query, hydrated, limit);
      results = reranked.map((r) => {
        const original = candidates.get(r.id);
        return {
          id: r.id,
          score: r.score,
          title: original?.title || r.id,
          rerankScore: r.rerankScore,
          source: `${original?.source}+rerank`,
          preview: original?.preview
        };
      });
    } else {
      results.sort((a, b) => b.score - a.score);
      results = results.slice(0, limit);
    }
    if (jsonOutput) {
      const jsonResults = results.map((r) => ({
        id: r.id,
        score: Number.parseFloat(r.score.toFixed(4)),
        preview: r.preview || r.title,
        source: r.source,
        reranked: useReranker
      }));
      console.log(JSON.stringify(jsonResults, null, 2));
    } else {
      if (results.length === 0) {
        console.log(`
\uD83D\uDD0D No results found for "${query}"
`);
        console.log("Try:");
        console.log("  - Broader search terms");
        console.log("  - Checking if documents are indexed (amalfa stats)");
      } else {
        console.log(`
\uD83D\uDD0D Found ${results.length} result(s) for "${query}"${useReranker ? " (Reranked)" : ""}:
`);
        for (let i = 0;i < results.length; i++) {
          const r = results[i];
          const index = i + 1;
          const score = r.score.toFixed(useReranker ? 4 : 3);
          const sourceBadge = r.source?.includes("grep") || r.source?.includes("hybrid") ? " [\uD83C\uDFAF Exact]" : "";
          console.log(`${index}. ${r.id} (score: ${score})${sourceBadge}`);
          console.log(`   ${r.preview || r.title}
`);
        }
        console.log(`\uD83D\uDCA1 Tip: Use 'amalfa read <id>' to view full content of a result
`);
      }
    }
  } catch (error49) {
    if (jsonOutput) {
      console.error(JSON.stringify({
        error: error49 instanceof Error ? error49.message : String(error49)
      }));
    } else {
      console.error("\u274C Search failed:", error49 instanceof Error ? error49.message : error49);
    }
    process.exit(1);
  } finally {
    db.close();
  }
}

// src/cli/commands/server.ts
init_defaults();
import { spawn as spawn3 } from "child_process";
import { existsSync as existsSync15, readFileSync as readFileSync6, unlinkSync } from "fs";
import { join as join18 } from "path";
async function cmdServe(_args) {
  if (!await checkDatabase()) {
    process.exit(1);
  }
  const dbPath = await getDbPath();
  console.error("\uD83D\uDE80 Starting AMALFA MCP Server...");
  console.error(`\uD83D\uDCCA Database: ${dbPath}`);
  console.error("");
  const serverPath = join18(process.cwd(), "src/mcp/index.ts");
  const proc = spawn3("bun", ["run", serverPath, "serve"], {
    stdio: "inherit",
    cwd: process.cwd()
  });
  proc.on("exit", (code) => {
    process.exit(code ?? 0);
  });
}
async function cmdServers(args) {
  const action = args[1];
  if (action && !action.startsWith("-") && ["start", "stop", "restart", "status"].includes(action)) {
    if (action === "status") {} else {
      await manageAllServers(action);
      return;
    }
  }
  const showDot = args.includes("--dot");
  const SERVICES = [
    {
      name: "MCP Server",
      pidFile: join18(AMALFA_DIRS.runtime, "mcp.pid"),
      port: "stdio",
      id: "mcp",
      cmd: "amalfa serve"
    },
    {
      name: "Vector Daemon",
      pidFile: join18(AMALFA_DIRS.runtime, "vector-daemon.pid"),
      port: "3010",
      id: "vector",
      cmd: "amalfa vector start"
    },
    {
      name: "Reranker Daemon",
      pidFile: join18(AMALFA_DIRS.runtime, "reranker-daemon.pid"),
      port: "3011",
      id: "reranker",
      cmd: "amalfa reranker start"
    },
    {
      name: "File Watcher",
      pidFile: join18(AMALFA_DIRS.runtime, "daemon.pid"),
      port: "-",
      id: "watcher",
      cmd: "amalfa daemon start"
    },
    {
      name: "Sonar Agent",
      pidFile: join18(AMALFA_DIRS.runtime, "sonar.pid"),
      port: "3012",
      id: "sonar",
      cmd: "amalfa sonar start"
    },
    {
      name: "Dashboard",
      pidFile: join18(AMALFA_DIRS.runtime, "dashboard.pid"),
      port: "3013",
      id: "dashboard",
      cmd: "amalfa dashboard start"
    }
  ];
  async function isRunning(pid) {
    try {
      process.kill(pid, 0);
      return true;
    } catch {
      return false;
    }
  }
  if (showDot) {
    const statuses = new Map;
    for (const svc of SERVICES) {
      let status = "stopped";
      let pidStr = "-";
      if (existsSync15(svc.pidFile)) {
        try {
          const text = readFileSync6(svc.pidFile, "utf-8");
          const pid = Number.parseInt(text.trim(), 10);
          if (!Number.isNaN(pid) && await isRunning(pid)) {
            status = "running";
            pidStr = pid.toString();
          } else {
            status = "stale";
            pidStr = `${pid}`;
          }
        } catch {}
      }
      statuses.set(svc.id, { status, pid: pidStr });
    }
    console.log("digraph AMALFA {");
    console.log("  rankdir=LR;");
    console.log("  node [shape=box, style=filled];");
    console.log("");
    console.log("  // Nodes");
    for (const svc of SERVICES) {
      const st = statuses.get(svc.id);
      const color = st?.status === "running" ? "lightgreen" : st?.status === "stale" ? "orange" : "lightgray";
      const label = `${svc.name}\\nPort: ${svc.port}\\nPID: ${st?.pid || "-"}`;
      console.log(`  ${svc.id} [label="${label}", fillcolor=${color}];`);
    }
    console.log("");
    console.log("  // Database");
    console.log('  db [label="SQLite\\n.amalfa/resonance.db", shape=cylinder, fillcolor=lightyellow];');
    console.log("");
    console.log("  // Connections");
    console.log('  mcp -> db [label="read/write"];');
    console.log('  vector -> db [label="embeddings"];');
    console.log('  watcher -> db [label="updates"];');
    console.log('  mcp -> vector [label="query", style=dashed];');
    console.log('  vector -> reranker [label="rerank", style=dashed];');
    console.log("}");
    console.log("");
    console.log("# Save to file: amalfa servers --dot > amalfa.dot");
    console.log("# Render: dot -Tpng amalfa.dot -o amalfa.png");
    return;
  }
  console.log(`
\uD83D\uDCE1 AMALFA Service Status
`);
  console.log("\u2500".repeat(95));
  console.log("SERVICE".padEnd(18) + "COMMAND".padEnd(25) + "PORT".padEnd(12) + "STATUS".padEnd(15) + "PID".padEnd(10));
  console.log("\u2500".repeat(95));
  for (const svc of SERVICES) {
    let status = "\u26AA\uFE0F STOPPED";
    let pidStr = "-";
    if (existsSync15(svc.pidFile)) {
      try {
        const text = readFileSync6(svc.pidFile, "utf-8");
        const pid = Number.parseInt(text.trim(), 10);
        if (!Number.isNaN(pid) && await isRunning(pid)) {
          status = "\uD83D\uDFE2 RUNNING";
          pidStr = pid.toString();
        } else {
          status = "\uD83D\uDD34 STALE";
          pidStr = `${pid} (?)`;
        }
      } catch {}
    }
    console.log(svc.name.padEnd(18) + svc.cmd.padEnd(25) + svc.port.padEnd(12) + status.padEnd(15) + pidStr.padEnd(10));
  }
  console.log("\u2500".repeat(95));
  console.log(`
\uD83D\uDCA1 Commands: amalfa servers [start|stop|restart] | amalfa vector start | amalfa daemon start
`);
}
var BACKGROUND_SERVICES = [
  {
    name: "Vector Daemon",
    cmd: "amalfa",
    args: ["vector", "start"]
  },
  {
    name: "Reranker Daemon",
    cmd: "amalfa",
    args: ["reranker", "start"]
  },
  {
    name: "File Watcher",
    cmd: "amalfa",
    args: ["daemon", "start"]
  },
  {
    name: "Sonar Agent",
    cmd: "amalfa",
    args: ["sonar", "start"]
  },
  {
    name: "Dashboard",
    cmd: "amalfa",
    args: ["dashboard", "start"]
  }
];
async function manageAllServers(action) {
  if (action === "stop" || action === "restart") {
    await cmdStopAll([]);
  }
  if (action === "start" || action === "restart") {
    console.log(`\uD83D\uDE80 Starting background services...
`);
    for (const svc of BACKGROUND_SERVICES) {
      console.log(`\u25B6\uFE0F  Starting ${svc.name}...`);
      const child = spawn3(svc.cmd, svc.args, {
        detached: true,
        stdio: "ignore",
        cwd: process.cwd()
      });
      child.unref();
      await new Promise((resolve4) => setTimeout(resolve4, 500));
    }
    console.log(`
\u2705 All background services triggered.`);
    console.log("Run 'amalfa servers' to check status.");
  }
}
async function cmdStopAll(_args) {
  console.log(`\uD83D\uDED1 Stopping ALL Amalfa Services...
`);
  const SERVICES = [
    {
      name: "Vector Daemon",
      pidFile: join18(AMALFA_DIRS.runtime, "vector-daemon.pid")
    },
    {
      name: "Reranker Daemon",
      pidFile: join18(AMALFA_DIRS.runtime, "reranker-daemon.pid")
    },
    { name: "File Watcher", pidFile: join18(AMALFA_DIRS.runtime, "daemon.pid") },
    { name: "Sonar Agent", pidFile: join18(AMALFA_DIRS.runtime, "sonar.pid") },
    { name: "Dashboard", pidFile: join18(AMALFA_DIRS.runtime, "dashboard.pid") },
    { name: "MCP Server", pidFile: join18(AMALFA_DIRS.runtime, "mcp.pid") }
  ];
  let stoppedCount = 0;
  for (const svc of SERVICES) {
    if (existsSync15(svc.pidFile)) {
      try {
        const pidStr = readFileSync6(svc.pidFile, "utf-8").trim();
        const pid = Number.parseInt(pidStr, 10);
        if (!Number.isNaN(pid)) {
          try {
            process.kill(pid, 0);
            process.kill(pid, "SIGTERM");
            console.log(`\u2705 Sent SIGTERM to ${svc.name} (PID: ${pid})`);
            stoppedCount++;
          } catch {
            console.log(`\uD83E\uDDF9 Cleaning stale PID file for ${svc.name}`);
          }
        }
      } catch (e) {
        console.warn(`\u26A0\uFE0F Failed to stop ${svc.name}:`, e);
      }
      try {
        unlinkSync(svc.pidFile);
      } catch {}
    }
  }
  if (stoppedCount === 0) {
    console.log("\u2728 No active services found.");
  } else {
    console.log(`
\u2705 Stopped ${stoppedCount} service(s).`);
  }
}

// src/cli/commands/services.ts
init_defaults();
import { existsSync as existsSync18 } from "fs";

// src/ember/index.ts
import { join as join19 } from "path";
var {Glob: Glob2 } = globalThis.Bun;

// src/ember/analyzer.ts
class EmberAnalyzer {
  db;
  langClient;
  log = getLogger("EmberAnalyzer");
  graphEngine;
  communities = null;
  isGraphLoaded = false;
  constructor(db, langClient) {
    this.db = db;
    this.langClient = langClient;
    this.graphEngine = new GraphEngine;
  }
  async prepare() {
    this.log.info("Loading graph engine for analysis...");
    await this.graphEngine.load(this.db.getRawDb());
    this.communities = this.graphEngine.detectCommunities();
    this.isGraphLoaded = true;
    this.log.info("Graph engine ready.");
  }
  async analyze(filePath, content) {
    this.log.info(`Analyzing ${filePath}...`);
    if (!this.isGraphLoaded) {
      await this.prepare();
    }
    const filename = filePath.split("/").pop() || "unknown";
    const id = filename.replace(/\.(md|ts|js)$/, "").toLowerCase().replace(/[^a-z0-9-]/g, "-");
    const node = this.db.getNode(id);
    if (!node) {
      this.log.warn(`Node ${id} not found in graph. Skipping analysis.`);
      return null;
    }
    const proposedTags = [];
    const proposedLinks = [];
    let extractedGraph;
    if (this.communities && this.communities[id] !== undefined) {
      const communityId = this.communities[id];
      const communityNodes = Object.entries(this.communities).filter(([_, comm]) => comm === communityId).map(([nId]) => nId);
      if (communityNodes.length > 2) {
        const tagFreq = new Map;
        let neighborCount = 0;
        const neighbors = this.graphEngine.getNeighbors(id);
        for (const neighborId of neighbors) {
          const neighbor = this.db.getNode(neighborId);
          const rawTags = neighbor?.meta?.tags;
          const nTags = Array.isArray(rawTags) ? rawTags : typeof rawTags === "string" ? [rawTags] : [];
          for (const tag of nTags) {
            tagFreq.set(tag, (tagFreq.get(tag) || 0) + 1);
          }
          neighborCount++;
        }
        if (neighborCount > 0) {
          for (const [tag, count] of tagFreq.entries()) {
            if (count / neighborCount >= 0.5) {
              const rawNodeTags = node.meta?.tags;
              const currentTags = Array.isArray(rawNodeTags) ? rawNodeTags : typeof rawNodeTags === "string" ? [rawNodeTags] : [];
              if (!currentTags.includes(tag) && !proposedTags.includes(tag)) {
                proposedTags.push(tag);
              }
            }
          }
        }
      }
    }
    const tags = node.meta?.tags || [];
    if (content.length < 100 && !tags.includes("stub")) {
      proposedTags.push("stub");
    }
    if (this.langClient && content.length > 200) {
      try {
        const currentTags = Array.isArray(node.meta?.tags) ? node.meta?.tags : [];
        const extracted = await this.langClient.extract(content);
        extractedGraph = extracted;
        if (extracted?.entities && Array.isArray(extracted.entities)) {
          this.log.debug({ file: filename, count: extracted.entities.length }, "Extracted entities via Sidecar");
          for (const ent of extracted.entities) {
            const tagName = ent.name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-+|-+$/g, "");
            if (tagName.length > 1 && !/^[\d-]+$/.test(tagName) && !currentTags.includes(tagName) && !proposedTags.includes(tagName)) {
              proposedTags.push(tagName);
            }
          }
        }
      } catch (e) {
        this.log.warn({ err: e }, "LangExtract sidecar failed for file");
      }
    }
    if (proposedTags.length === 0 && proposedLinks.length === 0 && !extractedGraph) {
      return null;
    }
    const sidecar = {
      targetFile: toRootRelative(filePath),
      generatedAt: new Date().toISOString(),
      confidence: 0.8,
      graphData: extractedGraph || undefined,
      changes: {
        tags: proposedTags.length > 0 ? { add: proposedTags } : undefined,
        links: proposedLinks.length > 0 ? { add: proposedLinks } : undefined
      }
    };
    return sidecar;
  }
}

// src/ember/generator.ts
class EmberGenerator {
  log = getLogger("EmberGenerator");
  async generate(sidecar) {
    const sidecarPath = `${sidecar.targetFile}.ember.json`;
    try {
      await Bun.write(sidecarPath, JSON.stringify(sidecar, null, 2));
      this.log.info(`Generated sidecar: ${sidecarPath}`);
      return sidecarPath;
    } catch (error49) {
      this.log.error({ err: error49, file: sidecarPath }, "Failed to write sidecar");
      throw error49;
    }
  }
}

// src/ember/squasher.ts
import { unlink } from "fs/promises";

// src/utils/ghost.ts
var import_gray_matter2 = __toESM(require_gray_matter(), 1);
import { execSync } from "child_process";
import { createHash as createHash2 } from "crypto";
function getSubstanceHash(content, filePath) {
  const ext = filePath.split(".").pop()?.toLowerCase();
  let substance = content;
  if (ext === "md" || ext === "markdown") {
    try {
      const parsed = import_gray_matter2.default(content);
      substance = parsed.content.trim();
    } catch (_e) {
      substance = content.trim();
    }
  } else if (ext === "ts" || ext === "js" || ext === "json") {
    substance = content.split(`
`).filter((line) => !line.includes("amalfa_hash") && !line.includes("git_signature")).join(`
`).trim();
  }
  substance = substance.replace(/\r\n/g, `
`);
  return createHash2("sha256").update(substance).digest("hex");
}
function commitFile(filePath, message) {
  try {
    execSync(`git add "${filePath}"`);
    execSync(`git commit -m "${message}"`);
    return true;
  } catch (_e) {
    return false;
  }
}

// src/ember/squasher.ts
var import_gray_matter3 = __toESM(require_gray_matter(), 1);

class EmberSquasher {
  log = getLogger("EmberSquasher");
  async squash(sidecarPath) {
    try {
      const sidecarContent = await Bun.file(sidecarPath).text();
      const sidecar = JSON.parse(sidecarContent);
      const targetPath = sidecar.targetFile;
      const fileContent = await Bun.file(targetPath).text();
      const parsed = import_gray_matter3.default(fileContent);
      const data = parsed.data || {};
      if (sidecar.changes.tags) {
        const currentTags = Array.isArray(data.tags) ? data.tags : [];
        const toAdd = sidecar.changes.tags.add || [];
        const toRemove = sidecar.changes.tags.remove || [];
        const newTags = new Set(currentTags);
        for (const t of toAdd) {
          newTags.add(t);
        }
        for (const t of toRemove) {
          newTags.delete(t);
        }
        data.tags = Array.from(newTags);
      }
      if (sidecar.changes.frontmatter) {
        Object.assign(data, sidecar.changes.frontmatter);
      }
      if (sidecar.changes.summary) {
        data.summary = sidecar.changes.summary;
      }
      const substanceHash = getSubstanceHash(parsed.content, targetPath);
      data.amalfa_hash = substanceHash;
      const newContent = import_gray_matter3.default.stringify(parsed.content, data);
      await Bun.write(targetPath, newContent);
      const committed = commitFile(targetPath, "chore(ember): squash sidecar insights");
      if (committed) {
        this.log.info({ targetPath }, "\uD83D\uDD0F Sealed and commited file");
      } else {
        this.log.warn({ targetPath }, "\u26A0\uFE0F  Failed to commit file (Ghost Signature active but not committed)");
      }
      this.log.info(`Squashed sidecar into ${targetPath}`);
      await unlink(sidecarPath);
    } catch (error49) {
      this.log.error({ err: error49, file: sidecarPath }, "Failed to squash sidecar");
      throw error49;
    }
  }
}

// src/ember/index.ts
class EmberService {
  config;
  analyzer;
  generator;
  squasher;
  langClient;
  log = getLogger("EmberService");
  constructor(db, config3) {
    this.config = config3;
    this.langClient = new LangExtractClient;
    this.analyzer = new EmberAnalyzer(db, this.langClient);
    this.generator = new EmberGenerator;
    this.squasher = new EmberSquasher;
  }
  async runFullSweep(dryRun = false) {
    this.log.info("Starting full Ember sweep...");
    const files = await this.discoverFiles();
    let enrichedCount = 0;
    for (const file2 of files) {
      const content = await Bun.file(file2).text();
      const sidecar = await this.analyzer.analyze(file2, content);
      if (sidecar) {
        if (dryRun) {
          this.log.info(`[Dry Run] Would generate sidecar for ${file2}`);
          console.log(JSON.stringify(sidecar, null, 2));
        } else {
          await this.generator.generate(sidecar);
          enrichedCount++;
        }
      }
    }
    this.log.info(`Sweep complete. Enriched ${enrichedCount} files.`);
    return enrichedCount;
  }
  async analyze(filePath, content) {
    return this.analyzer.analyze(filePath, content);
  }
  async generate(sidecar) {
    return this.generator.generate(sidecar);
  }
  async squashAll() {
    this.log.info("Squashing all pending sidecars...");
    let count = 0;
    const sidecars = await this.findSidecars();
    for (const sidecarPath of sidecars) {
      await this.squasher.squash(sidecarPath);
      count++;
    }
    this.log.info(`Squashed ${count} sidecars.`);
    return count;
  }
  async findSidecars() {
    const sidecars = [];
    const glob = new Glob2("**/*.ember.json");
    const sources = this.config.sources || ["./docs"];
    for (const source of sources) {
      const sourcePath = join19(process.cwd(), source);
      for (const file2 of glob.scanSync({ cwd: sourcePath })) {
        sidecars.push(join19(sourcePath, file2));
      }
    }
    return sidecars;
  }
  async discoverFiles() {
    const files = [];
    const glob = new Glob2("**/*.{md,mdx}");
    const sources = this.config.sources || ["./docs"];
    const excludes = this.config.excludePatterns || [];
    for (const source of sources) {
      const sourcePath = join19(process.cwd(), source);
      try {
        for (const file2 of glob.scanSync({ cwd: sourcePath })) {
          const shouldExclude = excludes.some((p) => file2.includes(p));
          if (!shouldExclude) {
            files.push(join19(sourcePath, file2));
          }
        }
      } catch (e) {
        this.log.warn({ source: sourcePath, err: e }, "Failed to scan source");
      }
    }
    return files;
  }
}

// src/cli/commands/services.ts
init_DaemonManager();

// src/utils/ollama-discovery.ts
var {$ } = globalThis.Bun;
var log10 = getLogger("OllamaDiscovery");
function parseOllamaList(stdout) {
  const lines = stdout.trim().split(`
`);
  const models = [];
  for (let i = 1;i < lines.length; i++) {
    const line = lines[i]?.trim();
    if (!line)
      continue;
    const parts = line.split(/\s+/);
    if (parts.length >= 4) {
      models.push({
        name: parts[0] ?? "",
        id: parts[1] ?? "",
        size: parts[2] ?? "",
        modified: parts.slice(3).join(" ")
      });
    }
  }
  return models;
}
function parseModelInfo(stdout) {
  try {
    return JSON.parse(stdout);
  } catch {
    const info = {};
    const lines = stdout.split(`
`);
    for (const line of lines) {
      const [key, ...valueParts] = line.split(":");
      if (key && valueParts.length > 0) {
        info[key.trim()] = valueParts.join(":").trim();
      }
    }
    return info;
  }
}
async function discoverOllamaCapabilities() {
  try {
    const versionResult = await $`ollama --version`.quiet();
    if (versionResult.exitCode !== 0) {
      throw new Error("Ollama not found");
    }
    const versionOutput = versionResult.stdout?.toString()?.trim() ?? "unknown";
    log10.info(`\u2705 Ollama detected: ${versionOutput}`);
    const listResult = await $`ollama list`.quiet();
    if (listResult.exitCode !== 0) {
      throw new Error("Failed to list Ollama models");
    }
    const models = parseOllamaList(listResult.stdout?.toString() ?? "");
    log10.info(`\uD83D\uDCE6 Found ${models.length} model(s): ${models.map((m) => m.name).join(", ")}`);
    const searchModel = models.length > 0 ? models[0]?.name : null;
    if (!searchModel) {
      log10.warn("\u26A0\uFE0F  No preferred models found");
      return {
        available: true,
        suggestedModel: null,
        allModels: models
      };
    }
    const _phi3 = models.find((m) => m.name === "phi3:latest");
    let modelInfo = null;
    try {
      const showResult = await $`ollama show ${searchModel}`.quiet();
      if (showResult.exitCode === 0) {
        modelInfo = parseModelInfo(showResult.stdout?.toString() ?? "");
      }
    } catch (_e) {
      log10.warn(`\u26A0\uFE0F  Could not get details for ${searchModel}`);
    }
    const selectedModel = models.find((m) => m.name === searchModel);
    log10.info(`\u2705 Using ${searchModel} for search tasks (size: ${selectedModel?.size ?? "unknown"})`);
    return {
      available: true,
      model: searchModel,
      size: selectedModel?.size,
      suggestedModel: searchModel,
      capabilities: modelInfo,
      allModels: models
    };
  } catch (error49) {
    const errorMsg = error49 instanceof Error ? error49.message : String(error49);
    log10.warn(`\u26A0\uFE0F  Ollama not available: ${errorMsg}`);
    log10.info("   Install: curl -fsSL https://ollama.ai/install.sh | sh");
    log10.info("   Then run: ollama pull phi3:latest");
    return {
      available: false,
      allModels: []
    };
  }
}

// src/cli/commands/services.ts
async function cmdWatcher(args) {
  const action = args[1] || "status";
  const validActions = ["start", "stop", "status", "restart"];
  if (!validActions.includes(action)) {
    console.error(`\u274C Invalid action: ${action}`);
    console.error(`
Usage: amalfa watcher <start|stop|status|restart>`);
    process.exit(1);
  }
  const manager = new DaemonManager;
  if (action === "status") {
    const status = await manager.checkFileWatcher();
    if (status.running) {
      console.log(`\u2705 File Watcher: Running (PID: ${status.pid})`);
    } else {
      console.log("\u274C File Watcher: Stopped");
    }
    return;
  }
  if (action === "start") {
    console.log("\uD83D\uDE80 Starting File Watcher...");
    try {
      await manager.startFileWatcher();
      console.log("\u2705 File Watcher started");
    } catch (e) {
      console.error("\u274C Failed to start File Watcher:", e);
      process.exit(1);
    }
    return;
  }
  if (action === "stop") {
    console.log("\uD83D\uDED1 Stopping File Watcher...");
    try {
      await manager.stopFileWatcher();
      console.log("\u2705 File Watcher stopped");
    } catch (e) {
      console.error("\u274C Failed to stop File Watcher:", e);
      process.exit(1);
    }
    return;
  }
  if (action === "restart") {
    console.log("\uD83D\uDD04 Restarting File Watcher...");
    try {
      await manager.stopFileWatcher();
      await manager.startFileWatcher();
      console.log("\u2705 File Watcher restarted");
    } catch (e) {
      console.error("\u274C Failed to restart File Watcher:", e);
      process.exit(1);
    }
    return;
  }
}
async function cmdVector(args) {
  const action = args[1] || "status";
  const validActions = ["start", "stop", "status", "restart"];
  if (!validActions.includes(action)) {
    console.error(`\u274C Invalid action: ${action}`);
    console.error(`
Usage: amalfa vector <start|stop|status|restart>`);
    process.exit(1);
  }
  const manager = new DaemonManager;
  if (action === "status") {
    const status = await manager.checkVectorDaemon();
    if (status.running) {
      console.log(`\u2705 Vector Daemon: Running (PID: ${status.pid}, Port: ${status.port})`);
    } else {
      console.log("\u274C Vector Daemon: Stopped");
    }
    return;
  }
  if (action === "start") {
    console.log("\uD83D\uDE80 Starting Vector Daemon...");
    try {
      await manager.startVectorDaemon();
      console.log("\u2705 Vector Daemon started");
    } catch (e) {
      console.error("\u274C Failed to start Vector Daemon:", e);
      process.exit(1);
    }
    return;
  }
  if (action === "stop") {
    console.log("\uD83D\uDED1 Stopping Vector Daemon...");
    try {
      await manager.stopVectorDaemon();
      console.log("\u2705 Vector Daemon stopped");
    } catch (e) {
      console.error("\u274C Failed to stop Vector Daemon:", e);
      process.exit(1);
    }
    return;
  }
  if (action === "restart") {
    console.log("\uD83D\uDD04 Restarting Vector Daemon...");
    try {
      await manager.stopVectorDaemon();
      await manager.startVectorDaemon();
      console.log("\u2705 Vector Daemon restarted");
    } catch (e) {
      console.error("\u274C Failed to restart Vector Daemon:", e);
      process.exit(1);
    }
    return;
  }
}
async function cmdReranker(args) {
  const action = args[1] || "status";
  const validActions = ["start", "stop", "status", "restart"];
  if (!validActions.includes(action)) {
    console.error(`\u274C Invalid action: ${action}`);
    console.error(`
Usage: amalfa reranker <start|stop|status|restart>`);
    process.exit(1);
  }
  const manager = new DaemonManager;
  if (action === "status") {
    const status = await manager.checkRerankerDaemon();
    if (status.running) {
      console.log(`\u2705 Reranker Daemon: Running (PID: ${status.pid}, Port: ${status.port})`);
    } else {
      console.log("\u274C Reranker Daemon: Stopped");
    }
    return;
  }
  if (action === "start") {
    console.log("\uD83D\uDE80 Starting Reranker Daemon...");
    try {
      await manager.startRerankerDaemon();
      console.log("\u2705 Reranker Daemon started");
    } catch (e) {
      console.error("\u274C Failed to start Reranker Daemon:", e);
      process.exit(1);
    }
    return;
  }
  if (action === "stop") {
    console.log("\uD83D\uDED1 Stopping Reranker Daemon...");
    try {
      await manager.stopRerankerDaemon();
      console.log("\u2705 Reranker Daemon stopped");
    } catch (e) {
      console.error("\u274C Failed to stop Reranker Daemon:", e);
      process.exit(1);
    }
    return;
  }
  if (action === "restart") {
    console.log("\uD83D\uDD04 Restarting Reranker Daemon...");
    try {
      await manager.stopRerankerDaemon();
      await manager.startRerankerDaemon();
      console.log("\u2705 Reranker Daemon restarted");
    } catch (e) {
      console.error("\u274C Failed to restart Reranker Daemon:", e);
      process.exit(1);
    }
    return;
  }
}
async function cmdSonar(args) {
  const action = args[1] || "status";
  const validActions = ["start", "stop", "status", "restart", "chat"];
  if (!validActions.includes(action)) {
    console.error(`\u274C Invalid action: ${action}`);
    console.error(`
Usage: amalfa sonar <start|stop|status|restart|chat>`);
    process.exit(1);
  }
  const manager = new DaemonManager;
  if (action === "status") {
    console.log("\uD83D\uDD0D Checking status...");
    try {
      const ollama = await discoverOllamaCapabilities();
      if (ollama.available) {
        console.log(`\u2705 Ollama: Running (Model: ${ollama.model}, Size: ${ollama.size})`);
      } else {
        console.log("\u274C Ollama: Not detected");
      }
    } catch {
      console.log("\u274C Ollama: Check failed");
    }
    const status = await manager.checkSonarAgent();
    if (status.running) {
      console.log(`\u2705 Sonar Agent: Running (PID: ${status.pid}, Port: ${status.port})`);
      try {
        const res = await fetch(`http://localhost:${status.port}/health`);
        const health = await res.json();
        console.log(`   Health: ${JSON.stringify(health)}`);
      } catch {
        console.log("   Health: \u26A0\uFE0F  Unresponsive");
      }
    } else {
      console.log("\u274C Sonar Agent: Stopped");
    }
    return;
  }
  if (action === "start") {
    console.log("\uD83D\uDE80 Starting Sonar Agent...");
    try {
      await manager.startSonarAgent();
      console.log("\u2705 Sonar Agent started");
    } catch (e) {
      console.error("\u274C Failed to start Sonar Agent:", e);
      process.exit(1);
    }
    return;
  }
  if (action === "stop") {
    console.log("\uD83D\uDED1 Stopping Sonar Agent...");
    try {
      await manager.stopSonarAgent();
      console.log("\u2705 Sonar Agent stopped");
    } catch (e) {
      console.error("\u274C Failed to stop Sonar Agent:", e);
      process.exit(1);
    }
    return;
  }
  if (action === "chat") {
    const { chatLoop: chatLoop2 } = await Promise.resolve().then(() => (init_sonar_chat(), exports_sonar_chat));
    await chatLoop2();
    return;
  }
  if (action === "restart") {
    console.log("\uD83D\uDD04 Restarting Sonar Agent...");
    try {
      await manager.stopSonarAgent();
      await manager.startSonarAgent();
      console.log("\u2705 Sonar Agent restarted");
    } catch (e) {
      console.error("\u274C Failed to restart Sonar Agent:", e);
      process.exit(1);
    }
    return;
  }
}
async function cmdEmber(args) {
  const rawAction = args[1] || "help";
  const action = rawAction === "--help" || rawAction === "-h" ? "help" : rawAction;
  if (action === "help") {
    console.log(`
EMBER - Automated Enrichment Service

Usage:
  amalfa ember scan [--dry-run]   Analyze files and generate sidecars
  amalfa ember squash             Merge sidecars into markdown files
  amalfa ember status             Show pending sidecars (TODO)
`);
    return;
  }
  const dbPath = await getDbPath();
  if (!existsSync18(dbPath)) {
    console.error("\u274C Database not found. Run 'amalfa init' first.");
    process.exit(1);
  }
  const db = new ResonanceDB(dbPath);
  const appConfig = await loadConfig();
  const emberConfig = {
    enabled: true,
    sources: appConfig.sources || ["./docs"],
    minConfidence: 0.7,
    backupDir: ".amalfa/backups",
    excludePatterns: appConfig.excludePatterns || []
  };
  const ember = new EmberService(db, emberConfig);
  try {
    if (action === "scan") {
      const dryRun = args.includes("--dry-run");
      await ember.runFullSweep(dryRun);
    } else if (action === "squash") {
      await ember.squashAll();
    } else if (action === "status") {
      console.log("Checking pending sidecars... (Not yet implemented)");
    } else {
      console.error(`\u274C Unknown action: ${action}`);
      process.exit(1);
    }
  } catch (e) {
    console.error("\u274C Ember command failed:", e);
    process.exit(1);
  } finally {
    db.close();
  }
}

// src/cli/commands/setup.ts
async function cmdSetupMcp(_args) {
  const { resolve: resolve4 } = await import("path");
  const cwd = resolve4(process.cwd());
  const mcpScript = resolve4(cwd, "src/mcp/index.ts");
  const bunPath = process.execPath.replace(/\/bun$/, "");
  const minimalPath = [
    bunPath,
    "/usr/local/bin",
    "/usr/bin",
    "/bin",
    "/usr/sbin",
    "/sbin",
    "/opt/homebrew/bin"
  ].join(":");
  const config3 = {
    mcpServers: {
      amalfa: {
        command: "bun",
        args: ["run", "--cwd", cwd, mcpScript],
        env: {
          PATH: minimalPath
        }
      }
    }
  };
  console.log(`
\u2705 AMALFA MCP Configuration`);
  console.log("=".repeat(60));
  console.log(`\uD83D\uDCC2 Installation: ${cwd}`);
  console.log("=".repeat(60));
  console.log(`
\uD83D\uDCCB Copy this JSON to your MCP client config:`);
  console.log("   Claude Desktop: ~/Library/Application Support/Claude/claude_desktop_config.json");
  console.log(`   Warp Preview: MCP settings
`);
  console.log("=".repeat(60));
  console.log();
  console.log(JSON.stringify(config3, null, 2));
  console.log();
  console.log("=".repeat(60));
  console.log("\uD83D\uDCA1 Tip: If you move this folder, run 'amalfa setup-mcp' again");
  console.log("=".repeat(60));
  console.log();
}

// src/cli/commands/setup-python.ts
import { existsSync as existsSync19 } from "fs";
import { resolve as resolve4 } from "path";
async function cmdSetupPython() {
  console.log(`
\uD83D\uDC0D Amalfa Python Sidecar Setup`);
  console.log("=".repeat(60));
  const uvCheck = Bun.spawnSync(["which", "uv"]);
  if (uvCheck.exitCode !== 0) {
    console.error("\u274C 'uv' package manager not found.");
    console.log("To install uv, run:");
    console.log("  curl -LsSf https://astral.sh/uv/install.sh | sh");
    console.log(`
Then run this command again.`);
    process.exit(1);
  }
  console.log("\u2705 'uv' found.");
  const sidecarDir = resolve4(process.cwd(), "src/sidecars/lang-extract");
  if (!existsSync19(sidecarDir)) {
    console.error(`\u274C Sidecar directory not found at: ${sidecarDir}`);
    console.log("Ensure you are running this from the project root.");
    process.exit(1);
  }
  console.log(`\uD83D\uDCC2 Sidecar directory: ${sidecarDir}`);
  console.log("\uD83D\uDCE6 Installing Python dependencies...");
  const proc = Bun.spawn(["uv", "sync"], {
    cwd: sidecarDir,
    stdout: "inherit",
    stderr: "inherit"
  });
  const exitCode = await proc.exited;
  if (exitCode !== 0) {
    console.error("\u274C Failed to install Python dependencies.");
    process.exit(1);
  }
  console.log(`
\u2705 Python environment ready!`);
  console.log("=".repeat(60));
  console.log("To enable Advanced Entity Extraction:");
  console.log("1. Ensure GEMINI_API_KEY is set in your environment.");
  console.log("2. That's it! The Ingestor will auto-detect the capability.");
  console.log("=".repeat(60));
}

// src/core/SidecarSquasher.ts
import { readFileSync as readFileSync7 } from "fs";

// node_modules/@isaacs/balanced-match/dist/esm/index.js
var balanced = (a, b, str2) => {
  const ma = a instanceof RegExp ? maybeMatch(a, str2) : a;
  const mb = b instanceof RegExp ? maybeMatch(b, str2) : b;
  const r = ma !== null && mb != null && range(ma, mb, str2);
  return r && {
    start: r[0],
    end: r[1],
    pre: str2.slice(0, r[0]),
    body: str2.slice(r[0] + ma.length, r[1]),
    post: str2.slice(r[1] + mb.length)
  };
};
var maybeMatch = (reg, str2) => {
  const m = str2.match(reg);
  return m ? m[0] : null;
};
var range = (a, b, str2) => {
  let begs, beg, left, right = undefined, result;
  let ai = str2.indexOf(a);
  let bi = str2.indexOf(b, ai + 1);
  let i = ai;
  if (ai >= 0 && bi > 0) {
    if (a === b) {
      return [ai, bi];
    }
    begs = [];
    left = str2.length;
    while (i >= 0 && !result) {
      if (i === ai) {
        begs.push(i);
        ai = str2.indexOf(a, i + 1);
      } else if (begs.length === 1) {
        const r = begs.pop();
        if (r !== undefined)
          result = [r, bi];
      } else {
        beg = begs.pop();
        if (beg !== undefined && beg < left) {
          left = beg;
          right = bi;
        }
        bi = str2.indexOf(b, i + 1);
      }
      i = ai < bi && ai >= 0 ? ai : bi;
    }
    if (begs.length && right !== undefined) {
      result = [left, right];
    }
  }
  return result;
};

// node_modules/@isaacs/brace-expansion/dist/esm/index.js
var escSlash = "\x00SLASH" + Math.random() + "\x00";
var escOpen = "\x00OPEN" + Math.random() + "\x00";
var escClose = "\x00CLOSE" + Math.random() + "\x00";
var escComma = "\x00COMMA" + Math.random() + "\x00";
var escPeriod = "\x00PERIOD" + Math.random() + "\x00";
var escSlashPattern = new RegExp(escSlash, "g");
var escOpenPattern = new RegExp(escOpen, "g");
var escClosePattern = new RegExp(escClose, "g");
var escCommaPattern = new RegExp(escComma, "g");
var escPeriodPattern = new RegExp(escPeriod, "g");
var slashPattern = /\\\\/g;
var openPattern = /\\{/g;
var closePattern = /\\}/g;
var commaPattern = /\\,/g;
var periodPattern = /\\./g;
function numeric(str2) {
  return !isNaN(str2) ? parseInt(str2, 10) : str2.charCodeAt(0);
}
function escapeBraces(str2) {
  return str2.replace(slashPattern, escSlash).replace(openPattern, escOpen).replace(closePattern, escClose).replace(commaPattern, escComma).replace(periodPattern, escPeriod);
}
function unescapeBraces(str2) {
  return str2.replace(escSlashPattern, "\\").replace(escOpenPattern, "{").replace(escClosePattern, "}").replace(escCommaPattern, ",").replace(escPeriodPattern, ".");
}
function parseCommaParts(str2) {
  if (!str2) {
    return [""];
  }
  const parts = [];
  const m = balanced("{", "}", str2);
  if (!m) {
    return str2.split(",");
  }
  const { pre, body, post } = m;
  const p = pre.split(",");
  p[p.length - 1] += "{" + body + "}";
  const postParts = parseCommaParts(post);
  if (post.length) {
    p[p.length - 1] += postParts.shift();
    p.push.apply(p, postParts);
  }
  parts.push.apply(parts, p);
  return parts;
}
function expand(str2) {
  if (!str2) {
    return [];
  }
  if (str2.slice(0, 2) === "{}") {
    str2 = "\\{\\}" + str2.slice(2);
  }
  return expand_(escapeBraces(str2), true).map(unescapeBraces);
}
function embrace(str2) {
  return "{" + str2 + "}";
}
function isPadded(el) {
  return /^-?0\d/.test(el);
}
function lte2(i, y) {
  return i <= y;
}
function gte2(i, y) {
  return i >= y;
}
function expand_(str2, isTop) {
  const expansions = [];
  const m = balanced("{", "}", str2);
  if (!m)
    return [str2];
  const pre = m.pre;
  const post = m.post.length ? expand_(m.post, false) : [""];
  if (/\$$/.test(m.pre)) {
    for (let k = 0;k < post.length; k++) {
      const expansion = pre + "{" + m.body + "}" + post[k];
      expansions.push(expansion);
    }
  } else {
    const isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
    const isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
    const isSequence = isNumericSequence || isAlphaSequence;
    const isOptions = m.body.indexOf(",") >= 0;
    if (!isSequence && !isOptions) {
      if (m.post.match(/,(?!,).*\}/)) {
        str2 = m.pre + "{" + m.body + escClose + m.post;
        return expand_(str2);
      }
      return [str2];
    }
    let n;
    if (isSequence) {
      n = m.body.split(/\.\./);
    } else {
      n = parseCommaParts(m.body);
      if (n.length === 1 && n[0] !== undefined) {
        n = expand_(n[0], false).map(embrace);
        if (n.length === 1) {
          return post.map((p) => m.pre + n[0] + p);
        }
      }
    }
    let N;
    if (isSequence && n[0] !== undefined && n[1] !== undefined) {
      const x = numeric(n[0]);
      const y = numeric(n[1]);
      const width = Math.max(n[0].length, n[1].length);
      let incr = n.length === 3 && n[2] !== undefined ? Math.abs(numeric(n[2])) : 1;
      let test = lte2;
      const reverse = y < x;
      if (reverse) {
        incr *= -1;
        test = gte2;
      }
      const pad = n.some(isPadded);
      N = [];
      for (let i = x;test(i, y); i += incr) {
        let c;
        if (isAlphaSequence) {
          c = String.fromCharCode(i);
          if (c === "\\") {
            c = "";
          }
        } else {
          c = String(i);
          if (pad) {
            const need = width - c.length;
            if (need > 0) {
              const z2 = new Array(need + 1).join("0");
              if (i < 0) {
                c = "-" + z2 + c.slice(1);
              } else {
                c = z2 + c;
              }
            }
          }
        }
        N.push(c);
      }
    } else {
      N = [];
      for (let j = 0;j < n.length; j++) {
        N.push.apply(N, expand_(n[j], false));
      }
    }
    for (let j = 0;j < N.length; j++) {
      for (let k = 0;k < post.length; k++) {
        const expansion = pre + N[j] + post[k];
        if (!isTop || isSequence || expansion) {
          expansions.push(expansion);
        }
      }
    }
  }
  return expansions;
}

// node_modules/minimatch/dist/esm/assert-valid-pattern.js
var MAX_PATTERN_LENGTH = 1024 * 64;
var assertValidPattern = (pattern) => {
  if (typeof pattern !== "string") {
    throw new TypeError("invalid pattern");
  }
  if (pattern.length > MAX_PATTERN_LENGTH) {
    throw new TypeError("pattern is too long");
  }
};

// node_modules/minimatch/dist/esm/brace-expressions.js
var posixClasses = {
  "[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", true],
  "[:alpha:]": ["\\p{L}\\p{Nl}", true],
  "[:ascii:]": ["\\x" + "00-\\x" + "7f", false],
  "[:blank:]": ["\\p{Zs}\\t", true],
  "[:cntrl:]": ["\\p{Cc}", true],
  "[:digit:]": ["\\p{Nd}", true],
  "[:graph:]": ["\\p{Z}\\p{C}", true, true],
  "[:lower:]": ["\\p{Ll}", true],
  "[:print:]": ["\\p{C}", true],
  "[:punct:]": ["\\p{P}", true],
  "[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", true],
  "[:upper:]": ["\\p{Lu}", true],
  "[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", true],
  "[:xdigit:]": ["A-Fa-f0-9", false]
};
var braceEscape = (s) => s.replace(/[[\]\\-]/g, "\\$&");
var regexpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var rangesToString = (ranges) => ranges.join("");
var parseClass = (glob, position) => {
  const pos = position;
  if (glob.charAt(pos) !== "[") {
    throw new Error("not in a brace expression");
  }
  const ranges = [];
  const negs = [];
  let i = pos + 1;
  let sawStart = false;
  let uflag = false;
  let escaping = false;
  let negate = false;
  let endPos = pos;
  let rangeStart = "";
  WHILE:
    while (i < glob.length) {
      const c = glob.charAt(i);
      if ((c === "!" || c === "^") && i === pos + 1) {
        negate = true;
        i++;
        continue;
      }
      if (c === "]" && sawStart && !escaping) {
        endPos = i + 1;
        break;
      }
      sawStart = true;
      if (c === "\\") {
        if (!escaping) {
          escaping = true;
          i++;
          continue;
        }
      }
      if (c === "[" && !escaping) {
        for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {
          if (glob.startsWith(cls, i)) {
            if (rangeStart) {
              return ["$.", false, glob.length - pos, true];
            }
            i += cls.length;
            if (neg)
              negs.push(unip);
            else
              ranges.push(unip);
            uflag = uflag || u;
            continue WHILE;
          }
        }
      }
      escaping = false;
      if (rangeStart) {
        if (c > rangeStart) {
          ranges.push(braceEscape(rangeStart) + "-" + braceEscape(c));
        } else if (c === rangeStart) {
          ranges.push(braceEscape(c));
        }
        rangeStart = "";
        i++;
        continue;
      }
      if (glob.startsWith("-]", i + 1)) {
        ranges.push(braceEscape(c + "-"));
        i += 2;
        continue;
      }
      if (glob.startsWith("-", i + 1)) {
        rangeStart = c;
        i += 2;
        continue;
      }
      ranges.push(braceEscape(c));
      i++;
    }
  if (endPos < i) {
    return ["", false, 0, false];
  }
  if (!ranges.length && !negs.length) {
    return ["$.", false, glob.length - pos, true];
  }
  if (negs.length === 0 && ranges.length === 1 && /^\\?.$/.test(ranges[0]) && !negate) {
    const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
    return [regexpEscape(r), false, endPos - pos, false];
  }
  const sranges = "[" + (negate ? "^" : "") + rangesToString(ranges) + "]";
  const snegs = "[" + (negate ? "" : "^") + rangesToString(negs) + "]";
  const comb = ranges.length && negs.length ? "(" + sranges + "|" + snegs + ")" : ranges.length ? sranges : snegs;
  return [comb, uflag, endPos - pos, true];
};

// node_modules/minimatch/dist/esm/unescape.js
var unescape2 = (s, { windowsPathsNoEscape = false, magicalBraces = true } = {}) => {
  if (magicalBraces) {
    return windowsPathsNoEscape ? s.replace(/\[([^\/\\])\]/g, "$1") : s.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2").replace(/\\([^\/])/g, "$1");
  }
  return windowsPathsNoEscape ? s.replace(/\[([^\/\\{}])\]/g, "$1") : s.replace(/((?!\\).|^)\[([^\/\\{}])\]/g, "$1$2").replace(/\\([^\/{}])/g, "$1");
};

// node_modules/minimatch/dist/esm/ast.js
var types = new Set(["!", "?", "+", "*", "@"]);
var isExtglobType = (c) => types.has(c);
var startNoTraversal = "(?!(?:^|/)\\.\\.?(?:$|/))";
var startNoDot = "(?!\\.)";
var addPatternStart = new Set(["[", "."]);
var justDots = new Set(["..", "."]);
var reSpecials = new Set("().*{}+?[]^$\\!");
var regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var qmark = "[^/]";
var star = qmark + "*?";
var starNoEmpty = qmark + "+?";

class AST {
  type;
  #root;
  #hasMagic;
  #uflag = false;
  #parts = [];
  #parent;
  #parentIndex;
  #negs;
  #filledNegs = false;
  #options;
  #toString;
  #emptyExt = false;
  constructor(type, parent, options2 = {}) {
    this.type = type;
    if (type)
      this.#hasMagic = true;
    this.#parent = parent;
    this.#root = this.#parent ? this.#parent.#root : this;
    this.#options = this.#root === this ? options2 : this.#root.#options;
    this.#negs = this.#root === this ? [] : this.#root.#negs;
    if (type === "!" && !this.#root.#filledNegs)
      this.#negs.push(this);
    this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;
  }
  get hasMagic() {
    if (this.#hasMagic !== undefined)
      return this.#hasMagic;
    for (const p of this.#parts) {
      if (typeof p === "string")
        continue;
      if (p.type || p.hasMagic)
        return this.#hasMagic = true;
    }
    return this.#hasMagic;
  }
  toString() {
    if (this.#toString !== undefined)
      return this.#toString;
    if (!this.type) {
      return this.#toString = this.#parts.map((p) => String(p)).join("");
    } else {
      return this.#toString = this.type + "(" + this.#parts.map((p) => String(p)).join("|") + ")";
    }
  }
  #fillNegs() {
    if (this !== this.#root)
      throw new Error("should only call on root");
    if (this.#filledNegs)
      return this;
    this.toString();
    this.#filledNegs = true;
    let n;
    while (n = this.#negs.pop()) {
      if (n.type !== "!")
        continue;
      let p = n;
      let pp = p.#parent;
      while (pp) {
        for (let i = p.#parentIndex + 1;!pp.type && i < pp.#parts.length; i++) {
          for (const part of n.#parts) {
            if (typeof part === "string") {
              throw new Error("string part in extglob AST??");
            }
            part.copyIn(pp.#parts[i]);
          }
        }
        p = pp;
        pp = p.#parent;
      }
    }
    return this;
  }
  push(...parts) {
    for (const p of parts) {
      if (p === "")
        continue;
      if (typeof p !== "string" && !(p instanceof AST && p.#parent === this)) {
        throw new Error("invalid part: " + p);
      }
      this.#parts.push(p);
    }
  }
  toJSON() {
    const ret = this.type === null ? this.#parts.slice().map((p) => typeof p === "string" ? p : p.toJSON()) : [this.type, ...this.#parts.map((p) => p.toJSON())];
    if (this.isStart() && !this.type)
      ret.unshift([]);
    if (this.isEnd() && (this === this.#root || this.#root.#filledNegs && this.#parent?.type === "!")) {
      ret.push({});
    }
    return ret;
  }
  isStart() {
    if (this.#root === this)
      return true;
    if (!this.#parent?.isStart())
      return false;
    if (this.#parentIndex === 0)
      return true;
    const p = this.#parent;
    for (let i = 0;i < this.#parentIndex; i++) {
      const pp = p.#parts[i];
      if (!(pp instanceof AST && pp.type === "!")) {
        return false;
      }
    }
    return true;
  }
  isEnd() {
    if (this.#root === this)
      return true;
    if (this.#parent?.type === "!")
      return true;
    if (!this.#parent?.isEnd())
      return false;
    if (!this.type)
      return this.#parent?.isEnd();
    const pl = this.#parent ? this.#parent.#parts.length : 0;
    return this.#parentIndex === pl - 1;
  }
  copyIn(part) {
    if (typeof part === "string")
      this.push(part);
    else
      this.push(part.clone(this));
  }
  clone(parent) {
    const c = new AST(this.type, parent);
    for (const p of this.#parts) {
      c.copyIn(p);
    }
    return c;
  }
  static #parseAST(str2, ast, pos, opt) {
    let escaping = false;
    let inBrace = false;
    let braceStart = -1;
    let braceNeg = false;
    if (ast.type === null) {
      let i2 = pos;
      let acc2 = "";
      while (i2 < str2.length) {
        const c = str2.charAt(i2++);
        if (escaping || c === "\\") {
          escaping = !escaping;
          acc2 += c;
          continue;
        }
        if (inBrace) {
          if (i2 === braceStart + 1) {
            if (c === "^" || c === "!") {
              braceNeg = true;
            }
          } else if (c === "]" && !(i2 === braceStart + 2 && braceNeg)) {
            inBrace = false;
          }
          acc2 += c;
          continue;
        } else if (c === "[") {
          inBrace = true;
          braceStart = i2;
          braceNeg = false;
          acc2 += c;
          continue;
        }
        if (!opt.noext && isExtglobType(c) && str2.charAt(i2) === "(") {
          ast.push(acc2);
          acc2 = "";
          const ext = new AST(c, ast);
          i2 = AST.#parseAST(str2, ext, i2, opt);
          ast.push(ext);
          continue;
        }
        acc2 += c;
      }
      ast.push(acc2);
      return i2;
    }
    let i = pos + 1;
    let part = new AST(null, ast);
    const parts = [];
    let acc = "";
    while (i < str2.length) {
      const c = str2.charAt(i++);
      if (escaping || c === "\\") {
        escaping = !escaping;
        acc += c;
        continue;
      }
      if (inBrace) {
        if (i === braceStart + 1) {
          if (c === "^" || c === "!") {
            braceNeg = true;
          }
        } else if (c === "]" && !(i === braceStart + 2 && braceNeg)) {
          inBrace = false;
        }
        acc += c;
        continue;
      } else if (c === "[") {
        inBrace = true;
        braceStart = i;
        braceNeg = false;
        acc += c;
        continue;
      }
      if (isExtglobType(c) && str2.charAt(i) === "(") {
        part.push(acc);
        acc = "";
        const ext = new AST(c, part);
        part.push(ext);
        i = AST.#parseAST(str2, ext, i, opt);
        continue;
      }
      if (c === "|") {
        part.push(acc);
        acc = "";
        parts.push(part);
        part = new AST(null, ast);
        continue;
      }
      if (c === ")") {
        if (acc === "" && ast.#parts.length === 0) {
          ast.#emptyExt = true;
        }
        part.push(acc);
        acc = "";
        ast.push(...parts, part);
        return i;
      }
      acc += c;
    }
    ast.type = null;
    ast.#hasMagic = undefined;
    ast.#parts = [str2.substring(pos - 1)];
    return i;
  }
  static fromGlob(pattern, options2 = {}) {
    const ast = new AST(null, undefined, options2);
    AST.#parseAST(pattern, ast, 0, options2);
    return ast;
  }
  toMMPattern() {
    if (this !== this.#root)
      return this.#root.toMMPattern();
    const glob = this.toString();
    const [re, body, hasMagic, uflag] = this.toRegExpSource();
    const anyMagic = hasMagic || this.#hasMagic || this.#options.nocase && !this.#options.nocaseMagicOnly && glob.toUpperCase() !== glob.toLowerCase();
    if (!anyMagic) {
      return body;
    }
    const flags = (this.#options.nocase ? "i" : "") + (uflag ? "u" : "");
    return Object.assign(new RegExp(`^${re}$`, flags), {
      _src: re,
      _glob: glob
    });
  }
  get options() {
    return this.#options;
  }
  toRegExpSource(allowDot) {
    const dot = allowDot ?? !!this.#options.dot;
    if (this.#root === this)
      this.#fillNegs();
    if (!this.type) {
      const noEmpty = this.isStart() && this.isEnd() && !this.#parts.some((s) => typeof s !== "string");
      const src = this.#parts.map((p) => {
        const [re, _, hasMagic, uflag] = typeof p === "string" ? AST.#parseGlob(p, this.#hasMagic, noEmpty) : p.toRegExpSource(allowDot);
        this.#hasMagic = this.#hasMagic || hasMagic;
        this.#uflag = this.#uflag || uflag;
        return re;
      }).join("");
      let start2 = "";
      if (this.isStart()) {
        if (typeof this.#parts[0] === "string") {
          const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);
          if (!dotTravAllowed) {
            const aps = addPatternStart;
            const needNoTrav = dot && aps.has(src.charAt(0)) || src.startsWith("\\.") && aps.has(src.charAt(2)) || src.startsWith("\\.\\.") && aps.has(src.charAt(4));
            const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
            start2 = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : "";
          }
        }
      }
      let end = "";
      if (this.isEnd() && this.#root.#filledNegs && this.#parent?.type === "!") {
        end = "(?:$|\\/)";
      }
      const final2 = start2 + src + end;
      return [
        final2,
        unescape2(src),
        this.#hasMagic = !!this.#hasMagic,
        this.#uflag
      ];
    }
    const repeated = this.type === "*" || this.type === "+";
    const start = this.type === "!" ? "(?:(?!(?:" : "(?:";
    let body = this.#partsToRegExp(dot);
    if (this.isStart() && this.isEnd() && !body && this.type !== "!") {
      const s = this.toString();
      this.#parts = [s];
      this.type = null;
      this.#hasMagic = undefined;
      return [s, unescape2(this.toString()), false, false];
    }
    let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot ? "" : this.#partsToRegExp(true);
    if (bodyDotAllowed === body) {
      bodyDotAllowed = "";
    }
    if (bodyDotAllowed) {
      body = `(?:${body})(?:${bodyDotAllowed})*?`;
    }
    let final = "";
    if (this.type === "!" && this.#emptyExt) {
      final = (this.isStart() && !dot ? startNoDot : "") + starNoEmpty;
    } else {
      const close = this.type === "!" ? "))" + (this.isStart() && !dot && !allowDot ? startNoDot : "") + star + ")" : this.type === "@" ? ")" : this.type === "?" ? ")?" : this.type === "+" && bodyDotAllowed ? ")" : this.type === "*" && bodyDotAllowed ? `)?` : `)${this.type}`;
      final = start + body + close;
    }
    return [
      final,
      unescape2(body),
      this.#hasMagic = !!this.#hasMagic,
      this.#uflag
    ];
  }
  #partsToRegExp(dot) {
    return this.#parts.map((p) => {
      if (typeof p === "string") {
        throw new Error("string type in extglob ast??");
      }
      const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot);
      this.#uflag = this.#uflag || uflag;
      return re;
    }).filter((p) => !(this.isStart() && this.isEnd()) || !!p).join("|");
  }
  static #parseGlob(glob, hasMagic, noEmpty = false) {
    let escaping = false;
    let re = "";
    let uflag = false;
    for (let i = 0;i < glob.length; i++) {
      const c = glob.charAt(i);
      if (escaping) {
        escaping = false;
        re += (reSpecials.has(c) ? "\\" : "") + c;
        continue;
      }
      if (c === "\\") {
        if (i === glob.length - 1) {
          re += "\\\\";
        } else {
          escaping = true;
        }
        continue;
      }
      if (c === "[") {
        const [src, needUflag, consumed, magic] = parseClass(glob, i);
        if (consumed) {
          re += src;
          uflag = uflag || needUflag;
          i += consumed - 1;
          hasMagic = hasMagic || magic;
          continue;
        }
      }
      if (c === "*") {
        re += noEmpty && glob === "*" ? starNoEmpty : star;
        hasMagic = true;
        continue;
      }
      if (c === "?") {
        re += qmark;
        hasMagic = true;
        continue;
      }
      re += regExpEscape(c);
    }
    return [re, unescape2(glob), !!hasMagic, uflag];
  }
}

// node_modules/minimatch/dist/esm/escape.js
var escape2 = (s, { windowsPathsNoEscape = false, magicalBraces = false } = {}) => {
  if (magicalBraces) {
    return windowsPathsNoEscape ? s.replace(/[?*()[\]{}]/g, "[$&]") : s.replace(/[?*()[\]\\{}]/g, "\\$&");
  }
  return windowsPathsNoEscape ? s.replace(/[?*()[\]]/g, "[$&]") : s.replace(/[?*()[\]\\]/g, "\\$&");
};

// node_modules/minimatch/dist/esm/index.js
var minimatch = (p, pattern, options2 = {}) => {
  assertValidPattern(pattern);
  if (!options2.nocomment && pattern.charAt(0) === "#") {
    return false;
  }
  return new Minimatch(pattern, options2).match(p);
};
var starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
var starDotExtTest = (ext) => (f) => !f.startsWith(".") && f.endsWith(ext);
var starDotExtTestDot = (ext) => (f) => f.endsWith(ext);
var starDotExtTestNocase = (ext) => {
  ext = ext.toLowerCase();
  return (f) => !f.startsWith(".") && f.toLowerCase().endsWith(ext);
};
var starDotExtTestNocaseDot = (ext) => {
  ext = ext.toLowerCase();
  return (f) => f.toLowerCase().endsWith(ext);
};
var starDotStarRE = /^\*+\.\*+$/;
var starDotStarTest = (f) => !f.startsWith(".") && f.includes(".");
var starDotStarTestDot = (f) => f !== "." && f !== ".." && f.includes(".");
var dotStarRE = /^\.\*+$/;
var dotStarTest = (f) => f !== "." && f !== ".." && f.startsWith(".");
var starRE = /^\*+$/;
var starTest = (f) => f.length !== 0 && !f.startsWith(".");
var starTestDot = (f) => f.length !== 0 && f !== "." && f !== "..";
var qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
var qmarksTestNocase = ([$0, ext = ""]) => {
  const noext = qmarksTestNoExt([$0]);
  if (!ext)
    return noext;
  ext = ext.toLowerCase();
  return (f) => noext(f) && f.toLowerCase().endsWith(ext);
};
var qmarksTestNocaseDot = ([$0, ext = ""]) => {
  const noext = qmarksTestNoExtDot([$0]);
  if (!ext)
    return noext;
  ext = ext.toLowerCase();
  return (f) => noext(f) && f.toLowerCase().endsWith(ext);
};
var qmarksTestDot = ([$0, ext = ""]) => {
  const noext = qmarksTestNoExtDot([$0]);
  return !ext ? noext : (f) => noext(f) && f.endsWith(ext);
};
var qmarksTest = ([$0, ext = ""]) => {
  const noext = qmarksTestNoExt([$0]);
  return !ext ? noext : (f) => noext(f) && f.endsWith(ext);
};
var qmarksTestNoExt = ([$0]) => {
  const len = $0.length;
  return (f) => f.length === len && !f.startsWith(".");
};
var qmarksTestNoExtDot = ([$0]) => {
  const len = $0.length;
  return (f) => f.length === len && f !== "." && f !== "..";
};
var defaultPlatform = typeof process === "object" && process ? typeof process.env === "object" && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : "posix";
var path2 = {
  win32: { sep: "\\" },
  posix: { sep: "/" }
};
var sep = defaultPlatform === "win32" ? path2.win32.sep : path2.posix.sep;
minimatch.sep = sep;
var GLOBSTAR = Symbol("globstar **");
minimatch.GLOBSTAR = GLOBSTAR;
var qmark2 = "[^/]";
var star2 = qmark2 + "*?";
var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
var filter = (pattern, options2 = {}) => (p) => minimatch(p, pattern, options2);
minimatch.filter = filter;
var ext = (a, b = {}) => Object.assign({}, a, b);
var defaults = (def) => {
  if (!def || typeof def !== "object" || !Object.keys(def).length) {
    return minimatch;
  }
  const orig = minimatch;
  const m = (p, pattern, options2 = {}) => orig(p, pattern, ext(def, options2));
  return Object.assign(m, {
    Minimatch: class Minimatch extends orig.Minimatch {
      constructor(pattern, options2 = {}) {
        super(pattern, ext(def, options2));
      }
      static defaults(options2) {
        return orig.defaults(ext(def, options2)).Minimatch;
      }
    },
    AST: class AST2 extends orig.AST {
      constructor(type, parent, options2 = {}) {
        super(type, parent, ext(def, options2));
      }
      static fromGlob(pattern, options2 = {}) {
        return orig.AST.fromGlob(pattern, ext(def, options2));
      }
    },
    unescape: (s, options2 = {}) => orig.unescape(s, ext(def, options2)),
    escape: (s, options2 = {}) => orig.escape(s, ext(def, options2)),
    filter: (pattern, options2 = {}) => orig.filter(pattern, ext(def, options2)),
    defaults: (options2) => orig.defaults(ext(def, options2)),
    makeRe: (pattern, options2 = {}) => orig.makeRe(pattern, ext(def, options2)),
    braceExpand: (pattern, options2 = {}) => orig.braceExpand(pattern, ext(def, options2)),
    match: (list, pattern, options2 = {}) => orig.match(list, pattern, ext(def, options2)),
    sep: orig.sep,
    GLOBSTAR
  });
};
minimatch.defaults = defaults;
var braceExpand = (pattern, options2 = {}) => {
  assertValidPattern(pattern);
  if (options2.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
    return [pattern];
  }
  return expand(pattern);
};
minimatch.braceExpand = braceExpand;
var makeRe = (pattern, options2 = {}) => new Minimatch(pattern, options2).makeRe();
minimatch.makeRe = makeRe;
var match = (list, pattern, options2 = {}) => {
  const mm = new Minimatch(pattern, options2);
  list = list.filter((f) => mm.match(f));
  if (mm.options.nonull && !list.length) {
    list.push(pattern);
  }
  return list;
};
minimatch.match = match;
var globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
var regExpEscape2 = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");

class Minimatch {
  options;
  set;
  pattern;
  windowsPathsNoEscape;
  nonegate;
  negate;
  comment;
  empty;
  preserveMultipleSlashes;
  partial;
  globSet;
  globParts;
  nocase;
  isWindows;
  platform;
  windowsNoMagicRoot;
  regexp;
  constructor(pattern, options2 = {}) {
    assertValidPattern(pattern);
    options2 = options2 || {};
    this.options = options2;
    this.pattern = pattern;
    this.platform = options2.platform || defaultPlatform;
    this.isWindows = this.platform === "win32";
    this.windowsPathsNoEscape = !!options2.windowsPathsNoEscape || options2.allowWindowsEscape === false;
    if (this.windowsPathsNoEscape) {
      this.pattern = this.pattern.replace(/\\/g, "/");
    }
    this.preserveMultipleSlashes = !!options2.preserveMultipleSlashes;
    this.regexp = null;
    this.negate = false;
    this.nonegate = !!options2.nonegate;
    this.comment = false;
    this.empty = false;
    this.partial = !!options2.partial;
    this.nocase = !!this.options.nocase;
    this.windowsNoMagicRoot = options2.windowsNoMagicRoot !== undefined ? options2.windowsNoMagicRoot : !!(this.isWindows && this.nocase);
    this.globSet = [];
    this.globParts = [];
    this.set = [];
    this.make();
  }
  hasMagic() {
    if (this.options.magicalBraces && this.set.length > 1) {
      return true;
    }
    for (const pattern of this.set) {
      for (const part of pattern) {
        if (typeof part !== "string")
          return true;
      }
    }
    return false;
  }
  debug(..._) {}
  make() {
    const pattern = this.pattern;
    const options2 = this.options;
    if (!options2.nocomment && pattern.charAt(0) === "#") {
      this.comment = true;
      return;
    }
    if (!pattern) {
      this.empty = true;
      return;
    }
    this.parseNegate();
    this.globSet = [...new Set(this.braceExpand())];
    if (options2.debug) {
      this.debug = (...args) => console.error(...args);
    }
    this.debug(this.pattern, this.globSet);
    const rawGlobParts = this.globSet.map((s) => this.slashSplit(s));
    this.globParts = this.preprocess(rawGlobParts);
    this.debug(this.pattern, this.globParts);
    let set3 = this.globParts.map((s, _, __) => {
      if (this.isWindows && this.windowsNoMagicRoot) {
        const isUNC = s[0] === "" && s[1] === "" && (s[2] === "?" || !globMagic.test(s[2])) && !globMagic.test(s[3]);
        const isDrive = /^[a-z]:/i.test(s[0]);
        if (isUNC) {
          return [...s.slice(0, 4), ...s.slice(4).map((ss) => this.parse(ss))];
        } else if (isDrive) {
          return [s[0], ...s.slice(1).map((ss) => this.parse(ss))];
        }
      }
      return s.map((ss) => this.parse(ss));
    });
    this.debug(this.pattern, set3);
    this.set = set3.filter((s) => s.indexOf(false) === -1);
    if (this.isWindows) {
      for (let i = 0;i < this.set.length; i++) {
        const p = this.set[i];
        if (p[0] === "" && p[1] === "" && this.globParts[i][2] === "?" && typeof p[3] === "string" && /^[a-z]:$/i.test(p[3])) {
          p[2] = "?";
        }
      }
    }
    this.debug(this.pattern, this.set);
  }
  preprocess(globParts) {
    if (this.options.noglobstar) {
      for (let i = 0;i < globParts.length; i++) {
        for (let j = 0;j < globParts[i].length; j++) {
          if (globParts[i][j] === "**") {
            globParts[i][j] = "*";
          }
        }
      }
    }
    const { optimizationLevel = 1 } = this.options;
    if (optimizationLevel >= 2) {
      globParts = this.firstPhasePreProcess(globParts);
      globParts = this.secondPhasePreProcess(globParts);
    } else if (optimizationLevel >= 1) {
      globParts = this.levelOneOptimize(globParts);
    } else {
      globParts = this.adjascentGlobstarOptimize(globParts);
    }
    return globParts;
  }
  adjascentGlobstarOptimize(globParts) {
    return globParts.map((parts) => {
      let gs = -1;
      while ((gs = parts.indexOf("**", gs + 1)) !== -1) {
        let i = gs;
        while (parts[i + 1] === "**") {
          i++;
        }
        if (i !== gs) {
          parts.splice(gs, i - gs);
        }
      }
      return parts;
    });
  }
  levelOneOptimize(globParts) {
    return globParts.map((parts) => {
      parts = parts.reduce((set3, part) => {
        const prev = set3[set3.length - 1];
        if (part === "**" && prev === "**") {
          return set3;
        }
        if (part === "..") {
          if (prev && prev !== ".." && prev !== "." && prev !== "**") {
            set3.pop();
            return set3;
          }
        }
        set3.push(part);
        return set3;
      }, []);
      return parts.length === 0 ? [""] : parts;
    });
  }
  levelTwoFileOptimize(parts) {
    if (!Array.isArray(parts)) {
      parts = this.slashSplit(parts);
    }
    let didSomething = false;
    do {
      didSomething = false;
      if (!this.preserveMultipleSlashes) {
        for (let i = 1;i < parts.length - 1; i++) {
          const p = parts[i];
          if (i === 1 && p === "" && parts[0] === "")
            continue;
          if (p === "." || p === "") {
            didSomething = true;
            parts.splice(i, 1);
            i--;
          }
        }
        if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
          didSomething = true;
          parts.pop();
        }
      }
      let dd = 0;
      while ((dd = parts.indexOf("..", dd + 1)) !== -1) {
        const p = parts[dd - 1];
        if (p && p !== "." && p !== ".." && p !== "**") {
          didSomething = true;
          parts.splice(dd - 1, 2);
          dd -= 2;
        }
      }
    } while (didSomething);
    return parts.length === 0 ? [""] : parts;
  }
  firstPhasePreProcess(globParts) {
    let didSomething = false;
    do {
      didSomething = false;
      for (let parts of globParts) {
        let gs = -1;
        while ((gs = parts.indexOf("**", gs + 1)) !== -1) {
          let gss = gs;
          while (parts[gss + 1] === "**") {
            gss++;
          }
          if (gss > gs) {
            parts.splice(gs + 1, gss - gs);
          }
          let next = parts[gs + 1];
          const p = parts[gs + 2];
          const p2 = parts[gs + 3];
          if (next !== "..")
            continue;
          if (!p || p === "." || p === ".." || !p2 || p2 === "." || p2 === "..") {
            continue;
          }
          didSomething = true;
          parts.splice(gs, 1);
          const other = parts.slice(0);
          other[gs] = "**";
          globParts.push(other);
          gs--;
        }
        if (!this.preserveMultipleSlashes) {
          for (let i = 1;i < parts.length - 1; i++) {
            const p = parts[i];
            if (i === 1 && p === "" && parts[0] === "")
              continue;
            if (p === "." || p === "") {
              didSomething = true;
              parts.splice(i, 1);
              i--;
            }
          }
          if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
            didSomething = true;
            parts.pop();
          }
        }
        let dd = 0;
        while ((dd = parts.indexOf("..", dd + 1)) !== -1) {
          const p = parts[dd - 1];
          if (p && p !== "." && p !== ".." && p !== "**") {
            didSomething = true;
            const needDot = dd === 1 && parts[dd + 1] === "**";
            const splin = needDot ? ["."] : [];
            parts.splice(dd - 1, 2, ...splin);
            if (parts.length === 0)
              parts.push("");
            dd -= 2;
          }
        }
      }
    } while (didSomething);
    return globParts;
  }
  secondPhasePreProcess(globParts) {
    for (let i = 0;i < globParts.length - 1; i++) {
      for (let j = i + 1;j < globParts.length; j++) {
        const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);
        if (matched) {
          globParts[i] = [];
          globParts[j] = matched;
          break;
        }
      }
    }
    return globParts.filter((gs) => gs.length);
  }
  partsMatch(a, b, emptyGSMatch = false) {
    let ai = 0;
    let bi = 0;
    let result = [];
    let which = "";
    while (ai < a.length && bi < b.length) {
      if (a[ai] === b[bi]) {
        result.push(which === "b" ? b[bi] : a[ai]);
        ai++;
        bi++;
      } else if (emptyGSMatch && a[ai] === "**" && b[bi] === a[ai + 1]) {
        result.push(a[ai]);
        ai++;
      } else if (emptyGSMatch && b[bi] === "**" && a[ai] === b[bi + 1]) {
        result.push(b[bi]);
        bi++;
      } else if (a[ai] === "*" && b[bi] && (this.options.dot || !b[bi].startsWith(".")) && b[bi] !== "**") {
        if (which === "b")
          return false;
        which = "a";
        result.push(a[ai]);
        ai++;
        bi++;
      } else if (b[bi] === "*" && a[ai] && (this.options.dot || !a[ai].startsWith(".")) && a[ai] !== "**") {
        if (which === "a")
          return false;
        which = "b";
        result.push(b[bi]);
        ai++;
        bi++;
      } else {
        return false;
      }
    }
    return a.length === b.length && result;
  }
  parseNegate() {
    if (this.nonegate)
      return;
    const pattern = this.pattern;
    let negate = false;
    let negateOffset = 0;
    for (let i = 0;i < pattern.length && pattern.charAt(i) === "!"; i++) {
      negate = !negate;
      negateOffset++;
    }
    if (negateOffset)
      this.pattern = pattern.slice(negateOffset);
    this.negate = negate;
  }
  matchOne(file2, pattern, partial3 = false) {
    const options2 = this.options;
    if (this.isWindows) {
      const fileDrive = typeof file2[0] === "string" && /^[a-z]:$/i.test(file2[0]);
      const fileUNC = !fileDrive && file2[0] === "" && file2[1] === "" && file2[2] === "?" && /^[a-z]:$/i.test(file2[3]);
      const patternDrive = typeof pattern[0] === "string" && /^[a-z]:$/i.test(pattern[0]);
      const patternUNC = !patternDrive && pattern[0] === "" && pattern[1] === "" && pattern[2] === "?" && typeof pattern[3] === "string" && /^[a-z]:$/i.test(pattern[3]);
      const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined;
      const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined;
      if (typeof fdi === "number" && typeof pdi === "number") {
        const [fd, pd] = [file2[fdi], pattern[pdi]];
        if (fd.toLowerCase() === pd.toLowerCase()) {
          pattern[pdi] = fd;
          if (pdi > fdi) {
            pattern = pattern.slice(pdi);
          } else if (fdi > pdi) {
            file2 = file2.slice(fdi);
          }
        }
      }
    }
    const { optimizationLevel = 1 } = this.options;
    if (optimizationLevel >= 2) {
      file2 = this.levelTwoFileOptimize(file2);
    }
    this.debug("matchOne", this, { file: file2, pattern });
    this.debug("matchOne", file2.length, pattern.length);
    for (var fi = 0, pi = 0, fl = file2.length, pl = pattern.length;fi < fl && pi < pl; fi++, pi++) {
      this.debug("matchOne loop");
      var p = pattern[pi];
      var f = file2[fi];
      this.debug(pattern, p, f);
      if (p === false) {
        return false;
      }
      if (p === GLOBSTAR) {
        this.debug("GLOBSTAR", [pattern, p, f]);
        var fr = fi;
        var pr = pi + 1;
        if (pr === pl) {
          this.debug("** at the end");
          for (;fi < fl; fi++) {
            if (file2[fi] === "." || file2[fi] === ".." || !options2.dot && file2[fi].charAt(0) === ".")
              return false;
          }
          return true;
        }
        while (fr < fl) {
          var swallowee = file2[fr];
          this.debug(`
globstar while`, file2, fr, pattern, pr, swallowee);
          if (this.matchOne(file2.slice(fr), pattern.slice(pr), partial3)) {
            this.debug("globstar found match!", fr, fl, swallowee);
            return true;
          } else {
            if (swallowee === "." || swallowee === ".." || !options2.dot && swallowee.charAt(0) === ".") {
              this.debug("dot detected!", file2, fr, pattern, pr);
              break;
            }
            this.debug("globstar swallow a segment, and continue");
            fr++;
          }
        }
        if (partial3) {
          this.debug(`
>>> no match, partial?`, file2, fr, pattern, pr);
          if (fr === fl) {
            return true;
          }
        }
        return false;
      }
      let hit;
      if (typeof p === "string") {
        hit = f === p;
        this.debug("string match", p, f, hit);
      } else {
        hit = p.test(f);
        this.debug("pattern match", p, f, hit);
      }
      if (!hit)
        return false;
    }
    if (fi === fl && pi === pl) {
      return true;
    } else if (fi === fl) {
      return partial3;
    } else if (pi === pl) {
      return fi === fl - 1 && file2[fi] === "";
    } else {
      throw new Error("wtf?");
    }
  }
  braceExpand() {
    return braceExpand(this.pattern, this.options);
  }
  parse(pattern) {
    assertValidPattern(pattern);
    const options2 = this.options;
    if (pattern === "**")
      return GLOBSTAR;
    if (pattern === "")
      return "";
    let m;
    let fastTest = null;
    if (m = pattern.match(starRE)) {
      fastTest = options2.dot ? starTestDot : starTest;
    } else if (m = pattern.match(starDotExtRE)) {
      fastTest = (options2.nocase ? options2.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options2.dot ? starDotExtTestDot : starDotExtTest)(m[1]);
    } else if (m = pattern.match(qmarksRE)) {
      fastTest = (options2.nocase ? options2.dot ? qmarksTestNocaseDot : qmarksTestNocase : options2.dot ? qmarksTestDot : qmarksTest)(m);
    } else if (m = pattern.match(starDotStarRE)) {
      fastTest = options2.dot ? starDotStarTestDot : starDotStarTest;
    } else if (m = pattern.match(dotStarRE)) {
      fastTest = dotStarTest;
    }
    const re = AST.fromGlob(pattern, this.options).toMMPattern();
    if (fastTest && typeof re === "object") {
      Reflect.defineProperty(re, "test", { value: fastTest });
    }
    return re;
  }
  makeRe() {
    if (this.regexp || this.regexp === false)
      return this.regexp;
    const set3 = this.set;
    if (!set3.length) {
      this.regexp = false;
      return this.regexp;
    }
    const options2 = this.options;
    const twoStar = options2.noglobstar ? star2 : options2.dot ? twoStarDot : twoStarNoDot;
    const flags = new Set(options2.nocase ? ["i"] : []);
    let re = set3.map((pattern) => {
      const pp = pattern.map((p) => {
        if (p instanceof RegExp) {
          for (const f of p.flags.split(""))
            flags.add(f);
        }
        return typeof p === "string" ? regExpEscape2(p) : p === GLOBSTAR ? GLOBSTAR : p._src;
      });
      pp.forEach((p, i) => {
        const next = pp[i + 1];
        const prev = pp[i - 1];
        if (p !== GLOBSTAR || prev === GLOBSTAR) {
          return;
        }
        if (prev === undefined) {
          if (next !== undefined && next !== GLOBSTAR) {
            pp[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + next;
          } else {
            pp[i] = twoStar;
          }
        } else if (next === undefined) {
          pp[i - 1] = prev + "(?:\\/|\\/" + twoStar + ")?";
        } else if (next !== GLOBSTAR) {
          pp[i - 1] = prev + "(?:\\/|\\/" + twoStar + "\\/)" + next;
          pp[i + 1] = GLOBSTAR;
        }
      });
      const filtered = pp.filter((p) => p !== GLOBSTAR);
      if (this.partial && filtered.length >= 1) {
        const prefixes = [];
        for (let i = 1;i <= filtered.length; i++) {
          prefixes.push(filtered.slice(0, i).join("/"));
        }
        return "(?:" + prefixes.join("|") + ")";
      }
      return filtered.join("/");
    }).join("|");
    const [open, close] = set3.length > 1 ? ["(?:", ")"] : ["", ""];
    re = "^" + open + re + close + "$";
    if (this.partial) {
      re = "^(?:\\/|" + open + re.slice(1, -1) + close + ")$";
    }
    if (this.negate)
      re = "^(?!" + re + ").+$";
    try {
      this.regexp = new RegExp(re, [...flags].join(""));
    } catch (ex) {
      this.regexp = false;
    }
    return this.regexp;
  }
  slashSplit(p) {
    if (this.preserveMultipleSlashes) {
      return p.split("/");
    } else if (this.isWindows && /^\/\/[^\/]+/.test(p)) {
      return ["", ...p.split(/\/+/)];
    } else {
      return p.split(/\/+/);
    }
  }
  match(f, partial3 = this.partial) {
    this.debug("match", f, this.pattern);
    if (this.comment) {
      return false;
    }
    if (this.empty) {
      return f === "";
    }
    if (f === "/" && partial3) {
      return true;
    }
    const options2 = this.options;
    if (this.isWindows) {
      f = f.split("\\").join("/");
    }
    const ff = this.slashSplit(f);
    this.debug(this.pattern, "split", ff);
    const set3 = this.set;
    this.debug(this.pattern, "set", set3);
    let filename = ff[ff.length - 1];
    if (!filename) {
      for (let i = ff.length - 2;!filename && i >= 0; i--) {
        filename = ff[i];
      }
    }
    for (let i = 0;i < set3.length; i++) {
      const pattern = set3[i];
      let file2 = ff;
      if (options2.matchBase && pattern.length === 1) {
        file2 = [filename];
      }
      const hit = this.matchOne(file2, pattern, partial3);
      if (hit) {
        if (options2.flipNegate) {
          return true;
        }
        return !this.negate;
      }
    }
    if (options2.flipNegate) {
      return false;
    }
    return this.negate;
  }
  static defaults(def) {
    return minimatch.defaults(def).Minimatch;
  }
}
minimatch.AST = AST;
minimatch.Minimatch = Minimatch;
minimatch.escape = escape2;
minimatch.unescape = unescape2;

// node_modules/glob/dist/esm/glob.js
import { fileURLToPath as fileURLToPath2 } from "url";

// node_modules/lru-cache/dist/esm/index.js
var defaultPerf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
var warned = new Set;
var PROCESS = typeof process === "object" && !!process ? process : {};
var emitWarning = (msg, type, code, fn) => {
  typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type, code, fn) : console.error(`[${code}] ${type}: ${msg}`);
};
var AC = globalThis.AbortController;
var AS = globalThis.AbortSignal;
if (typeof AC === "undefined") {
  AS = class AbortSignal2 {
    onabort;
    _onabort = [];
    reason;
    aborted = false;
    addEventListener(_, fn) {
      this._onabort.push(fn);
    }
  };
  AC = class AbortController2 {
    constructor() {
      warnACPolyfill();
    }
    signal = new AS;
    abort(reason) {
      if (this.signal.aborted)
        return;
      this.signal.reason = reason;
      this.signal.aborted = true;
      for (const fn of this.signal._onabort) {
        fn(reason);
      }
      this.signal.onabort?.(reason);
    }
  };
  let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
  const warnACPolyfill = () => {
    if (!printACPolyfillWarning)
      return;
    printACPolyfillWarning = false;
    emitWarning("AbortController is not defined. If using lru-cache in " + "node 14, load an AbortController polyfill from the " + "`node-abort-controller` package. A minimal polyfill is " + "provided for use by LRUCache.fetch(), but it should not be " + "relied upon in other contexts (eg, passing it to other APIs that " + "use AbortController/AbortSignal might have undesirable effects). " + "You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
  };
}
var shouldWarn = (code) => !warned.has(code);
var TYPE = Symbol("type");
var isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
var getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;

class ZeroArray extends Array {
  constructor(size) {
    super(size);
    this.fill(0);
  }
}

class Stack {
  heap;
  length;
  static #constructing = false;
  static create(max) {
    const HeapCls = getUintArray(max);
    if (!HeapCls)
      return [];
    Stack.#constructing = true;
    const s = new Stack(max, HeapCls);
    Stack.#constructing = false;
    return s;
  }
  constructor(max, HeapCls) {
    if (!Stack.#constructing) {
      throw new TypeError("instantiate Stack using Stack.create(n)");
    }
    this.heap = new HeapCls(max);
    this.length = 0;
  }
  push(n) {
    this.heap[this.length++] = n;
  }
  pop() {
    return this.heap[--this.length];
  }
}

class LRUCache {
  #max;
  #maxSize;
  #dispose;
  #onInsert;
  #disposeAfter;
  #fetchMethod;
  #memoMethod;
  #perf;
  get perf() {
    return this.#perf;
  }
  ttl;
  ttlResolution;
  ttlAutopurge;
  updateAgeOnGet;
  updateAgeOnHas;
  allowStale;
  noDisposeOnSet;
  noUpdateTTL;
  maxEntrySize;
  sizeCalculation;
  noDeleteOnFetchRejection;
  noDeleteOnStaleGet;
  allowStaleOnFetchAbort;
  allowStaleOnFetchRejection;
  ignoreFetchAbort;
  #size;
  #calculatedSize;
  #keyMap;
  #keyList;
  #valList;
  #next;
  #prev;
  #head;
  #tail;
  #free;
  #disposed;
  #sizes;
  #starts;
  #ttls;
  #autopurgeTimers;
  #hasDispose;
  #hasFetchMethod;
  #hasDisposeAfter;
  #hasOnInsert;
  static unsafeExposeInternals(c) {
    return {
      starts: c.#starts,
      ttls: c.#ttls,
      autopurgeTimers: c.#autopurgeTimers,
      sizes: c.#sizes,
      keyMap: c.#keyMap,
      keyList: c.#keyList,
      valList: c.#valList,
      next: c.#next,
      prev: c.#prev,
      get head() {
        return c.#head;
      },
      get tail() {
        return c.#tail;
      },
      free: c.#free,
      isBackgroundFetch: (p) => c.#isBackgroundFetch(p),
      backgroundFetch: (k, index, options2, context) => c.#backgroundFetch(k, index, options2, context),
      moveToTail: (index) => c.#moveToTail(index),
      indexes: (options2) => c.#indexes(options2),
      rindexes: (options2) => c.#rindexes(options2),
      isStale: (index) => c.#isStale(index)
    };
  }
  get max() {
    return this.#max;
  }
  get maxSize() {
    return this.#maxSize;
  }
  get calculatedSize() {
    return this.#calculatedSize;
  }
  get size() {
    return this.#size;
  }
  get fetchMethod() {
    return this.#fetchMethod;
  }
  get memoMethod() {
    return this.#memoMethod;
  }
  get dispose() {
    return this.#dispose;
  }
  get onInsert() {
    return this.#onInsert;
  }
  get disposeAfter() {
    return this.#disposeAfter;
  }
  constructor(options2) {
    const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, onInsert, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort, perf } = options2;
    if (perf !== undefined) {
      if (typeof perf?.now !== "function") {
        throw new TypeError("perf option must have a now() method if specified");
      }
    }
    this.#perf = perf ?? defaultPerf;
    if (max !== 0 && !isPosInt(max)) {
      throw new TypeError("max option must be a nonnegative integer");
    }
    const UintArray = max ? getUintArray(max) : Array;
    if (!UintArray) {
      throw new Error("invalid max value: " + max);
    }
    this.#max = max;
    this.#maxSize = maxSize;
    this.maxEntrySize = maxEntrySize || this.#maxSize;
    this.sizeCalculation = sizeCalculation;
    if (this.sizeCalculation) {
      if (!this.#maxSize && !this.maxEntrySize) {
        throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
      }
      if (typeof this.sizeCalculation !== "function") {
        throw new TypeError("sizeCalculation set to non-function");
      }
    }
    if (memoMethod !== undefined && typeof memoMethod !== "function") {
      throw new TypeError("memoMethod must be a function if defined");
    }
    this.#memoMethod = memoMethod;
    if (fetchMethod !== undefined && typeof fetchMethod !== "function") {
      throw new TypeError("fetchMethod must be a function if specified");
    }
    this.#fetchMethod = fetchMethod;
    this.#hasFetchMethod = !!fetchMethod;
    this.#keyMap = new Map;
    this.#keyList = new Array(max).fill(undefined);
    this.#valList = new Array(max).fill(undefined);
    this.#next = new UintArray(max);
    this.#prev = new UintArray(max);
    this.#head = 0;
    this.#tail = 0;
    this.#free = Stack.create(max);
    this.#size = 0;
    this.#calculatedSize = 0;
    if (typeof dispose === "function") {
      this.#dispose = dispose;
    }
    if (typeof onInsert === "function") {
      this.#onInsert = onInsert;
    }
    if (typeof disposeAfter === "function") {
      this.#disposeAfter = disposeAfter;
      this.#disposed = [];
    } else {
      this.#disposeAfter = undefined;
      this.#disposed = undefined;
    }
    this.#hasDispose = !!this.#dispose;
    this.#hasOnInsert = !!this.#onInsert;
    this.#hasDisposeAfter = !!this.#disposeAfter;
    this.noDisposeOnSet = !!noDisposeOnSet;
    this.noUpdateTTL = !!noUpdateTTL;
    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
    this.ignoreFetchAbort = !!ignoreFetchAbort;
    if (this.maxEntrySize !== 0) {
      if (this.#maxSize !== 0) {
        if (!isPosInt(this.#maxSize)) {
          throw new TypeError("maxSize must be a positive integer if specified");
        }
      }
      if (!isPosInt(this.maxEntrySize)) {
        throw new TypeError("maxEntrySize must be a positive integer if specified");
      }
      this.#initializeSizeTracking();
    }
    this.allowStale = !!allowStale;
    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
    this.updateAgeOnGet = !!updateAgeOnGet;
    this.updateAgeOnHas = !!updateAgeOnHas;
    this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
    this.ttlAutopurge = !!ttlAutopurge;
    this.ttl = ttl || 0;
    if (this.ttl) {
      if (!isPosInt(this.ttl)) {
        throw new TypeError("ttl must be a positive integer if specified");
      }
      this.#initializeTTLTracking();
    }
    if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
      throw new TypeError("At least one of max, maxSize, or ttl is required");
    }
    if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
      const code = "LRU_CACHE_UNBOUNDED";
      if (shouldWarn(code)) {
        warned.add(code);
        const msg = "TTL caching without ttlAutopurge, max, or maxSize can " + "result in unbounded memory consumption.";
        emitWarning(msg, "UnboundedCacheWarning", code, LRUCache);
      }
    }
  }
  getRemainingTTL(key) {
    return this.#keyMap.has(key) ? Infinity : 0;
  }
  #initializeTTLTracking() {
    const ttls = new ZeroArray(this.#max);
    const starts = new ZeroArray(this.#max);
    this.#ttls = ttls;
    this.#starts = starts;
    const purgeTimers = this.ttlAutopurge ? new Array(this.#max) : undefined;
    this.#autopurgeTimers = purgeTimers;
    this.#setItemTTL = (index, ttl, start = this.#perf.now()) => {
      starts[index] = ttl !== 0 ? start : 0;
      ttls[index] = ttl;
      if (purgeTimers?.[index]) {
        clearTimeout(purgeTimers[index]);
        purgeTimers[index] = undefined;
      }
      if (ttl !== 0 && purgeTimers) {
        const t = setTimeout(() => {
          if (this.#isStale(index)) {
            this.#delete(this.#keyList[index], "expire");
          }
        }, ttl + 1);
        if (t.unref) {
          t.unref();
        }
        purgeTimers[index] = t;
      }
    };
    this.#updateItemAge = (index) => {
      starts[index] = ttls[index] !== 0 ? this.#perf.now() : 0;
    };
    this.#statusTTL = (status, index) => {
      if (ttls[index]) {
        const ttl = ttls[index];
        const start = starts[index];
        if (!ttl || !start)
          return;
        status.ttl = ttl;
        status.start = start;
        status.now = cachedNow || getNow();
        const age = status.now - start;
        status.remainingTTL = ttl - age;
      }
    };
    let cachedNow = 0;
    const getNow = () => {
      const n = this.#perf.now();
      if (this.ttlResolution > 0) {
        cachedNow = n;
        const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
        if (t.unref) {
          t.unref();
        }
      }
      return n;
    };
    this.getRemainingTTL = (key) => {
      const index = this.#keyMap.get(key);
      if (index === undefined) {
        return 0;
      }
      const ttl = ttls[index];
      const start = starts[index];
      if (!ttl || !start) {
        return Infinity;
      }
      const age = (cachedNow || getNow()) - start;
      return ttl - age;
    };
    this.#isStale = (index) => {
      const s = starts[index];
      const t = ttls[index];
      return !!t && !!s && (cachedNow || getNow()) - s > t;
    };
  }
  #updateItemAge = () => {};
  #statusTTL = () => {};
  #setItemTTL = () => {};
  #isStale = () => false;
  #initializeSizeTracking() {
    const sizes = new ZeroArray(this.#max);
    this.#calculatedSize = 0;
    this.#sizes = sizes;
    this.#removeItemSize = (index) => {
      this.#calculatedSize -= sizes[index];
      sizes[index] = 0;
    };
    this.#requireSize = (k, v, size, sizeCalculation) => {
      if (this.#isBackgroundFetch(v)) {
        return 0;
      }
      if (!isPosInt(size)) {
        if (sizeCalculation) {
          if (typeof sizeCalculation !== "function") {
            throw new TypeError("sizeCalculation must be a function");
          }
          size = sizeCalculation(v, k);
          if (!isPosInt(size)) {
            throw new TypeError("sizeCalculation return invalid (expect positive integer)");
          }
        } else {
          throw new TypeError("invalid size value (must be positive integer). " + "When maxSize or maxEntrySize is used, sizeCalculation " + "or size must be set.");
        }
      }
      return size;
    };
    this.#addItemSize = (index, size, status) => {
      sizes[index] = size;
      if (this.#maxSize) {
        const maxSize = this.#maxSize - sizes[index];
        while (this.#calculatedSize > maxSize) {
          this.#evict(true);
        }
      }
      this.#calculatedSize += sizes[index];
      if (status) {
        status.entrySize = size;
        status.totalCalculatedSize = this.#calculatedSize;
      }
    };
  }
  #removeItemSize = (_i) => {};
  #addItemSize = (_i, _s, _st) => {};
  #requireSize = (_k, _v, size, sizeCalculation) => {
    if (size || sizeCalculation) {
      throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
    }
    return 0;
  };
  *#indexes({ allowStale = this.allowStale } = {}) {
    if (this.#size) {
      for (let i = this.#tail;; ) {
        if (!this.#isValidIndex(i)) {
          break;
        }
        if (allowStale || !this.#isStale(i)) {
          yield i;
        }
        if (i === this.#head) {
          break;
        } else {
          i = this.#prev[i];
        }
      }
    }
  }
  *#rindexes({ allowStale = this.allowStale } = {}) {
    if (this.#size) {
      for (let i = this.#head;; ) {
        if (!this.#isValidIndex(i)) {
          break;
        }
        if (allowStale || !this.#isStale(i)) {
          yield i;
        }
        if (i === this.#tail) {
          break;
        } else {
          i = this.#next[i];
        }
      }
    }
  }
  #isValidIndex(index) {
    return index !== undefined && this.#keyMap.get(this.#keyList[index]) === index;
  }
  *entries() {
    for (const i of this.#indexes()) {
      if (this.#valList[i] !== undefined && this.#keyList[i] !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
        yield [this.#keyList[i], this.#valList[i]];
      }
    }
  }
  *rentries() {
    for (const i of this.#rindexes()) {
      if (this.#valList[i] !== undefined && this.#keyList[i] !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
        yield [this.#keyList[i], this.#valList[i]];
      }
    }
  }
  *keys() {
    for (const i of this.#indexes()) {
      const k = this.#keyList[i];
      if (k !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
        yield k;
      }
    }
  }
  *rkeys() {
    for (const i of this.#rindexes()) {
      const k = this.#keyList[i];
      if (k !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
        yield k;
      }
    }
  }
  *values() {
    for (const i of this.#indexes()) {
      const v = this.#valList[i];
      if (v !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
        yield this.#valList[i];
      }
    }
  }
  *rvalues() {
    for (const i of this.#rindexes()) {
      const v = this.#valList[i];
      if (v !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
        yield this.#valList[i];
      }
    }
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  [Symbol.toStringTag] = "LRUCache";
  find(fn, getOptions = {}) {
    for (const i of this.#indexes()) {
      const v = this.#valList[i];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === undefined)
        continue;
      if (fn(value, this.#keyList[i], this)) {
        return this.get(this.#keyList[i], getOptions);
      }
    }
  }
  forEach(fn, thisp = this) {
    for (const i of this.#indexes()) {
      const v = this.#valList[i];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === undefined)
        continue;
      fn.call(thisp, value, this.#keyList[i], this);
    }
  }
  rforEach(fn, thisp = this) {
    for (const i of this.#rindexes()) {
      const v = this.#valList[i];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === undefined)
        continue;
      fn.call(thisp, value, this.#keyList[i], this);
    }
  }
  purgeStale() {
    let deleted = false;
    for (const i of this.#rindexes({ allowStale: true })) {
      if (this.#isStale(i)) {
        this.#delete(this.#keyList[i], "expire");
        deleted = true;
      }
    }
    return deleted;
  }
  info(key) {
    const i = this.#keyMap.get(key);
    if (i === undefined)
      return;
    const v = this.#valList[i];
    const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
    if (value === undefined)
      return;
    const entry = { value };
    if (this.#ttls && this.#starts) {
      const ttl = this.#ttls[i];
      const start = this.#starts[i];
      if (ttl && start) {
        const remain = ttl - (this.#perf.now() - start);
        entry.ttl = remain;
        entry.start = Date.now();
      }
    }
    if (this.#sizes) {
      entry.size = this.#sizes[i];
    }
    return entry;
  }
  dump() {
    const arr = [];
    for (const i of this.#indexes({ allowStale: true })) {
      const key = this.#keyList[i];
      const v = this.#valList[i];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === undefined || key === undefined)
        continue;
      const entry = { value };
      if (this.#ttls && this.#starts) {
        entry.ttl = this.#ttls[i];
        const age = this.#perf.now() - this.#starts[i];
        entry.start = Math.floor(Date.now() - age);
      }
      if (this.#sizes) {
        entry.size = this.#sizes[i];
      }
      arr.unshift([key, entry]);
    }
    return arr;
  }
  load(arr) {
    this.clear();
    for (const [key, entry] of arr) {
      if (entry.start) {
        const age = Date.now() - entry.start;
        entry.start = this.#perf.now() - age;
      }
      this.set(key, entry.value, entry);
    }
  }
  set(k, v, setOptions = {}) {
    if (v === undefined) {
      this.delete(k);
      return this;
    }
    const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
    let { noUpdateTTL = this.noUpdateTTL } = setOptions;
    const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
    if (this.maxEntrySize && size > this.maxEntrySize) {
      if (status) {
        status.set = "miss";
        status.maxEntrySizeExceeded = true;
      }
      this.#delete(k, "set");
      return this;
    }
    let index = this.#size === 0 ? undefined : this.#keyMap.get(k);
    if (index === undefined) {
      index = this.#size === 0 ? this.#tail : this.#free.length !== 0 ? this.#free.pop() : this.#size === this.#max ? this.#evict(false) : this.#size;
      this.#keyList[index] = k;
      this.#valList[index] = v;
      this.#keyMap.set(k, index);
      this.#next[this.#tail] = index;
      this.#prev[index] = this.#tail;
      this.#tail = index;
      this.#size++;
      this.#addItemSize(index, size, status);
      if (status)
        status.set = "add";
      noUpdateTTL = false;
      if (this.#hasOnInsert) {
        this.#onInsert?.(v, k, "add");
      }
    } else {
      this.#moveToTail(index);
      const oldVal = this.#valList[index];
      if (v !== oldVal) {
        if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
          oldVal.__abortController.abort(new Error("replaced"));
          const { __staleWhileFetching: s } = oldVal;
          if (s !== undefined && !noDisposeOnSet) {
            if (this.#hasDispose) {
              this.#dispose?.(s, k, "set");
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([s, k, "set"]);
            }
          }
        } else if (!noDisposeOnSet) {
          if (this.#hasDispose) {
            this.#dispose?.(oldVal, k, "set");
          }
          if (this.#hasDisposeAfter) {
            this.#disposed?.push([oldVal, k, "set"]);
          }
        }
        this.#removeItemSize(index);
        this.#addItemSize(index, size, status);
        this.#valList[index] = v;
        if (status) {
          status.set = "replace";
          const oldValue = oldVal && this.#isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
          if (oldValue !== undefined)
            status.oldValue = oldValue;
        }
      } else if (status) {
        status.set = "update";
      }
      if (this.#hasOnInsert) {
        this.onInsert?.(v, k, v === oldVal ? "update" : "replace");
      }
    }
    if (ttl !== 0 && !this.#ttls) {
      this.#initializeTTLTracking();
    }
    if (this.#ttls) {
      if (!noUpdateTTL) {
        this.#setItemTTL(index, ttl, start);
      }
      if (status)
        this.#statusTTL(status, index);
    }
    if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
      const dt = this.#disposed;
      let task;
      while (task = dt?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
    return this;
  }
  pop() {
    try {
      while (this.#size) {
        const val = this.#valList[this.#head];
        this.#evict(true);
        if (this.#isBackgroundFetch(val)) {
          if (val.__staleWhileFetching) {
            return val.__staleWhileFetching;
          }
        } else if (val !== undefined) {
          return val;
        }
      }
    } finally {
      if (this.#hasDisposeAfter && this.#disposed) {
        const dt = this.#disposed;
        let task;
        while (task = dt?.shift()) {
          this.#disposeAfter?.(...task);
        }
      }
    }
  }
  #evict(free) {
    const head = this.#head;
    const k = this.#keyList[head];
    const v = this.#valList[head];
    if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {
      v.__abortController.abort(new Error("evicted"));
    } else if (this.#hasDispose || this.#hasDisposeAfter) {
      if (this.#hasDispose) {
        this.#dispose?.(v, k, "evict");
      }
      if (this.#hasDisposeAfter) {
        this.#disposed?.push([v, k, "evict"]);
      }
    }
    this.#removeItemSize(head);
    if (this.#autopurgeTimers?.[head]) {
      clearTimeout(this.#autopurgeTimers[head]);
      this.#autopurgeTimers[head] = undefined;
    }
    if (free) {
      this.#keyList[head] = undefined;
      this.#valList[head] = undefined;
      this.#free.push(head);
    }
    if (this.#size === 1) {
      this.#head = this.#tail = 0;
      this.#free.length = 0;
    } else {
      this.#head = this.#next[head];
    }
    this.#keyMap.delete(k);
    this.#size--;
    return head;
  }
  has(k, hasOptions = {}) {
    const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
    const index = this.#keyMap.get(k);
    if (index !== undefined) {
      const v = this.#valList[index];
      if (this.#isBackgroundFetch(v) && v.__staleWhileFetching === undefined) {
        return false;
      }
      if (!this.#isStale(index)) {
        if (updateAgeOnHas) {
          this.#updateItemAge(index);
        }
        if (status) {
          status.has = "hit";
          this.#statusTTL(status, index);
        }
        return true;
      } else if (status) {
        status.has = "stale";
        this.#statusTTL(status, index);
      }
    } else if (status) {
      status.has = "miss";
    }
    return false;
  }
  peek(k, peekOptions = {}) {
    const { allowStale = this.allowStale } = peekOptions;
    const index = this.#keyMap.get(k);
    if (index === undefined || !allowStale && this.#isStale(index)) {
      return;
    }
    const v = this.#valList[index];
    return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
  }
  #backgroundFetch(k, index, options2, context) {
    const v = index === undefined ? undefined : this.#valList[index];
    if (this.#isBackgroundFetch(v)) {
      return v;
    }
    const ac = new AC;
    const { signal } = options2;
    signal?.addEventListener("abort", () => ac.abort(signal.reason), {
      signal: ac.signal
    });
    const fetchOpts = {
      signal: ac.signal,
      options: options2,
      context
    };
    const cb = (v2, updateCache = false) => {
      const { aborted: aborted3 } = ac.signal;
      const ignoreAbort = options2.ignoreFetchAbort && v2 !== undefined;
      const proceed = options2.ignoreFetchAbort || !!(options2.allowStaleOnFetchAbort && v2 !== undefined);
      if (options2.status) {
        if (aborted3 && !updateCache) {
          options2.status.fetchAborted = true;
          options2.status.fetchError = ac.signal.reason;
          if (ignoreAbort)
            options2.status.fetchAbortIgnored = true;
        } else {
          options2.status.fetchResolved = true;
        }
      }
      if (aborted3 && !ignoreAbort && !updateCache) {
        return fetchFail(ac.signal.reason, proceed);
      }
      const bf2 = p;
      const vl = this.#valList[index];
      if (vl === p || ignoreAbort && updateCache && vl === undefined) {
        if (v2 === undefined) {
          if (bf2.__staleWhileFetching !== undefined) {
            this.#valList[index] = bf2.__staleWhileFetching;
          } else {
            this.#delete(k, "fetch");
          }
        } else {
          if (options2.status)
            options2.status.fetchUpdated = true;
          this.set(k, v2, fetchOpts.options);
        }
      }
      return v2;
    };
    const eb = (er) => {
      if (options2.status) {
        options2.status.fetchRejected = true;
        options2.status.fetchError = er;
      }
      return fetchFail(er, false);
    };
    const fetchFail = (er, proceed) => {
      const { aborted: aborted3 } = ac.signal;
      const allowStaleAborted = aborted3 && options2.allowStaleOnFetchAbort;
      const allowStale = allowStaleAborted || options2.allowStaleOnFetchRejection;
      const noDelete = allowStale || options2.noDeleteOnFetchRejection;
      const bf2 = p;
      if (this.#valList[index] === p) {
        const del = !noDelete || !proceed && bf2.__staleWhileFetching === undefined;
        if (del) {
          this.#delete(k, "fetch");
        } else if (!allowStaleAborted) {
          this.#valList[index] = bf2.__staleWhileFetching;
        }
      }
      if (allowStale) {
        if (options2.status && bf2.__staleWhileFetching !== undefined) {
          options2.status.returnedStale = true;
        }
        return bf2.__staleWhileFetching;
      } else if (bf2.__returned === bf2) {
        throw er;
      }
    };
    const pcall = (res, rej) => {
      const fmp = this.#fetchMethod?.(k, v, fetchOpts);
      if (fmp && fmp instanceof Promise) {
        fmp.then((v2) => res(v2 === undefined ? undefined : v2), rej);
      }
      ac.signal.addEventListener("abort", () => {
        if (!options2.ignoreFetchAbort || options2.allowStaleOnFetchAbort) {
          res(undefined);
          if (options2.allowStaleOnFetchAbort) {
            res = (v2) => cb(v2, true);
          }
        }
      });
    };
    if (options2.status)
      options2.status.fetchDispatched = true;
    const p = new Promise(pcall).then(cb, eb);
    const bf = Object.assign(p, {
      __abortController: ac,
      __staleWhileFetching: v,
      __returned: undefined
    });
    if (index === undefined) {
      this.set(k, bf, { ...fetchOpts.options, status: undefined });
      index = this.#keyMap.get(k);
    } else {
      this.#valList[index] = bf;
    }
    return bf;
  }
  #isBackgroundFetch(p) {
    if (!this.#hasFetchMethod)
      return false;
    const b = p;
    return !!b && b instanceof Promise && b.hasOwnProperty("__staleWhileFetching") && b.__abortController instanceof AC;
  }
  async fetch(k, fetchOptions = {}) {
    const {
      allowStale = this.allowStale,
      updateAgeOnGet = this.updateAgeOnGet,
      noDeleteOnStaleGet = this.noDeleteOnStaleGet,
      ttl = this.ttl,
      noDisposeOnSet = this.noDisposeOnSet,
      size = 0,
      sizeCalculation = this.sizeCalculation,
      noUpdateTTL = this.noUpdateTTL,
      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
      ignoreFetchAbort = this.ignoreFetchAbort,
      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
      context,
      forceRefresh = false,
      status,
      signal
    } = fetchOptions;
    if (!this.#hasFetchMethod) {
      if (status)
        status.fetch = "get";
      return this.get(k, {
        allowStale,
        updateAgeOnGet,
        noDeleteOnStaleGet,
        status
      });
    }
    const options2 = {
      allowStale,
      updateAgeOnGet,
      noDeleteOnStaleGet,
      ttl,
      noDisposeOnSet,
      size,
      sizeCalculation,
      noUpdateTTL,
      noDeleteOnFetchRejection,
      allowStaleOnFetchRejection,
      allowStaleOnFetchAbort,
      ignoreFetchAbort,
      status,
      signal
    };
    let index = this.#keyMap.get(k);
    if (index === undefined) {
      if (status)
        status.fetch = "miss";
      const p = this.#backgroundFetch(k, index, options2, context);
      return p.__returned = p;
    } else {
      const v = this.#valList[index];
      if (this.#isBackgroundFetch(v)) {
        const stale = allowStale && v.__staleWhileFetching !== undefined;
        if (status) {
          status.fetch = "inflight";
          if (stale)
            status.returnedStale = true;
        }
        return stale ? v.__staleWhileFetching : v.__returned = v;
      }
      const isStale = this.#isStale(index);
      if (!forceRefresh && !isStale) {
        if (status)
          status.fetch = "hit";
        this.#moveToTail(index);
        if (updateAgeOnGet) {
          this.#updateItemAge(index);
        }
        if (status)
          this.#statusTTL(status, index);
        return v;
      }
      const p = this.#backgroundFetch(k, index, options2, context);
      const hasStale = p.__staleWhileFetching !== undefined;
      const staleVal = hasStale && allowStale;
      if (status) {
        status.fetch = isStale ? "stale" : "refresh";
        if (staleVal && isStale)
          status.returnedStale = true;
      }
      return staleVal ? p.__staleWhileFetching : p.__returned = p;
    }
  }
  async forceFetch(k, fetchOptions = {}) {
    const v = await this.fetch(k, fetchOptions);
    if (v === undefined)
      throw new Error("fetch() returned undefined");
    return v;
  }
  memo(k, memoOptions = {}) {
    const memoMethod = this.#memoMethod;
    if (!memoMethod) {
      throw new Error("no memoMethod provided to constructor");
    }
    const { context, forceRefresh, ...options2 } = memoOptions;
    const v = this.get(k, options2);
    if (!forceRefresh && v !== undefined)
      return v;
    const vv = memoMethod(k, v, {
      options: options2,
      context
    });
    this.set(k, vv, options2);
    return vv;
  }
  get(k, getOptions = {}) {
    const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
    const index = this.#keyMap.get(k);
    if (index !== undefined) {
      const value = this.#valList[index];
      const fetching = this.#isBackgroundFetch(value);
      if (status)
        this.#statusTTL(status, index);
      if (this.#isStale(index)) {
        if (status)
          status.get = "stale";
        if (!fetching) {
          if (!noDeleteOnStaleGet) {
            this.#delete(k, "expire");
          }
          if (status && allowStale)
            status.returnedStale = true;
          return allowStale ? value : undefined;
        } else {
          if (status && allowStale && value.__staleWhileFetching !== undefined) {
            status.returnedStale = true;
          }
          return allowStale ? value.__staleWhileFetching : undefined;
        }
      } else {
        if (status)
          status.get = "hit";
        if (fetching) {
          return value.__staleWhileFetching;
        }
        this.#moveToTail(index);
        if (updateAgeOnGet) {
          this.#updateItemAge(index);
        }
        return value;
      }
    } else if (status) {
      status.get = "miss";
    }
  }
  #connect(p, n) {
    this.#prev[n] = p;
    this.#next[p] = n;
  }
  #moveToTail(index) {
    if (index !== this.#tail) {
      if (index === this.#head) {
        this.#head = this.#next[index];
      } else {
        this.#connect(this.#prev[index], this.#next[index]);
      }
      this.#connect(this.#tail, index);
      this.#tail = index;
    }
  }
  delete(k) {
    return this.#delete(k, "delete");
  }
  #delete(k, reason) {
    let deleted = false;
    if (this.#size !== 0) {
      const index = this.#keyMap.get(k);
      if (index !== undefined) {
        if (this.#autopurgeTimers?.[index]) {
          clearTimeout(this.#autopurgeTimers?.[index]);
          this.#autopurgeTimers[index] = undefined;
        }
        deleted = true;
        if (this.#size === 1) {
          this.#clear(reason);
        } else {
          this.#removeItemSize(index);
          const v = this.#valList[index];
          if (this.#isBackgroundFetch(v)) {
            v.__abortController.abort(new Error("deleted"));
          } else if (this.#hasDispose || this.#hasDisposeAfter) {
            if (this.#hasDispose) {
              this.#dispose?.(v, k, reason);
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([v, k, reason]);
            }
          }
          this.#keyMap.delete(k);
          this.#keyList[index] = undefined;
          this.#valList[index] = undefined;
          if (index === this.#tail) {
            this.#tail = this.#prev[index];
          } else if (index === this.#head) {
            this.#head = this.#next[index];
          } else {
            const pi = this.#prev[index];
            this.#next[pi] = this.#next[index];
            const ni = this.#next[index];
            this.#prev[ni] = this.#prev[index];
          }
          this.#size--;
          this.#free.push(index);
        }
      }
    }
    if (this.#hasDisposeAfter && this.#disposed?.length) {
      const dt = this.#disposed;
      let task;
      while (task = dt?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
    return deleted;
  }
  clear() {
    return this.#clear("delete");
  }
  #clear(reason) {
    for (const index of this.#rindexes({ allowStale: true })) {
      const v = this.#valList[index];
      if (this.#isBackgroundFetch(v)) {
        v.__abortController.abort(new Error("deleted"));
      } else {
        const k = this.#keyList[index];
        if (this.#hasDispose) {
          this.#dispose?.(v, k, reason);
        }
        if (this.#hasDisposeAfter) {
          this.#disposed?.push([v, k, reason]);
        }
      }
    }
    this.#keyMap.clear();
    this.#valList.fill(undefined);
    this.#keyList.fill(undefined);
    if (this.#ttls && this.#starts) {
      this.#ttls.fill(0);
      this.#starts.fill(0);
      for (const t of this.#autopurgeTimers ?? []) {
        if (t !== undefined)
          clearTimeout(t);
      }
      this.#autopurgeTimers?.fill(undefined);
    }
    if (this.#sizes) {
      this.#sizes.fill(0);
    }
    this.#head = 0;
    this.#tail = 0;
    this.#free.length = 0;
    this.#calculatedSize = 0;
    this.#size = 0;
    if (this.#hasDisposeAfter && this.#disposed) {
      const dt = this.#disposed;
      let task;
      while (task = dt?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
  }
}

// node_modules/path-scurry/dist/esm/index.js
import { posix, win32 } from "path";
import { fileURLToPath } from "url";
import { lstatSync as lstatSync2, readdir as readdirCB, readdirSync as readdirSync2, readlinkSync, realpathSync as rps } from "fs";
import * as actualFS from "fs";
import { lstat, readdir as readdir3, readlink, realpath } from "fs/promises";

// node_modules/path-scurry/node_modules/minipass/dist/esm/index.js
import { EventEmitter as EventEmitter2 } from "events";
import Stream from "stream";
import { StringDecoder } from "string_decoder";
var proc = typeof process === "object" && process ? process : {
  stdout: null,
  stderr: null
};
var isStream = (s) => !!s && typeof s === "object" && (s instanceof Minipass || s instanceof Stream || isReadable(s) || isWritable(s));
var isReadable = (s) => !!s && typeof s === "object" && s instanceof EventEmitter2 && typeof s.pipe === "function" && s.pipe !== Stream.Writable.prototype.pipe;
var isWritable = (s) => !!s && typeof s === "object" && s instanceof EventEmitter2 && typeof s.write === "function" && typeof s.end === "function";
var EOF = Symbol("EOF");
var MAYBE_EMIT_END = Symbol("maybeEmitEnd");
var EMITTED_END = Symbol("emittedEnd");
var EMITTING_END = Symbol("emittingEnd");
var EMITTED_ERROR = Symbol("emittedError");
var CLOSED = Symbol("closed");
var READ = Symbol("read");
var FLUSH = Symbol("flush");
var FLUSHCHUNK = Symbol("flushChunk");
var ENCODING = Symbol("encoding");
var DECODER = Symbol("decoder");
var FLOWING = Symbol("flowing");
var PAUSED = Symbol("paused");
var RESUME = Symbol("resume");
var BUFFER = Symbol("buffer");
var PIPES = Symbol("pipes");
var BUFFERLENGTH = Symbol("bufferLength");
var BUFFERPUSH = Symbol("bufferPush");
var BUFFERSHIFT = Symbol("bufferShift");
var OBJECTMODE = Symbol("objectMode");
var DESTROYED = Symbol("destroyed");
var ERROR = Symbol("error");
var EMITDATA = Symbol("emitData");
var EMITEND = Symbol("emitEnd");
var EMITEND2 = Symbol("emitEnd2");
var ASYNC = Symbol("async");
var ABORT = Symbol("abort");
var ABORTED = Symbol("aborted");
var SIGNAL = Symbol("signal");
var DATALISTENERS = Symbol("dataListeners");
var DISCARDED = Symbol("discarded");
var defer = (fn) => Promise.resolve().then(fn);
var nodefer = (fn) => fn();
var isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
var isArrayBufferLike = (b) => b instanceof ArrayBuffer || !!b && typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0;
var isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);

class Pipe {
  src;
  dest;
  opts;
  ondrain;
  constructor(src, dest, opts) {
    this.src = src;
    this.dest = dest;
    this.opts = opts;
    this.ondrain = () => src[RESUME]();
    this.dest.on("drain", this.ondrain);
  }
  unpipe() {
    this.dest.removeListener("drain", this.ondrain);
  }
  proxyErrors(_er) {}
  end() {
    this.unpipe();
    if (this.opts.end)
      this.dest.end();
  }
}

class PipeProxyErrors extends Pipe {
  unpipe() {
    this.src.removeListener("error", this.proxyErrors);
    super.unpipe();
  }
  constructor(src, dest, opts) {
    super(src, dest, opts);
    this.proxyErrors = (er) => dest.emit("error", er);
    src.on("error", this.proxyErrors);
  }
}
var isObjectModeOptions = (o) => !!o.objectMode;
var isEncodingOptions = (o) => !o.objectMode && !!o.encoding && o.encoding !== "buffer";

class Minipass extends EventEmitter2 {
  [FLOWING] = false;
  [PAUSED] = false;
  [PIPES] = [];
  [BUFFER] = [];
  [OBJECTMODE];
  [ENCODING];
  [ASYNC];
  [DECODER];
  [EOF] = false;
  [EMITTED_END] = false;
  [EMITTING_END] = false;
  [CLOSED] = false;
  [EMITTED_ERROR] = null;
  [BUFFERLENGTH] = 0;
  [DESTROYED] = false;
  [SIGNAL];
  [ABORTED] = false;
  [DATALISTENERS] = 0;
  [DISCARDED] = false;
  writable = true;
  readable = true;
  constructor(...args) {
    const options2 = args[0] || {};
    super();
    if (options2.objectMode && typeof options2.encoding === "string") {
      throw new TypeError("Encoding and objectMode may not be used together");
    }
    if (isObjectModeOptions(options2)) {
      this[OBJECTMODE] = true;
      this[ENCODING] = null;
    } else if (isEncodingOptions(options2)) {
      this[ENCODING] = options2.encoding;
      this[OBJECTMODE] = false;
    } else {
      this[OBJECTMODE] = false;
      this[ENCODING] = null;
    }
    this[ASYNC] = !!options2.async;
    this[DECODER] = this[ENCODING] ? new StringDecoder(this[ENCODING]) : null;
    if (options2 && options2.debugExposeBuffer === true) {
      Object.defineProperty(this, "buffer", { get: () => this[BUFFER] });
    }
    if (options2 && options2.debugExposePipes === true) {
      Object.defineProperty(this, "pipes", { get: () => this[PIPES] });
    }
    const { signal } = options2;
    if (signal) {
      this[SIGNAL] = signal;
      if (signal.aborted) {
        this[ABORT]();
      } else {
        signal.addEventListener("abort", () => this[ABORT]());
      }
    }
  }
  get bufferLength() {
    return this[BUFFERLENGTH];
  }
  get encoding() {
    return this[ENCODING];
  }
  set encoding(_enc) {
    throw new Error("Encoding must be set at instantiation time");
  }
  setEncoding(_enc) {
    throw new Error("Encoding must be set at instantiation time");
  }
  get objectMode() {
    return this[OBJECTMODE];
  }
  set objectMode(_om) {
    throw new Error("objectMode must be set at instantiation time");
  }
  get ["async"]() {
    return this[ASYNC];
  }
  set ["async"](a) {
    this[ASYNC] = this[ASYNC] || !!a;
  }
  [ABORT]() {
    this[ABORTED] = true;
    this.emit("abort", this[SIGNAL]?.reason);
    this.destroy(this[SIGNAL]?.reason);
  }
  get aborted() {
    return this[ABORTED];
  }
  set aborted(_) {}
  write(chunk, encoding, cb) {
    if (this[ABORTED])
      return false;
    if (this[EOF])
      throw new Error("write after end");
    if (this[DESTROYED]) {
      this.emit("error", Object.assign(new Error("Cannot call write after a stream was destroyed"), { code: "ERR_STREAM_DESTROYED" }));
      return true;
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = "utf8";
    }
    if (!encoding)
      encoding = "utf8";
    const fn = this[ASYNC] ? defer : nodefer;
    if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
      if (isArrayBufferView(chunk)) {
        chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
      } else if (isArrayBufferLike(chunk)) {
        chunk = Buffer.from(chunk);
      } else if (typeof chunk !== "string") {
        throw new Error("Non-contiguous data written to non-objectMode stream");
      }
    }
    if (this[OBJECTMODE]) {
      if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
        this[FLUSH](true);
      if (this[FLOWING])
        this.emit("data", chunk);
      else
        this[BUFFERPUSH](chunk);
      if (this[BUFFERLENGTH] !== 0)
        this.emit("readable");
      if (cb)
        fn(cb);
      return this[FLOWING];
    }
    if (!chunk.length) {
      if (this[BUFFERLENGTH] !== 0)
        this.emit("readable");
      if (cb)
        fn(cb);
      return this[FLOWING];
    }
    if (typeof chunk === "string" && !(encoding === this[ENCODING] && !this[DECODER]?.lastNeed)) {
      chunk = Buffer.from(chunk, encoding);
    }
    if (Buffer.isBuffer(chunk) && this[ENCODING]) {
      chunk = this[DECODER].write(chunk);
    }
    if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
      this[FLUSH](true);
    if (this[FLOWING])
      this.emit("data", chunk);
    else
      this[BUFFERPUSH](chunk);
    if (this[BUFFERLENGTH] !== 0)
      this.emit("readable");
    if (cb)
      fn(cb);
    return this[FLOWING];
  }
  read(n) {
    if (this[DESTROYED])
      return null;
    this[DISCARDED] = false;
    if (this[BUFFERLENGTH] === 0 || n === 0 || n && n > this[BUFFERLENGTH]) {
      this[MAYBE_EMIT_END]();
      return null;
    }
    if (this[OBJECTMODE])
      n = null;
    if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {
      this[BUFFER] = [
        this[ENCODING] ? this[BUFFER].join("") : Buffer.concat(this[BUFFER], this[BUFFERLENGTH])
      ];
    }
    const ret = this[READ](n || null, this[BUFFER][0]);
    this[MAYBE_EMIT_END]();
    return ret;
  }
  [READ](n, chunk) {
    if (this[OBJECTMODE])
      this[BUFFERSHIFT]();
    else {
      const c = chunk;
      if (n === c.length || n === null)
        this[BUFFERSHIFT]();
      else if (typeof c === "string") {
        this[BUFFER][0] = c.slice(n);
        chunk = c.slice(0, n);
        this[BUFFERLENGTH] -= n;
      } else {
        this[BUFFER][0] = c.subarray(n);
        chunk = c.subarray(0, n);
        this[BUFFERLENGTH] -= n;
      }
    }
    this.emit("data", chunk);
    if (!this[BUFFER].length && !this[EOF])
      this.emit("drain");
    return chunk;
  }
  end(chunk, encoding, cb) {
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = undefined;
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = "utf8";
    }
    if (chunk !== undefined)
      this.write(chunk, encoding);
    if (cb)
      this.once("end", cb);
    this[EOF] = true;
    this.writable = false;
    if (this[FLOWING] || !this[PAUSED])
      this[MAYBE_EMIT_END]();
    return this;
  }
  [RESUME]() {
    if (this[DESTROYED])
      return;
    if (!this[DATALISTENERS] && !this[PIPES].length) {
      this[DISCARDED] = true;
    }
    this[PAUSED] = false;
    this[FLOWING] = true;
    this.emit("resume");
    if (this[BUFFER].length)
      this[FLUSH]();
    else if (this[EOF])
      this[MAYBE_EMIT_END]();
    else
      this.emit("drain");
  }
  resume() {
    return this[RESUME]();
  }
  pause() {
    this[FLOWING] = false;
    this[PAUSED] = true;
    this[DISCARDED] = false;
  }
  get destroyed() {
    return this[DESTROYED];
  }
  get flowing() {
    return this[FLOWING];
  }
  get paused() {
    return this[PAUSED];
  }
  [BUFFERPUSH](chunk) {
    if (this[OBJECTMODE])
      this[BUFFERLENGTH] += 1;
    else
      this[BUFFERLENGTH] += chunk.length;
    this[BUFFER].push(chunk);
  }
  [BUFFERSHIFT]() {
    if (this[OBJECTMODE])
      this[BUFFERLENGTH] -= 1;
    else
      this[BUFFERLENGTH] -= this[BUFFER][0].length;
    return this[BUFFER].shift();
  }
  [FLUSH](noDrain = false) {
    do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) && this[BUFFER].length);
    if (!noDrain && !this[BUFFER].length && !this[EOF])
      this.emit("drain");
  }
  [FLUSHCHUNK](chunk) {
    this.emit("data", chunk);
    return this[FLOWING];
  }
  pipe(dest, opts) {
    if (this[DESTROYED])
      return dest;
    this[DISCARDED] = false;
    const ended = this[EMITTED_END];
    opts = opts || {};
    if (dest === proc.stdout || dest === proc.stderr)
      opts.end = false;
    else
      opts.end = opts.end !== false;
    opts.proxyErrors = !!opts.proxyErrors;
    if (ended) {
      if (opts.end)
        dest.end();
    } else {
      this[PIPES].push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts));
      if (this[ASYNC])
        defer(() => this[RESUME]());
      else
        this[RESUME]();
    }
    return dest;
  }
  unpipe(dest) {
    const p = this[PIPES].find((p2) => p2.dest === dest);
    if (p) {
      if (this[PIPES].length === 1) {
        if (this[FLOWING] && this[DATALISTENERS] === 0) {
          this[FLOWING] = false;
        }
        this[PIPES] = [];
      } else
        this[PIPES].splice(this[PIPES].indexOf(p), 1);
      p.unpipe();
    }
  }
  addListener(ev, handler) {
    return this.on(ev, handler);
  }
  on(ev, handler) {
    const ret = super.on(ev, handler);
    if (ev === "data") {
      this[DISCARDED] = false;
      this[DATALISTENERS]++;
      if (!this[PIPES].length && !this[FLOWING]) {
        this[RESUME]();
      }
    } else if (ev === "readable" && this[BUFFERLENGTH] !== 0) {
      super.emit("readable");
    } else if (isEndish(ev) && this[EMITTED_END]) {
      super.emit(ev);
      this.removeAllListeners(ev);
    } else if (ev === "error" && this[EMITTED_ERROR]) {
      const h = handler;
      if (this[ASYNC])
        defer(() => h.call(this, this[EMITTED_ERROR]));
      else
        h.call(this, this[EMITTED_ERROR]);
    }
    return ret;
  }
  removeListener(ev, handler) {
    return this.off(ev, handler);
  }
  off(ev, handler) {
    const ret = super.off(ev, handler);
    if (ev === "data") {
      this[DATALISTENERS] = this.listeners("data").length;
      if (this[DATALISTENERS] === 0 && !this[DISCARDED] && !this[PIPES].length) {
        this[FLOWING] = false;
      }
    }
    return ret;
  }
  removeAllListeners(ev) {
    const ret = super.removeAllListeners(ev);
    if (ev === "data" || ev === undefined) {
      this[DATALISTENERS] = 0;
      if (!this[DISCARDED] && !this[PIPES].length) {
        this[FLOWING] = false;
      }
    }
    return ret;
  }
  get emittedEnd() {
    return this[EMITTED_END];
  }
  [MAYBE_EMIT_END]() {
    if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this[BUFFER].length === 0 && this[EOF]) {
      this[EMITTING_END] = true;
      this.emit("end");
      this.emit("prefinish");
      this.emit("finish");
      if (this[CLOSED])
        this.emit("close");
      this[EMITTING_END] = false;
    }
  }
  emit(ev, ...args) {
    const data = args[0];
    if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED]) {
      return false;
    } else if (ev === "data") {
      return !this[OBJECTMODE] && !data ? false : this[ASYNC] ? (defer(() => this[EMITDATA](data)), true) : this[EMITDATA](data);
    } else if (ev === "end") {
      return this[EMITEND]();
    } else if (ev === "close") {
      this[CLOSED] = true;
      if (!this[EMITTED_END] && !this[DESTROYED])
        return false;
      const ret2 = super.emit("close");
      this.removeAllListeners("close");
      return ret2;
    } else if (ev === "error") {
      this[EMITTED_ERROR] = data;
      super.emit(ERROR, data);
      const ret2 = !this[SIGNAL] || this.listeners("error").length ? super.emit("error", data) : false;
      this[MAYBE_EMIT_END]();
      return ret2;
    } else if (ev === "resume") {
      const ret2 = super.emit("resume");
      this[MAYBE_EMIT_END]();
      return ret2;
    } else if (ev === "finish" || ev === "prefinish") {
      const ret2 = super.emit(ev);
      this.removeAllListeners(ev);
      return ret2;
    }
    const ret = super.emit(ev, ...args);
    this[MAYBE_EMIT_END]();
    return ret;
  }
  [EMITDATA](data) {
    for (const p of this[PIPES]) {
      if (p.dest.write(data) === false)
        this.pause();
    }
    const ret = this[DISCARDED] ? false : super.emit("data", data);
    this[MAYBE_EMIT_END]();
    return ret;
  }
  [EMITEND]() {
    if (this[EMITTED_END])
      return false;
    this[EMITTED_END] = true;
    this.readable = false;
    return this[ASYNC] ? (defer(() => this[EMITEND2]()), true) : this[EMITEND2]();
  }
  [EMITEND2]() {
    if (this[DECODER]) {
      const data = this[DECODER].end();
      if (data) {
        for (const p of this[PIPES]) {
          p.dest.write(data);
        }
        if (!this[DISCARDED])
          super.emit("data", data);
      }
    }
    for (const p of this[PIPES]) {
      p.end();
    }
    const ret = super.emit("end");
    this.removeAllListeners("end");
    return ret;
  }
  async collect() {
    const buf = Object.assign([], {
      dataLength: 0
    });
    if (!this[OBJECTMODE])
      buf.dataLength = 0;
    const p = this.promise();
    this.on("data", (c) => {
      buf.push(c);
      if (!this[OBJECTMODE])
        buf.dataLength += c.length;
    });
    await p;
    return buf;
  }
  async concat() {
    if (this[OBJECTMODE]) {
      throw new Error("cannot concat in objectMode");
    }
    const buf = await this.collect();
    return this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength);
  }
  async promise() {
    return new Promise((resolve5, reject) => {
      this.on(DESTROYED, () => reject(new Error("stream destroyed")));
      this.on("error", (er) => reject(er));
      this.on("end", () => resolve5());
    });
  }
  [Symbol.asyncIterator]() {
    this[DISCARDED] = false;
    let stopped = false;
    const stop = async () => {
      this.pause();
      stopped = true;
      return { value: undefined, done: true };
    };
    const next = () => {
      if (stopped)
        return stop();
      const res = this.read();
      if (res !== null)
        return Promise.resolve({ done: false, value: res });
      if (this[EOF])
        return stop();
      let resolve5;
      let reject;
      const onerr = (er) => {
        this.off("data", ondata);
        this.off("end", onend);
        this.off(DESTROYED, ondestroy);
        stop();
        reject(er);
      };
      const ondata = (value) => {
        this.off("error", onerr);
        this.off("end", onend);
        this.off(DESTROYED, ondestroy);
        this.pause();
        resolve5({ value, done: !!this[EOF] });
      };
      const onend = () => {
        this.off("error", onerr);
        this.off("data", ondata);
        this.off(DESTROYED, ondestroy);
        stop();
        resolve5({ done: true, value: undefined });
      };
      const ondestroy = () => onerr(new Error("stream destroyed"));
      return new Promise((res2, rej) => {
        reject = rej;
        resolve5 = res2;
        this.once(DESTROYED, ondestroy);
        this.once("error", onerr);
        this.once("end", onend);
        this.once("data", ondata);
      });
    };
    return {
      next,
      throw: stop,
      return: stop,
      [Symbol.asyncIterator]() {
        return this;
      }
    };
  }
  [Symbol.iterator]() {
    this[DISCARDED] = false;
    let stopped = false;
    const stop = () => {
      this.pause();
      this.off(ERROR, stop);
      this.off(DESTROYED, stop);
      this.off("end", stop);
      stopped = true;
      return { done: true, value: undefined };
    };
    const next = () => {
      if (stopped)
        return stop();
      const value = this.read();
      return value === null ? stop() : { done: false, value };
    };
    this.once("end", stop);
    this.once(ERROR, stop);
    this.once(DESTROYED, stop);
    return {
      next,
      throw: stop,
      return: stop,
      [Symbol.iterator]() {
        return this;
      }
    };
  }
  destroy(er) {
    if (this[DESTROYED]) {
      if (er)
        this.emit("error", er);
      else
        this.emit(DESTROYED);
      return this;
    }
    this[DESTROYED] = true;
    this[DISCARDED] = true;
    this[BUFFER].length = 0;
    this[BUFFERLENGTH] = 0;
    const wc = this;
    if (typeof wc.close === "function" && !this[CLOSED])
      wc.close();
    if (er)
      this.emit("error", er);
    else
      this.emit(DESTROYED);
    return this;
  }
  static get isStream() {
    return isStream;
  }
}

// node_modules/path-scurry/dist/esm/index.js
var realpathSync2 = rps.native;
var defaultFS = {
  lstatSync: lstatSync2,
  readdir: readdirCB,
  readdirSync: readdirSync2,
  readlinkSync,
  realpathSync: realpathSync2,
  promises: {
    lstat,
    readdir: readdir3,
    readlink,
    realpath
  }
};
var fsFromOption = (fsOption) => !fsOption || fsOption === defaultFS || fsOption === actualFS ? defaultFS : {
  ...defaultFS,
  ...fsOption,
  promises: {
    ...defaultFS.promises,
    ...fsOption.promises || {}
  }
};
var uncDriveRegexp = /^\\\\\?\\([a-z]:)\\?$/i;
var uncToDrive = (rootPath) => rootPath.replace(/\//g, "\\").replace(uncDriveRegexp, "$1\\");
var eitherSep = /[\\\/]/;
var UNKNOWN = 0;
var IFIFO = 1;
var IFCHR = 2;
var IFDIR = 4;
var IFBLK = 6;
var IFREG = 8;
var IFLNK = 10;
var IFSOCK = 12;
var IFMT = 15;
var IFMT_UNKNOWN = ~IFMT;
var READDIR_CALLED = 16;
var LSTAT_CALLED = 32;
var ENOTDIR = 64;
var ENOENT = 128;
var ENOREADLINK = 256;
var ENOREALPATH = 512;
var ENOCHILD = ENOTDIR | ENOENT | ENOREALPATH;
var TYPEMASK = 1023;
var entToType = (s) => s.isFile() ? IFREG : s.isDirectory() ? IFDIR : s.isSymbolicLink() ? IFLNK : s.isCharacterDevice() ? IFCHR : s.isBlockDevice() ? IFBLK : s.isSocket() ? IFSOCK : s.isFIFO() ? IFIFO : UNKNOWN;
var normalizeCache = new LRUCache({ max: 2 ** 12 });
var normalize2 = (s) => {
  const c = normalizeCache.get(s);
  if (c)
    return c;
  const n = s.normalize("NFKD");
  normalizeCache.set(s, n);
  return n;
};
var normalizeNocaseCache = new LRUCache({ max: 2 ** 12 });
var normalizeNocase = (s) => {
  const c = normalizeNocaseCache.get(s);
  if (c)
    return c;
  const n = normalize2(s.toLowerCase());
  normalizeNocaseCache.set(s, n);
  return n;
};

class ResolveCache extends LRUCache {
  constructor() {
    super({ max: 256 });
  }
}

class ChildrenCache extends LRUCache {
  constructor(maxSize = 16 * 1024) {
    super({
      maxSize,
      sizeCalculation: (a) => a.length + 1
    });
  }
}
var setAsCwd = Symbol("PathScurry setAsCwd");

class PathBase {
  name;
  root;
  roots;
  parent;
  nocase;
  isCWD = false;
  #fs;
  #dev;
  get dev() {
    return this.#dev;
  }
  #mode;
  get mode() {
    return this.#mode;
  }
  #nlink;
  get nlink() {
    return this.#nlink;
  }
  #uid;
  get uid() {
    return this.#uid;
  }
  #gid;
  get gid() {
    return this.#gid;
  }
  #rdev;
  get rdev() {
    return this.#rdev;
  }
  #blksize;
  get blksize() {
    return this.#blksize;
  }
  #ino;
  get ino() {
    return this.#ino;
  }
  #size;
  get size() {
    return this.#size;
  }
  #blocks;
  get blocks() {
    return this.#blocks;
  }
  #atimeMs;
  get atimeMs() {
    return this.#atimeMs;
  }
  #mtimeMs;
  get mtimeMs() {
    return this.#mtimeMs;
  }
  #ctimeMs;
  get ctimeMs() {
    return this.#ctimeMs;
  }
  #birthtimeMs;
  get birthtimeMs() {
    return this.#birthtimeMs;
  }
  #atime;
  get atime() {
    return this.#atime;
  }
  #mtime;
  get mtime() {
    return this.#mtime;
  }
  #ctime;
  get ctime() {
    return this.#ctime;
  }
  #birthtime;
  get birthtime() {
    return this.#birthtime;
  }
  #matchName;
  #depth;
  #fullpath;
  #fullpathPosix;
  #relative;
  #relativePosix;
  #type;
  #children;
  #linkTarget;
  #realpath;
  get parentPath() {
    return (this.parent || this).fullpath();
  }
  get path() {
    return this.parentPath;
  }
  constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {
    this.name = name;
    this.#matchName = nocase ? normalizeNocase(name) : normalize2(name);
    this.#type = type & TYPEMASK;
    this.nocase = nocase;
    this.roots = roots;
    this.root = root || this;
    this.#children = children;
    this.#fullpath = opts.fullpath;
    this.#relative = opts.relative;
    this.#relativePosix = opts.relativePosix;
    this.parent = opts.parent;
    if (this.parent) {
      this.#fs = this.parent.#fs;
    } else {
      this.#fs = fsFromOption(opts.fs);
    }
  }
  depth() {
    if (this.#depth !== undefined)
      return this.#depth;
    if (!this.parent)
      return this.#depth = 0;
    return this.#depth = this.parent.depth() + 1;
  }
  childrenCache() {
    return this.#children;
  }
  resolve(path3) {
    if (!path3) {
      return this;
    }
    const rootPath = this.getRootString(path3);
    const dir = path3.substring(rootPath.length);
    const dirParts = dir.split(this.splitSep);
    const result = rootPath ? this.getRoot(rootPath).#resolveParts(dirParts) : this.#resolveParts(dirParts);
    return result;
  }
  #resolveParts(dirParts) {
    let p = this;
    for (const part of dirParts) {
      p = p.child(part);
    }
    return p;
  }
  children() {
    const cached3 = this.#children.get(this);
    if (cached3) {
      return cached3;
    }
    const children = Object.assign([], { provisional: 0 });
    this.#children.set(this, children);
    this.#type &= ~READDIR_CALLED;
    return children;
  }
  child(pathPart, opts) {
    if (pathPart === "" || pathPart === ".") {
      return this;
    }
    if (pathPart === "..") {
      return this.parent || this;
    }
    const children = this.children();
    const name = this.nocase ? normalizeNocase(pathPart) : normalize2(pathPart);
    for (const p of children) {
      if (p.#matchName === name) {
        return p;
      }
    }
    const s = this.parent ? this.sep : "";
    const fullpath = this.#fullpath ? this.#fullpath + s + pathPart : undefined;
    const pchild = this.newChild(pathPart, UNKNOWN, {
      ...opts,
      parent: this,
      fullpath
    });
    if (!this.canReaddir()) {
      pchild.#type |= ENOENT;
    }
    children.push(pchild);
    return pchild;
  }
  relative() {
    if (this.isCWD)
      return "";
    if (this.#relative !== undefined) {
      return this.#relative;
    }
    const name = this.name;
    const p = this.parent;
    if (!p) {
      return this.#relative = this.name;
    }
    const pv = p.relative();
    return pv + (!pv || !p.parent ? "" : this.sep) + name;
  }
  relativePosix() {
    if (this.sep === "/")
      return this.relative();
    if (this.isCWD)
      return "";
    if (this.#relativePosix !== undefined)
      return this.#relativePosix;
    const name = this.name;
    const p = this.parent;
    if (!p) {
      return this.#relativePosix = this.fullpathPosix();
    }
    const pv = p.relativePosix();
    return pv + (!pv || !p.parent ? "" : "/") + name;
  }
  fullpath() {
    if (this.#fullpath !== undefined) {
      return this.#fullpath;
    }
    const name = this.name;
    const p = this.parent;
    if (!p) {
      return this.#fullpath = this.name;
    }
    const pv = p.fullpath();
    const fp = pv + (!p.parent ? "" : this.sep) + name;
    return this.#fullpath = fp;
  }
  fullpathPosix() {
    if (this.#fullpathPosix !== undefined)
      return this.#fullpathPosix;
    if (this.sep === "/")
      return this.#fullpathPosix = this.fullpath();
    if (!this.parent) {
      const p2 = this.fullpath().replace(/\\/g, "/");
      if (/^[a-z]:\//i.test(p2)) {
        return this.#fullpathPosix = `//?/${p2}`;
      } else {
        return this.#fullpathPosix = p2;
      }
    }
    const p = this.parent;
    const pfpp = p.fullpathPosix();
    const fpp = pfpp + (!pfpp || !p.parent ? "" : "/") + this.name;
    return this.#fullpathPosix = fpp;
  }
  isUnknown() {
    return (this.#type & IFMT) === UNKNOWN;
  }
  isType(type) {
    return this[`is${type}`]();
  }
  getType() {
    return this.isUnknown() ? "Unknown" : this.isDirectory() ? "Directory" : this.isFile() ? "File" : this.isSymbolicLink() ? "SymbolicLink" : this.isFIFO() ? "FIFO" : this.isCharacterDevice() ? "CharacterDevice" : this.isBlockDevice() ? "BlockDevice" : this.isSocket() ? "Socket" : "Unknown";
  }
  isFile() {
    return (this.#type & IFMT) === IFREG;
  }
  isDirectory() {
    return (this.#type & IFMT) === IFDIR;
  }
  isCharacterDevice() {
    return (this.#type & IFMT) === IFCHR;
  }
  isBlockDevice() {
    return (this.#type & IFMT) === IFBLK;
  }
  isFIFO() {
    return (this.#type & IFMT) === IFIFO;
  }
  isSocket() {
    return (this.#type & IFMT) === IFSOCK;
  }
  isSymbolicLink() {
    return (this.#type & IFLNK) === IFLNK;
  }
  lstatCached() {
    return this.#type & LSTAT_CALLED ? this : undefined;
  }
  readlinkCached() {
    return this.#linkTarget;
  }
  realpathCached() {
    return this.#realpath;
  }
  readdirCached() {
    const children = this.children();
    return children.slice(0, children.provisional);
  }
  canReadlink() {
    if (this.#linkTarget)
      return true;
    if (!this.parent)
      return false;
    const ifmt = this.#type & IFMT;
    return !(ifmt !== UNKNOWN && ifmt !== IFLNK || this.#type & ENOREADLINK || this.#type & ENOENT);
  }
  calledReaddir() {
    return !!(this.#type & READDIR_CALLED);
  }
  isENOENT() {
    return !!(this.#type & ENOENT);
  }
  isNamed(n) {
    return !this.nocase ? this.#matchName === normalize2(n) : this.#matchName === normalizeNocase(n);
  }
  async readlink() {
    const target = this.#linkTarget;
    if (target) {
      return target;
    }
    if (!this.canReadlink()) {
      return;
    }
    if (!this.parent) {
      return;
    }
    try {
      const read = await this.#fs.promises.readlink(this.fullpath());
      const linkTarget = (await this.parent.realpath())?.resolve(read);
      if (linkTarget) {
        return this.#linkTarget = linkTarget;
      }
    } catch (er) {
      this.#readlinkFail(er.code);
      return;
    }
  }
  readlinkSync() {
    const target = this.#linkTarget;
    if (target) {
      return target;
    }
    if (!this.canReadlink()) {
      return;
    }
    if (!this.parent) {
      return;
    }
    try {
      const read = this.#fs.readlinkSync(this.fullpath());
      const linkTarget = this.parent.realpathSync()?.resolve(read);
      if (linkTarget) {
        return this.#linkTarget = linkTarget;
      }
    } catch (er) {
      this.#readlinkFail(er.code);
      return;
    }
  }
  #readdirSuccess(children) {
    this.#type |= READDIR_CALLED;
    for (let p = children.provisional;p < children.length; p++) {
      const c = children[p];
      if (c)
        c.#markENOENT();
    }
  }
  #markENOENT() {
    if (this.#type & ENOENT)
      return;
    this.#type = (this.#type | ENOENT) & IFMT_UNKNOWN;
    this.#markChildrenENOENT();
  }
  #markChildrenENOENT() {
    const children = this.children();
    children.provisional = 0;
    for (const p of children) {
      p.#markENOENT();
    }
  }
  #markENOREALPATH() {
    this.#type |= ENOREALPATH;
    this.#markENOTDIR();
  }
  #markENOTDIR() {
    if (this.#type & ENOTDIR)
      return;
    let t = this.#type;
    if ((t & IFMT) === IFDIR)
      t &= IFMT_UNKNOWN;
    this.#type = t | ENOTDIR;
    this.#markChildrenENOENT();
  }
  #readdirFail(code = "") {
    if (code === "ENOTDIR" || code === "EPERM") {
      this.#markENOTDIR();
    } else if (code === "ENOENT") {
      this.#markENOENT();
    } else {
      this.children().provisional = 0;
    }
  }
  #lstatFail(code = "") {
    if (code === "ENOTDIR") {
      const p = this.parent;
      p.#markENOTDIR();
    } else if (code === "ENOENT") {
      this.#markENOENT();
    }
  }
  #readlinkFail(code = "") {
    let ter = this.#type;
    ter |= ENOREADLINK;
    if (code === "ENOENT")
      ter |= ENOENT;
    if (code === "EINVAL" || code === "UNKNOWN") {
      ter &= IFMT_UNKNOWN;
    }
    this.#type = ter;
    if (code === "ENOTDIR" && this.parent) {
      this.parent.#markENOTDIR();
    }
  }
  #readdirAddChild(e, c) {
    return this.#readdirMaybePromoteChild(e, c) || this.#readdirAddNewChild(e, c);
  }
  #readdirAddNewChild(e, c) {
    const type = entToType(e);
    const child = this.newChild(e.name, type, { parent: this });
    const ifmt = child.#type & IFMT;
    if (ifmt !== IFDIR && ifmt !== IFLNK && ifmt !== UNKNOWN) {
      child.#type |= ENOTDIR;
    }
    c.unshift(child);
    c.provisional++;
    return child;
  }
  #readdirMaybePromoteChild(e, c) {
    for (let p = c.provisional;p < c.length; p++) {
      const pchild = c[p];
      const name = this.nocase ? normalizeNocase(e.name) : normalize2(e.name);
      if (name !== pchild.#matchName) {
        continue;
      }
      return this.#readdirPromoteChild(e, pchild, p, c);
    }
  }
  #readdirPromoteChild(e, p, index, c) {
    const v = p.name;
    p.#type = p.#type & IFMT_UNKNOWN | entToType(e);
    if (v !== e.name)
      p.name = e.name;
    if (index !== c.provisional) {
      if (index === c.length - 1)
        c.pop();
      else
        c.splice(index, 1);
      c.unshift(p);
    }
    c.provisional++;
    return p;
  }
  async lstat() {
    if ((this.#type & ENOENT) === 0) {
      try {
        this.#applyStat(await this.#fs.promises.lstat(this.fullpath()));
        return this;
      } catch (er) {
        this.#lstatFail(er.code);
      }
    }
  }
  lstatSync() {
    if ((this.#type & ENOENT) === 0) {
      try {
        this.#applyStat(this.#fs.lstatSync(this.fullpath()));
        return this;
      } catch (er) {
        this.#lstatFail(er.code);
      }
    }
  }
  #applyStat(st) {
    const { atime, atimeMs, birthtime, birthtimeMs, blksize, blocks, ctime, ctimeMs, dev, gid, ino, mode, mtime, mtimeMs, nlink, rdev, size, uid } = st;
    this.#atime = atime;
    this.#atimeMs = atimeMs;
    this.#birthtime = birthtime;
    this.#birthtimeMs = birthtimeMs;
    this.#blksize = blksize;
    this.#blocks = blocks;
    this.#ctime = ctime;
    this.#ctimeMs = ctimeMs;
    this.#dev = dev;
    this.#gid = gid;
    this.#ino = ino;
    this.#mode = mode;
    this.#mtime = mtime;
    this.#mtimeMs = mtimeMs;
    this.#nlink = nlink;
    this.#rdev = rdev;
    this.#size = size;
    this.#uid = uid;
    const ifmt = entToType(st);
    this.#type = this.#type & IFMT_UNKNOWN | ifmt | LSTAT_CALLED;
    if (ifmt !== UNKNOWN && ifmt !== IFDIR && ifmt !== IFLNK) {
      this.#type |= ENOTDIR;
    }
  }
  #onReaddirCB = [];
  #readdirCBInFlight = false;
  #callOnReaddirCB(children) {
    this.#readdirCBInFlight = false;
    const cbs = this.#onReaddirCB.slice();
    this.#onReaddirCB.length = 0;
    cbs.forEach((cb) => cb(null, children));
  }
  readdirCB(cb, allowZalgo = false) {
    if (!this.canReaddir()) {
      if (allowZalgo)
        cb(null, []);
      else
        queueMicrotask(() => cb(null, []));
      return;
    }
    const children = this.children();
    if (this.calledReaddir()) {
      const c = children.slice(0, children.provisional);
      if (allowZalgo)
        cb(null, c);
      else
        queueMicrotask(() => cb(null, c));
      return;
    }
    this.#onReaddirCB.push(cb);
    if (this.#readdirCBInFlight) {
      return;
    }
    this.#readdirCBInFlight = true;
    const fullpath = this.fullpath();
    this.#fs.readdir(fullpath, { withFileTypes: true }, (er, entries) => {
      if (er) {
        this.#readdirFail(er.code);
        children.provisional = 0;
      } else {
        for (const e of entries) {
          this.#readdirAddChild(e, children);
        }
        this.#readdirSuccess(children);
      }
      this.#callOnReaddirCB(children.slice(0, children.provisional));
      return;
    });
  }
  #asyncReaddirInFlight;
  async readdir() {
    if (!this.canReaddir()) {
      return [];
    }
    const children = this.children();
    if (this.calledReaddir()) {
      return children.slice(0, children.provisional);
    }
    const fullpath = this.fullpath();
    if (this.#asyncReaddirInFlight) {
      await this.#asyncReaddirInFlight;
    } else {
      let resolve5 = () => {};
      this.#asyncReaddirInFlight = new Promise((res) => resolve5 = res);
      try {
        for (const e of await this.#fs.promises.readdir(fullpath, {
          withFileTypes: true
        })) {
          this.#readdirAddChild(e, children);
        }
        this.#readdirSuccess(children);
      } catch (er) {
        this.#readdirFail(er.code);
        children.provisional = 0;
      }
      this.#asyncReaddirInFlight = undefined;
      resolve5();
    }
    return children.slice(0, children.provisional);
  }
  readdirSync() {
    if (!this.canReaddir()) {
      return [];
    }
    const children = this.children();
    if (this.calledReaddir()) {
      return children.slice(0, children.provisional);
    }
    const fullpath = this.fullpath();
    try {
      for (const e of this.#fs.readdirSync(fullpath, {
        withFileTypes: true
      })) {
        this.#readdirAddChild(e, children);
      }
      this.#readdirSuccess(children);
    } catch (er) {
      this.#readdirFail(er.code);
      children.provisional = 0;
    }
    return children.slice(0, children.provisional);
  }
  canReaddir() {
    if (this.#type & ENOCHILD)
      return false;
    const ifmt = IFMT & this.#type;
    if (!(ifmt === UNKNOWN || ifmt === IFDIR || ifmt === IFLNK)) {
      return false;
    }
    return true;
  }
  shouldWalk(dirs, walkFilter) {
    return (this.#type & IFDIR) === IFDIR && !(this.#type & ENOCHILD) && !dirs.has(this) && (!walkFilter || walkFilter(this));
  }
  async realpath() {
    if (this.#realpath)
      return this.#realpath;
    if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)
      return;
    try {
      const rp = await this.#fs.promises.realpath(this.fullpath());
      return this.#realpath = this.resolve(rp);
    } catch (_) {
      this.#markENOREALPATH();
    }
  }
  realpathSync() {
    if (this.#realpath)
      return this.#realpath;
    if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)
      return;
    try {
      const rp = this.#fs.realpathSync(this.fullpath());
      return this.#realpath = this.resolve(rp);
    } catch (_) {
      this.#markENOREALPATH();
    }
  }
  [setAsCwd](oldCwd) {
    if (oldCwd === this)
      return;
    oldCwd.isCWD = false;
    this.isCWD = true;
    const changed = new Set([]);
    let rp = [];
    let p = this;
    while (p && p.parent) {
      changed.add(p);
      p.#relative = rp.join(this.sep);
      p.#relativePosix = rp.join("/");
      p = p.parent;
      rp.push("..");
    }
    p = oldCwd;
    while (p && p.parent && !changed.has(p)) {
      p.#relative = undefined;
      p.#relativePosix = undefined;
      p = p.parent;
    }
  }
}

class PathWin32 extends PathBase {
  sep = "\\";
  splitSep = eitherSep;
  constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {
    super(name, type, root, roots, nocase, children, opts);
  }
  newChild(name, type = UNKNOWN, opts = {}) {
    return new PathWin32(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
  }
  getRootString(path3) {
    return win32.parse(path3).root;
  }
  getRoot(rootPath) {
    rootPath = uncToDrive(rootPath.toUpperCase());
    if (rootPath === this.root.name) {
      return this.root;
    }
    for (const [compare, root] of Object.entries(this.roots)) {
      if (this.sameRoot(rootPath, compare)) {
        return this.roots[rootPath] = root;
      }
    }
    return this.roots[rootPath] = new PathScurryWin32(rootPath, this).root;
  }
  sameRoot(rootPath, compare = this.root.name) {
    rootPath = rootPath.toUpperCase().replace(/\//g, "\\").replace(uncDriveRegexp, "$1\\");
    return rootPath === compare;
  }
}

class PathPosix extends PathBase {
  splitSep = "/";
  sep = "/";
  constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {
    super(name, type, root, roots, nocase, children, opts);
  }
  getRootString(path3) {
    return path3.startsWith("/") ? "/" : "";
  }
  getRoot(_rootPath) {
    return this.root;
  }
  newChild(name, type = UNKNOWN, opts = {}) {
    return new PathPosix(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
  }
}

class PathScurryBase {
  root;
  rootPath;
  roots;
  cwd;
  #resolveCache;
  #resolvePosixCache;
  #children;
  nocase;
  #fs;
  constructor(cwd = process.cwd(), pathImpl, sep2, { nocase, childrenCacheSize = 16 * 1024, fs: fs3 = defaultFS } = {}) {
    this.#fs = fsFromOption(fs3);
    if (cwd instanceof URL || cwd.startsWith("file://")) {
      cwd = fileURLToPath(cwd);
    }
    const cwdPath = pathImpl.resolve(cwd);
    this.roots = Object.create(null);
    this.rootPath = this.parseRootPath(cwdPath);
    this.#resolveCache = new ResolveCache;
    this.#resolvePosixCache = new ResolveCache;
    this.#children = new ChildrenCache(childrenCacheSize);
    const split = cwdPath.substring(this.rootPath.length).split(sep2);
    if (split.length === 1 && !split[0]) {
      split.pop();
    }
    if (nocase === undefined) {
      throw new TypeError("must provide nocase setting to PathScurryBase ctor");
    }
    this.nocase = nocase;
    this.root = this.newRoot(this.#fs);
    this.roots[this.rootPath] = this.root;
    let prev = this.root;
    let len = split.length - 1;
    const joinSep = pathImpl.sep;
    let abs = this.rootPath;
    let sawFirst = false;
    for (const part of split) {
      const l = len--;
      prev = prev.child(part, {
        relative: new Array(l).fill("..").join(joinSep),
        relativePosix: new Array(l).fill("..").join("/"),
        fullpath: abs += (sawFirst ? "" : joinSep) + part
      });
      sawFirst = true;
    }
    this.cwd = prev;
  }
  depth(path3 = this.cwd) {
    if (typeof path3 === "string") {
      path3 = this.cwd.resolve(path3);
    }
    return path3.depth();
  }
  childrenCache() {
    return this.#children;
  }
  resolve(...paths) {
    let r = "";
    for (let i = paths.length - 1;i >= 0; i--) {
      const p = paths[i];
      if (!p || p === ".")
        continue;
      r = r ? `${p}/${r}` : p;
      if (this.isAbsolute(p)) {
        break;
      }
    }
    const cached3 = this.#resolveCache.get(r);
    if (cached3 !== undefined) {
      return cached3;
    }
    const result = this.cwd.resolve(r).fullpath();
    this.#resolveCache.set(r, result);
    return result;
  }
  resolvePosix(...paths) {
    let r = "";
    for (let i = paths.length - 1;i >= 0; i--) {
      const p = paths[i];
      if (!p || p === ".")
        continue;
      r = r ? `${p}/${r}` : p;
      if (this.isAbsolute(p)) {
        break;
      }
    }
    const cached3 = this.#resolvePosixCache.get(r);
    if (cached3 !== undefined) {
      return cached3;
    }
    const result = this.cwd.resolve(r).fullpathPosix();
    this.#resolvePosixCache.set(r, result);
    return result;
  }
  relative(entry = this.cwd) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    }
    return entry.relative();
  }
  relativePosix(entry = this.cwd) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    }
    return entry.relativePosix();
  }
  basename(entry = this.cwd) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    }
    return entry.name;
  }
  dirname(entry = this.cwd) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    }
    return (entry.parent || entry).fullpath();
  }
  async readdir(entry = this.cwd, opts = {
    withFileTypes: true
  }) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      opts = entry;
      entry = this.cwd;
    }
    const { withFileTypes } = opts;
    if (!entry.canReaddir()) {
      return [];
    } else {
      const p = await entry.readdir();
      return withFileTypes ? p : p.map((e) => e.name);
    }
  }
  readdirSync(entry = this.cwd, opts = {
    withFileTypes: true
  }) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      opts = entry;
      entry = this.cwd;
    }
    const { withFileTypes = true } = opts;
    if (!entry.canReaddir()) {
      return [];
    } else if (withFileTypes) {
      return entry.readdirSync();
    } else {
      return entry.readdirSync().map((e) => e.name);
    }
  }
  async lstat(entry = this.cwd) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    }
    return entry.lstat();
  }
  lstatSync(entry = this.cwd) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    }
    return entry.lstatSync();
  }
  async readlink(entry = this.cwd, { withFileTypes } = {
    withFileTypes: false
  }) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      withFileTypes = entry.withFileTypes;
      entry = this.cwd;
    }
    const e = await entry.readlink();
    return withFileTypes ? e : e?.fullpath();
  }
  readlinkSync(entry = this.cwd, { withFileTypes } = {
    withFileTypes: false
  }) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      withFileTypes = entry.withFileTypes;
      entry = this.cwd;
    }
    const e = entry.readlinkSync();
    return withFileTypes ? e : e?.fullpath();
  }
  async realpath(entry = this.cwd, { withFileTypes } = {
    withFileTypes: false
  }) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      withFileTypes = entry.withFileTypes;
      entry = this.cwd;
    }
    const e = await entry.realpath();
    return withFileTypes ? e : e?.fullpath();
  }
  realpathSync(entry = this.cwd, { withFileTypes } = {
    withFileTypes: false
  }) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      withFileTypes = entry.withFileTypes;
      entry = this.cwd;
    }
    const e = entry.realpathSync();
    return withFileTypes ? e : e?.fullpath();
  }
  async walk(entry = this.cwd, opts = {}) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      opts = entry;
      entry = this.cwd;
    }
    const { withFileTypes = true, follow = false, filter: filter2, walkFilter } = opts;
    const results = [];
    if (!filter2 || filter2(entry)) {
      results.push(withFileTypes ? entry : entry.fullpath());
    }
    const dirs = new Set;
    const walk = (dir, cb) => {
      dirs.add(dir);
      dir.readdirCB((er, entries) => {
        if (er) {
          return cb(er);
        }
        let len = entries.length;
        if (!len)
          return cb();
        const next = () => {
          if (--len === 0) {
            cb();
          }
        };
        for (const e of entries) {
          if (!filter2 || filter2(e)) {
            results.push(withFileTypes ? e : e.fullpath());
          }
          if (follow && e.isSymbolicLink()) {
            e.realpath().then((r) => r?.isUnknown() ? r.lstat() : r).then((r) => r?.shouldWalk(dirs, walkFilter) ? walk(r, next) : next());
          } else {
            if (e.shouldWalk(dirs, walkFilter)) {
              walk(e, next);
            } else {
              next();
            }
          }
        }
      }, true);
    };
    const start = entry;
    return new Promise((res, rej) => {
      walk(start, (er) => {
        if (er)
          return rej(er);
        res(results);
      });
    });
  }
  walkSync(entry = this.cwd, opts = {}) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      opts = entry;
      entry = this.cwd;
    }
    const { withFileTypes = true, follow = false, filter: filter2, walkFilter } = opts;
    const results = [];
    if (!filter2 || filter2(entry)) {
      results.push(withFileTypes ? entry : entry.fullpath());
    }
    const dirs = new Set([entry]);
    for (const dir of dirs) {
      const entries = dir.readdirSync();
      for (const e of entries) {
        if (!filter2 || filter2(e)) {
          results.push(withFileTypes ? e : e.fullpath());
        }
        let r = e;
        if (e.isSymbolicLink()) {
          if (!(follow && (r = e.realpathSync())))
            continue;
          if (r.isUnknown())
            r.lstatSync();
        }
        if (r.shouldWalk(dirs, walkFilter)) {
          dirs.add(r);
        }
      }
    }
    return results;
  }
  [Symbol.asyncIterator]() {
    return this.iterate();
  }
  iterate(entry = this.cwd, options2 = {}) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      options2 = entry;
      entry = this.cwd;
    }
    return this.stream(entry, options2)[Symbol.asyncIterator]();
  }
  [Symbol.iterator]() {
    return this.iterateSync();
  }
  *iterateSync(entry = this.cwd, opts = {}) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      opts = entry;
      entry = this.cwd;
    }
    const { withFileTypes = true, follow = false, filter: filter2, walkFilter } = opts;
    if (!filter2 || filter2(entry)) {
      yield withFileTypes ? entry : entry.fullpath();
    }
    const dirs = new Set([entry]);
    for (const dir of dirs) {
      const entries = dir.readdirSync();
      for (const e of entries) {
        if (!filter2 || filter2(e)) {
          yield withFileTypes ? e : e.fullpath();
        }
        let r = e;
        if (e.isSymbolicLink()) {
          if (!(follow && (r = e.realpathSync())))
            continue;
          if (r.isUnknown())
            r.lstatSync();
        }
        if (r.shouldWalk(dirs, walkFilter)) {
          dirs.add(r);
        }
      }
    }
  }
  stream(entry = this.cwd, opts = {}) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      opts = entry;
      entry = this.cwd;
    }
    const { withFileTypes = true, follow = false, filter: filter2, walkFilter } = opts;
    const results = new Minipass({ objectMode: true });
    if (!filter2 || filter2(entry)) {
      results.write(withFileTypes ? entry : entry.fullpath());
    }
    const dirs = new Set;
    const queue = [entry];
    let processing = 0;
    const process4 = () => {
      let paused = false;
      while (!paused) {
        const dir = queue.shift();
        if (!dir) {
          if (processing === 0)
            results.end();
          return;
        }
        processing++;
        dirs.add(dir);
        const onReaddir = (er, entries, didRealpaths = false) => {
          if (er)
            return results.emit("error", er);
          if (follow && !didRealpaths) {
            const promises = [];
            for (const e of entries) {
              if (e.isSymbolicLink()) {
                promises.push(e.realpath().then((r) => r?.isUnknown() ? r.lstat() : r));
              }
            }
            if (promises.length) {
              Promise.all(promises).then(() => onReaddir(null, entries, true));
              return;
            }
          }
          for (const e of entries) {
            if (e && (!filter2 || filter2(e))) {
              if (!results.write(withFileTypes ? e : e.fullpath())) {
                paused = true;
              }
            }
          }
          processing--;
          for (const e of entries) {
            const r = e.realpathCached() || e;
            if (r.shouldWalk(dirs, walkFilter)) {
              queue.push(r);
            }
          }
          if (paused && !results.flowing) {
            results.once("drain", process4);
          } else if (!sync) {
            process4();
          }
        };
        let sync = true;
        dir.readdirCB(onReaddir, true);
        sync = false;
      }
    };
    process4();
    return results;
  }
  streamSync(entry = this.cwd, opts = {}) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      opts = entry;
      entry = this.cwd;
    }
    const { withFileTypes = true, follow = false, filter: filter2, walkFilter } = opts;
    const results = new Minipass({ objectMode: true });
    const dirs = new Set;
    if (!filter2 || filter2(entry)) {
      results.write(withFileTypes ? entry : entry.fullpath());
    }
    const queue = [entry];
    let processing = 0;
    const process4 = () => {
      let paused = false;
      while (!paused) {
        const dir = queue.shift();
        if (!dir) {
          if (processing === 0)
            results.end();
          return;
        }
        processing++;
        dirs.add(dir);
        const entries = dir.readdirSync();
        for (const e of entries) {
          if (!filter2 || filter2(e)) {
            if (!results.write(withFileTypes ? e : e.fullpath())) {
              paused = true;
            }
          }
        }
        processing--;
        for (const e of entries) {
          let r = e;
          if (e.isSymbolicLink()) {
            if (!(follow && (r = e.realpathSync())))
              continue;
            if (r.isUnknown())
              r.lstatSync();
          }
          if (r.shouldWalk(dirs, walkFilter)) {
            queue.push(r);
          }
        }
      }
      if (paused && !results.flowing)
        results.once("drain", process4);
    };
    process4();
    return results;
  }
  chdir(path3 = this.cwd) {
    const oldCwd = this.cwd;
    this.cwd = typeof path3 === "string" ? this.cwd.resolve(path3) : path3;
    this.cwd[setAsCwd](oldCwd);
  }
}

class PathScurryWin32 extends PathScurryBase {
  sep = "\\";
  constructor(cwd = process.cwd(), opts = {}) {
    const { nocase = true } = opts;
    super(cwd, win32, "\\", { ...opts, nocase });
    this.nocase = nocase;
    for (let p = this.cwd;p; p = p.parent) {
      p.nocase = this.nocase;
    }
  }
  parseRootPath(dir) {
    return win32.parse(dir).root.toUpperCase();
  }
  newRoot(fs3) {
    return new PathWin32(this.rootPath, IFDIR, undefined, this.roots, this.nocase, this.childrenCache(), { fs: fs3 });
  }
  isAbsolute(p) {
    return p.startsWith("/") || p.startsWith("\\") || /^[a-z]:(\/|\\)/i.test(p);
  }
}

class PathScurryPosix extends PathScurryBase {
  sep = "/";
  constructor(cwd = process.cwd(), opts = {}) {
    const { nocase = false } = opts;
    super(cwd, posix, "/", { ...opts, nocase });
    this.nocase = nocase;
  }
  parseRootPath(_dir) {
    return "/";
  }
  newRoot(fs3) {
    return new PathPosix(this.rootPath, IFDIR, undefined, this.roots, this.nocase, this.childrenCache(), { fs: fs3 });
  }
  isAbsolute(p) {
    return p.startsWith("/");
  }
}

class PathScurryDarwin extends PathScurryPosix {
  constructor(cwd = process.cwd(), opts = {}) {
    const { nocase = true } = opts;
    super(cwd, { ...opts, nocase });
  }
}
var Path = process.platform === "win32" ? PathWin32 : PathPosix;
var PathScurry = process.platform === "win32" ? PathScurryWin32 : process.platform === "darwin" ? PathScurryDarwin : PathScurryPosix;

// node_modules/glob/dist/esm/pattern.js
var isPatternList = (pl) => pl.length >= 1;
var isGlobList = (gl) => gl.length >= 1;

class Pattern {
  #patternList;
  #globList;
  #index;
  length;
  #platform;
  #rest;
  #globString;
  #isDrive;
  #isUNC;
  #isAbsolute;
  #followGlobstar = true;
  constructor(patternList, globList, index, platform2) {
    if (!isPatternList(patternList)) {
      throw new TypeError("empty pattern list");
    }
    if (!isGlobList(globList)) {
      throw new TypeError("empty glob list");
    }
    if (globList.length !== patternList.length) {
      throw new TypeError("mismatched pattern list and glob list lengths");
    }
    this.length = patternList.length;
    if (index < 0 || index >= this.length) {
      throw new TypeError("index out of range");
    }
    this.#patternList = patternList;
    this.#globList = globList;
    this.#index = index;
    this.#platform = platform2;
    if (this.#index === 0) {
      if (this.isUNC()) {
        const [p0, p1, p2, p3, ...prest] = this.#patternList;
        const [g0, g1, g2, g3, ...grest] = this.#globList;
        if (prest[0] === "") {
          prest.shift();
          grest.shift();
        }
        const p = [p0, p1, p2, p3, ""].join("/");
        const g = [g0, g1, g2, g3, ""].join("/");
        this.#patternList = [p, ...prest];
        this.#globList = [g, ...grest];
        this.length = this.#patternList.length;
      } else if (this.isDrive() || this.isAbsolute()) {
        const [p1, ...prest] = this.#patternList;
        const [g1, ...grest] = this.#globList;
        if (prest[0] === "") {
          prest.shift();
          grest.shift();
        }
        const p = p1 + "/";
        const g = g1 + "/";
        this.#patternList = [p, ...prest];
        this.#globList = [g, ...grest];
        this.length = this.#patternList.length;
      }
    }
  }
  pattern() {
    return this.#patternList[this.#index];
  }
  isString() {
    return typeof this.#patternList[this.#index] === "string";
  }
  isGlobstar() {
    return this.#patternList[this.#index] === GLOBSTAR;
  }
  isRegExp() {
    return this.#patternList[this.#index] instanceof RegExp;
  }
  globString() {
    return this.#globString = this.#globString || (this.#index === 0 ? this.isAbsolute() ? this.#globList[0] + this.#globList.slice(1).join("/") : this.#globList.join("/") : this.#globList.slice(this.#index).join("/"));
  }
  hasMore() {
    return this.length > this.#index + 1;
  }
  rest() {
    if (this.#rest !== undefined)
      return this.#rest;
    if (!this.hasMore())
      return this.#rest = null;
    this.#rest = new Pattern(this.#patternList, this.#globList, this.#index + 1, this.#platform);
    this.#rest.#isAbsolute = this.#isAbsolute;
    this.#rest.#isUNC = this.#isUNC;
    this.#rest.#isDrive = this.#isDrive;
    return this.#rest;
  }
  isUNC() {
    const pl = this.#patternList;
    return this.#isUNC !== undefined ? this.#isUNC : this.#isUNC = this.#platform === "win32" && this.#index === 0 && pl[0] === "" && pl[1] === "" && typeof pl[2] === "string" && !!pl[2] && typeof pl[3] === "string" && !!pl[3];
  }
  isDrive() {
    const pl = this.#patternList;
    return this.#isDrive !== undefined ? this.#isDrive : this.#isDrive = this.#platform === "win32" && this.#index === 0 && this.length > 1 && typeof pl[0] === "string" && /^[a-z]:$/i.test(pl[0]);
  }
  isAbsolute() {
    const pl = this.#patternList;
    return this.#isAbsolute !== undefined ? this.#isAbsolute : this.#isAbsolute = pl[0] === "" && pl.length > 1 || this.isDrive() || this.isUNC();
  }
  root() {
    const p = this.#patternList[0];
    return typeof p === "string" && this.isAbsolute() && this.#index === 0 ? p : "";
  }
  checkFollowGlobstar() {
    return !(this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar);
  }
  markFollowGlobstar() {
    if (this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar)
      return false;
    this.#followGlobstar = false;
    return true;
  }
}

// node_modules/glob/node_modules/minipass/dist/esm/index.js
import { EventEmitter as EventEmitter3 } from "events";
import Stream2 from "stream";
import { StringDecoder as StringDecoder2 } from "string_decoder";
var proc2 = typeof process === "object" && process ? process : {
  stdout: null,
  stderr: null
};
var isStream2 = (s) => !!s && typeof s === "object" && (s instanceof Minipass2 || s instanceof Stream2 || isReadable2(s) || isWritable2(s));
var isReadable2 = (s) => !!s && typeof s === "object" && s instanceof EventEmitter3 && typeof s.pipe === "function" && s.pipe !== Stream2.Writable.prototype.pipe;
var isWritable2 = (s) => !!s && typeof s === "object" && s instanceof EventEmitter3 && typeof s.write === "function" && typeof s.end === "function";
var EOF2 = Symbol("EOF");
var MAYBE_EMIT_END2 = Symbol("maybeEmitEnd");
var EMITTED_END2 = Symbol("emittedEnd");
var EMITTING_END2 = Symbol("emittingEnd");
var EMITTED_ERROR2 = Symbol("emittedError");
var CLOSED2 = Symbol("closed");
var READ2 = Symbol("read");
var FLUSH2 = Symbol("flush");
var FLUSHCHUNK2 = Symbol("flushChunk");
var ENCODING2 = Symbol("encoding");
var DECODER2 = Symbol("decoder");
var FLOWING2 = Symbol("flowing");
var PAUSED2 = Symbol("paused");
var RESUME2 = Symbol("resume");
var BUFFER2 = Symbol("buffer");
var PIPES2 = Symbol("pipes");
var BUFFERLENGTH2 = Symbol("bufferLength");
var BUFFERPUSH2 = Symbol("bufferPush");
var BUFFERSHIFT2 = Symbol("bufferShift");
var OBJECTMODE2 = Symbol("objectMode");
var DESTROYED2 = Symbol("destroyed");
var ERROR2 = Symbol("error");
var EMITDATA2 = Symbol("emitData");
var EMITEND3 = Symbol("emitEnd");
var EMITEND22 = Symbol("emitEnd2");
var ASYNC2 = Symbol("async");
var ABORT2 = Symbol("abort");
var ABORTED2 = Symbol("aborted");
var SIGNAL2 = Symbol("signal");
var DATALISTENERS2 = Symbol("dataListeners");
var DISCARDED2 = Symbol("discarded");
var defer2 = (fn) => Promise.resolve().then(fn);
var nodefer2 = (fn) => fn();
var isEndish2 = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
var isArrayBufferLike2 = (b) => b instanceof ArrayBuffer || !!b && typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0;
var isArrayBufferView2 = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);

class Pipe2 {
  src;
  dest;
  opts;
  ondrain;
  constructor(src, dest, opts) {
    this.src = src;
    this.dest = dest;
    this.opts = opts;
    this.ondrain = () => src[RESUME2]();
    this.dest.on("drain", this.ondrain);
  }
  unpipe() {
    this.dest.removeListener("drain", this.ondrain);
  }
  proxyErrors(_er) {}
  end() {
    this.unpipe();
    if (this.opts.end)
      this.dest.end();
  }
}

class PipeProxyErrors2 extends Pipe2 {
  unpipe() {
    this.src.removeListener("error", this.proxyErrors);
    super.unpipe();
  }
  constructor(src, dest, opts) {
    super(src, dest, opts);
    this.proxyErrors = (er) => dest.emit("error", er);
    src.on("error", this.proxyErrors);
  }
}
var isObjectModeOptions2 = (o) => !!o.objectMode;
var isEncodingOptions2 = (o) => !o.objectMode && !!o.encoding && o.encoding !== "buffer";

class Minipass2 extends EventEmitter3 {
  [FLOWING2] = false;
  [PAUSED2] = false;
  [PIPES2] = [];
  [BUFFER2] = [];
  [OBJECTMODE2];
  [ENCODING2];
  [ASYNC2];
  [DECODER2];
  [EOF2] = false;
  [EMITTED_END2] = false;
  [EMITTING_END2] = false;
  [CLOSED2] = false;
  [EMITTED_ERROR2] = null;
  [BUFFERLENGTH2] = 0;
  [DESTROYED2] = false;
  [SIGNAL2];
  [ABORTED2] = false;
  [DATALISTENERS2] = 0;
  [DISCARDED2] = false;
  writable = true;
  readable = true;
  constructor(...args) {
    const options2 = args[0] || {};
    super();
    if (options2.objectMode && typeof options2.encoding === "string") {
      throw new TypeError("Encoding and objectMode may not be used together");
    }
    if (isObjectModeOptions2(options2)) {
      this[OBJECTMODE2] = true;
      this[ENCODING2] = null;
    } else if (isEncodingOptions2(options2)) {
      this[ENCODING2] = options2.encoding;
      this[OBJECTMODE2] = false;
    } else {
      this[OBJECTMODE2] = false;
      this[ENCODING2] = null;
    }
    this[ASYNC2] = !!options2.async;
    this[DECODER2] = this[ENCODING2] ? new StringDecoder2(this[ENCODING2]) : null;
    if (options2 && options2.debugExposeBuffer === true) {
      Object.defineProperty(this, "buffer", { get: () => this[BUFFER2] });
    }
    if (options2 && options2.debugExposePipes === true) {
      Object.defineProperty(this, "pipes", { get: () => this[PIPES2] });
    }
    const { signal } = options2;
    if (signal) {
      this[SIGNAL2] = signal;
      if (signal.aborted) {
        this[ABORT2]();
      } else {
        signal.addEventListener("abort", () => this[ABORT2]());
      }
    }
  }
  get bufferLength() {
    return this[BUFFERLENGTH2];
  }
  get encoding() {
    return this[ENCODING2];
  }
  set encoding(_enc) {
    throw new Error("Encoding must be set at instantiation time");
  }
  setEncoding(_enc) {
    throw new Error("Encoding must be set at instantiation time");
  }
  get objectMode() {
    return this[OBJECTMODE2];
  }
  set objectMode(_om) {
    throw new Error("objectMode must be set at instantiation time");
  }
  get ["async"]() {
    return this[ASYNC2];
  }
  set ["async"](a) {
    this[ASYNC2] = this[ASYNC2] || !!a;
  }
  [ABORT2]() {
    this[ABORTED2] = true;
    this.emit("abort", this[SIGNAL2]?.reason);
    this.destroy(this[SIGNAL2]?.reason);
  }
  get aborted() {
    return this[ABORTED2];
  }
  set aborted(_) {}
  write(chunk, encoding, cb) {
    if (this[ABORTED2])
      return false;
    if (this[EOF2])
      throw new Error("write after end");
    if (this[DESTROYED2]) {
      this.emit("error", Object.assign(new Error("Cannot call write after a stream was destroyed"), { code: "ERR_STREAM_DESTROYED" }));
      return true;
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = "utf8";
    }
    if (!encoding)
      encoding = "utf8";
    const fn = this[ASYNC2] ? defer2 : nodefer2;
    if (!this[OBJECTMODE2] && !Buffer.isBuffer(chunk)) {
      if (isArrayBufferView2(chunk)) {
        chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
      } else if (isArrayBufferLike2(chunk)) {
        chunk = Buffer.from(chunk);
      } else if (typeof chunk !== "string") {
        throw new Error("Non-contiguous data written to non-objectMode stream");
      }
    }
    if (this[OBJECTMODE2]) {
      if (this[FLOWING2] && this[BUFFERLENGTH2] !== 0)
        this[FLUSH2](true);
      if (this[FLOWING2])
        this.emit("data", chunk);
      else
        this[BUFFERPUSH2](chunk);
      if (this[BUFFERLENGTH2] !== 0)
        this.emit("readable");
      if (cb)
        fn(cb);
      return this[FLOWING2];
    }
    if (!chunk.length) {
      if (this[BUFFERLENGTH2] !== 0)
        this.emit("readable");
      if (cb)
        fn(cb);
      return this[FLOWING2];
    }
    if (typeof chunk === "string" && !(encoding === this[ENCODING2] && !this[DECODER2]?.lastNeed)) {
      chunk = Buffer.from(chunk, encoding);
    }
    if (Buffer.isBuffer(chunk) && this[ENCODING2]) {
      chunk = this[DECODER2].write(chunk);
    }
    if (this[FLOWING2] && this[BUFFERLENGTH2] !== 0)
      this[FLUSH2](true);
    if (this[FLOWING2])
      this.emit("data", chunk);
    else
      this[BUFFERPUSH2](chunk);
    if (this[BUFFERLENGTH2] !== 0)
      this.emit("readable");
    if (cb)
      fn(cb);
    return this[FLOWING2];
  }
  read(n) {
    if (this[DESTROYED2])
      return null;
    this[DISCARDED2] = false;
    if (this[BUFFERLENGTH2] === 0 || n === 0 || n && n > this[BUFFERLENGTH2]) {
      this[MAYBE_EMIT_END2]();
      return null;
    }
    if (this[OBJECTMODE2])
      n = null;
    if (this[BUFFER2].length > 1 && !this[OBJECTMODE2]) {
      this[BUFFER2] = [
        this[ENCODING2] ? this[BUFFER2].join("") : Buffer.concat(this[BUFFER2], this[BUFFERLENGTH2])
      ];
    }
    const ret = this[READ2](n || null, this[BUFFER2][0]);
    this[MAYBE_EMIT_END2]();
    return ret;
  }
  [READ2](n, chunk) {
    if (this[OBJECTMODE2])
      this[BUFFERSHIFT2]();
    else {
      const c = chunk;
      if (n === c.length || n === null)
        this[BUFFERSHIFT2]();
      else if (typeof c === "string") {
        this[BUFFER2][0] = c.slice(n);
        chunk = c.slice(0, n);
        this[BUFFERLENGTH2] -= n;
      } else {
        this[BUFFER2][0] = c.subarray(n);
        chunk = c.subarray(0, n);
        this[BUFFERLENGTH2] -= n;
      }
    }
    this.emit("data", chunk);
    if (!this[BUFFER2].length && !this[EOF2])
      this.emit("drain");
    return chunk;
  }
  end(chunk, encoding, cb) {
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = undefined;
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = "utf8";
    }
    if (chunk !== undefined)
      this.write(chunk, encoding);
    if (cb)
      this.once("end", cb);
    this[EOF2] = true;
    this.writable = false;
    if (this[FLOWING2] || !this[PAUSED2])
      this[MAYBE_EMIT_END2]();
    return this;
  }
  [RESUME2]() {
    if (this[DESTROYED2])
      return;
    if (!this[DATALISTENERS2] && !this[PIPES2].length) {
      this[DISCARDED2] = true;
    }
    this[PAUSED2] = false;
    this[FLOWING2] = true;
    this.emit("resume");
    if (this[BUFFER2].length)
      this[FLUSH2]();
    else if (this[EOF2])
      this[MAYBE_EMIT_END2]();
    else
      this.emit("drain");
  }
  resume() {
    return this[RESUME2]();
  }
  pause() {
    this[FLOWING2] = false;
    this[PAUSED2] = true;
    this[DISCARDED2] = false;
  }
  get destroyed() {
    return this[DESTROYED2];
  }
  get flowing() {
    return this[FLOWING2];
  }
  get paused() {
    return this[PAUSED2];
  }
  [BUFFERPUSH2](chunk) {
    if (this[OBJECTMODE2])
      this[BUFFERLENGTH2] += 1;
    else
      this[BUFFERLENGTH2] += chunk.length;
    this[BUFFER2].push(chunk);
  }
  [BUFFERSHIFT2]() {
    if (this[OBJECTMODE2])
      this[BUFFERLENGTH2] -= 1;
    else
      this[BUFFERLENGTH2] -= this[BUFFER2][0].length;
    return this[BUFFER2].shift();
  }
  [FLUSH2](noDrain = false) {
    do {} while (this[FLUSHCHUNK2](this[BUFFERSHIFT2]()) && this[BUFFER2].length);
    if (!noDrain && !this[BUFFER2].length && !this[EOF2])
      this.emit("drain");
  }
  [FLUSHCHUNK2](chunk) {
    this.emit("data", chunk);
    return this[FLOWING2];
  }
  pipe(dest, opts) {
    if (this[DESTROYED2])
      return dest;
    this[DISCARDED2] = false;
    const ended = this[EMITTED_END2];
    opts = opts || {};
    if (dest === proc2.stdout || dest === proc2.stderr)
      opts.end = false;
    else
      opts.end = opts.end !== false;
    opts.proxyErrors = !!opts.proxyErrors;
    if (ended) {
      if (opts.end)
        dest.end();
    } else {
      this[PIPES2].push(!opts.proxyErrors ? new Pipe2(this, dest, opts) : new PipeProxyErrors2(this, dest, opts));
      if (this[ASYNC2])
        defer2(() => this[RESUME2]());
      else
        this[RESUME2]();
    }
    return dest;
  }
  unpipe(dest) {
    const p = this[PIPES2].find((p2) => p2.dest === dest);
    if (p) {
      if (this[PIPES2].length === 1) {
        if (this[FLOWING2] && this[DATALISTENERS2] === 0) {
          this[FLOWING2] = false;
        }
        this[PIPES2] = [];
      } else
        this[PIPES2].splice(this[PIPES2].indexOf(p), 1);
      p.unpipe();
    }
  }
  addListener(ev, handler) {
    return this.on(ev, handler);
  }
  on(ev, handler) {
    const ret = super.on(ev, handler);
    if (ev === "data") {
      this[DISCARDED2] = false;
      this[DATALISTENERS2]++;
      if (!this[PIPES2].length && !this[FLOWING2]) {
        this[RESUME2]();
      }
    } else if (ev === "readable" && this[BUFFERLENGTH2] !== 0) {
      super.emit("readable");
    } else if (isEndish2(ev) && this[EMITTED_END2]) {
      super.emit(ev);
      this.removeAllListeners(ev);
    } else if (ev === "error" && this[EMITTED_ERROR2]) {
      const h = handler;
      if (this[ASYNC2])
        defer2(() => h.call(this, this[EMITTED_ERROR2]));
      else
        h.call(this, this[EMITTED_ERROR2]);
    }
    return ret;
  }
  removeListener(ev, handler) {
    return this.off(ev, handler);
  }
  off(ev, handler) {
    const ret = super.off(ev, handler);
    if (ev === "data") {
      this[DATALISTENERS2] = this.listeners("data").length;
      if (this[DATALISTENERS2] === 0 && !this[DISCARDED2] && !this[PIPES2].length) {
        this[FLOWING2] = false;
      }
    }
    return ret;
  }
  removeAllListeners(ev) {
    const ret = super.removeAllListeners(ev);
    if (ev === "data" || ev === undefined) {
      this[DATALISTENERS2] = 0;
      if (!this[DISCARDED2] && !this[PIPES2].length) {
        this[FLOWING2] = false;
      }
    }
    return ret;
  }
  get emittedEnd() {
    return this[EMITTED_END2];
  }
  [MAYBE_EMIT_END2]() {
    if (!this[EMITTING_END2] && !this[EMITTED_END2] && !this[DESTROYED2] && this[BUFFER2].length === 0 && this[EOF2]) {
      this[EMITTING_END2] = true;
      this.emit("end");
      this.emit("prefinish");
      this.emit("finish");
      if (this[CLOSED2])
        this.emit("close");
      this[EMITTING_END2] = false;
    }
  }
  emit(ev, ...args) {
    const data = args[0];
    if (ev !== "error" && ev !== "close" && ev !== DESTROYED2 && this[DESTROYED2]) {
      return false;
    } else if (ev === "data") {
      return !this[OBJECTMODE2] && !data ? false : this[ASYNC2] ? (defer2(() => this[EMITDATA2](data)), true) : this[EMITDATA2](data);
    } else if (ev === "end") {
      return this[EMITEND3]();
    } else if (ev === "close") {
      this[CLOSED2] = true;
      if (!this[EMITTED_END2] && !this[DESTROYED2])
        return false;
      const ret2 = super.emit("close");
      this.removeAllListeners("close");
      return ret2;
    } else if (ev === "error") {
      this[EMITTED_ERROR2] = data;
      super.emit(ERROR2, data);
      const ret2 = !this[SIGNAL2] || this.listeners("error").length ? super.emit("error", data) : false;
      this[MAYBE_EMIT_END2]();
      return ret2;
    } else if (ev === "resume") {
      const ret2 = super.emit("resume");
      this[MAYBE_EMIT_END2]();
      return ret2;
    } else if (ev === "finish" || ev === "prefinish") {
      const ret2 = super.emit(ev);
      this.removeAllListeners(ev);
      return ret2;
    }
    const ret = super.emit(ev, ...args);
    this[MAYBE_EMIT_END2]();
    return ret;
  }
  [EMITDATA2](data) {
    for (const p of this[PIPES2]) {
      if (p.dest.write(data) === false)
        this.pause();
    }
    const ret = this[DISCARDED2] ? false : super.emit("data", data);
    this[MAYBE_EMIT_END2]();
    return ret;
  }
  [EMITEND3]() {
    if (this[EMITTED_END2])
      return false;
    this[EMITTED_END2] = true;
    this.readable = false;
    return this[ASYNC2] ? (defer2(() => this[EMITEND22]()), true) : this[EMITEND22]();
  }
  [EMITEND22]() {
    if (this[DECODER2]) {
      const data = this[DECODER2].end();
      if (data) {
        for (const p of this[PIPES2]) {
          p.dest.write(data);
        }
        if (!this[DISCARDED2])
          super.emit("data", data);
      }
    }
    for (const p of this[PIPES2]) {
      p.end();
    }
    const ret = super.emit("end");
    this.removeAllListeners("end");
    return ret;
  }
  async collect() {
    const buf = Object.assign([], {
      dataLength: 0
    });
    if (!this[OBJECTMODE2])
      buf.dataLength = 0;
    const p = this.promise();
    this.on("data", (c) => {
      buf.push(c);
      if (!this[OBJECTMODE2])
        buf.dataLength += c.length;
    });
    await p;
    return buf;
  }
  async concat() {
    if (this[OBJECTMODE2]) {
      throw new Error("cannot concat in objectMode");
    }
    const buf = await this.collect();
    return this[ENCODING2] ? buf.join("") : Buffer.concat(buf, buf.dataLength);
  }
  async promise() {
    return new Promise((resolve5, reject) => {
      this.on(DESTROYED2, () => reject(new Error("stream destroyed")));
      this.on("error", (er) => reject(er));
      this.on("end", () => resolve5());
    });
  }
  [Symbol.asyncIterator]() {
    this[DISCARDED2] = false;
    let stopped = false;
    const stop = async () => {
      this.pause();
      stopped = true;
      return { value: undefined, done: true };
    };
    const next = () => {
      if (stopped)
        return stop();
      const res = this.read();
      if (res !== null)
        return Promise.resolve({ done: false, value: res });
      if (this[EOF2])
        return stop();
      let resolve5;
      let reject;
      const onerr = (er) => {
        this.off("data", ondata);
        this.off("end", onend);
        this.off(DESTROYED2, ondestroy);
        stop();
        reject(er);
      };
      const ondata = (value) => {
        this.off("error", onerr);
        this.off("end", onend);
        this.off(DESTROYED2, ondestroy);
        this.pause();
        resolve5({ value, done: !!this[EOF2] });
      };
      const onend = () => {
        this.off("error", onerr);
        this.off("data", ondata);
        this.off(DESTROYED2, ondestroy);
        stop();
        resolve5({ done: true, value: undefined });
      };
      const ondestroy = () => onerr(new Error("stream destroyed"));
      return new Promise((res2, rej) => {
        reject = rej;
        resolve5 = res2;
        this.once(DESTROYED2, ondestroy);
        this.once("error", onerr);
        this.once("end", onend);
        this.once("data", ondata);
      });
    };
    return {
      next,
      throw: stop,
      return: stop,
      [Symbol.asyncIterator]() {
        return this;
      }
    };
  }
  [Symbol.iterator]() {
    this[DISCARDED2] = false;
    let stopped = false;
    const stop = () => {
      this.pause();
      this.off(ERROR2, stop);
      this.off(DESTROYED2, stop);
      this.off("end", stop);
      stopped = true;
      return { done: true, value: undefined };
    };
    const next = () => {
      if (stopped)
        return stop();
      const value = this.read();
      return value === null ? stop() : { done: false, value };
    };
    this.once("end", stop);
    this.once(ERROR2, stop);
    this.once(DESTROYED2, stop);
    return {
      next,
      throw: stop,
      return: stop,
      [Symbol.iterator]() {
        return this;
      }
    };
  }
  destroy(er) {
    if (this[DESTROYED2]) {
      if (er)
        this.emit("error", er);
      else
        this.emit(DESTROYED2);
      return this;
    }
    this[DESTROYED2] = true;
    this[DISCARDED2] = true;
    this[BUFFER2].length = 0;
    this[BUFFERLENGTH2] = 0;
    const wc = this;
    if (typeof wc.close === "function" && !this[CLOSED2])
      wc.close();
    if (er)
      this.emit("error", er);
    else
      this.emit(DESTROYED2);
    return this;
  }
  static get isStream() {
    return isStream2;
  }
}

// node_modules/glob/dist/esm/ignore.js
var defaultPlatform2 = typeof process === "object" && process && typeof process.platform === "string" ? process.platform : "linux";

class Ignore {
  relative;
  relativeChildren;
  absolute;
  absoluteChildren;
  platform;
  mmopts;
  constructor(ignored, { nobrace, nocase, noext, noglobstar, platform: platform2 = defaultPlatform2 }) {
    this.relative = [];
    this.absolute = [];
    this.relativeChildren = [];
    this.absoluteChildren = [];
    this.platform = platform2;
    this.mmopts = {
      dot: true,
      nobrace,
      nocase,
      noext,
      noglobstar,
      optimizationLevel: 2,
      platform: platform2,
      nocomment: true,
      nonegate: true
    };
    for (const ign of ignored)
      this.add(ign);
  }
  add(ign) {
    const mm = new Minimatch(ign, this.mmopts);
    for (let i = 0;i < mm.set.length; i++) {
      const parsed = mm.set[i];
      const globParts = mm.globParts[i];
      if (!parsed || !globParts) {
        throw new Error("invalid pattern object");
      }
      while (parsed[0] === "." && globParts[0] === ".") {
        parsed.shift();
        globParts.shift();
      }
      const p = new Pattern(parsed, globParts, 0, this.platform);
      const m = new Minimatch(p.globString(), this.mmopts);
      const children = globParts[globParts.length - 1] === "**";
      const absolute = p.isAbsolute();
      if (absolute)
        this.absolute.push(m);
      else
        this.relative.push(m);
      if (children) {
        if (absolute)
          this.absoluteChildren.push(m);
        else
          this.relativeChildren.push(m);
      }
    }
  }
  ignored(p) {
    const fullpath = p.fullpath();
    const fullpaths = `${fullpath}/`;
    const relative = p.relative() || ".";
    const relatives = `${relative}/`;
    for (const m of this.relative) {
      if (m.match(relative) || m.match(relatives))
        return true;
    }
    for (const m of this.absolute) {
      if (m.match(fullpath) || m.match(fullpaths))
        return true;
    }
    return false;
  }
  childrenIgnored(p) {
    const fullpath = p.fullpath() + "/";
    const relative = (p.relative() || ".") + "/";
    for (const m of this.relativeChildren) {
      if (m.match(relative))
        return true;
    }
    for (const m of this.absoluteChildren) {
      if (m.match(fullpath))
        return true;
    }
    return false;
  }
}

// node_modules/glob/dist/esm/processor.js
class HasWalkedCache {
  store;
  constructor(store = new Map) {
    this.store = store;
  }
  copy() {
    return new HasWalkedCache(new Map(this.store));
  }
  hasWalked(target, pattern) {
    return this.store.get(target.fullpath())?.has(pattern.globString());
  }
  storeWalked(target, pattern) {
    const fullpath = target.fullpath();
    const cached3 = this.store.get(fullpath);
    if (cached3)
      cached3.add(pattern.globString());
    else
      this.store.set(fullpath, new Set([pattern.globString()]));
  }
}

class MatchRecord {
  store = new Map;
  add(target, absolute, ifDir) {
    const n = (absolute ? 2 : 0) | (ifDir ? 1 : 0);
    const current = this.store.get(target);
    this.store.set(target, current === undefined ? n : n & current);
  }
  entries() {
    return [...this.store.entries()].map(([path3, n]) => [
      path3,
      !!(n & 2),
      !!(n & 1)
    ]);
  }
}

class SubWalks {
  store = new Map;
  add(target, pattern) {
    if (!target.canReaddir()) {
      return;
    }
    const subs = this.store.get(target);
    if (subs) {
      if (!subs.find((p) => p.globString() === pattern.globString())) {
        subs.push(pattern);
      }
    } else
      this.store.set(target, [pattern]);
  }
  get(target) {
    const subs = this.store.get(target);
    if (!subs) {
      throw new Error("attempting to walk unknown path");
    }
    return subs;
  }
  entries() {
    return this.keys().map((k) => [k, this.store.get(k)]);
  }
  keys() {
    return [...this.store.keys()].filter((t) => t.canReaddir());
  }
}

class Processor2 {
  hasWalkedCache;
  matches = new MatchRecord;
  subwalks = new SubWalks;
  patterns;
  follow;
  dot;
  opts;
  constructor(opts, hasWalkedCache) {
    this.opts = opts;
    this.follow = !!opts.follow;
    this.dot = !!opts.dot;
    this.hasWalkedCache = hasWalkedCache ? hasWalkedCache.copy() : new HasWalkedCache;
  }
  processPatterns(target, patterns) {
    this.patterns = patterns;
    const processingSet = patterns.map((p) => [target, p]);
    for (let [t, pattern] of processingSet) {
      this.hasWalkedCache.storeWalked(t, pattern);
      const root = pattern.root();
      const absolute = pattern.isAbsolute() && this.opts.absolute !== false;
      if (root) {
        t = t.resolve(root === "/" && this.opts.root !== undefined ? this.opts.root : root);
        const rest2 = pattern.rest();
        if (!rest2) {
          this.matches.add(t, true, false);
          continue;
        } else {
          pattern = rest2;
        }
      }
      if (t.isENOENT())
        continue;
      let p;
      let rest;
      let changed = false;
      while (typeof (p = pattern.pattern()) === "string" && (rest = pattern.rest())) {
        const c = t.resolve(p);
        t = c;
        pattern = rest;
        changed = true;
      }
      p = pattern.pattern();
      rest = pattern.rest();
      if (changed) {
        if (this.hasWalkedCache.hasWalked(t, pattern))
          continue;
        this.hasWalkedCache.storeWalked(t, pattern);
      }
      if (typeof p === "string") {
        const ifDir = p === ".." || p === "" || p === ".";
        this.matches.add(t.resolve(p), absolute, ifDir);
        continue;
      } else if (p === GLOBSTAR) {
        if (!t.isSymbolicLink() || this.follow || pattern.checkFollowGlobstar()) {
          this.subwalks.add(t, pattern);
        }
        const rp = rest?.pattern();
        const rrest = rest?.rest();
        if (!rest || (rp === "" || rp === ".") && !rrest) {
          this.matches.add(t, absolute, rp === "" || rp === ".");
        } else {
          if (rp === "..") {
            const tp = t.parent || t;
            if (!rrest)
              this.matches.add(tp, absolute, true);
            else if (!this.hasWalkedCache.hasWalked(tp, rrest)) {
              this.subwalks.add(tp, rrest);
            }
          }
        }
      } else if (p instanceof RegExp) {
        this.subwalks.add(t, pattern);
      }
    }
    return this;
  }
  subwalkTargets() {
    return this.subwalks.keys();
  }
  child() {
    return new Processor2(this.opts, this.hasWalkedCache);
  }
  filterEntries(parent, entries) {
    const patterns = this.subwalks.get(parent);
    const results = this.child();
    for (const e of entries) {
      for (const pattern of patterns) {
        const absolute = pattern.isAbsolute();
        const p = pattern.pattern();
        const rest = pattern.rest();
        if (p === GLOBSTAR) {
          results.testGlobstar(e, pattern, rest, absolute);
        } else if (p instanceof RegExp) {
          results.testRegExp(e, p, rest, absolute);
        } else {
          results.testString(e, p, rest, absolute);
        }
      }
    }
    return results;
  }
  testGlobstar(e, pattern, rest, absolute) {
    if (this.dot || !e.name.startsWith(".")) {
      if (!pattern.hasMore()) {
        this.matches.add(e, absolute, false);
      }
      if (e.canReaddir()) {
        if (this.follow || !e.isSymbolicLink()) {
          this.subwalks.add(e, pattern);
        } else if (e.isSymbolicLink()) {
          if (rest && pattern.checkFollowGlobstar()) {
            this.subwalks.add(e, rest);
          } else if (pattern.markFollowGlobstar()) {
            this.subwalks.add(e, pattern);
          }
        }
      }
    }
    if (rest) {
      const rp = rest.pattern();
      if (typeof rp === "string" && rp !== ".." && rp !== "" && rp !== ".") {
        this.testString(e, rp, rest.rest(), absolute);
      } else if (rp === "..") {
        const ep = e.parent || e;
        this.subwalks.add(ep, rest);
      } else if (rp instanceof RegExp) {
        this.testRegExp(e, rp, rest.rest(), absolute);
      }
    }
  }
  testRegExp(e, p, rest, absolute) {
    if (!p.test(e.name))
      return;
    if (!rest) {
      this.matches.add(e, absolute, false);
    } else {
      this.subwalks.add(e, rest);
    }
  }
  testString(e, p, rest, absolute) {
    if (!e.isNamed(p))
      return;
    if (!rest) {
      this.matches.add(e, absolute, false);
    } else {
      this.subwalks.add(e, rest);
    }
  }
}

// node_modules/glob/dist/esm/walker.js
var makeIgnore = (ignore, opts) => typeof ignore === "string" ? new Ignore([ignore], opts) : Array.isArray(ignore) ? new Ignore(ignore, opts) : ignore;

class GlobUtil {
  path;
  patterns;
  opts;
  seen = new Set;
  paused = false;
  aborted = false;
  #onResume = [];
  #ignore;
  #sep;
  signal;
  maxDepth;
  includeChildMatches;
  constructor(patterns, path3, opts) {
    this.patterns = patterns;
    this.path = path3;
    this.opts = opts;
    this.#sep = !opts.posix && opts.platform === "win32" ? "\\" : "/";
    this.includeChildMatches = opts.includeChildMatches !== false;
    if (opts.ignore || !this.includeChildMatches) {
      this.#ignore = makeIgnore(opts.ignore ?? [], opts);
      if (!this.includeChildMatches && typeof this.#ignore.add !== "function") {
        const m = "cannot ignore child matches, ignore lacks add() method.";
        throw new Error(m);
      }
    }
    this.maxDepth = opts.maxDepth || Infinity;
    if (opts.signal) {
      this.signal = opts.signal;
      this.signal.addEventListener("abort", () => {
        this.#onResume.length = 0;
      });
    }
  }
  #ignored(path3) {
    return this.seen.has(path3) || !!this.#ignore?.ignored?.(path3);
  }
  #childrenIgnored(path3) {
    return !!this.#ignore?.childrenIgnored?.(path3);
  }
  pause() {
    this.paused = true;
  }
  resume() {
    if (this.signal?.aborted)
      return;
    this.paused = false;
    let fn = undefined;
    while (!this.paused && (fn = this.#onResume.shift())) {
      fn();
    }
  }
  onResume(fn) {
    if (this.signal?.aborted)
      return;
    if (!this.paused) {
      fn();
    } else {
      this.#onResume.push(fn);
    }
  }
  async matchCheck(e, ifDir) {
    if (ifDir && this.opts.nodir)
      return;
    let rpc;
    if (this.opts.realpath) {
      rpc = e.realpathCached() || await e.realpath();
      if (!rpc)
        return;
      e = rpc;
    }
    const needStat = e.isUnknown() || this.opts.stat;
    const s = needStat ? await e.lstat() : e;
    if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
      const target = await s.realpath();
      if (target && (target.isUnknown() || this.opts.stat)) {
        await target.lstat();
      }
    }
    return this.matchCheckTest(s, ifDir);
  }
  matchCheckTest(e, ifDir) {
    return e && (this.maxDepth === Infinity || e.depth() <= this.maxDepth) && (!ifDir || e.canReaddir()) && (!this.opts.nodir || !e.isDirectory()) && (!this.opts.nodir || !this.opts.follow || !e.isSymbolicLink() || !e.realpathCached()?.isDirectory()) && !this.#ignored(e) ? e : undefined;
  }
  matchCheckSync(e, ifDir) {
    if (ifDir && this.opts.nodir)
      return;
    let rpc;
    if (this.opts.realpath) {
      rpc = e.realpathCached() || e.realpathSync();
      if (!rpc)
        return;
      e = rpc;
    }
    const needStat = e.isUnknown() || this.opts.stat;
    const s = needStat ? e.lstatSync() : e;
    if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
      const target = s.realpathSync();
      if (target && (target?.isUnknown() || this.opts.stat)) {
        target.lstatSync();
      }
    }
    return this.matchCheckTest(s, ifDir);
  }
  matchFinish(e, absolute) {
    if (this.#ignored(e))
      return;
    if (!this.includeChildMatches && this.#ignore?.add) {
      const ign = `${e.relativePosix()}/**`;
      this.#ignore.add(ign);
    }
    const abs = this.opts.absolute === undefined ? absolute : this.opts.absolute;
    this.seen.add(e);
    const mark = this.opts.mark && e.isDirectory() ? this.#sep : "";
    if (this.opts.withFileTypes) {
      this.matchEmit(e);
    } else if (abs) {
      const abs2 = this.opts.posix ? e.fullpathPosix() : e.fullpath();
      this.matchEmit(abs2 + mark);
    } else {
      const rel = this.opts.posix ? e.relativePosix() : e.relative();
      const pre = this.opts.dotRelative && !rel.startsWith(".." + this.#sep) ? "." + this.#sep : "";
      this.matchEmit(!rel ? "." + mark : pre + rel + mark);
    }
  }
  async match(e, absolute, ifDir) {
    const p = await this.matchCheck(e, ifDir);
    if (p)
      this.matchFinish(p, absolute);
  }
  matchSync(e, absolute, ifDir) {
    const p = this.matchCheckSync(e, ifDir);
    if (p)
      this.matchFinish(p, absolute);
  }
  walkCB(target, patterns, cb) {
    if (this.signal?.aborted)
      cb();
    this.walkCB2(target, patterns, new Processor2(this.opts), cb);
  }
  walkCB2(target, patterns, processor, cb) {
    if (this.#childrenIgnored(target))
      return cb();
    if (this.signal?.aborted)
      cb();
    if (this.paused) {
      this.onResume(() => this.walkCB2(target, patterns, processor, cb));
      return;
    }
    processor.processPatterns(target, patterns);
    let tasks = 1;
    const next = () => {
      if (--tasks === 0)
        cb();
    };
    for (const [m, absolute, ifDir] of processor.matches.entries()) {
      if (this.#ignored(m))
        continue;
      tasks++;
      this.match(m, absolute, ifDir).then(() => next());
    }
    for (const t of processor.subwalkTargets()) {
      if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
        continue;
      }
      tasks++;
      const childrenCached = t.readdirCached();
      if (t.calledReaddir())
        this.walkCB3(t, childrenCached, processor, next);
      else {
        t.readdirCB((_, entries) => this.walkCB3(t, entries, processor, next), true);
      }
    }
    next();
  }
  walkCB3(target, entries, processor, cb) {
    processor = processor.filterEntries(target, entries);
    let tasks = 1;
    const next = () => {
      if (--tasks === 0)
        cb();
    };
    for (const [m, absolute, ifDir] of processor.matches.entries()) {
      if (this.#ignored(m))
        continue;
      tasks++;
      this.match(m, absolute, ifDir).then(() => next());
    }
    for (const [target2, patterns] of processor.subwalks.entries()) {
      tasks++;
      this.walkCB2(target2, patterns, processor.child(), next);
    }
    next();
  }
  walkCBSync(target, patterns, cb) {
    if (this.signal?.aborted)
      cb();
    this.walkCB2Sync(target, patterns, new Processor2(this.opts), cb);
  }
  walkCB2Sync(target, patterns, processor, cb) {
    if (this.#childrenIgnored(target))
      return cb();
    if (this.signal?.aborted)
      cb();
    if (this.paused) {
      this.onResume(() => this.walkCB2Sync(target, patterns, processor, cb));
      return;
    }
    processor.processPatterns(target, patterns);
    let tasks = 1;
    const next = () => {
      if (--tasks === 0)
        cb();
    };
    for (const [m, absolute, ifDir] of processor.matches.entries()) {
      if (this.#ignored(m))
        continue;
      this.matchSync(m, absolute, ifDir);
    }
    for (const t of processor.subwalkTargets()) {
      if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
        continue;
      }
      tasks++;
      const children = t.readdirSync();
      this.walkCB3Sync(t, children, processor, next);
    }
    next();
  }
  walkCB3Sync(target, entries, processor, cb) {
    processor = processor.filterEntries(target, entries);
    let tasks = 1;
    const next = () => {
      if (--tasks === 0)
        cb();
    };
    for (const [m, absolute, ifDir] of processor.matches.entries()) {
      if (this.#ignored(m))
        continue;
      this.matchSync(m, absolute, ifDir);
    }
    for (const [target2, patterns] of processor.subwalks.entries()) {
      tasks++;
      this.walkCB2Sync(target2, patterns, processor.child(), next);
    }
    next();
  }
}

class GlobWalker extends GlobUtil {
  matches = new Set;
  constructor(patterns, path3, opts) {
    super(patterns, path3, opts);
  }
  matchEmit(e) {
    this.matches.add(e);
  }
  async walk() {
    if (this.signal?.aborted)
      throw this.signal.reason;
    if (this.path.isUnknown()) {
      await this.path.lstat();
    }
    await new Promise((res, rej) => {
      this.walkCB(this.path, this.patterns, () => {
        if (this.signal?.aborted) {
          rej(this.signal.reason);
        } else {
          res(this.matches);
        }
      });
    });
    return this.matches;
  }
  walkSync() {
    if (this.signal?.aborted)
      throw this.signal.reason;
    if (this.path.isUnknown()) {
      this.path.lstatSync();
    }
    this.walkCBSync(this.path, this.patterns, () => {
      if (this.signal?.aborted)
        throw this.signal.reason;
    });
    return this.matches;
  }
}

class GlobStream extends GlobUtil {
  results;
  constructor(patterns, path3, opts) {
    super(patterns, path3, opts);
    this.results = new Minipass2({
      signal: this.signal,
      objectMode: true
    });
    this.results.on("drain", () => this.resume());
    this.results.on("resume", () => this.resume());
  }
  matchEmit(e) {
    this.results.write(e);
    if (!this.results.flowing)
      this.pause();
  }
  stream() {
    const target = this.path;
    if (target.isUnknown()) {
      target.lstat().then(() => {
        this.walkCB(target, this.patterns, () => this.results.end());
      });
    } else {
      this.walkCB(target, this.patterns, () => this.results.end());
    }
    return this.results;
  }
  streamSync() {
    if (this.path.isUnknown()) {
      this.path.lstatSync();
    }
    this.walkCBSync(this.path, this.patterns, () => this.results.end());
    return this.results;
  }
}

// node_modules/glob/dist/esm/glob.js
var defaultPlatform3 = typeof process === "object" && process && typeof process.platform === "string" ? process.platform : "linux";

class Glob3 {
  absolute;
  cwd;
  root;
  dot;
  dotRelative;
  follow;
  ignore;
  magicalBraces;
  mark;
  matchBase;
  maxDepth;
  nobrace;
  nocase;
  nodir;
  noext;
  noglobstar;
  pattern;
  platform;
  realpath;
  scurry;
  stat;
  signal;
  windowsPathsNoEscape;
  withFileTypes;
  includeChildMatches;
  opts;
  patterns;
  constructor(pattern, opts) {
    if (!opts)
      throw new TypeError("glob options required");
    this.withFileTypes = !!opts.withFileTypes;
    this.signal = opts.signal;
    this.follow = !!opts.follow;
    this.dot = !!opts.dot;
    this.dotRelative = !!opts.dotRelative;
    this.nodir = !!opts.nodir;
    this.mark = !!opts.mark;
    if (!opts.cwd) {
      this.cwd = "";
    } else if (opts.cwd instanceof URL || opts.cwd.startsWith("file://")) {
      opts.cwd = fileURLToPath2(opts.cwd);
    }
    this.cwd = opts.cwd || "";
    this.root = opts.root;
    this.magicalBraces = !!opts.magicalBraces;
    this.nobrace = !!opts.nobrace;
    this.noext = !!opts.noext;
    this.realpath = !!opts.realpath;
    this.absolute = opts.absolute;
    this.includeChildMatches = opts.includeChildMatches !== false;
    this.noglobstar = !!opts.noglobstar;
    this.matchBase = !!opts.matchBase;
    this.maxDepth = typeof opts.maxDepth === "number" ? opts.maxDepth : Infinity;
    this.stat = !!opts.stat;
    this.ignore = opts.ignore;
    if (this.withFileTypes && this.absolute !== undefined) {
      throw new Error("cannot set absolute and withFileTypes:true");
    }
    if (typeof pattern === "string") {
      pattern = [pattern];
    }
    this.windowsPathsNoEscape = !!opts.windowsPathsNoEscape || opts.allowWindowsEscape === false;
    if (this.windowsPathsNoEscape) {
      pattern = pattern.map((p) => p.replace(/\\/g, "/"));
    }
    if (this.matchBase) {
      if (opts.noglobstar) {
        throw new TypeError("base matching requires globstar");
      }
      pattern = pattern.map((p) => p.includes("/") ? p : `./**/${p}`);
    }
    this.pattern = pattern;
    this.platform = opts.platform || defaultPlatform3;
    this.opts = { ...opts, platform: this.platform };
    if (opts.scurry) {
      this.scurry = opts.scurry;
      if (opts.nocase !== undefined && opts.nocase !== opts.scurry.nocase) {
        throw new Error("nocase option contradicts provided scurry option");
      }
    } else {
      const Scurry = opts.platform === "win32" ? PathScurryWin32 : opts.platform === "darwin" ? PathScurryDarwin : opts.platform ? PathScurryPosix : PathScurry;
      this.scurry = new Scurry(this.cwd, {
        nocase: opts.nocase,
        fs: opts.fs
      });
    }
    this.nocase = this.scurry.nocase;
    const nocaseMagicOnly = this.platform === "darwin" || this.platform === "win32";
    const mmo = {
      ...opts,
      dot: this.dot,
      matchBase: this.matchBase,
      nobrace: this.nobrace,
      nocase: this.nocase,
      nocaseMagicOnly,
      nocomment: true,
      noext: this.noext,
      nonegate: true,
      optimizationLevel: 2,
      platform: this.platform,
      windowsPathsNoEscape: this.windowsPathsNoEscape,
      debug: !!this.opts.debug
    };
    const mms = this.pattern.map((p) => new Minimatch(p, mmo));
    const [matchSet, globParts] = mms.reduce((set3, m) => {
      set3[0].push(...m.set);
      set3[1].push(...m.globParts);
      return set3;
    }, [[], []]);
    this.patterns = matchSet.map((set3, i) => {
      const g = globParts[i];
      if (!g)
        throw new Error("invalid pattern object");
      return new Pattern(set3, g, 0, this.platform);
    });
  }
  async walk() {
    return [
      ...await new GlobWalker(this.patterns, this.scurry.cwd, {
        ...this.opts,
        maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
        platform: this.platform,
        nocase: this.nocase,
        includeChildMatches: this.includeChildMatches
      }).walk()
    ];
  }
  walkSync() {
    return [
      ...new GlobWalker(this.patterns, this.scurry.cwd, {
        ...this.opts,
        maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
        platform: this.platform,
        nocase: this.nocase,
        includeChildMatches: this.includeChildMatches
      }).walkSync()
    ];
  }
  stream() {
    return new GlobStream(this.patterns, this.scurry.cwd, {
      ...this.opts,
      maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
      platform: this.platform,
      nocase: this.nocase,
      includeChildMatches: this.includeChildMatches
    }).stream();
  }
  streamSync() {
    return new GlobStream(this.patterns, this.scurry.cwd, {
      ...this.opts,
      maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
      platform: this.platform,
      nocase: this.nocase,
      includeChildMatches: this.includeChildMatches
    }).streamSync();
  }
  iterateSync() {
    return this.streamSync()[Symbol.iterator]();
  }
  [Symbol.iterator]() {
    return this.iterateSync();
  }
  iterate() {
    return this.stream()[Symbol.asyncIterator]();
  }
  [Symbol.asyncIterator]() {
    return this.iterate();
  }
}

// node_modules/glob/dist/esm/has-magic.js
var hasMagic = (pattern, options2 = {}) => {
  if (!Array.isArray(pattern)) {
    pattern = [pattern];
  }
  for (const p of pattern) {
    if (new Minimatch(p, options2).hasMagic())
      return true;
  }
  return false;
};

// node_modules/glob/dist/esm/index.js
function globStreamSync(pattern, options2 = {}) {
  return new Glob3(pattern, options2).streamSync();
}
function globStream(pattern, options2 = {}) {
  return new Glob3(pattern, options2).stream();
}
function globSync(pattern, options2 = {}) {
  return new Glob3(pattern, options2).walkSync();
}
async function glob_(pattern, options2 = {}) {
  return new Glob3(pattern, options2).walk();
}
function globIterateSync(pattern, options2 = {}) {
  return new Glob3(pattern, options2).iterateSync();
}
function globIterate(pattern, options2 = {}) {
  return new Glob3(pattern, options2).iterate();
}
var streamSync = globStreamSync;
var stream = Object.assign(globStream, { sync: globStreamSync });
var iterateSync = globIterateSync;
var iterate = Object.assign(globIterate, {
  sync: globIterateSync
});
var sync = Object.assign(globSync, {
  stream: globStreamSync,
  iterate: globIterateSync
});
var glob = Object.assign(glob_, {
  glob: glob_,
  globSync,
  sync,
  globStream,
  stream,
  globStreamSync,
  streamSync,
  globIterate,
  iterate,
  globIterateSync,
  iterateSync,
  Glob: Glob3,
  hasMagic,
  escape: escape2,
  unescape: unescape2
});
glob.glob = glob;

// src/core/SidecarSquasher.ts
var log11 = getLogger("SidecarSquasher");

class SidecarSquasher {
  db;
  constructor(db) {
    this.db = db;
  }
  async squash(pattern = "**/*.json") {
    const sidecars = await glob(pattern, { cwd: process.cwd() });
    let totalNodes = 0;
    let totalEdges = 0;
    let processedFiles = 0;
    log11.info({ count: sidecars.length, pattern }, "Found sidecar files to squash");
    for (const sidecarPath of sidecars) {
      try {
        const stats = await this.squashFile(sidecarPath);
        if (stats) {
          totalNodes += stats.nodes;
          totalEdges += stats.edges;
          processedFiles++;
        }
      } catch (e) {
        log11.error({ file: sidecarPath, err: e }, "Failed to squash sidecar");
      }
    }
    log11.info({ processedFiles, totalNodes, totalEdges }, "Squash routine complete");
    return { nodes: totalNodes, edges: totalEdges, files: processedFiles };
  }
  async squashFile(sidecarPath) {
    const content = readFileSync7(sidecarPath, "utf-8");
    let data;
    try {
      const jsonStr = content.replace(/```json\n?|\n?```/g, "").trim();
      const parsed = JSON.parse(jsonStr);
      if (parsed.changes || parsed.graphData) {
        const sidecar = parsed;
        if (sidecar.graphData) {
          data = sidecar.graphData;
        } else {
          log11.debug({ file: sidecarPath }, "Sidecar has no graphData, skipping graph squash");
          return null;
        }
      } else if (parsed.entities) {
        data = parsed;
      } else {
        log11.warn({ file: sidecarPath }, "Unknown sidecar format");
        return null;
      }
    } catch (_e) {
      log11.warn({ file: sidecarPath }, "Invalid JSON in sidecar, skipping");
      return null;
    }
    const relativePath = toRootRelative(sidecarPath);
    const parentPath = relativePath.replace(/\.ember\.json$/, "");
    const parentId = this.db.generateId(parentPath);
    const parentNode = this.db.getNode(parentId);
    if (!parentNode) {
      log11.debug({ parentPath, parentId }, "Parent node not found, skipping squash");
      return null;
    }
    let nodeCount = 0;
    let edgeCount = 0;
    const runTransaction = this.db.getRawDb().transaction(() => {
      log11.info({ entityCount: data.entities.length }, "Processing entities");
      const symbolIdMap = new Map;
      const insertNodeStmt = this.db.getRawDb().prepare(`
                INSERT INTO nodes (id, type, title, domain, layer, summary, meta, date)
                VALUES ($id, $type, $title, $domain, $layer, $summary, $meta, $date)
                ON CONFLICT(id) DO UPDATE SET
                summary = excluded.summary,
                date = excluded.date
            `);
      const insertEdgeStmt = this.db.getRawDb().prepare(`
                INSERT OR IGNORE INTO edges (source, target, type, confidence, veracity, context_source)
                VALUES ($source, $target, $type, $confidence, $veracity, $contextSource)
            `);
      for (const entity of data.entities) {
        const symbolId = this.db.generateId(`${parentPath}:${entity.name}`);
        symbolIdMap.set(entity.name, symbolId);
        insertNodeStmt.run({
          $id: symbolId,
          $type: entity.type.toLowerCase(),
          $title: entity.name,
          $domain: parentNode.domain || "code",
          $layer: "symbol",
          $summary: entity.description || null,
          $meta: JSON.stringify({
            source: parentPath,
            parent_id: parentId,
            extraction_source: "lang-extract"
          }),
          $date: new Date().toISOString()
        });
        nodeCount++;
        insertEdgeStmt.run({
          $source: parentId,
          $target: symbolId,
          $type: "DEFINES",
          $confidence: 1,
          $veracity: 1,
          $contextSource: "lang-extract"
        });
        edgeCount++;
      }
      for (const rel of data.relationships) {
        const sourceId = symbolIdMap.get(rel.source);
        if (sourceId) {
          const targetId = symbolIdMap.get(rel.target);
          if (targetId) {
            insertEdgeStmt.run({
              $source: sourceId,
              $target: targetId,
              $type: rel.type.toUpperCase(),
              $confidence: 0.8,
              $veracity: 1,
              $contextSource: "lang-extract"
            });
            edgeCount++;
          }
        }
      }
    });
    runTransaction();
    return { nodes: nodeCount, edges: edgeCount };
  }
}

// src/cli/commands/squash.ts
init_defaults();
async function cmdSquash(args) {
  let pattern = "**/*.json";
  const patternIdx = args.indexOf("--pattern");
  if (patternIdx !== -1 && args[patternIdx + 1]) {
    pattern = args[patternIdx + 1];
  }
  const log12 = getLogger("CLI:Squash");
  try {
    log12.info({ pattern }, "Initializing squash routine...");
    const config3 = loadSettings();
    const db = ResonanceDB.init(config3.database);
    const squasher = new SidecarSquasher(db);
    const stats = await squasher.squash(pattern);
    console.log("");
    console.log("Squash Complete:");
    console.log(`  Files Processed: ${stats.files}`);
    console.log(`  Nodes Created/Updated: ${stats.nodes}`);
    console.log(`  Edges Created: ${stats.edges}`);
    console.log("");
  } catch (e) {
    log12.error({ err: e }, "Squash failed");
    process.exit(1);
  } finally {
    process.exit(0);
  }
}

// src/cli/commands/dashboard.ts
init_defaults();
import { spawn as spawn4 } from "child_process";
import { existsSync as existsSync20, readFileSync as readFileSync8 } from "fs";
import { join as join21 } from "path";
var _log = getLogger("CLI:Dashboard");
var PID_FILE = join21(AMALFA_DIRS.runtime, "dashboard.pid");
var PORT = 3013;
async function cmdDashboard(args) {
  const subcommand = args[0] || "status";
  switch (subcommand) {
    case "start":
      await startDashboard();
      break;
    case "stop":
      await stopDashboard();
      break;
    case "restart":
      await stopDashboard();
      await new Promise((resolve5) => setTimeout(resolve5, 1000));
      await startDashboard();
      break;
    case "status":
      await showStatus();
      break;
    case "open":
      await openDashboard();
      break;
    default:
      console.log("Usage: amalfa dashboard [start|stop|restart|status|open]");
      process.exit(1);
  }
}
async function startDashboard() {
  if (existsSync20(PID_FILE)) {
    const pid = readFileSync8(PID_FILE, "utf-8").trim();
    console.log(`\u26A0\uFE0F  Dashboard may already be running (PID: ${pid})`);
    console.log("   Run 'amalfa dashboard stop' first if needed.");
    return;
  }
  console.log("\uD83D\uDE80 Starting dashboard...");
  const child = spawn4("bun", ["run", "src/services/dashboard-daemon.ts"], {
    detached: true,
    stdio: "ignore",
    cwd: process.cwd()
  });
  child.unref();
  await new Promise((resolve5) => setTimeout(resolve5, 1000));
  if (existsSync20(PID_FILE)) {
    const pid = readFileSync8(PID_FILE, "utf-8").trim();
    console.log(`\u2705 Dashboard started (PID: ${pid})`);
    console.log(`   View at: http://localhost:${PORT}`);
  } else {
    console.log("\u274C Failed to start dashboard");
  }
}
async function stopDashboard() {
  if (!existsSync20(PID_FILE)) {
    console.log("\u26A0\uFE0F  Dashboard is not running");
    return;
  }
  const pid = readFileSync8(PID_FILE, "utf-8").trim();
  console.log(`\uD83D\uDED1 Stopping dashboard (PID: ${pid})...`);
  try {
    process.kill(Number(pid), "SIGTERM");
    await new Promise((resolve5) => setTimeout(resolve5, 500));
    console.log("\u2705 Dashboard stopped");
  } catch (err) {
    console.log("\u274C Failed to stop dashboard:", err);
  }
}
async function showStatus() {
  if (existsSync20(PID_FILE)) {
    const pid = readFileSync8(PID_FILE, "utf-8").trim();
    console.log(`\u2705 Dashboard is running`);
    console.log(`   PID: ${pid}`);
    console.log(`   URL: http://localhost:${PORT}`);
  } else {
    console.log("\u26A0\uFE0F  Dashboard is not running");
    console.log("   Run 'amalfa dashboard start' to start it");
  }
}
async function openDashboard() {
  if (!existsSync20(PID_FILE)) {
    console.log("\u26A0\uFE0F  Dashboard is not running. Starting it now...");
    await startDashboard();
    await new Promise((resolve5) => setTimeout(resolve5, 1500));
  }
  const url2 = `http://localhost:${PORT}`;
  console.log(`\uD83C\uDF10 Opening dashboard: ${url2}`);
  Bun.spawnSync(["open", url2]);
}

// src/cli/commands/stats.ts
init_defaults();
import {
  existsSync as existsSync21,
  readdirSync as readdirSync3,
  statSync as statSync5,
  statSync as statSyncFs
} from "fs";
import { join as join22 } from "path";
async function cmdStats(args) {
  if (!await checkDatabase()) {
    process.exit(1);
  }
  const dbPath = await getDbPath();
  const db = new ResonanceDB(dbPath);
  const config3 = await loadConfig();
  const sources = config3.sources || ["./docs"];
  try {
    let scan = function(dir) {
      if (!existsSync21(dir))
        return;
      const entries = readdirSync3(dir, { withFileTypes: true });
      for (const entry of entries) {
        const fullPath = join22(dir, entry.name);
        if (entry.name.startsWith("."))
          continue;
        if (entry.isDirectory()) {
          scan(fullPath);
        } else if (entry.name.endsWith(".md")) {
          const mtime = statSyncFs(fullPath).mtime;
          if (mtime > dbStats.mtime) {
            newerFiles++;
          }
          if (mtime > newestFileDate) {
            newestFileDate = mtime;
          }
        }
      }
    };
    const stats = db.getStats();
    const dbStats = statSync5(dbPath);
    const fileSizeMB = (dbStats.size / 1024 / 1024).toFixed(2);
    let newerFiles = 0;
    let newestFileDate = new Date(0);
    for (const source of sources) {
      scan(join22(process.cwd(), source));
    }
    const isStale = newerFiles > 0;
    const statusIcon = isStale ? "\u26A0\uFE0F  STALE" : "\u2705 FRESH";
    let orphanSection = "";
    if (args.includes("--orphans")) {
      const orphanSql = `
                SELECT n.id, n.type
                FROM nodes n
                LEFT JOIN edges e1 ON n.id = e1.source
                LEFT JOIN edges e2 ON n.id = e2.target
                WHERE e1.source IS NULL AND e2.target IS NULL
                  AND n.type != 'root' -- Exclude root
                  AND n.type != 'domain' -- Exclude domain markers
            `;
      const orphans = db.getRawDb().query(orphanSql).all();
      if (orphans.length > 0) {
        const orphanRate = (orphans.length / stats.nodes * 100).toFixed(1);
        orphanSection = `
Orphans:    ${orphans.length} (${orphanRate}%) - Run 'amalfa ember scan' to fix`;
      } else {
        orphanSection = `
Orphans:    0 (Graph is fully connected)`;
      }
    }
    console.log(`
\uD83D\uDCCA AMALFA Database Statistics

Database: ${dbPath}
Status:   ${statusIcon}
Size:     ${fileSizeMB} MB

Nodes:      ${stats.nodes.toLocaleString()}
Edges:      ${stats.edges.toLocaleString()}
Embeddings: ${stats.vectors.toLocaleString()} (384-dim)${orphanSection}

Sources:       ${sources.join(", ")}
DB Modified:   ${new Date(dbStats.mtime).toISOString()}
Latest File:   ${newestFileDate.toISOString()}
Stale Files:   ${newerFiles}

${isStale ? "\u26A0\uFE0F  ACTION REQUIRED: Run 'amalfa init' or start 'amalfa daemon' to update!" : "\uD83D\uDD0D System is up to date."}
`);
  } catch (error49) {
    console.error("\u274C Failed to read database statistics:", error49);
    process.exit(1);
  } finally {
    db.close();
  }
}

// src/cli/commands/validate.ts
init_defaults();
import { statSync as statSync6 } from "fs";
var VERSION2 = package_default.version;
async function cmdValidate(args) {
  console.log(`\uD83D\uDEE1\uFE0F  AMALFA Database Validation
`);
  if (!await checkDatabase()) {
    console.error(`
\u274C Validation failed: Database not found`);
    process.exit(1);
  }
  const dbPath = await getDbPath();
  const db = new ResonanceDB(dbPath);
  const tracker = new StatsTracker;
  const config3 = await loadConfig();
  try {
    const stats = db.getStats();
    const fileSize = statSync6(dbPath).size;
    const dbSizeMB = fileSize / 1024 / 1024;
    const currentSnapshot = {
      timestamp: new Date().toISOString(),
      nodes: stats.nodes,
      edges: stats.edges,
      embeddings: stats.vectors,
      dbSizeMB,
      version: VERSION2
    };
    const validation = tracker.validate(currentSnapshot);
    const graphIssues = [];
    if (args.includes("--graph")) {
      console.log("\uD83D\uDD0D Checking Graph Integrity...");
      const dangling = db.getRawDb().query(`
				SELECT COUNT(*) as c FROM edges e
				LEFT JOIN nodes s ON e.source = s.id
				LEFT JOIN nodes t ON e.target = t.id
				WHERE s.id IS NULL OR t.id IS NULL
			`).get();
      if (dangling.c > 0) {
        graphIssues.push(`Found ${dangling.c} dangling edges (source/target missing)`);
        validation.errors.push("Graph integrity compromised: Dangling edges found");
      }
      const selfLoops = db.getRawDb().query(`
				SELECT COUNT(*) as c FROM edges WHERE source = target
			`).get();
      if (selfLoops.c > 0) {
        graphIssues.push(`Found ${selfLoops.c} self-loops (source == target)`);
        validation.warnings.push(`Graph contains ${selfLoops.c} self-loops`);
      }
      const threshold = config3.graph?.tuning?.louvain?.superNodeThreshold || 50;
      const superNodes = db.getRawDb().query(`
				SELECT id, (SELECT COUNT(*) FROM edges WHERE source = nodes.id OR target = nodes.id) as degree
				FROM nodes
				WHERE degree > ?
				ORDER BY degree DESC
				LIMIT 5
			`).all(threshold);
      if (superNodes.length > 0) {
        graphIssues.push(`Found ${superNodes.length}+ Super Nodes (> ${threshold} edges):`);
        superNodes.forEach((n) => {
          graphIssues.push(`  - ${n.id} (${n.degree})`);
        });
        validation.warnings.push(`Graph contains Super Nodes (potential hairballs)`);
      }
    }
    console.log("\uD83D\uDCCA Current State:");
    console.log(`  Nodes: ${stats.nodes}`);
    console.log(`  Edges: ${stats.edges}`);
    console.log(`  Embeddings: ${stats.vectors}`);
    console.log(`  Database size: ${dbSizeMB.toFixed(2)} MB
`);
    if (validation.errors.length > 0) {
      console.error("\u274C ERRORS (Must Fix):");
      for (const error49 of validation.errors) {
        console.error(`  - ${error49}`);
      }
      console.error("");
    }
    if (validation.warnings.length > 0) {
      console.warn("\u26A0\uFE0F  WARNINGS:");
      for (const warning of validation.warnings) {
        console.warn(`  - ${warning}`);
      }
      console.warn("");
    }
    const snapshots = tracker.getAllSnapshots();
    if (snapshots.length > 1) {
      console.log(tracker.getSummary());
      console.log("");
    }
    if (validation.valid) {
      console.log("\u2705 Validation passed! Database is healthy.");
      if (validation.warnings.length > 0) {
        console.log(`
\uD83D\uDCA1 Consider addressing warnings before publishing.`);
      }
    } else {
      console.error("\u274C Validation failed! Database has critical issues.");
      console.error(`
Fix errors before publishing:`);
      console.error("  - Run: amalfa init");
      db.close();
      process.exit(1);
    }
    db.close();
  } catch (error49) {
    db.close();
    console.error("\u274C Validation failed:", error49);
    process.exit(1);
  }
}

// src/cli.ts
var VERSION3 = package_default.version;
var args = process.argv.slice(2);
var command = args[0];
if (process.cwd() === "/") {
  const scriptBasedRoot = resolve5(import.meta.dir, "..");
  if (existsSync23(join24(scriptBasedRoot, "package.json"))) {
    try {
      console.error(`\u26A0\uFE0F  Detected CWD as system root. Switching to: ${scriptBasedRoot}`);
      process.chdir(scriptBasedRoot);
    } catch (e) {
      console.error("Failed to switch CWD:", e);
    }
  }
}
function showHelp() {
  console.log(`
AMALFA v${VERSION3} - A Memory Layer For Agents

Usage:
  amalfa <command> [options]

Commands:
  init [--force]     Initialize database from markdown files
  serve              Start MCP server (stdio transport)
  search <query>     Search knowledge graph [--limit N] [--json]
  read <node-id>     Read document content [--json]
  explore <node-id>  Show related documents [--relation type] [--json]
  list-sources       Show configured source directories [--json]
  find-gaps          Discover similar but unlinked documents [--limit N] [--threshold T] [--json]
  inject-tags <path> Add metadata tags to markdown file <tag1> [tag2...] [--json]
  stats              Show database statistics
  validate           Validate database health (pre-publish gate)
  doctor             Check installation and configuration
  setup-mcp          Generate MCP configuration JSON
  setup-python       Initialize Python sidecar environment
  watcher <action>   Manage file watcher (start|stop|status|restart)
  vector <action>    Manage vector daemon (start|stop|status|restart)
  reranker <action>  Manage reranker daemon (start|stop|status|restart)
  sonar <action>     Manage Sonar AI agent (start|stop|status|restart)
  ember <action>     Manage Ember enrichment service (scan|squash)
  squash             Ingest sidecar JSON files into the graph
  scripts list       List available scripts and their descriptions
  servers [--dot]    Show status of all AMALFA services (--dot for graph)
  stop-all (kill)    Stop all running AMALFA services

Options:
  --force            Override pre-flight warnings (errors still block)
  --version, -v      Show version number
  --help, -h         Show this help message

Examples:
  amalfa init        # Initialize with pre-flight validation
  amalfa init --force # Override warnings (use with caution)
  amalfa serve       # Start MCP server for Claude Desktop
  amalfa search "oauth patterns"  # Search knowledge graph
  amalfa read docs/README.md      # Read document content
  amalfa explore docs/README.md   # Show related documents
  amalfa list-sources             # Show source directories
  amalfa stats       # Show knowledge graph statistics
  amalfa doctor      # Verify installation
  amalfa sonar start # Start Sonar AI agent for enhanced search
  amalfa watcher start # Start file watcher for real-time updates

Documentation: https://github.com/pjsvis/amalfa
`);
}
function showVersion() {
  console.log(`amalfa v${VERSION3}`);
}
async function cmdScripts() {
  const action = args[1] || "list";
  if (action === "list") {
    await Promise.resolve().then(() => (init_list_scripts(), exports_list_scripts));
    return;
  }
  console.error(`\u274C Invalid action: ${action}`);
  console.error("Usage: amalfa scripts list");
  process.exit(1);
}
async function main() {
  switch (command) {
    case "serve":
      await cmdServe(args);
      break;
    case "search":
      await cmdSearch(args.slice(1));
      break;
    case "read":
      await cmdRead(args.slice(1));
      break;
    case "explore":
      await cmdExplore(args.slice(1));
      break;
    case "list-sources":
      await cmdListSources(args.slice(1));
      break;
    case "find-gaps":
      await cmdFindGaps(args.slice(1));
      break;
    case "inject-tags":
      await cmdInjectTags(args.slice(1));
      break;
    case "stats":
      await cmdStats(args);
      break;
    case "doctor":
      await cmdDoctor(args);
      break;
    case "validate":
      await cmdValidate(args);
      break;
    case "init":
      await cmdInit(args);
      break;
    case "watcher":
      await cmdWatcher(args);
      break;
    case "vector":
      await cmdVector(args);
      break;
    case "reranker":
      await cmdReranker(args);
      break;
    case "setup-mcp":
      await cmdSetupMcp(args);
      break;
    case "setup-python":
      await cmdSetupPython();
      break;
    case "servers":
      await cmdServers(args);
      break;
    case "stop-all":
    case "kill":
      await cmdStopAll(args);
      break;
    case "sonar":
      await cmdSonar(args);
      break;
    case "ember":
      await cmdEmber(args);
      break;
    case "squash":
      await cmdSquash(args.slice(1));
      break;
    case "harvest":
      await cmdHarvest(args.slice(1));
      break;
    case "harvest-lexicon":
      await cmdHarvestLexicon(args.slice(1));
      break;
    case "dashboard":
      await cmdDashboard(args.slice(1));
      break;
    case "scripts":
      await cmdScripts();
      break;
    case "enhance": {
      const { cmdEnhance: cmdEnhance2 } = await Promise.resolve().then(() => (init_enhance_commands(), exports_enhance_commands));
      await cmdEnhance2(args);
      break;
    }
    case "version":
    case "--version":
    case "-v":
      showVersion();
      break;
    case "help":
    case "--help":
    case "-h":
    case undefined:
      showHelp();
      break;
    default:
      console.error(`\u274C Unknown command: ${command}
`);
      showHelp();
      process.exit(1);
  }
}
main().catch((error49) => {
  console.error("\u274C Fatal error:", error49);
  process.exit(1);
});

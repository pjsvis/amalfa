This requires an upgrade to our "Mentation" logic. To prevent the "Substrate" (Google Docs) from corrupting your "Things" (JSON), we must explicitly recognize code artifacts.

Since Google Docs lacks a native "Code Block" element, we must use a **Heuristic**: *If text is formatted in a monospaced font (like Courier New or Consolas), treat it as code.*

Here is the enhanced script suite. It includes the JSON-safe Markdown exporter and the requested Document Indexer.


### Updated Script: ctx_toolkit.gs

Replace your previous code with this version.


```JavaScript

/** \
 * @OnlyCurrentDoc \
 * Ctx Toolkit: Markdown Export (JSON-Safe) & Registry Generator \
 * [Implements: PHI-1, PHI-12] \
 */ \
 \
function onOpen() { \
  DocumentApp.getUi() \
      .createMenu('Ctx Utilities') \
      .addItem('Export as Markdown (Smart)', 'saveMarkdownToDrive') \
      .addItem('Generate Document Index', 'generateDocsIndex') \
      .addToUi(); \
} \
 \
// --- MODULE 1: MARKDOWN EXPORTER --- \
 \
function saveMarkdownToDrive() { \
  const doc = DocumentApp.getActiveDocument(); \
  const body = doc.getBody(); \
  const fileName = doc.getName() + ".md"; \
   \
  // Convert \
  const text = convertBodyToMarkdown(body); \
   \
  // Save \
  DriveApp.createFile(fileName, text, MimeType.PLAIN_TEXT); \
  DocumentApp.getUi().alert('Success. Saved ' + fileName + ' to Drive root.'); \
} \
 \
function convertBodyToMarkdown(body) { \
  const numChildren = body.getNumChildren(); \
  let markdown = ""; \
  let inCodeBlock = false; \
 \
  for (let i = 0; i &lt; numChildren; i++) { \
    const child = body.getChild(i); \
    const type = child.getType(); \
 \
    // Handle Code Blocks (State Machine) \
    // We check if the current paragraph looks like code \
    let isCode = false; \
    if (type === DocumentApp.ElementType.PARAGRAPH) { \
      isCode = isMonospaced(child.asParagraph()); \
    } \
 \
    // State Transitions \
    if (isCode && !inCodeBlock) { \
      markdown += "```json\n"; // Assumes JSON based on your context, or use empty ``` \
      inCodeBlock = true; \
    } else if (!isCode && inCodeBlock) { \
      markdown += "```\n\n"; \
      inCodeBlock = false; \
    } \
 \
    // Processing \
    switch (type) { \
      case DocumentApp.ElementType.PARAGRAPH: \
        // If inside code block, raw text only. If outside, process markdown syntax. \
        markdown += inCodeBlock  \
          ? child.asParagraph().getText() + "\n"  \
          : processParagraph(child.asParagraph()) + "\n\n"; \
        break; \
      case DocumentApp.ElementType.LIST_ITEM: \
        // Close code block before list if open (safety) \
        if (inCodeBlock) { markdown += "```\n\n"; inCodeBlock = false; } \
        markdown += processListItem(child.asListItem()) + "\n"; \
        break; \
      default: \
        // Ignore unsupported elements to reduce entropy \
        break; \
    } \
  } \
   \
  // Final cleanup if doc ends in code \
  if (inCodeBlock) { markdown += "```\n"; } \
   \
  return markdown; \
} \
 \
function isMonospaced(paragraph) { \
  // Heuristic: Check the font of the first character.  \
  // If "Courier New", "Consolas", or "Roboto Mono", it's code. \
  const text = paragraph.editAsText(); \
  if (text.getText().length === 0) return false; \
   \
  const font = text.getFontFamily(0);  \
  // Add other fonts if you use them \
  const codeFonts = ["Courier New", "Consolas", "Roboto Mono", "Source Code Pro"]; \
  return codeFonts.includes(font); \
} \
 \
function processParagraph(paragraph) { \
  const text = paragraph.getText(); \
  const heading = paragraph.getHeading(); \
 \
  switch (heading) { \
    case DocumentApp.ParagraphHeading.HEADING1: return "# " + text; \
    case DocumentApp.ParagraphHeading.HEADING2: return "## " + text; \
    case DocumentApp.ParagraphHeading.HEADING3: return "### " + text; \
    case DocumentApp.ParagraphHeading.NORMAL:  \
      if (paragraph.editAsText().isBold(0)) return "**" + text + "**"; \
      return text; \
    default: return text; \
  } \
} \
 \
function processListItem(listItem) { \
  const text = listItem.getText(); \
  const nesting = listItem.getNestingLevel(); \
  const glyphType = listItem.getGlyphType(); \
  const indent = "  ".repeat(nesting); \
  const prefix = (glyphType === DocumentApp.GlyphType.NUMBER) ? "1. " : "- "; \
  return indent + prefix + text; \
} \
 \
// --- MODULE 2: DOCUMENT INDEXER --- \
 \
function generateDocsIndex() { \
  // [Implements: PHI-1] Structure unstructured Drive "Stuff" into a List \
   \
  const doc = DocumentApp.create('Index - My Google Docs'); \
  const body = doc.getBody(); \
   \
  body.appendParagraph("Index of Google Documents").setHeading(DocumentApp.ParagraphHeading.HEADING1); \
  body.appendParagraph("Generated by Ctx Toolkit on " + new Date()); \
   \
  const files = DriveApp.getFilesByType(MimeType.GOOGLE_DOCS); \
   \
  while (files.hasNext()) { \
    const file = files.next(); \
    const listItem = body.appendListItem(file.getName()); \
     \
    // Add Link \
    listItem.setLinkUrl(file.getUrl()); \
  } \
   \
  doc.saveAndClose(); \
  DocumentApp.getUi().alert('Index created! Check your Drive for "Index - My Google Docs"'); \
} \
````


### Operational Notes (User Manual)



1. **For the JSON Handler:** Ensure your JSON in the Google Doc is formatted with **Courier New** (or Consolas). The script now detects this font as a signal to wrap the text in ``` blocks and—crucially—prevents the Markdown processor from mangling the internal punctuation.
2. **For the List:** Run Generate Document Index. This will spawn a *new* Google Doc in your root folder containing a clickable list of every Google Doc in your Drive.
    * *Warning:* If you have thousands of docs, this execution might time out (Google limits script runtimes). If so, we will need to add a "Folder Specific" filter.

Does this align with your "Test-First Implementation Protocol" (COG-13)?
